{"rss":{"@version":"2.0","@xmlns:discourse":"http://www.discourse.org/","@xmlns:atom":"http://www.w3.org/2005/Atom","@xmlns:dc":"http://purl.org/dc/elements/1.1/","channel":{"title":"Starknet Community Forum - Latest topics","link":"https://community.starknet.io/latest","description":"Latest topics","lastBuildDate":"Sat, 10 Aug 2024 01:15:48 +0000","atom:link":{"@href":"https://community.starknet.io/latest.rss","@rel":"self","@type":"application/rss+xml"},"item":[{"title":"Immutable Component Config","dc:creator":"ericnordelo","category":"SNIPs","description":"<p>Standardizing Starknet component configuration avoiding unnecessary storage manipulation.</p>\n<h2><a name=\"p-2357364-abstract-1\" class=\"anchor\" href=\"https://community.starknet.io#p-2357364-abstract-1\"></a>Abstract:</h2>\n<p>This standard proposes a mechanism to allow setting component‚Äôs configurable constants in the extending contracts without needing to save them in storage. Library and protocol developers can leverage this standard to make their components configurable, while keeping the constants hardcoded in the bytecode, removing the extra storage reads that using the storage for this would require.</p>\n<h2><a name=\"p-2357364-motivation-2\" class=\"anchor\" href=\"https://community.starknet.io#p-2357364-motivation-2\"></a>Motivation:</h2>\n<p>Library and protocol developers often want to make components configurable over a set of parameters to leverage flexibility for the final users. In Solidity, immutable variables and/or virtual functions are often used to provide this kind of flexibility, since they are hardcoded into the bytecode, not requiring storage reads for accessing the value later, even when they may be initialized in construction time. Cairo doesn‚Äôt implement these immutable or virtual mechanisms, but this SNIP proposes a standard to allow users of the component to set these bytecode constants in the contracts that extend from the component.</p>\n<h2><a name=\"p-2357364-specification-3\" class=\"anchor\" href=\"https://community.starknet.io#p-2357364-specification-3\"></a>Specification:</h2>\n<p>Components that use a set of one-time configurable constants, should provide an <code>ImmutableConfig</code> trait inside the component module, and this trait MUST contain only associated constants, and optionally a single function named <code>validate</code>.</p>\n<p>The <code>validate</code> function may be used for adding constraints for the config members, and it panic if the config is invalid, or silently pass otherwise. This function MUST only be used in tests (when testing the contract to ensure the config is valid), and shouldn‚Äôt be part of the contract release bytecode since the compiler should optimize it away.</p>\n<p>Note that validate doesn‚Äôt enforce that your config is right directly, since is never executed on your contract flow, but is designed to catch issues when testing the contract using the component.</p>\n<p>Example:</p>\n<pre><code class=\"lang-auto\">#[starknet::component]\npub mod ERC2981Component {\n    use openzeppelin_introspection::src5::SRC5Component::InternalTrait as SRC5InternalTrait;\n    use openzeppelin_introspection::src5::SRC5Component::SRC5Impl;\n    use openzeppelin_introspection::src5::SRC5Component;\n\n    #[storage]\n    struct Storage {\n        (...)\n    }\n\n    mod Errors {\n        (...)\n    }\n\n    /// Constants expected to be defined at the contract level used to configure the component\n    /// behaviour.\n    ///\n    /// - `FEE_DENOMINATOR`: The denominator with which to interpret the fee set in\n    ///   `set_token_royalty` and `set_default_royalty` as a fraction of the sale price.\n    pub trait ImmutableConfig {\n        const FEE_DENOMINATOR: u256;\n    }\n\n    #[embeddable_as(ERC2981Impl)]\n    impl ERC2981&lt;\n        TContractState,\n        +HasComponent&lt;TContractState&gt;,\n        impl Immutable: ImmutableConfig,\n        impl SRC5: SRC5Component::HasComponent&lt;TContractState&gt;,\n        +Drop&lt;TContractState&gt;,\n    &gt; of IERC2981&lt;ComponentState&lt;TContractState&gt;&gt; {\n        fn royalty_info(\n            self: @ComponentState&lt;TContractState&gt;, token_id: u256, sale_price: u256\n        ) -&gt; (ContractAddress, u256) {\n            (...)\n\n            let royalty_amount = sale_price\n                * royalty_info.royalty_fraction\n                / Immutable::FEE_DENOMINATOR;\n\n            (royalty_info.receiver, royalty_amount)\n        }\n    }\n\n    (...)\n}\n</code></pre>\n<p>Notice that the ERC2981 embeddable implementation depends on an implementation of the <code>ImmutableConfig</code> trait.</p>\n<p>Users of the library that want to use the component, need to provide an implementation specifying the values for each configurable const.</p>\n<pre><code class=\"lang-auto\">#[starknet::contract]\npub mod Contract {\n    use super::ERC2981Component::ImmutableConfig;\n    use super::ERC2981Component;\n    use openzeppelin_introspection::src5::SRC5Component;\n\n    component!(path: ERC2981Component, storage: erc2981, event: ERC2981Event);\n    component!(path: SRC5Component, storage: src5, event: SRC5Event);\n\n    #[abi(embed_v0)]\n    impl ERC2981Impl = ERC2981Component::ERC2981Impl&lt;ContractState&gt;;\n\n    impl ERC2981Config of ERC2981Component::ImmutableConfig {\n        const DEFAULT_FEE_DENOMINATOR: u256 = 10_000;\n    }\n\n    (...)\n}\n</code></pre>\n<h3><a name=\"p-2357364-defaultconfig-4\" class=\"anchor\" href=\"https://community.starknet.io#p-2357364-defaultconfig-4\"></a>DefaultConfig</h3>\n<p>Sometimes even while we want some constants to be configurable, we want to provide default values for them, that can be used if the users don‚Äôt want/need to modify the default values.</p>\n<p>For this, a default implementation MAY be provided, and MUST be a sibling of the component itself (direct child of the parent module), with the name <code>DefaultConfig</code>.</p>\n<p>Example:</p>\n<pre><code class=\"lang-auto\">#[starknet::component]\npub mod ERC2981Component {\n    (...)\n}\n\n/// Implementation of the ERC2981 component that can be directly used in contracts.\n///\n/// The default fee denominator is set to 10_000.\npub impl DefaultConfig of ERC2981Component::ImmutableConfig {\n    const FEE_DENOMINATOR: u256 = 10_000;\n}\n</code></pre>\n<p>Then users may use the component in contracts as follow:</p>\n<pre><code class=\"lang-auto\">#[starknet::contract]\npub mod Contract {\n    use super::{ERC2981Component, DefaultConfig};\n    use openzeppelin_introspection::src5::SRC5Component;\n\n    component!(path: ERC2981Component, storage: erc2981, event: ERC2981Event);\n    component!(path: SRC5Component, storage: src5, event: SRC5Event);\n\n    #[abi(embed_v0)]\n    impl ERC2981Impl = ERC2981Component::ERC2981Impl&lt;ContractState&gt;;\n\n    (...)\n}\n</code></pre>\n<p>Note that we are not defining the implementation again, just bringing it into scope by importing it directly.</p>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://community.starknet.io/t/immutable-component-config/114434\">Read full topic</a></p>","link":"https://community.starknet.io/t/immutable-component-config/114434","pubDate":"Sat, 10 Aug 2024 01:15:48 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"community.starknet.io-topic-114434"},"source":{"@url":"https://community.starknet.io/t/immutable-component-config/114434.rss","#text":"Immutable Component Config"}},{"title":"L1/L2 Reorg Behaviour","dc:creator":"caljoshba","category":"üôè Help and Support","description":"<p>Just doing some digging into chain reorgs and was hoping you might have some details on how Starknet handles them:</p>\n<ul>\n<li>\n<p>In the instance of an L2 reorg (very unlikely but it did happen in back in April 2024):</p>\n<ul>\n<li>How does Starknet handle the submitted transactions? I assume they mark the transaction as <code>REVERTED</code>, but do they re-process the transaction or would we need to resubmit?</li>\n<li>I guess it is up to us to monitor the last block hash we received to ensure there has not been a reorg or do Starknet give an easy mechanism for this?</li>\n</ul>\n</li>\n<li>\n<p>In the instance of an L1 reorg:</p>\n<ul>\n<li>\n<p>For an unconfirmed transaction:</p>\n<ul>\n<li>Does the transaction remain in the mempool and is reprocessed? Would this end up with a new Tx hash? How might we be notified of this new Tx?</li>\n</ul>\n</li>\n<li>\n<p>For a confirmed (multiple confirmations) transaction (incredibly unlikely)</p>\n<ul>\n<li>Starknet would mark this as <code>REVERTED</code>?</li>\n<li>If so, I guess we need to resubmit? And we would do this by listening for <code>REVERTED</code> transactions</li>\n<li>Could this potentially lead to a situation in which one transaction (Tx1) is confirmed on L1 (on what turns out to be an uncle), another (Tx2) is later confirmed on L1 on the canonical which means Tx2 is final but Tx1 is reverted after Tx2 is submitted?</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>Any help here or pointing in the right direction would be very useful.</p>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://community.starknet.io/t/l1-l2-reorg-behaviour/114431\">Read full topic</a></p>","link":"https://community.starknet.io/t/l1-l2-reorg-behaviour/114431","pubDate":"Fri, 09 Aug 2024 05:58:48 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"community.starknet.io-topic-114431"},"source":{"@url":"https://community.starknet.io/t/l1-l2-reorg-behaviour/114431.rss","#text":"L1/L2 Reorg Behaviour"}},{"title":"EIP712 authorization in Cairo 2","dc:creator":"dreamDev525","category":"üôè Help and Support","description":"<p>How to integrate EIP712 authorization in cairo latest version.</p>\n            <p><small>2 posts - 2 participants</small></p>\n            <p><a href=\"https://community.starknet.io/t/eip712-authorization-in-cairo-2/114430\">Read full topic</a></p>","link":"https://community.starknet.io/t/eip712-authorization-in-cairo-2/114430","pubDate":"Fri, 09 Aug 2024 05:57:54 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"community.starknet.io-topic-114430"},"source":{"@url":"https://community.starknet.io/t/eip712-authorization-in-cairo-2/114430.rss","#text":"EIP712 authorization in Cairo 2"}},{"title":"About Starknet developers","dc:creator":"n1neteen","category":"ü§∑‚Äç‚ôÄÔ∏è All-Purpose Hangout","description":"<p>Hi, I love starknet, I love what they are trying to do, but can someone tell me why I am constantly rug by starknet developers? I have been in this industry for five years. Almost 70% of the money I saved for my dreams and goals for five years is gone‚Ä¶ And this happened not once but many times after the airdrop process. My biggest loss was by ZKX. I was so bad that I‚Äôm just now coming to my senses. Is there really no one in the Starknet team who can control this? Don‚Äôt you really do risk management when you give incentives and support to developers? Don‚Äôt you think about the possibility that one day these guys might drop everything and leave? And don‚Äôt you really think that our users/community will suffer because of this? Yes, I lost almost everything because the starknet team didn‚Äôt think about this. <a class=\"mention\" href=\"https://community.starknet.io/u/elibensasson\">@elibensasson</a></p>\n            <p><small>3 posts - 2 participants</small></p>\n            <p><a href=\"https://community.starknet.io/t/about-starknet-developers/114406\">Read full topic</a></p>","link":"https://community.starknet.io/t/about-starknet-developers/114406","pubDate":"Thu, 01 Aug 2024 02:02:30 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"community.starknet.io-topic-114406"},"source":{"@url":"https://community.starknet.io/t/about-starknet-developers/114406.rss","#text":"About Starknet developers"}},{"title":"Sharing some ideas on quantum-resistant digital signature schemes","dc:creator":"vagabondmaster","category":"ü§∑‚Äç‚ôÄÔ∏è All-Purpose Hangout","description":"<p>As we know, when quantum computers become more advanced, they could compromise the security of cryptographic systems like RSA, DLP, and Elliptic Curves. In the case of Elliptic Curves, the compromise could have negative impacts on various blockchains that use it in digital signatures, such as Bitcoin, Ethereum, and Starknet.</p>\n<p>When this will happen is unknown, I believe. The question is how to prevent future quantum attacks. Vitalik Buterin presents some ideas (how to hard-fork to save most users‚Äô funds in a quantum emergency) about what to do in case of attacks. I like the post, but I am concerned with preventive measures.</p>\n<p>Since Starknet uses AA, in theory, it would be possible to replace the elliptic curve used in digital signatures with algorithms that are theoretically resistant to quantum attacks, such as those proposed by NIST (Crystals-Dilithium, Falcon, Rainbow). Please correct me if I‚Äôm wrong. If the reasoning is correct, I ask if there is any proposal to replace the Stark curve, if necessary.</p>\n<p>I present these concerns because I want the best for this community. I apologize if the ideas are not relevant.</p>\n            <p><small>3 posts - 2 participants</small></p>\n            <p><a href=\"https://community.starknet.io/t/sharing-some-ideas-on-quantum-resistant-digital-signature-schemes/114397\">Read full topic</a></p>","link":"https://community.starknet.io/t/sharing-some-ideas-on-quantum-resistant-digital-signature-schemes/114397","pubDate":"Mon, 29 Jul 2024 07:38:06 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"community.starknet.io-topic-114397"},"source":{"@url":"https://community.starknet.io/t/sharing-some-ideas-on-quantum-resistant-digital-signature-schemes/114397.rss","#text":"Sharing some ideas on quantum-resistant digital signature schemes"}},{"title":"Collective Feedback on Improving Provision","dc:creator":"webOfTrust","category":"Provisions Discussions","description":"<p><strong>Intro and general remarks</strong></p>\n<p>After reading Eli‚Äôs <a href=\"https://starkware.co/integrity-matters-blog/airdrop-reflections/?preview_id=7828\" rel=\"noopener nofollow ugc\">Airdrop Reflections</a> cc <a class=\"mention\" href=\"https://community.starknet.io/u/elibensasson\">@elibensasson</a> , <a href=\"https://old.reddit.com/r/ethfinance/comments/1du681u/daily_general_discussion_july_3_2024/lbfksnw/\" rel=\"noopener nofollow ugc\">Benido</a>, an acknowledged delegate in the ecosystem and community member, took the initiative to gather feedback on improving upcoming provision. So, this post is a collaborative post from several members of the <a href=\"https://www.reddit.com/user/ethfinance/\" rel=\"noopener nofollow ugc\">ETHFinance community on reddit</a>, which includes Starknet delegates. While our feedback is not based on scientific research (and quantitative data is hard to get anyway), the community discusses airdrop design a lot. Hence we hope our feedback is valuable.</p>\n<p>Airdrops have been farmed since the fall of 2021 after <em>UNI</em> did their airdrop, but we believe it‚Äôs fair to assume they have never been farmed as intensively as these days. What started as some crypto natives farming with multiple wallets instead of one is now an industry with professional solutions. The result is a cat-and-mouse game between protocols without a token and farmers.</p>\n<p>Basically, every airdrop of the past 6 months has received overwhelmingly negative feedback, but obviously, incentives allow professional players to invest a lot of money to put pressure on protocols to influence airdrop design and potential changes that favour their business (both for recent airdrops, but also future airdrops of other protocols).</p>\n<p>Interestingly most airdropping protocols apparently did not ask for or exchange sybil reports from earlier airdrops. This was criticised a lot, especially when sybil reports from airdrop A received a lot of tokens from airdrop B.</p>\n<p>Technically linear airdrops would be fair, but even those have received some negative feedback (‚Äú<em>the rich getting richer</em>‚Äù). A linear design potentially leads to centralization in governance and runs counter to the (Starknet) goal of distributing to a broad set of individuals. Technically it of course could be distributed linearly, but then a very high percentage of the addresses would have no relevant stake in governance.</p>\n<p>In the case of <em>EigenLayer</em> the airdrop design was first a linear airdrop which was amended with a min allocation for all addresses. This was from our point of view a good decision for EL at that point in time, but likely will be exploited in the future similarly to how Uniswap started the ‚Äúone interaction‚Äù farming in 2021.</p>\n<p>On top a linear airdrop design is harder for L1s and L2s, since there is not a single metric (like amount deposited in the case of EigenLayer) that could be used. Transaction fees could be one metric, volume bridged, transaction volume onchain or a combination could be others.</p>\n<p>The best airdrops of the past 12 months were likely part of the Solana ecosystem and were successful because Solana was not farmed as much after the FTX collapse. <em><a href=\"https://www.jito.network/blog/jto-airdrop-eligibility-and-allocation-specifications/\" rel=\"noopener nofollow ugc\">Jito</a></em> ($JTO) was only distributed to 9852 addresses. The success is not a result of airdrop design, but more a lucky coincidence of missing focus of farmers and a surprisingly strong ecosystem rising from the ashes of FTX and Sam Bankman-Fried.</p>\n<p><strong>Feedback Starknet Provisions Part I</strong></p>\n<p>We will focus on the requirements for Starknet users since that accounted for 87% of the first airdrop.<br>\nFrom our point of view, there are indeed two design choices that should have been made differently:</p>\n<ol>\n<li>\n<p>The ETH minimum balance of 0.005 ETH was discussed extensively. We believe that the biggest issue here was that choosing the ETH balance was a strategic mistake and runs counter to the USP for layer 2s like Starknet. The value proposition is that gas fees are low, hence you can make hundreds of transactions with next to 0 ETH</p>\n</li>\n<li>\n<p>A second design decision that wasn‚Äôt discussed as much as taking a snapshot at a certain block height. Two extreme examples: a user that had funds on Starknet and was active for months bridges out at block height snapshot -1 and is now not eligible for the airdrop. A second user that bridges in after being inactive for months (but has conducted the minimal viable activity to be eligible) bridges in at block heights snapshot -1 and is now eligible. In our opinion, the first user is a (more) valuable user for the Starknet ecosystem, but because of the snapshot based design, only the less valuable Starknet user is eligible and rewarded.</p>\n</li>\n</ol>\n<p><strong>Suggestions on how to make subsequent rounds of Starknets better</strong></p>\n<p>Every requirement should be aligned with <a href=\"https://starkware.co/integrity-matters-blog/starknet-vision/\" rel=\"noopener nofollow ugc\">Starknet‚Äôs strategic approach and goals</a>. We don‚Äôt believe in crafting requirements that might filter out some farmers, but contradict what Starknet is and has been building.</p>\n<p>To make sure that is the case and also to get a realistic temperature check we suggest sharing provision requirements with trusted delegates and/ or trusted users (who potentially have to sign an NDA beforehand). Outsider feedback is valuable and could catch a possible 0.005 ETH balance v2 or at least give feedback to improve details.</p>\n<p>As a rule of thumb, we believe that the fewer rumours about Starknet Provision part II (or III or IV) the better. Since every token can only be airdropped once and some competitors have already fully allocated the corresponding token supply, spending these tokens later could even be a strategic advantage. Still timing this is hard, since being too late could mean that the airdrop doesn‚Äôt have any positive effect either.</p>\n<p>For more detailed design recommendations there are two core questions to consider:</p>\n<blockquote>\n<p>What are the requirements to identify ‚Äúreal users‚Äù, as unique human beings?<br>\nWhat are the requirements to identify ‚Äúgood users‚Äù, so users that show alignment with Starknet?</p>\n</blockquote>\n<p>The challenge to identify real users/ people and ‚Äúproof of personhood‚Äù is hard, and likely even harder or connected to a lot of effort for Starknet because it‚Äôs not EVM based and making use of solutions like Gitcoin Passport likely needs additional development (to be e.g. able to link a Gitcoin Passport not just to a 0xEVM address, but also a Starknet address).</p>\n<p>On top Starknet should ask all major protocols which airdropped tokens in the past 12-18 months for sybil reports. This will require a lot of effort for Starknet, but it is necessary because of the transparency of the space.<br>\nAt the same time, we believe that there are metrics that raise the likelihood of a certain address being a real user. You can‚Äôt fake funds onchain. A user that has &gt;X USD in assets onchain is likely a real user. Finding X is not easy, but could likely be derived from the sybil farm reports from other protocols and analytics platforms.</p>\n<p>In other words: <strong>How does farming work?</strong> Users/ services split their capital into small parts and push it to a lot of addresses. To have assets worth &gt;X USD in all sybilling addresses you would need a lot of capital.</p>\n<p>Of course not all addresses with funds &lt;X USD are farms, so this approach likely only finds real users, but doesn‚Äôt identify farmers - but it should be a step in the right direction and could lead to better distribution by potentially being more confident to giving out tokens to these users without going strictly linear.</p>\n<p>These metrics then need to be measured in connection with a time-based metric instead of a snapshot. That makes sure it can‚Äôt be game easily and users aren‚Äôt disqualified by chance/ bad luck with regards to snapshot timing.</p>\n<p>Addresses that were funded via FIAT onramps are likely both ‚Äúreal‚Äù and ‚Äúgood users‚Äù. Farms are usually funded via CEX withdrawals. FIAT onramps are likely used mainly by real users, because the onramp fees would eat profit from farms and there is usually a KYC process connected to using an onramp and farms will likely avoid these. These are good users, because they have more skin in the game than just sending / bridging old funds back and forth.</p>\n<p>On top we believe the following metrics are valid to identify good/ aligned users:</p>\n<ol>\n<li>Users that still hold their $STKR airdrop, both in vSTRK, but also in defi protocols like AMMs and borrowing and lending. The defi spring campaign offered great incentives to put the STRK to work, so these would have been tracked accordingly.</li>\n<li>Users who did not receive a $STRK airdrop but have bought tokens on the secondary market</li>\n<li>Users paying gas in $STRK (though this one is likely being farmed already, so likely not the perfect signal)</li>\n<li>Users that have increased their net balance on Starknet (so not in USD, but more in STRK / ETH)</li>\n</ol>\n<hr>\n<p>Sybil is a difficult challenge and the only way possible to counter this is to gather collective feedback iteratively. I invite you to share your input and feedback.</p>\n<p>Also, assuming that I am not breaking any rules and guidelines on this forum by sharing link(s) or tag.</p>\n<hr>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://community.starknet.io/t/collective-feedback-on-improving-provision/114371\">Read full topic</a></p>","link":"https://community.starknet.io/t/collective-feedback-on-improving-provision/114371","pubDate":"Fri, 19 Jul 2024 15:20:45 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"community.starknet.io-topic-114371"},"source":{"@url":"https://community.starknet.io/t/collective-feedback-on-improving-provision/114371.rss","#text":"Collective Feedback on Improving Provision"}},{"title":"Cairo v2.7.0 is coming!","dc:creator":"FeedTheFed","category":"Cairo Development","description":"<h2><a name=\"tldr-1\" class=\"anchor\" href=\"https://community.starknet.io#tldr-1\"></a>TL;DR</h2>\n<p>Cairo 2.7.0 will be released soon! At the moment, <a href=\"https://github.com/starkware-libs/cairo/releases/tag/v2.7.0-rc.3\">2.7.0-rc.3</a> is available and can be tested by the community. This version involves a Sierra upgrade to v1.6.0, <strong>which means contracts written with v2.7.0 are only deployable on Starknet ‚â• 0.13.2</strong>. The Testnet upgrade is planned for Aug 5, and the Mainnet upgrade is planned for Aug 26 (you can find more details <a href=\"https://community.starknet.io/t/starknet-v0-13-2-pre-release-notes/114223\">here</a>). As usual, you can continue using older compiler versions for your contracts and deploy them on Starknet.</p>\n<p>v2.7.0 is a HUGE version with an abundance of new features &amp; updates:</p>\n<ul>\n<li><a href=\"https://community.starknet.io/t/cairo-v2-7-0-is-coming/114362#the-2024_07-edition-3\">New edition, <code>2024_07</code></a></li>\n<li><a href=\"https://community.starknet.io/t/cairo-v2-7-0-is-coming/114362#deref-4\">The <code>Deref</code> and <code>DerefMut</code> traits are added to the corelib</a>, which allows the compiler to, given a deref implementation, treat the source type as the target type</li>\n<li><a href=\"https://community.starknet.io/t/cairo-v2-7-0-is-coming/114362#contract-storage-5\">Contract storage is now much more flexible</a>:\n<ul>\n<li>Allowing read/write for <a href=\"https://community.starknet.io/t/cairo-v2-7-0-is-coming/114362#individual-member-access-6\">individual members</a> for every type that derives <code>Store</code></li>\n<li>Introducing the new <a href=\"https://community.starknet.io/t/cairo-v2-7-0-is-coming/114362#maps-8\"><code>Map</code> type</a> (you no longer have to use legacy maps!)</li>\n<li>Introducing the <a href=\"https://community.starknet.io/t/cairo-v2-7-0-is-coming/114362#storage-vecs-10\"><code>Vec</code> type</a></li>\n<li>Adding a new <a href=\"https://community.starknet.io/t/cairo-v2-7-0-is-coming/114362#storage-nodes-12\">‚Äústorage node‚Äù concept</a> that allows arbitrary nesting (e.g. structs with maps, or properties that are themselves storage nodes)</li>\n</ul>\n</li>\n<li><a href=\"https://community.starknet.io/t/cairo-v2-7-0-is-coming/114362#phantom-types-17\">Phantom types</a></li>\n<li><a href=\"https://community.starknet.io/t/cairo-v2-7-0-is-coming/114362#associated-items-18\">Associated items</a> are introduced to Cairo, allowing you to define types, consts and impls associated with a given trait.</li>\n<li><a href=\"https://community.starknet.io/t/cairo-v2-7-0-is-coming/114362#for-loops-22\">for loops</a> - we now have <code>for elem in array</code></li>\n<li><a href=\"https://community.starknet.io/t/cairo-v2-7-0-is-coming/114362#sha256-23\">sha256</a> support in the corelib</li>\n<li><a href=\"https://community.starknet.io/t/cairo-v2-7-0-is-coming/114362#default-implementations-24\">default implementations</a></li>\n<li><a href=\"https://community.starknet.io/t/cairo-v2-7-0-is-coming/114362#fixed-size-arrays-25\">fixed-size array</a> type</li>\n<li><a href=\"https://community.starknet.io/t/cairo-v2-7-0-is-coming/114362#arithmetic-circuits-26\">Arithmetic circuits support</a> - construct and run arithmetic circuits defined over arbitrary modulus up to 384 bits. This is particularly useful to allow efficient verification over Starknet for different proof systems, e.g. groth16 (the <a href=\"https://x.com/feltroidPrime/status/1807612773251039430\">Garaga</a> project in particular is a good example of a project that relies on this feature)</li>\n</ul>\n<p>The above only includes the most significant new features, for a comprehensive list of changes see the <a href=\"https://github.com/starkware-libs/cairo/releases/tag/v2.7.0-rc.0\">release notes</a>. We now proceed to dive into each of the changes mentioned above.</p>\n<h2><a name=\"breaking-changes-2\" class=\"anchor\" href=\"https://community.starknet.io#breaking-changes-2\"></a>Breaking changes</h2>\n<p>While we‚Äôre trying to avoid breaking any existing code in minor versions, we may allow changing internal traits or generated code that could affect existing user code. While not affecting the majority of contracts, we cover the list of potential breaking changes below:</p>\n<ul>\n<li>The compiler generated <code>&lt;storage_var_name&gt;ContractMemberStateTrait</code> traits, where <code>storage_var_name</code> is a name of a property of the <code>Storage</code> struct, no longer exist. If your code depended directly on one of these traits, then it will break.</li>\n<li>The return type of <code>contract_state_for_testing</code> and <code>component_state_for_testing</code> will not have access to the storage members. For example:</li>\n</ul>\n<pre><code class=\"lang-auto\">let state = MyContract::contract_state_for_testing();\nlet value = state.storage_var.read(); // won't compile\n</code></pre>\n<p>To fix this, add <code>mut</code> or <code>@</code> as follows:</p>\n<pre><code class=\"lang-auto\">let state = @MyContract::contract_state_for_testing();\nstate.storage_var.read(...);\nlet mut state = MyContract::contract_state_for_testing();\nstate.storage_var.write(...);\n</code></pre>\n<h2><a name=\"the-2024_07-edition-3\" class=\"anchor\" href=\"https://community.starknet.io#the-2024_07-edition-3\"></a>The 2024_07 edition</h2>\n<p>This new edition no longer auto adds <code>pub</code> modifiers to the <code>Storage</code> sturct and its members, this is now the responsibility of the developer. This is of particular importance for components, whose <code>Storage</code> struct is referred to by external contracts.</p>\n<p>We‚Äôre also narrowing the prelude, removing several traits which are not common to every contract. For a full diff, you can compare the old and new preule (the old prelude is the same for 2023_10 and 2023_11): <a href=\"https://github.com/starkware-libs/cairo/blob/main/corelib/src/prelude/v2023_10.cairo#L1\">v2023_10.cairo</a>, <a href=\"https://github.com/starkware-libs/cairo/blob/main/corelib/src/prelude/v2024_07.cairo\">v2024_07.cairo</a>. Note that in particular, all storage access traits were added to 2023_10 and 2023_11, but need to be imported with 2024_07.</p>\n<h2><a name=\"deref-4\" class=\"anchor\" href=\"https://community.starknet.io#deref-4\"></a>Deref</h2>\n<p>This version adds the <code>Deref</code> and <code>DerefMut</code> traits to the compiler. Similarly to <a href=\"https://doc.rust-lang.org/std/primitive.array.html\">Rust</a>, these are special traits known to the compiler:</p>\n<pre><code class=\"lang-auto\">pub trait Deref&lt;T&gt; {\n    type Target;\n    fn deref(self: T) -&gt; Self::Target;\n}\n\npub trait DerefMut&lt;T&gt; {\n    type Target;\n    fn deref_mut(ref self: T) -&gt; Self::Target;\n}\n</code></pre>\n<p>When type <code>T</code> can be dereferenced to type <code>K</code>, then we can access K‚Äôs members while holding an instance of <code>T</code>. Note that any time has at most one <code>deref</code> implementation. Additionally, for now only member access via deref is supported, i.e. impls with functions whose <code>self</code> argument is of type <code>K</code> will not be applicable when holding an instance of <code>T</code>. To illustrate how <code>Deref</code> works, consider the following example:</p>\n<pre><code class=\"lang-auto\">#[derive(Drop)]\nstruct Type1 {\n    a: u8\n}\n\n#[derive(Drop)]\nstruct Type2 {\n    b: u8\n}\n\nimpl DerefType1ToType2 of Deref&lt;Type1&gt; {\n    type Target = Type2;\n    fn deref(self: Type1) -&gt; Type2 {\n        Type2 { b: self.a }\n    }\n}\n</code></pre>\n<p>Thanks to the above <code>Deref</code> implementation, we can write the following:</p>\n<pre><code class=\"lang-auto\">let t1 = Type1 { a: 3 };\nlet b = t1.b;\n</code></pre>\n<p>Note that for the following to work, we need an implementation of <code>DerefMut</code> rather than <code>Deref</code>:</p>\n<pre><code class=\"lang-auto\">fn foo(ref t1: Type1) {\n    let b = t1.b;\n}\n\nimpl DerefType1ToType2 of DerefMut&lt;Type1&gt; {\n    type Target = Type2;\n    fn deref_mut(ref self: Type1) -&gt; Type2 {\n        Type2 { b: self.a }\n    }\n}\n</code></pre>\n<h2><a name=\"contract-storage-5\" class=\"anchor\" href=\"https://community.starknet.io#contract-storage-5\"></a>Contract Storage</h2>\n<p>Up until now the storage mechanism solely relied on the <code>Store</code> trait. If a type <code>T</code> had a <code>Store&lt;T&gt;</code> implementation, then <code>Storage</code> could contain members of type <code>T</code> (the only exception being components, where the member type was the component‚Äôs <code>Storage</code> type). For example:</p>\n<pre><code class=\"lang-auto\">#[derive(starknet::Store)]\nstruct MyStruct {\n    a: u128,\n    b: u128\n}\n\n#[storage]\nstruct Storage {\n    member: MyStruct\n}\n</code></pre>\n<p>When reading or writing to <code>member</code>, it was only possible to read or write the struct in its entirety, i.e. via <code>self.member.read()</code>. In v2.7.0, this mechanism is generalized.</p>\n<p>To allow this generalization, much of the code generation around contract storage was refactored. In particular, the <code>ContractMemberState</code> traits that were generated per each member of the <code>Storage</code> struct no longer exist. That is, if your code uses these generated traits explicitly, it will break. The role of these traits is now fulfilled by the <code>ContractStorageBase</code> and <code>ContractStorageBaseMut</code> generated structs. To understand those in more detail, read the ‚Äúunder the hood‚Äù sections below.</p>\n<h3><a name=\"individual-member-access-6\" class=\"anchor\" href=\"https://community.starknet.io#individual-member-access-6\"></a>Individual member access</h3>\n<p>Consider the above contract; in Cairo v2.7.0 onwards, the following syntax is supported:</p>\n<pre><code class=\"lang-auto\">fn storage_access(ref self: ContractState) {\n    let member: MyStruct = self.member.read() // old\n    let a = self.member.a.read(); // new\n    self.member.b.write(5); // new\n}\n</code></pre>\n<p>Note that this is only supported for types that explicitly derive <code>Store</code>, and won‚Äôt work for custom <code>Store</code> implementation (e.g. ones that are obtained by packing).</p>\n<h3><a name=\"individual-member-access-under-the-hood-7\" class=\"anchor\" href=\"https://community.starknet.io#individual-member-access-under-the-hood-7\"></a>Individual member access - under the hood</h3>\n<p>In the new version, <code>derive(Store)</code> will generate, in addition to a <code>Store</code> impl, a corresponding SubPointers type and an implementation of the SubPointers trait for this type. For our above example, the following code will be generated:</p>\n<pre><code class=\"lang-auto\">#[derive(Drop, Copy)]\nstruct MyStructSubPointers {\n    a: starknet::storage::StoragePointer&lt;u128&gt;,\n    b: starknet::storage::StoragePointer&lt;u128&gt;,\n}\n\nstruct MutableMyStructSubPointers {\n    a: starknet::storage::StoragePointer&lt;Mutable&lt;u128&gt;&gt;,\n    b: starknet::storage::StoragePointer&lt;Mutable&lt;u128&gt;&gt;,\n}\n\nimpl MyStructSubPointersImpl of starknet::storage::SubPointers&lt;MyStruct&gt; {\n   type SubPointersType = MyStructSubPointers;\n\n   fn sub_pointers(self: starknet::storage::StoragePointer&lt;MyStruct&gt;) -&gt; MyStructSubPointers {\n        let base_address = self.address;\n        let mut current_offset = self.offset;\n        let a_value = starknet::storage::StoragePointer {\n            address: base_address,\n            offset: current_offset,\n        };\n        current_offset = current_offset + starknet::Store::&lt;u128&gt;::size();\n        let b_value = starknet::storage::StoragePointer {\n            address: base_address,\n            offset: current_offset,\n        };\n        MyStructSubPointers {\n           a: a_value,\n           b: b_value,\n        }\n    }\n}\n\nimpl MutableMyStructSubPointersImpl of starknet::storage::MutableSubPointers&lt;MyStruct&gt; {\n   type SubPointersType = MutableMyStructSubPointers;\n\n   fn mutable_sub_pointers(self: starknet::storage::StoragePointer&lt;Mutable&lt;MyStruct&gt;&gt;) -&gt; MutableMyStructSubPointers {\n        let base_address = self.address;\n        let mut current_offset = self.offset;\n        let a_value = starknet::storage::StoragePointer {\n            address: base_address,\n            offset: current_offset,\n        };\n        current_offset = current_offset + starknet::Store::&lt;u128&gt;::size();\n        let b_value = starknet::storage::StoragePointer {\n            address: base_address,\n            offset: current_offset,\n        };\n        MutableMyStructSubPointers {\n           a: a_value,\n           b: b_value,\n        }\n    }\n}\n</code></pre>\n<p><code>StoragePointer</code> is a new type defined in storage.cairo, it points to a concrete storage slot via a base address and an offset. The above generated code explains why only structs that explicitly derive <code>Store</code> allow individual member access. The generated code assumes that each member is stored via its type‚Äôs <code>Store</code> implementation, which is not necessarily the case for custom implementations, e.g. ones based on packing.</p>\n<p>To understand how to get from <code>self:ContractState</code> to <code>self.member.a.read()</code>, we need to look into the types in question. The <code>ContractState</code> type is an empty struct generated by the compiler, that can be derefed to the <code>ContractStorageBase</code> or <code>ContractStorageBaseMut</code> types that are generated based on the <code>Storage</code> struct defined in the contract module:</p>\n<pre><code class=\"lang-auto\">#[derive(Drop, Copy)]\nstruct ContractStorageBase {\n    member: starknet::storage::StorageBase&lt;MyStruct&gt;,\n}\n\n#[derive(Drop, Copy)]\nstruct ContractStorageBaseMut {\n    member: starknet::storage::StorageBase&lt;starknet::storage::Mutable&lt;MyStruct&gt;&gt;,\n}\n\npub struct ContractState {}\n\nimpl StorageBaseImpl of starknet::storage::StorageBaseTrait&lt;ContractState&gt; {\n    type BaseType = ContractStorageBase;\n    type BaseMutType = ContractStorageBaseMut;\n\n    fn storage_base(self: @ContractState) -&gt; ContractStorageBase {\n        ContractStorageBase {\n           member: starknet::storage::StorageBase{ address: selector!(\"balance\") },\n        }\n    }\n    fn storage_base_mut(ref self: ContractState) -&gt; ContractStorageBaseMut {\n        ContractStorageBaseMut {\n           member: starknet::storage::StorageBase{ address: selector!(\"balance\") },\n        }\n    }\n}\n \nimpl ContractStateDeref of core::ops::SnapshotDeref&lt;ContractState&gt; {\n    type Target = ContractStorageBase;\n    fn snapshot_deref(self: @ContractState) -&gt; ContractStorageBase {\n        self.storage_base()\n    }\n}\n\nimpl ContractStateDerefMut of core::ops::DerefMut&lt;ContractState&gt; {\n    type Target = ContractStorageBaseMut;\n    fn deref_mut(ref self: ContractState) -&gt; ContractStorageBaseMut {\n        self.storage_base_mut()\n    }\n}\n</code></pre>\n<p>The above generated code shows us how <code>self.member</code> works, via the <code>DerefMut</code> implementation between <code>ref ContractState</code> and <code>ContractStorageBaseMut</code> that has <code>member</code> of type <code>StorageBase&lt;Mutable&lt;MyStruct&gt;&gt;</code>. To see how we can get from <code>StorageBase&lt;Mutable&lt;MyStruct&gt;&gt;</code> to <code>MyStruct</code>‚Äôs members, we need to follow the chain of derefs defined in storage.cairo:</p>\n<pre><code class=\"lang-auto\">// StorageBase&lt;Mutable&lt;MyStruct&gt;&gt; --&gt; StoragePath&lt;Mutable&lt;MyStruct&gt;&gt;\nimpl StorageBaseDeref&lt;T&gt; of core::ops::Deref&lt;StorageBase&lt;T&gt;&gt; {\n    type Target = StoragePath&lt;T&gt;;\n    fn deref(self: StorageBase&lt;T&gt;) -&gt; Self::Target {\n        self.as_path()\n    }\n}\n</code></pre>\n<p><code>StorageBase</code> represents the initial address of some type in storage. <code>StoragePath</code> is a struct that maintains a hash state that can be modified until we reach the storage location we need, and was devised mostly for <code>Map</code> accesses (or more complex storage accesses, such as storage nodes that we‚Äôll see in subsequent sections).</p>\n<p>We can now convert the <code>StoragePath</code> to a storage pointer by finalizing the hash state:</p>\n<pre><code class=\"lang-auto\">// StoragePath&lt;Mutable&lt;MyStruct&gt;&gt; --&gt; StoragePointer0Offset&lt;Mutable&lt;MyStruct&gt;&gt;\nimpl StoragePathDeref&lt;\n    T, impl PointerImpl: StorageAsPointer&lt;StoragePath&lt;T&gt;&gt;\n&gt; of core::ops::Deref&lt;StoragePath&lt;T&gt;&gt; {\n    type Target = StoragePointer0Offset&lt;PointerImpl::Value&gt;;\n    fn deref(self: StoragePath&lt;T&gt;) -&gt; StoragePointer0Offset&lt;PointerImpl::Value&gt; {\n        self.as_ptr()\n    }\n}\n\n// T is Mutable&lt;MyStruct&gt;, this impl gives us `as_ptr` that is used above\nimpl MutableStorableStoragePathAsPointer&lt;\n    T, +MutableTrait&lt;T&gt;, +starknet::Store&lt;MutableTrait::&lt;T&gt;::InnerType&gt;\n&gt; of StorageAsPointer&lt;StoragePath&lt;T&gt;&gt; {\n    type Value = T;\n    fn as_ptr(self: @StoragePath&lt;T&gt;) -&gt; StoragePointer0Offset&lt;T&gt; {\n        StoragePointer0Offset { address: (*self).finalize() }\n    }\n}\n\n// StoragePointer0Offset&lt;Mutable&lt;MyStruct&gt;&gt; --&gt; StoragePointer&lt;Mutable&lt;MyStruct&gt;&gt;\nimpl StoragePointer0OffsetDeref&lt;T&gt; of core::ops::Deref&lt;StoragePointer0Offset&lt;T&gt;&gt; {\n    type Target = StoragePointer&lt;T&gt;;\n    fn deref(self: StoragePointer0Offset&lt;T&gt;) -&gt; StoragePointer&lt;T&gt; {\n        StoragePointer::&lt;T&gt; { address: self.address, offset: 0 }\n    }\n}\n\npub struct Mutable&lt;T&gt; {}\n\ntrait MutableTrait&lt;T&gt; {\n    type InnerType;\n}\n\nimpl MutableImpl&lt;T&gt; of MutableTrait&lt;Mutable&lt;T&gt;&gt; {\n    type InnerType = T;\n}\n</code></pre>\n<p>The above derefs brought us to <code>StoragePointer&lt;Mutable&lt;MyStruct&gt;&gt;</code>. This is where the new sub pointers types kick in, via the following two derefs in storage.cairo:</p>\n<pre><code class=\"lang-auto\">// StoragePointer&lt;MyStruct&gt; --&gt;  MyStructSubPointers\nimpl SubPointersDeref&lt;T, +SubPointers&lt;T&gt;&gt; of core::ops::Deref&lt;StoragePointer&lt;T&gt;&gt; {\n    type Target = SubPointers::&lt;T&gt;::SubPointersType;\n    fn deref(self: StoragePointer&lt;T&gt;) -&gt; Self::Target {\n        self.sub_pointers()\n    }\n}\n\n// StoragePointer&lt;Mutable&lt;MyStruct&gt; --&gt; MutableMyStructSubPointers\nimpl MutableSubPointersDeref&lt;\n    T, +MutableSubPointers&lt;T&gt;\n&gt; of core::ops::Deref&lt;StoragePointer&lt;Mutable&lt;T&gt;&gt;&gt; {\n    type Target = MutableSubPointers::&lt;T&gt;::SubPointersType;\n    fn deref(self: StoragePointer&lt;Mutable&lt;T&gt;&gt;) -&gt; Self::Target {\n        self.mutable_sub_pointers()\n    }\n}\n</code></pre>\n<p>Now that we hold the <code>MutableMyStructSubPointers</code> type, to see why <code>self.member.a</code> works, we only need a reminder of the sub pointers type definition:</p>\n<pre><code class=\"lang-auto\">struct MutableMyStructSubPointers {\n    a: starknet::storage::StoragePointer&lt;Mutable&lt;u128&gt;&gt;,\n    b: starknet::storage::StoragePointer&lt;Mutable&lt;u128&gt;&gt;,\n}\n</code></pre>\n<p>Finally, <code>self.a.read()</code> works since <code>StoragePointer&lt;T&gt;</code> exposes read, and <code>self.a.write()</code> works since <code>StoragePointer&lt;Mutable&lt;T&gt;&gt;</code> exposes write:</p>\n<pre><code class=\"lang-auto\">// Store-based read for StoragePointer&lt;T&gt;\npub impl StorableStoragePointerReadAccess&lt;\n    T, +starknet::Store&lt;T&gt;\n&gt; of StoragePointerReadAccess&lt;StoragePointer&lt;T&gt;&gt; {\n    type Value = T;\n    fn read(self: @StoragePointer&lt;T&gt;) -&gt; T {\n        starknet::SyscallResultTrait::unwrap_syscall(\n            starknet::Store::&lt;T&gt;::read_at_offset(0, *self.address, *self.offset)\n        )\n    }\n}\n\n// When T is `Mutable&lt;K&gt;`, we need a separate \"read\" implementation in order to reach the internal type\nimpl MutableStorableStoragePointerReadAccess&lt;\n    T, +MutableTrait&lt;T&gt;, +starknet::Store&lt;MutableTrait::&lt;T&gt;::InnerType&gt;\n&gt; of StoragePointerReadAccess&lt;StoragePointer&lt;T&gt;&gt; {\n    type Value = MutableTrait::&lt;T&gt;::InnerType;\n    fn read(self: @StoragePointer&lt;T&gt;) -&gt; MutableTrait::&lt;T&gt;::InnerType {\n        starknet::SyscallResultTrait::unwrap_syscall(\n            starknet::Store::&lt;\n                MutableTrait::&lt;T&gt;::InnerType\n            &gt;::read_at_offset(0, *self.address, *self.offset)\n        )\n    }\n}\n\n// Write implementation for StoragePointer&lt;T&gt; where T is Mutable&lt;K&gt;\nimpl MutableStorableStoragePointerWriteAccess&lt;\n    T, +MutableTrait&lt;T&gt;, +starknet::Store&lt;MutableTrait::&lt;T&gt;::InnerType&gt;\n&gt; of StoragePointerWriteAccess&lt;StoragePointer&lt;T&gt;&gt; {\n    type Value = MutableTrait::&lt;T&gt;::InnerType;\n    fn write(self: StoragePointer&lt;T&gt;, value: MutableTrait::&lt;T&gt;::InnerType) {\n        starknet::SyscallResultTrait::unwrap_syscall(\n            starknet::Store::&lt;\n                MutableTrait::&lt;T&gt;::InnerType\n            &gt;::write_at_offset(0, self.address, self.offset, value)\n        )\n    }\n}\n</code></pre>\n<p>To summarize, we followed the path:</p>\n<p><code>ref ContractState</code> ‚Üí (deref) ‚Üí <code>ContractStorageBaseMut</code> ‚Üí  (<code>self.member</code>) ‚Üí <code>StorageBase&lt;Mutable&lt;MyStruct&gt;&gt;</code> ‚Üí (deref) ‚Üí <code>StoragePath&lt;Mutable&lt;MyStruct&gt;&gt;</code> ‚Üí (deref)  ‚Üí <code>StoragePointer0Offset&lt;Mutable&lt;MyStruct&gt;&gt;</code> ‚Üí (deref) ‚Üí <code>StoragePointer&lt;Mutable&lt;MyStruct&gt;&gt;</code> ‚Üí (deref) ‚Üí <code>MutableMyStructSubPointers</code>.</p>\n<h3><a name=\"maps-8\" class=\"anchor\" href=\"https://community.starknet.io#maps-8\"></a>Maps</h3>\n<p>Say goodbye to <code>LegacyMap</code>. <code>Map</code> is a new and more flexible type for maintaining mappings in a contract storage. With <code>Map&lt;K,V&gt;</code> we can:</p>\n<ul>\n<li>Have nested Maps (rather than having a tuple type key with <code>LegacyMap</code>)</li>\n<li>Have <code>Map</code> as a member of a struct (we will dive into this in the following <code>storage_node</code> section)</li>\n</ul>\n<p>Note that the storage layout of <code>Map&lt;K, V&gt;</code> is identical to that <code>LegacyMap&lt;K,V&gt;</code>, hence you can safely migrate to the new type.</p>\n<p>The <code>Map</code> type can not be instantiated via user code.</p>\n<p>To illustrate the use of the new type, consider the following simple contract:</p>\n<pre><code class=\"lang-auto\">#[starknet::contract]\nmod simple_contract {\n    use starknet::{ContractAddress, contract_address_const};\n    use starknet::storage::{Map, StoragePathEntry};\n    /// the latest edition 2024_07 also requires the following imports:\n    use starknet::storage::{StorageMapReadAccess, StorageMapWriteAccess}\n\n    #[storage]\n    struct Storage {\n        basic: u128,\n        balances: Map&lt;ContractAddress, u256&gt;,\n        nested_balances: Map&lt;ContractAddress, Map&lt;ContractAddress, u256&gt;&gt;,\n    }\n\n    #[abi(per_item)]\n    #[generate_trait]\n    pub impl SimpleContract of SimpleContractTrait {\n        #[external(v0)]\n        fn test_new_storage(ref self: ContractState) {\n            let address = contract_address_const::&lt;1&gt;();\n            self.balances.entry(address).read();\n            self.nested_balances.entry(address).entry(address).read();   \n            self.nested_balances.entry(address).entry(address).write(5);\n        }\n    }\n}\n</code></pre>\n<h3><a name=\"maps-under-the-hood-9\" class=\"anchor\" href=\"https://community.starknet.io#maps-under-the-hood-9\"></a>Maps - under the hood</h3>\n<p>The basic types that the new maps require are <code>Map</code> and <code>EntryInfo</code>. The purpose of these types is for us to be able to refer to the key type and value type from a <code>Map</code> instance, as illustrated by the following code in the corelib:</p>\n<pre><code class=\"lang-auto\">#[phantom]\npub struct Map&lt;K, V&gt; {}\n\n/// A trait for making a map like type support implement the `StoragePathEntry` trait.\ntrait EntryInfo&lt;T&gt; {\n    type Key;\n    type Value;\n}\n\nimpl EntryInfoImpl&lt;K, V&gt; of EntryInfo&lt;Map&lt;K, V&gt;&gt; {\n    type Key = K;\n    type Value = V;\n}\n</code></pre>\n<p>Accessing entires of a collection <code>C</code> is done via implementing the following trait:</p>\n<pre><code class=\"lang-auto\">pub trait StoragePathEntry&lt;C&gt; {\n    type Key;\n    type Value;\n    fn entry(self: C, key: Self::Key) -&gt; StoragePath&lt;Self::Value&gt;;\n}\n</code></pre>\n<p>Now we can proceed to show how the code from our previous example works:</p>\n<pre><code class=\"lang-auto\">self.balances.entry(address).read()\n</code></pre>\n<p>We already know, from diving into the implementation of individual members access, that <code>ContractState</code> can be dereferenced to <code>ContractStorageBase</code>, where <code>balances</code> is of type <code>StorageBase&lt;Map&lt;ContractAddress, u256&gt;</code>, which can then be dereferenced <code>StoragePath&lt;Map&lt;ContractAddress, u256&gt;&gt;</code> (to get write access, we would need to start from <code>ref ContractState</code>, which can be derefed to <code>ContractStorageBaseMut</code>, which in turn has a <code>balances</code> member of type <code>StoragePath&lt;Mutable&lt;Map&lt;ContractAddress, u256&gt;&gt;&gt;</code>).</p>\n<p>From <code>StoragePath&lt;Map&lt;ContractAddress, u256&gt;&gt;</code> or <code>StoragePath&lt;Mutable&lt;Map&lt;ContractAddress, u256&gt;&gt;&gt;</code> we get the <code>entry</code> functionality via one of the following implementations:</p>\n<pre><code class=\"lang-auto\">impl EntryInfoStoragePathEntry&lt;\n    T, \n    +EntryInfo&lt;T&gt;, \n    +core::hash::Hash&lt;EntryInfo::&lt;T&gt;::Key, \n     StoragePathHashState&gt;\n&gt; of StoragePathEntry&lt;StoragePath&lt;T&gt;&gt; {\n    type Key = EntryInfo::&lt;T&gt;::Key;\n    type Value = EntryInfo::&lt;T&gt;::Value;\n    fn entry(self: StoragePath&lt;T&gt;, key: EntryInfo::&lt;T&gt;::Key) -&gt; StoragePath&lt;EntryInfo::&lt;T&gt;::Value&gt; {\n        StoragePath::&lt;\n            EntryInfo::&lt;T&gt;::Value\n        &gt; {\n            hash_state: core::hash::Hash::&lt;\n                EntryInfo::&lt;T&gt;::Key, StoragePathHashState\n            &gt;::update_state(self.hash_state, key)\n        }\n    }\n}\n\nimpl MutableEntryStoragePathEntry&lt;\n    T,\n    +MutableTrait&lt;T&gt;,\n    impl EntryImpl: EntryInfo&lt;MutableTrait::&lt;T&gt;::InnerType&gt;,\n    +core::hash::Hash&lt;EntryImpl::Key,\n    StoragePathHashState&gt;\n&gt; of StoragePathEntry&lt;StoragePath&lt;T&gt;&gt; {\n    type Key = EntryImpl::Key;\n    type Value = Mutable&lt;EntryImpl::Value&gt;;\n    fn entry(self: StoragePath&lt;T&gt;, key: EntryImpl::Key) -&gt; StoragePath&lt;Mutable&lt;EntryImpl::Value&gt;&gt; {\n        StoragePath::&lt;\n            Mutable&lt;EntryImpl::Value&gt;\n        &gt; {\n            hash_state: core::hash::Hash::&lt;\n                EntryImpl::Key, StoragePathHashState\n            &gt;::update_state(self.hash_state, key)\n        }\n    }\n}\n</code></pre>\n<p>Above, we can see that <code>entry</code> modifies the <code>StoragePath</code> with a single hash application (specifically, Pedersen hash, as <code>StoragePathHashState</code> is just an alias to <code>PedersenHashState</code>). After calling entry, we end up with <code>StoragePath&lt;EntryInfo::&lt;T&gt;::Value&gt;</code> or <code>StoragePath&lt;Mutable&lt;EntryImpl::Value&gt;&gt;</code>. Note that <code>Value</code> can either implement <code>Store</code>, or itself be another <code>Map</code>, over which we can again call <code>entry</code>. If <code>Value</code> implements <code>Store</code>, then read access will be give by one of the following impls:</p>\n<pre><code class=\"lang-auto\">impl StorableEntryReadAccess&lt;\n    T,\n    +EntryInfo&lt;T&gt;,\n    +core::hash::Hash&lt;EntryInfo::&lt;T&gt;::Key,StoragePathHashState&gt;,\n    +starknet::Store&lt;EntryInfo::&lt;T&gt;::Value&gt;,\n&gt; of StorageMapReadAccessTrait&lt;StoragePath&lt;T&gt;&gt; {\n    type Key = EntryInfo::&lt;T&gt;::Key;\n    type Value = EntryInfo::&lt;T&gt;::Value;\n    fn read(self: StoragePath&lt;T&gt;, key: EntryInfo::&lt;T&gt;::Key) -&gt; EntryInfo::&lt;T&gt;::Value {\n        self.entry(key).as_ptr().read()\n    }\n}\n\nimpl MutableStorableEntryReadAccess&lt;\n    T,\n    +MutableTrait&lt;T&gt;,\n    +EntryInfo&lt;MutableTrait::&lt;T&gt;::InnerType&gt;,\n    +core::hash::Hash&lt;EntryInfo::&lt;MutableTrait::&lt;T&gt;::InnerType&gt;::Key, StoragePathHashState&gt;,\n    +starknet::Store&lt;EntryInfo::&lt;MutableTrait::&lt;T&gt;::InnerType&gt;::Value&gt;,\n&gt; of StorageMapReadAccessTrait&lt;StoragePath&lt;T&gt;&gt; {\n    type Key = EntryInfo::&lt;MutableTrait::&lt;T&gt;::InnerType&gt;::Key;\n    type Value = EntryInfo::&lt;MutableTrait::&lt;T&gt;::InnerType&gt;::Value;\n    #[inline(always)]\n    fn read(\n        self: StoragePath&lt;T&gt;, key: EntryInfo::&lt;MutableTrait::&lt;T&gt;::InnerType&gt;::Key\n    ) -&gt; EntryInfo::&lt;MutableTrait::&lt;T&gt;::InnerType&gt;::Value {\n        self.entry(key).as_ptr().read()\n    }\n}\n</code></pre>\n<p>A similar impl will give us write capabilities with the type <code>StoragePath&lt;Mutable&lt;EntryImpl::Value&gt;&gt;</code>.</p>\n<h3><a name=\"storage-vecs-10\" class=\"anchor\" href=\"https://community.starknet.io#storage-vecs-10\"></a>Storage vecs</h3>\n<p>So far, to have sequential access to a collection in storage, one needed to use maps or a custom implementation, e.g., as done by <a href=\"https://github.com/OpenZeppelin/cairo-contracts/blob/4f4e2e48bd86d99c3ee5ee405140bf1681529a2e/src/utils/structs/storage_array.cairo#L16\">OpenZeppelin</a>. This version introduces the <code>Vec</code> type, which allows keeping vectors in a contract‚Äôs storage.</p>\n<p>Below is an example of how one can use storage vectors:</p>\n<pre><code class=\"lang-auto\">use starknet::storage::{Vec, VecTrait, MutableVecTrait};\n\n#[storage]\nstruct Storage {\n    var1: Vec&lt;u256&gt;,\n    var2: Vec&lt;Map&lt;u8, Vec&lt;u8&gt;&gt;&gt;\n}\n\nfn foo(ref self: ContractState) {\n  self.var1.append().write(1);\n  self.var1.append().write(2);\n  assert!(self.var1.len() == 2);\n  assert!(self.var1[0].read() == 1 &amp;&amp; self.var1[1].read() == 2);\n  self.var1[0].write(4);\n  self.var2.append().entry(5).append().write(1);\n  assert!(self.var2[0].entry(5)[0].read() == 1);\n  self.var1[3].read(); // panic (out of bounds)\n}\n</code></pre>\n<h3><a name=\"storage-vecs-under-the-hood-11\" class=\"anchor\" href=\"https://community.starknet.io#storage-vecs-under-the-hood-11\"></a>Storage vecs - under the hood</h3>\n<p>The <code>VecTrait</code> and <code>MutableVecTrait</code> traits give us the ability to access vec indices and append new elements. These impls operate on <code>StoragePath&lt;Vec&lt;T&gt;&gt;</code> and <code>StoragePath&lt;Mutable&lt;Vec&lt;T&gt;&gt;&gt;</code>, which are the member types of the generated <code>ContractStorageBase</code> and <code>ContractStorageBaseMut</code> types, as we‚Äôve seen in ‚Äúindividual storage access - under the hood‚Äù.</p>\n<pre><code class=\"lang-auto\">pub struct Vec&lt;T&gt; {}\n\npub trait VecTrait&lt;T&gt; {\n    type ElementType;\n    fn at(self: T, index: u64) -&gt; StoragePath&lt;Self::ElementType&gt;;\n    fn len(self: T) -&gt; u64;\n}\n\npub trait MutableVecTrait&lt;T&gt; {\n    type ElementType;\n    fn at(self: T, index: u64) -&gt; StoragePath&lt;Mutable&lt;Self::ElementType&gt;&gt;;\n    fn len(self: T) -&gt; u64;\n    fn append(self: T) -&gt; StoragePath&lt;Mutable&lt;Self::ElementType&gt;&gt;;\n}\n\nimpl VecImpl&lt;T&gt; of VecTrait&lt;StoragePath&lt;Vec&lt;T&gt;&gt;&gt; {\n    type ElementType = T;\n    fn get(self: StoragePath&lt;Vec&lt;T&gt;&gt;, index: u64) -&gt; Option&lt;StoragePath&lt;T&gt;&gt; {\n        let vec_len = self.len();\n        if index &lt; vec_len {\n            Option::Some(self.update(index))\n        } else {\n            Option::None\n        }\n    }\n    fn at(self: StoragePath&lt;Vec&lt;T&gt;&gt;, index: u64) -&gt; StoragePath&lt;T&gt; {\n        assert!(index &lt; self.len(), \"Index out of bounds\");\n        self.update(index)\n    }\n    fn len(self: StoragePath&lt;Vec&lt;T&gt;&gt;) -&gt; u64 {\n        self.as_ptr().read()\n    }\n}\n\nimpl MutableVecImpl&lt;T&gt; of MutableVecTrait&lt;StoragePath&lt;Mutable&lt;Vec&lt;T&gt;&gt;&gt;&gt; {\n    type ElementType = T;\n    fn get(self: StoragePath&lt;Mutable&lt;Vec&lt;T&gt;&gt;&gt;, index: u64) -&gt; Option&lt;StoragePath&lt;Mutable&lt;T&gt;&gt;&gt; {\n        let vec_len = self.len();\n        if index &lt; vec_len {\n            Option::Some(self.update(index))\n        } else {\n            Option::None\n        }\n    }\n    fn at(self: StoragePath&lt;Mutable&lt;Vec&lt;T&gt;&gt;&gt;, index: u64) -&gt; StoragePath&lt;Mutable&lt;T&gt;&gt; {\n        assert!(index &lt; self.len(), \"Index out of bounds\");\n        self.update(index)\n    }\n    fn len(self: StoragePath&lt;Mutable&lt;Vec&lt;T&gt;&gt;&gt;) -&gt; u64 {\n        self.as_ptr().read()\n    }\n    fn append(self: StoragePath&lt;Mutable&lt;Vec&lt;T&gt;&gt;&gt;) -&gt; StoragePath&lt;Mutable&lt;T&gt;&gt; {\n        let vec_len = self.len();\n        self.as_ptr().write(vec_len + 1);\n        self.update(vec_len)\n    }\n}\n</code></pre>\n<p>Note that the storage layout of <code>Vec</code> is determined by the <code>get</code> implementation, which computes the address of the n‚Äôth element as <code>h(base_address, n)</code>, where <code>h</code> is the Pedersen hash function. The length of the array is held at <code>base_address</code>, where the base address is determined by the location of the array with respect to the <code>Storage</code> struct. For example, in the case of <code>var1</code> above, the base address is <code>sn_keccak(\"var1\")</code>, while the base address of <code>self.var2[0].entry(5).read()</code> is <code>pedersen(sn_keccak(\"var2\"), 5)</code>.</p>\n<h3><a name=\"storage-nodes-12\" class=\"anchor\" href=\"https://community.starknet.io#storage-nodes-12\"></a>Storage nodes</h3>\n<p>Storage nodes are a new concept introduced in Cairo v2.7.0. The motivation behind them was to have <code>Map</code>, or other ‚Äúspecial‚Äù types that do not implement <code>Store</code> but can appear inside <code>Storage</code>, as potential members of structs.</p>\n<p>You can think of storage nodes as nodes in a tree that lie within the contract storage space. Content is stored in the leaves, and intermediate nodes allow you to point to other locations in storage. Consider the following example:</p>\n<pre><code class=\"lang-auto\">struct Storage {\n    member: MyNode\n}\n\n#[starknet::storage_node]\nstruct MyNode {\n    a: u8,\n    b: u256,\n    c: Map&lt;u256, u256&gt;\n}\n\nfn foo(self: @ContractState) {\n   self.member.c.entry(5).read();\n}\n</code></pre>\n<p>Thanks to the <code>#[starknet::storage_node]</code> attribute over <code>MyNode</code>, we can have storage variables of type <code>MyNode</code>, although it doesn‚Äôt implement <code>Store</code>.</p>\n<p>The storage layout of <code>MyNode</code> will be based on the names of its members: <code>a</code>, <code>b</code>, and <code>c</code>. For example, the actual storage key read by <code>self.member.c.entry(5).read()</code> is:</p>\n<p><code>h(sn_keccak(\"member\"), h(sn_keccak(\"c\"), 5))</code>,</p>\n<p>where <code>h</code> is the Pedersen hash function.</p>\n<p>Maps in structs are not the only thing that you can do with storage nodes. To illustrate their strength, consider the following example:</p>\n<pre><code class=\"lang-auto\">struct Storage {\n    root: StorageTreeNode\n}\n\n#[starknet::storage_node]\nstruct StorageTreeNode {\n    value: u32,\n    left: StorageTreeNode,\n    right: StorageTreeNode\n}\n</code></pre>\n<p>Without the <code>#[starknet::storage_node]</code> attribute, the above code would not have compiled as <code>StorageTreeNode</code> has infinite size. The <code>#[starknet::storage_node]</code> attribute tells the compiler that <code>StorageTreeNode</code> will never be instantiated directly and will only serve to point to storage locations.</p>\n<p>Note that to make the above example interesting, you would need another property on <code>StorageTreeNode</code> which tells you whether or not you‚Äôre at a leaf (or, e.g., change <code>value</code> to <code>Option&lt;u32&gt;</code>, where <code>None</code> indicates that you hit a leaf). It‚Äôs important to emphasize that a storage node does not carry value by itself, it is essentially a path to some storage location from which I can read members. Hence, I cannot ask if <code>self.root.left</code> is <code>None</code>, it is a path to some location in storage, I can always point to it. Any actual information should be kept in storeable members of the storage node.</p>\n<h3><a name=\"storage-nodes-under-the-hood-13\" class=\"anchor\" href=\"https://community.starknet.io#storage-nodes-under-the-hood-13\"></a>Storage nodes - under the hood</h3>\n<p>Throughout this section, we‚Äôll use the following storage node as our example:</p>\n<pre><code class=\"lang-auto\">#[storage]\nstruct Storage {\n    member: MyNode\n}\n\n#[starknet::storage_node]\nstruct MyNode {\n    a: u8,\n    b: Map&lt;u256, u256&gt;,\n    c: MyNode\n}\n\nfn foo(self: @ContractState) {\n   self.member.a.read();\n   self.member.b.entry(5).read();\n   self.c.c.a.read();\n}\n\n</code></pre>\n<p>When trying to work out <code>self.member.a.read()</code>, without the new <code>#[storage_node]</code> attribute, trying to follow the path from ‚Äúindividual member access - under the hood‚Äù, we will break when trying to deref from<br>\n<code>StoragePath&lt;MyNode&gt;</code> to <code>StoragePointer0Offset&lt;MyNode&gt;, since the deref implementation needs an impl of the </code>StorageAsPointer trait, and the following generic implementation in the corelib won‚Äôt help since we don‚Äôt have <code>Store</code>:</p>\n<pre><code class=\"lang-auto\">pub trait StorageAsPointer&lt;TMemberState&gt; {\n    type Value;\n    fn as_ptr(self: @TMemberState) -&gt; StoragePointer0Offset&lt;Self::Value&gt;;\n}\n\nimpl StorableStoragePathAsPointer&lt;T, +starknet::Store&lt;T&gt;&gt; of StorageAsPointer&lt;StoragePath&lt;T&gt;&gt; {\n    type Value = T;\n    fn as_ptr(self: @StoragePath&lt;T&gt;) -&gt; StoragePointer0Offset&lt;T&gt; {\n        StoragePointer0Offset { address: (*self).finalize() }\n    }\n}\n</code></pre>\n<p>Thus, we need a new way to get <code>read</code> from <code>StoragePath&lt;MyNode&gt;</code> without relying on <code>Store</code> (we will ignore <code>write</code> in this section since it is a repetition of the same <code>Mutable&lt;T&gt;</code> trick we‚Äôve seen in the previous sections).</p>\n<p>When annotating <code>MyNode</code> with the <code>#[starknet::storage_node]</code> attribute, the following code is generated:</p>\n<pre><code class=\"lang-auto\">#[derive(Drop, Copy)]\nstruct MyNodeStorageNode {\n    a: starknet::storage::PendingStoragePath&lt;u8&gt;,\n    b: starknet::storage::PendingStoragePath&lt;Map&lt;u256, u256&gt;&gt;,\n    c: starknet::storage::PendingStoragePath&lt;MyNode&gt;,\n}\n\nimpl MyNodeStorageNodeImpl of StorageNode&lt;MyNode&gt; {\n   \n   type NodeType = BalancePairStorageNode;\n\n   fn storage_node(self: StoragePath&lt;MyNode&gt;) -&gt; MyNodeStorageNode {\n        let a_value = PendingStoragePathTrait::new(\n                        @self,\n                        selector!(\"a\")\n                    );\n        let b_value = PendingStoragePathTrait::new(\n                        @self,\n                        selector!(\"b\")\n                    );\n        let c_value = PendingStoragePathTrait::new(\n                        @self,\n                        selector!(\"c\")\n                    );\n        MyNodeStorageNode {\n           a: a_value,\n           b: b_value,\n           c: c_value\n        }\n    }\n}\n</code></pre>\n<p>The above is similar to the generated sub pointers type, except now we need to encode <code>MyNode</code> member names in the storage path somehow. To this end, the <code>PendingStoragePath</code> type was introduced:</p>\n<pre><code class=\"lang-auto\">struct PendingStoragePath&lt;T&gt; {\n    hash_state: StoragePathHashState, // PedersenHashState\n    pending_key: felt252\n}\n</code></pre>\n<p>Now, the following deref implementation in the corelib completes the picture:</p>\n<pre><code class=\"lang-auto\">impl StorageNodeDeref&lt;T, +StorageNode&lt;T&gt;&gt; of core::ops::Deref&lt;StoragePath&lt;T&gt;&gt; {\n    type Target = StorageNode::&lt;T&gt;::NodeType;\n    fn deref(self: StoragePath&lt;T&gt;) -&gt; Self::Target {\n        self.storage_node()\n    }\n}\n</code></pre>\n<p>This is what gets us from <code>StoragePath&lt;MyNode&gt;</code> to <code>MyNodeStorageNode</code>, a struct whose members are <code>a</code>, <code>b</code>, and <code>c</code> (same as <code>MyNode</code>), but with the member types being wrapped by <code>PendingStoragePath</code>.</p>\n<p>The <code>read</code> functionality on <code>PendingStoragePath&lt;u8&gt;</code> comes from the following impls in the corelib:</p>\n<pre><code class=\"lang-auto\">// PendingStoragePath --&gt; StoragePath\nimpl PendingStoragePathAsPath&lt;T&gt; of StorageAsPath&lt;PendingStoragePath&lt;T&gt;&gt; {\n    type Value = T;\n    fn as_path(self: @PendingStoragePath&lt;T&gt;) -&gt; StoragePath&lt;T&gt; {\n        StoragePath::&lt;\n            T\n        &gt; { hash_state: core::hash::HashStateTrait::update(*self.hash_state, *self.pending_key) }\n    }\n}\n\n// T is PendingStoragePath&lt;u8&gt;\nimpl StorablePathableStorageAsPointer&lt;\n    T,\n    impl PathImpl: StorageAsPath&lt;T&gt;,\n    // PathImpl::Value is u8, the StorageAsPointer&lt;u8&gt;  impl is given by `StorableStoragePathAsPointer`\n    impl PtrImpl: StorageAsPointer&lt;StoragePath&lt;PathImpl::Value&gt;&gt;,\n&gt; of StorageAsPointer&lt;T&gt; {\n    type Value = PtrImpl::Value;\n    fn as_ptr(self: @T) -&gt; StoragePointer0Offset&lt;PtrImpl::Value&gt; {\n        let path = self.as_path();\n        path.as_ptr()\n    }\n}\n\n// This impl grants us `self.member.a.read()`\nimpl StorablePointerReadAccessImpl&lt;\n    T,\n    impl PointerImpl: StorageAsPointer&lt;T&gt;,\n    impl AccessImpl: StoragePointerReadAccess&lt;StoragePointer0Offset&lt;PointerImpl::Value&gt;&gt;,\n    +Drop&lt;T&gt;,\n    +Drop&lt;AccessImpl::Value&gt;,\n&gt; of StoragePointerReadAccess&lt;T&gt; {\n    type Value = AccessImpl::Value;\n    fn read(self: @T) -&gt; Self::Value {\n        self.as_ptr().read()\n    }\n}\n</code></pre>\n<p>The above shows us how can we get access to ‚Äústorable‚Äù members of the storage node. But what about <code>self.member.b.entry(5).read()</code> or <code>self.member.c.c.a.read()</code>.</p>\n<p>To get access to the map member via</p>\n<p><code>self.member.b.entry(5).read()</code></p>\n<p>we need the following two impls:</p>\n<pre><code class=\"lang-auto\">// T is PendingStoragePath&lt;Map&lt;u256, u256&gt;&gt;`\nimpl PathableStorageEntryImpl&lt;\n    T,\n    impl PathImpl: StorageAsPath&lt;T&gt;,\n    impl EntryImpl: StoragePathEntry&lt;StoragePath&lt;PathImpl::Value&gt;&gt;,\n    +Drop&lt;T&gt;,\n    +Drop&lt;EntryImpl::Key&gt;,\n&gt; of StoragePathEntry&lt;T&gt; {\n    type Key = EntryImpl::Key;\n    type Value = EntryImpl::Value;\n    fn entry(self: T, key: Self::Key) -&gt; StoragePath&lt;Self::Value&gt; {\n        let path = PathImpl::as_path(@self);\n        EntryImpl::entry(path, key)\n    }\n}\n\n// T is `StoragePath&lt;Map&lt;u256, u256&gt;&gt;`\nimpl StorageAsPathReadForward&lt;\n    T,\n    impl PathImpl: StorageAsPath&lt;T&gt;,\n    impl AccessImpl: StorageMapReadAccessTrait&lt;StoragePath&lt;PathImpl::Value&gt;&gt;,\n    +Drop&lt;T&gt;,\n    +Drop&lt;AccessImpl::Key&gt;,\n&gt; of StorageMapReadAccessTrait&lt;T&gt; {\n    type Key = AccessImpl::Key;\n    type Value = AccessImpl::Value;\n    #[inline(always)]\n    fn read(self: T, key: AccessImpl::Key) -&gt; AccessImpl::Value {\n        self.as_path().read(key)\n    }\n}\n</code></pre>\n<p>To keep reading the next storage node via e.g.</p>\n<p><code>self.member.c.c.a.read()</code></p>\n<p>we need to go back from <code>PendingStoragePath&lt;MyNode&gt;</code> back to <code>StoragePath&lt;MyNode&gt;</code>, from which we can again call the <code>storage_node()</code> function and obtain the <code>PendingStoragePath&lt;MyNode&gt;</code> type. This is achieve by the following deref impl:</p>\n<pre><code class=\"lang-auto\">impl PendingStoragePathDeref&lt;T&gt; of core::ops::Deref&lt;PendingStoragePath&lt;T&gt;&gt; {\n    type Target = StoragePath&lt;T&gt;;\n    fn deref(self: PendingStoragePath&lt;T&gt;) -&gt; Self::Target {\n        self.as_path()\n    }\n}\n</code></pre>\n<h3><a name=\"new-storage-design-examples-14\" class=\"anchor\" href=\"https://community.starknet.io#new-storage-design-examples-14\"></a>New storage design - examples</h3>\n<p>The new storage primitives that were discussed in the previous sections open new possibilities. We cover a few examples below.</p>\n<h4><a name=\"for-storage-variables-15\" class=\"anchor\" href=\"https://community.starknet.io#for-storage-variables-15\"></a>+= for Storage variables</h4>\n<p>A common storage access pattern is reading a value, adding/subtracting, and then writing the new value. With <code>StoragePath&lt;T&gt;</code> we can get the <code>+=</code> functionality for every storage variable whose type has an <code>AddAsign</code> implementation as follows:</p>\n<pre><code class=\"lang-auto\">#[starknet::contract]\nmod numeric_contract {\n    use core::ops::AddAssign;\n\n    pub impl AddAsignStorage&lt;\n        Lhs, Rhs, +Drop&lt;Lhs&gt;, +Drop&lt;Rhs&gt;, \n        +AddAssign&lt;Lhs, Rhs&gt;,\n        +Store&lt;Lhs&gt;\n    &gt; of AddAssign&lt;StorageBase&lt;Mutable&lt;Lhs&gt;&gt;, Rhs&gt; {\n        fn add_assign(ref self: StorageBase&lt;Mutable&lt;Lhs&gt;&gt;, rhs: Rhs) {\n            let mut value: Lhs = self.read();\n            value += rhs;\n            self.write(value);\n        }\n    }\n\n    #[storage]\n    struct Storage {\n        numeric: u128,\n    }\n\n    #[abi(per_item)]\n    #[generate_trait]\n    pub impl NumericContract of NumericContractTrait {\n        #[external(v0)]\n        fn inc(ref self: ContractState) {\n            let mut num = self.numeric;\n            num += 1;        \n        }\n    }\n}\n</code></pre>\n<p>By implementing <code>AddAsign</code> for <code>StorageBase&lt;Lhs&gt;</code> we were able to get <code>+=</code> for storage variables. Do note that this is not always desirable, since <code>+=</code> might hide expensive operations (storage write).</p>\n<p>Note that the above will not work for structs members, maps, and storage nodes, as those are not of type <code>StorageBase&lt;T&gt;</code>. To extend <code>+=</code> to all uints anywhere in storage, we need our impl to work on <code>StoragePath</code>, or more specifically anything that implements the <code>StorageAsPath</code> trait. This is illustrated below:</p>\n<pre><code class=\"lang-auto\">pub impl AddAsignStoragePath&lt;\n    Lhs, Rhs, +Drop&lt;Lhs&gt;, +Drop&lt;Rhs&gt;, \n    +AddAssign&lt;Lhs, Rhs&gt;,\n    +Store&lt;Lhs&gt;\n&gt; of AddAssign&lt;StoragePath&lt;Mutable&lt;Lhs&gt;&gt;, Rhs&gt; {\n    fn add_assign(ref self: StoragePath&lt;Mutable&lt;Lhs&gt;&gt;, rhs: Rhs) {\n        let mut value: Lhs = self.read();\n        value += rhs;\n        self.write(value);\n    }\n}\n\n// Lhs is StorageBase&lt;Mutable&lt;u8&gt;&gt;\n// LhsAsPath's value is Mutable&lt;u8&gt;\npub impl AddAsignStorageAsPath&lt;\n    Lhs, Rhs, +Drop&lt;Lhs&gt;, +Drop&lt;Rhs&gt;, \n    impl LhsAsPath: StorageAsPath&lt;Lhs&gt;,\n    +AddAssign&lt;StoragePath&lt;LhsAsPath::Value&gt;, Rhs&gt;\n&gt; of AddAssign&lt;Lhs, Rhs&gt; {\n    fn add_assign(ref self: Lhs, rhs: Rhs) {\n        let mut value = self.as_path();\n        value += rhs;\n    }\n}\n\n#[starknet::storage_node]\nstruct Numeric {\n    num: u8,\n    map: Map&lt;u8, u8&gt;\n}\n\nfn foo(ref self: ContractState) {\n    let mut numeric = self.numeric.num;\n    numeric += 1;\n    let mut numeric = self.numeric.map.read(5);\n    numeric += 6;\n}\n</code></pre>\n<p>To avoid the risk of having <code>+=</code> for storage variables that may have large hidden cost, one can ignore the <code>AddAssign</code> trait and implement a new trait, e.g. <code>StorageInc</code>, with an <code>inc</code> function that behaves similarly to the above</p>\n<h4><a name=\"giving-access-to-storage-variables-16\" class=\"anchor\" href=\"https://community.starknet.io#giving-access-to-storage-variables-16\"></a>Giving access to storage variables</h4>\n<p>In previous versions, the only way to access storage outside the contract module was to use components or the <code>unsafe_new_contract_state</code> function. With the new storage types, we can call functions that accept <code>StoragePath&lt;T&gt;</code>, and thus allow them to modify our storage.</p>\n<pre><code class=\"lang-auto\">#[starknet::storage_node]\nstruct Numeric {\n    num: u8,\n    map: Map&lt;u8, u8&gt;\n}\n\n#[storage]\nstruct Storage {\n    numeric: Numeric,\n    map: Map&lt;u8, u8&gt;,\n}\n\nfn foo(ref self: ContractState) {\n   modify_from_outside(self.numeric.deref(), self.map.deref());\n}\n\npub fn modify_from_outside(\n    numeric: StoragePath&lt;Mutable&lt;Numeric&gt;&gt;, \n    map: StoragePath&lt;Mutable&lt;Map&lt;u8,u8&gt;&gt;&gt; \n) {\n    numeric.num.write(1);\n    map.entry(5).write(3);\n}\n</code></pre>\n<p>Note that we had to call <code>deref</code> explicitly to move from <code>StorageBase</code> to <code>StoragePath</code>.</p>\n<p>This direction can yield a new way of writing components without much of the existing boilerplate. While still experimental, you can examine such an example in <a href=\"https://github.com/starkware-libs/cairo/blob/dev-v2.7.0/crates/cairo-lang-starknet/cairo_level_tests/components/erc20_mini.cairo\">erc20_mini.cairo</a>, and a contract using it in <a href=\"https://github.com/starkware-libs/cairo/blob/dev-v2.7.0/crates/cairo-lang-starknet/src/plugin/plugin_test_data/contracts/with_erc20_mini#L13\">with_erc20_mini</a>. With this approach, instead of using the <code>component!</code> macro and denoting a storage member by <code>#[substorage(v0)]</code>, you can define the component‚Äôs storage struct as a storage node.</p>\n<h2><a name=\"phantom-types-17\" class=\"anchor\" href=\"https://community.starknet.io#phantom-types-17\"></a>Phantom types</h2>\n<p>Types annotated by <code>#[phantom]</code> are types that cannot be instantiated. They are used to pass on information via traits that are implemented for them. For example, the following are phantom types:</p>\n<pre><code class=\"lang-auto\">#[phantom]\npub struct Map&lt;K, V&gt; {}\n\n#[phantom]\npub struct Vec&lt;T&gt; {}\n</code></pre>\n<p>This shouldn‚Äôt be surprising as the above types are only used as the generic type of <code>StoragePath</code>. The <code>Storage</code> struct and any struct annotated by <code>#[starknet::storage_node]</code> are also phantom types.</p>\n<h2><a name=\"associated-items-18\" class=\"anchor\" href=\"https://community.starknet.io#associated-items-18\"></a>Associated items</h2>\n<p>Associated items are items that are declared in traits and defined in implementations. They are defined similarly to the same concept in <a href=\"https://doc.rust-lang.org/reference/items/associated-items.html\">Rust</a>. We proceed to dive into each the possible associated items.</p>\n<h3><a name=\"associated-types-19\" class=\"anchor\" href=\"https://community.starknet.io#associated-types-19\"></a>Associated types</h3>\n<p>The addition trait is a good example of the potential advantage of associated types:</p>\n<pre><code class=\"lang-auto\">trait Add&lt;Lhs, Rhs&gt; {\n    type Result;\n    fn add(lhs: Lhs, rhs: Rhs) -&gt; Self::Result;\n}\n</code></pre>\n<p>suppose now that a function <code>foo&lt;A, B&gt;</code> needs the ability to add A and B. If we had defined the <code>Add</code> trait with an additional generic parameter that is used to describe the result, then our code would have looked like this:</p>\n<pre><code class=\"lang-auto\">fn foo&lt;A,B,C, +Add&lt;A,B,C&gt;&gt;(a:A, b:B) -&gt; C {\n   return a+b;\n}\n</code></pre>\n<p>However, with associated types, we can get the result type from the impl of <code>Add</code>, and we don‚Äôt need to pollute <code>foo</code> with an additional generic argument:</p>\n<pre><code class=\"lang-auto\">fn foo&lt;A,B, AddImpl: Add&lt;A,B&gt;&gt;(a: A, b: B) -&gt; AddImpl::Result {\n    return a+b;\n}\n</code></pre>\n<p>The point is that <code>foo</code> doesn‚Äôt necessarily need to generic on the addition result type, this information is associated with the impl of the <code>Add</code> trait.</p>\n<h3><a name=\"associated-consts-20\" class=\"anchor\" href=\"https://community.starknet.io#associated-consts-20\"></a>Associated consts</h3>\n<p>Suppose that we have a game with multiple character types, e.g. <code>Wizard</code> and <code>Warrior</code>, and each character has some fixed hp based on its type. We can model this scenario as follows:</p>\n<pre><code class=\"lang-auto\">#[derive(Drop)]\nstruct Warrior { ... }\n#[derive(Drop)]\nstruct Wizard { ... }\n\ntrait Character&lt;T&gt; {\n    const hp: u32;\n    fn fight(self: T);\n}\n\nimpl WizardCharacter of Character&lt;Wizard&gt; {\n    const hp: u32 = 70;\n    fn fight(self: Wizard) { ... } \n}\n\nimpl WarriorCharacter of Character&lt;Warrior&gt; {\n    const hp: u32 = 100;\n    fn fight(self: Warrior) { ... } \n}\n</code></pre>\n<p>Since hp is fixed per character type, associated costs allowed us to bind this number to the character trait rather than adding it to the struct or just hardcoding the value in the implementation.</p>\n<h3><a name=\"associated-impls-21\" class=\"anchor\" href=\"https://community.starknet.io#associated-impls-21\"></a>Associated impls</h3>\n<p>The new iterator traits are a good example of when one might need associated impls. Consider the new iterator traits from <a href=\"https://github.com/starkware-libs/cairo/blob/264e588698bec5dab5fbf8aadb21fa27e333e0d5/corelib/src/iter/traits/iterator.cairo#L2\">iterator.cairo</a>:</p>\n<pre><code class=\"lang-auto\">// T is the collection type\npub trait Iterator&lt;T&gt; {\n    type Item;\n    fn next(ref self: T) -&gt; Option&lt;Self::Item&gt;;\n}\n\n/// Turn a collection of values into an iterator.\npub trait IntoIterator&lt;T&gt; {\n    /// The iterator type that will be created.\n    type IntoIter;\n    impl Iterator: Iterator&lt;Self::IntoIter&gt;;\n\n    fn into_iter(self: T) -&gt; Self::IntoIter;\n}\n</code></pre>\n<p>An implementation of <code>IntoIterator</code> is expected to take a collection and return a corresponding iterator type <code>IntoIter</code>. How can we enforce that the returned type is indeed an iterator, i.e. something that implements that iterator trait? This is where the associated impl <code>Iterator</code> comes in, which is by definition an impl of the <code>Iterator</code> trait for the associated <code>IntoIter</code> iterator type.</p>\n<p>The important observation is that <strong>any</strong> implementation of <code>IntoIterator</code> should return an iterator. Thus, while we can use generic impl params to enforce a specific implementation of <code>IntoIterator</code> returning an actual iterator, it should be already determined at the trait level. Associated impls are exactly the tool that allows us to do it.</p>\n<p>Note that an implementation of <code>IntoIterator</code> does not necessarily need to specify the <code>Iterator</code> impl, if one exists in your context then it will be deduced, similarly to generic impl params. This is illustrated by the corelib‚Äôs implementation of <code>IntoIterator&lt;Array&lt;T&gt;&gt;</code>:</p>\n<pre><code class=\"lang-auto\">#[derive(Drop)]\npub struct ArrayIter&lt;T&gt; {\n    array: Array&lt;T&gt;,\n}\n\nimpl ArrayIterator&lt;T&gt; of Iterator&lt;ArrayIter&lt;T&gt;&gt; {\n    type Item = T;\n    fn next(ref self: ArrayIter&lt;T&gt;) -&gt; Option&lt;T&gt; {\n        self.array.pop_front()\n    }\n}\n\nimpl ArrayIntoIterator&lt;T&gt; of core::iter::IntoIterator&lt;Array&lt;T&gt;&gt; {\n    type IntoIter = ArrayIter&lt;T&gt;;\n    fn into_iter(self: Array&lt;T&gt;) -&gt; ArrayIter&lt;T&gt; {\n        ArrayIter { array: self }\n    }\n}\n</code></pre>\n<h2><a name=\"for-loops-22\" class=\"anchor\" href=\"https://community.starknet.io#for-loops-22\"></a>for loops</h2>\n<p>With iterators come for loops. You can now iterate over arrays and spans as follows:</p>\n<pre><code class=\"lang-auto\">fn test_for_loop_array_sum() {\n    let mut sum = 0;\n    for x in array![10, 11, 12] {\n        sum += x;\n    };\n    assert_eq!(sum, 33);\n}\n</code></pre>\n<p>The above loop is based on the <a href=\"https://github.com/starkware-libs/cairo/blob/88cefed325bd1039f80641b55220a0c84dd02ad8/corelib/src/array.cairo#L414\">ArrayIntoIterator</a> implementation in the corelib. You can find more examples in <a href=\"https://github.com/starkware-libs/cairo/blob/83a1129895a90cb536c6125d1599fa29cbdcfede/corelib/src/test/language_features/for_test.cairo#L1\">for_test.cairo</a>.</p>\n<h2><a name=\"sha256-23\" class=\"anchor\" href=\"https://community.starknet.io#sha256-23\"></a>SHA256</h2>\n<p>The <code>sha256_process_block_syscall</code> system call is added. You‚Äôll find high level functions for computing sha256 in <a href=\"https://github.com/starkware-libs/cairo/blob/f5ac2d1d24ae0a626e9925db0c564bd0c4fea433/corelib/src/sha256.cairo#L24\">sha256.cairo,</a> specifically <code>compute_sha256_u32_array</code> and <code>compute_sha256_byte_array</code>.</p>\n<p>Below is an example of computing sha256 in your contract:</p>\n<pre><code class=\"lang-auto\">#[external(v0)]\nfn test_sha256(ref self: ContractState) {\n    let mut input: Array::&lt;u32&gt; = Default::default();\n    input.append('aaaa');\n\n    // Test the sha256 syscall computation of the string 'aaaa'.\n    let [res, _, _, _, _, _, _, _,] = compute_sha256_u32_array(input, 0, 0);\n    assert(res == 0x61be55a8, 'Wrong hash value');\n}\n</code></pre>\n<p>Each syscall application costs ~ 180 gas. Taking padding into account, we need a syscall invocation per ~ 14 u32 inputs, resulting in ~ 3.2 gas per byte.</p>\n<h2><a name=\"default-implementations-24\" class=\"anchor\" href=\"https://community.starknet.io#default-implementations-24\"></a>Default implementations</h2>\n<p>We can now have default implementations of trait functions, similarly to <a href=\"https://doc.rust-lang.org/book/ch10-02-traits.html#default-implementations\">Rust</a>. Default implementations are illustrated in the example below:</p>\n<pre><code class=\"lang-auto\">trait TraitWithDefaultImpl {\n    fn foo(self: u256);\n    fn boo(self: u128) -&gt; u128 {\n        self+1\n    }\n}\n\nimpl SomeImpl of TraitWithDefaultImpl {\n    fn foo(self: u256) {}\n}\n\nimpl SomeOverridingImpl of TraitWithDefaultImpl {\n    fn foo(self: u256) {}\n    fn boo(self: u128) -&gt; u128 { self }\n}\n</code></pre>\n<p><code>SomeImpl::boo(3)</code> will use the default implementation, while <code>SomeOverridingImpl::boo(3)</code> will use its own implementation.</p>\n<h2><a name=\"fixed-size-arrays-25\" class=\"anchor\" href=\"https://community.starknet.io#fixed-size-arrays-25\"></a>Fixed size arrays</h2>\n<p>Fixed size arrays, denoted by <code>[T; N]</code>, are a type that represents an N-tuple of T:</p>\n<pre><code class=\"lang-auto\">let arr1: [u64; 5] = [1,2,3,4,5];\nlet arr2: Span&lt;u64&gt; = [1,2,3,4,5].span();\n</code></pre>\n<p>To access a member of a fixed size array we can either deconstruct it with something like <code>let [a, b, c, _, _] = arr1</code>, or use the <code>.span()</code> function. Note that if we plan to repeatedly access the array, then it makes sense to call <code>.span()</code> once and keep it available throughout the accesses.</p>\n<p>With const fixed size arrays, we can hardcode a potentially long sequence of data in our program, similarly to how <code>dw</code> (define word) was used in CairoZero:</p>\n<pre><code class=\"lang-auto\">const arr: [u64; 5] = [1,2,3,4,5];\n</code></pre>\n<p>To pass the const value cheaply between functions (without copying), you can call <code>.span()</code>, which has a trivial implementation (no cairo-steps overhead)</p>\n<pre><code class=\"lang-auto\">fn get_arr(arr: Span&lt;u64&gt;) { ... }\nget_arr(arr.span());\n</code></pre>\n<h2><a name=\"arithmetic-circuits-26\" class=\"anchor\" href=\"https://community.starknet.io#arithmetic-circuits-26\"></a>Arithmetic circuits</h2>\n<p>We introduce an efficient way to define and run arithmetic circuits with a 384-bit modulus. Arithmetic circuits in Cairo are aimed at applications that need to be as bare metal as possible, and want to avoid the overhead of Cairo by defining raw circuits. Two new builtins, <code>add_mod</code> and <code>mul_mod</code>, will perform arithmetic operations under the hood. That is, Cairo is only used to describe the circuit.</p>\n<p>Four types of gates are supported, <code>AddModGate</code>, <code>SubModGate</code>, <code>MulModGate</code>, and <code>InverseGate</code>. To construct a circuit, we use the empty <code>CircuitElement&lt;T&gt;</code> struct. The circuit description is encoded within the type <code>T</code>. That is, whenever we add a gate to the circuit, we wrap our existing circuit types with the appropriate gate types. For example, adding <code>CricuitElement&lt;Lhs&gt;</code> and <code>CircuitElement&lt;Rhs&gt;</code> results with <code>CircuitElement&lt;AddModGate&lt;Lhs, Rhs&gt;&gt;</code>.</p>\n<p>The following code constructs the circuit: <span class=\"math\">\\frac{1}{x+y}\\left((x+y)^{-1}-y\\right)</span>:</p>\n<pre><code class=\"lang-auto\">use core::circuit::{\n    RangeCheck96, AddMod, MulMod, u96, CircuitElement, CircuitInput, circuit_add, circuit_sub,\n    circuit_mul, circuit_inverse, EvalCircuitTrait, u384, CircuitOutputsTrait, CircuitModulus,\n    AddInputResultTrait, CircuitInputs,\n};\n\nlet in1 = CircuitElement::&lt;CircuitInput&lt;0&gt;&gt; {};\nlet in2 = CircuitElement::&lt;CircuitInput&lt;1&gt;&gt; {};\nlet add = circuit_add(in1, in2);\nlet inv = circuit_inverse(add);\nlet sub = circuit_sub(inv, in2);\nlet mul = circuit_mul(inv, sub);\n</code></pre>\n<p>Now, we need to define the output tuple:</p>\n<pre><code class=\"lang-auto\">let output_gates = (mul);\n</code></pre>\n<p>Note that any of the circuit‚Äôs gates can be added to the output tuple. We can access the value of any gate after evaluating, but <code>outputs</code> must include all gates whose out degree is 0. The evaluation would have remained the same if we were do define <code>output_gates</code> as <code>(mul, add, sub, inv)</code>.</p>\n<p>Next, we proceed to initialize the circuits with inputs, each input is represented by fixed size array of four u96:</p>\n<pre><code class=\"lang-auto\">output_gates.new_inputs()\n  .next([3, 0, 0, 0])\n  .next([6, 0, 0, 0])\n  .done()\n</code></pre>\n<p>Note that the <code>next</code> function returns a variant of the <code>AddInputResult</code> enum:</p>\n<pre><code class=\"lang-auto\">pub enum AddInputResult&lt;C&gt; {\n    /// All inputs have been filled.\n    Done: CircuitData&lt;C&gt;,\n    /// More inputs are needed to fill the circuit instance's data.\n    More: CircuitInputAccumulator&lt;C&gt;,\n}\n</code></pre>\n<p>We must fill all the inputs of the circuit, and calling <code>next</code> on the <code>Done</code> variant, whose type <code>CircuitData&lt;C&gt;</code> describes a circuit initialized with inputs, will result in a panic.</p>\n<p>Now that we have <code>CircuitData&lt;C&gt;</code> (<code>C</code> is now the long type encoding the entire circuit), we can define the modules and call eval:</p>\n<pre><code class=\"lang-auto\">let modulus = TryInto::&lt;_, CircuitModulus&gt;::try_into([7, 0, 0, 0]).unwrap();\n\nlet res = output_gates.eval(modulos).unwrap();\n</code></pre>\n<p>Note that  <code>eval</code> returns <code>Result</code>, as the evaluation may err due to division by zero. If the evaluation had been successful, we can ask the value of any intermediate gate, assuming we an instance of the corresponding type:</p>\n<pre><code class=\"lang-auto\">assert_eq!(res.get_output(add), u384 { limb0: 2, limb1: 0, limb2: 0, limb3: 0 });\nassert_eq!(res.get_output(inv), u384 { limb0: 4, limb1: 0, limb2: 0, limb3: 0 });\nassert_eq!(res.get_output(sub), u384 { limb0: 5, limb1: 0, limb2: 0, limb3: 0 });\nassert_eq!(res.get_output(mul), u384 { limb0: 6, limb1: 0, limb2: 0, limb3: 0 });\n</code></pre>\n            <p><small>14 posts - 5 participants</small></p>\n            <p><a href=\"https://community.starknet.io/t/cairo-v2-7-0-is-coming/114362\">Read full topic</a></p>","link":"https://community.starknet.io/t/cairo-v2-7-0-is-coming/114362","pubDate":"Wed, 17 Jul 2024 13:09:16 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"community.starknet.io-topic-114362"},"source":{"@url":"https://community.starknet.io/t/cairo-v2-7-0-is-coming/114362.rss","#text":"Cairo v2.7.0 is coming!"}},{"title":"SNIP 18: Staking‚Äôs First Stage on Starknet","dc:creator":"NatanSW","category":"SNIPs","description":"<p><strong>snip:</strong> 18<br>\n<strong>title:</strong> Staking‚Äôs First Stage on Starknet<br>\n<strong>author:</strong> Natan Granit <a href=\"mailto:natan@starkware.co\">natan@starkware.co</a><br>\n<strong>status:</strong> Draft<br>\n<strong>type:</strong> Standards Track<br>\n<strong>category:</strong> Core<br>\n<strong>created:</strong> July 10, 2024<br>\n<a href=\"https://github.com/starknet-io/SNIPs/pull/99/files?short_path=07d7e57#diff-07d7e5784da837130ab997e6d93179c12a717a90599cf25cc7d2568515e763b8\">Github link</a></p>\n<h1><a name=\"stakings-first-stage-on-starknet-1\" class=\"anchor\" href=\"https://community.starknet.io#stakings-first-stage-on-starknet-1\"></a>Staking‚Äôs First Stage on Starknet</h1>\n<h2><a name=\"abstract-2\" class=\"anchor\" href=\"https://community.starknet.io#abstract-2\"></a>Abstract</h2>\n<p>As Starknet continues its decentralized journey, we present StarkWare‚Äôs proposal for the first stage of staking. This is an important step in building the staking community and technology, offering new opportunities for users and developers.</p>\n<p>This SNIP aims for the first stage of staking to be live on Starknet mainnet in Q4 2024, featuring a permissionless on-chain staking protocol and stake delegation.</p>\n<p>In the following, we will describe in detail the staking proposal, its timeline, and its relation to future steps in decentralization.</p>\n<h2><a name=\"motivation-3\" class=\"anchor\" href=\"https://community.starknet.io#motivation-3\"></a>Motivation</h2>\n<p>The first stage of staking marks another crucial step in Starknet‚Äôs decentralized <a href=\"https://starkware.co/integrity-matters-blog/starknet-vision/\">vision</a>. Here are the key motivations for an incremental approach in Starknet‚Äôs decentralization process and for the proposed first step.</p>\n<p>In the future, as part of Starknet‚Äôs Consensus protocol, Stakers will be responsible for maintaining and securing the network by producing, attesting, and proving blocks. However, it‚Äôs not feasible to hand over these responsibilities all in one day. This is why an incremental approach is necessary, as it allows for the following:</p>\n<ul>\n<li><strong>Gradual Implementation:</strong> A PoS protocol is a complex structure that requires comprehensive testing and validation. By introducing its features in small, manageable milestones, we ensure that each step is carefully implemented and easily integrated. This approach also allows us to refine the process and address issues as they arise.</li>\n<li><strong>Stakers‚Äô Preparation:</strong> Giving Stakers time to adapt to new responsibilities, ensuring they are ready for their critical roles, and maximizing network stability during the transition.</li>\n<li><strong>Proven Reliability:</strong> By the time Stakers perform the aforementioned roles, we aim to have a proven set of sequencers that reliably produce and attest blocks, ensuring the network‚Äôs stability and performance.</li>\n</ul>\n<p>Specifically, in this proposed first stage, we will test the protocol‚Äôs economic incentive structure and some of its key smart contract components. The protocol reward structure must balance incentivizing participation with maintaining a sustainable inflation rate and allowing a sufficient amount of STRK to remain readily available for other network activity.</p>\n<p>By adopting this step-by-step approach, with the proposed first stage, we can gather valuable data, perform crucial tests, and thus refine the staking protocol as we implement it.</p>\n<h2><a name=\"specification-4\" class=\"anchor\" href=\"https://community.starknet.io#specification-4\"></a>Specification</h2>\n<h3><a name=\"overview-5\" class=\"anchor\" href=\"https://community.starknet.io#overview-5\"></a>Overview</h3>\n<p>The proposed first stage protocol features permissionless staking of STRK on Starknet with two staking flavors:</p>\n<ul>\n<li><strong>Staking:</strong> As a Staker, you can stake any amount of STRK greater than X STRK (X is between 10K-100K). Currently, Stakers are expected to run full nodes in preparation for the following stages. In the future, they will also need to run additional software that sequences and validates Starknet blocks and possibly perform additional network liveness and security tasks.</li>\n<li><strong>Stake Delegation:</strong> Delegators choose a Staker to whom they delegate their Stake, sharing rewards with said Staker. Stake Delegators do not need to run any software, as their chosen Staker runs it for them. This makes participation accessible to a broader audience, allowing users to participate in the Staking protocol without the technical and capital limitations.</li>\n</ul>\n<p>Both Stakers and Stake Delegators can unstake their funds, subject to protocol-defined latencies that ensure network stability and security. More details on these latencies can be found in the ‚ÄúLatencies‚Äù section.</p>\n<h3><a name=\"staking-rewards-6\" class=\"anchor\" href=\"https://community.starknet.io#staking-rewards-6\"></a>Staking Rewards</h3>\n<p>Staking rewards will be based on token minting. The rewards are calculated according to a minting curve, which follows Professor Noam Nisan‚Äôs <a href=\"https://starkware.co/a-token-minting-proposal-to-manage-inflation/\">proposal</a> (For more details on the minting curve, see the section below). Both Stakers and Stake Delegators earn rewards, depending on their respective stake and the reward-sharing constant (R) set by the Staker:</p>\n<ul>\n<li>\n<p><strong>Stakers:</strong> Earn rewards proportional to their own stake and the total stake delegated to them, adjusted by the reward-sharing constant. The formula is:</p>\n<p><code>({self_stake} + {total_stake_delegated} * (1 - R)) * {rewards_constant} * {time_interval}</code></p>\n</li>\n<li>\n<p><strong>Stake Delegators:</strong> Earn rewards proportional to their delegated stake and the reward-sharing constant. The formula is:</p>\n<p><code>{stake_delegated} * R * {rewards_constant} * {time_interval}</code></p>\n</li>\n</ul>\n<p>where <code>{rewards_constant}</code> is determined by the minting curve and depends on the total amount staked in the protocol. This reward structure incentivizes both staking, stake delegation, and competition among Stakers for delegators‚Äô stake.</p>\n<h3><a name=\"minting-curve-7\" class=\"anchor\" href=\"https://community.starknet.io#minting-curve-7\"></a>Minting curve</h3>\n<p>The minting curve addresses two critical aspects of the staking protocol by making the rewards dependent on the amount of STRK locked in the protocol. Here‚Äôs how it works:</p>\n<ul>\n<li>\n<p><strong>Balancing Participation:</strong> The more STRK tokens locked in the staking protocol, the lower the rewards become. This design ensures that not all STRK tokens are staked, allowing the Starknet community to continue using STRK for transaction fees and other activities. Additionally, it prevents unnecessary dilution of the token supply.</p>\n</li>\n<li>\n<p><strong>Encouraging Staking:</strong> When fewer STRK tokens are staked, the rewards get higher. This incentivizes participation in the staking protocol, guaranteeing a minimum level of economic security for the network by ensuring that a portion of STRK tokens is always staked.</p>\n</li>\n</ul>\n<p>In the first stage, the minting curve will be based on Professor Noam Nisan‚Äôs <a href=\"https://starkware.co/a-token-minting-proposal-to-manage-inflation/\">proposal</a>, with a slight parameter variation. The minting curve is defined by the following formula:</p>\n<p><code>M = C/10 * ‚àö S</code></p>\n<p>Where S is the staking rate in percent of the total supply of tokens, M is the annual minting rate, again in percent of the total supply of tokens and C is the maximal theoretical inflation, also in yearly percent. In Professor Nisan‚Äôs suggestion, C=4, assuming all 10B STRK tokens might participate in the staking protocol. For this first stage, we propose C be in the range of 1.8-2.5, considering the current circulating supply is much lower than 10B and not all STRK tokens will participate in the staking protocol.</p>\n<p>Deciding on a global inflation cap and exact minting curve parameters is a complex problem. Any decision made will likely require adjustments over time as market conditions change, such as the amount of circulating tokens. Given the sensitivity of this subject, we will recommend that the Starknet Foundation (SNF) hold a governance vote to decide on minting curve parameters and the processes to adjust those over time.</p>\n<h3><a name=\"latencies-8\" class=\"anchor\" href=\"https://community.starknet.io#latencies-8\"></a>Latencies</h3>\n<ul>\n<li><strong>Today:</strong> Entering and exiting the staking protocol is immediate, meaning that users can join or leave the staking process without delay. However, after exiting, the staked funds are subject to a security lockup period of 21 days*. During this period, users will not earn rewards and cannot withdraw their funds. This mechanism ensures network security by preventing Stakers from suddenly withdrawing significant stake and potentially destabilizing the network.</li>\n<li><strong>Future Versions:</strong> In future versions, we would introduce the notion of epochs, which are granular measures of time on Starknet based on blocks. This means that the latency for entering or exiting the protocol will be determined by the remaining time in the current epoch plus the duration of one full epoch. The withdrawal lockup period will still apply after exiting the protocol.</li>\n</ul>\n<p>*Although Stake Delegators are subject to a security lockup when withdrawing funds, they can move between Stakers without waiting the full lockup period, enhancing the delegation market‚Äôs competitiveness.</p>\n<h3><a name=\"stake-delegation-threshold-9\" class=\"anchor\" href=\"https://community.starknet.io#stake-delegation-threshold-9\"></a>Stake Delegation threshold</h3>\n<p>The ratio between a Staker‚Äôs own stake and the stake they receive from delegators is limited by a global Stake Delegation threshold (DT). The constraint is:</p>\n<p><code>{self_stake} + {delegated_stake} &lt; {self_stake} * DT</code></p>\n<p>This requirement ensures that Stakers have a sufficient stake in the network, aligning their interests with network stability and security.</p>\n<h3><a name=\"economical-parameters-10\" class=\"anchor\" href=\"https://community.starknet.io#economical-parameters-10\"></a>Economical parameters</h3>\n<p>Here is a table summarising the economic parameters proposed in this version:</p>\n<div class=\"md-table\">\n<table>\n<thead>\n<tr>\n<th><strong>Economical Parameter</strong></th>\n<th><strong>Proposed value</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Minimum STRK for Staking (X)</td>\n<td>10K-100K STRK</td>\n</tr>\n<tr>\n<td>Withdrawal Security lock up (W)</td>\n<td>21 days</td>\n</tr>\n<tr>\n<td>Minting curve yearly inflation cap (C)</td>\n<td>1.8-2.5%</td>\n</tr>\n<tr>\n<td>Delegation threshold (DT)</td>\n<td>5</td>\n</tr>\n<tr>\n<td>Reward-sharing parameter (R)</td>\n<td>Set individually by the Staker (0-1)</td>\n</tr>\n</tbody>\n</table>\n</div><p>These values are our proposed starting points for this version of the protocol. As part of the rationale behind this version, they are subject to change and may be adjusted to better suit the protocol‚Äôs needs.</p>\n<h3><a name=\"locked-token-participation-11\" class=\"anchor\" href=\"https://community.starknet.io#locked-token-participation-11\"></a>Locked Token Participation</h3>\n<p>Locked tokens will initially be excluded from staking. When Stakers begin validating and voting on blocks sequenced by the sequencer and their consensus is proved to L1, locked tokens will be allowed to participate in the staking protocol.</p>\n<h3><a name=\"general-points-12\" class=\"anchor\" href=\"https://community.starknet.io#general-points-12\"></a>General points</h3>\n<ul>\n<li>Rewards are claimed by actively sending a transaction.</li>\n<li>Both Stakers and Stake Delegators can add to their stake.</li>\n<li>There is no partial unstaking.</li>\n</ul>\n<h3><a name=\"security-considerations-13\" class=\"anchor\" href=\"https://community.starknet.io#security-considerations-13\"></a>Security Considerations</h3>\n<p>The staking protocol‚Äôs design includes several key security measures to ensure its integrity and user safety.</p>\n<h4><a name=\"modular-architecture-14\" class=\"anchor\" href=\"https://community.starknet.io#modular-architecture-14\"></a>Modular architecture</h4>\n<p>The proposed protocol will be implemented using a modular architecture, where different functionalities are separated into distinct contracts, such as staking, delegation, rewards supply, and more. This approach offers several advantages:</p>\n<ul>\n<li><strong>Simplifies Logic:</strong> Each contract has a clear and specific role, making the code easier to test, audit, and understand.</li>\n<li><strong>Enhances Access Control:</strong> By defining specific permissions for each contract, the risk of unauthorized access or misuse is reduced.</li>\n<li><strong>Allows Targeted Upgrades and Changes:</strong> Updating only the relevant contract minimizes the potential for introducing new vulnerabilities.</li>\n</ul>\n<h4><a name=\"permissions-and-key-management-15\" class=\"anchor\" href=\"https://community.starknet.io#permissions-and-key-management-15\"></a>Permissions and Key Management</h4>\n<p>The Staking protocol allows users to define different addresses for different functionalities. Thus, cold addresses with minimal activity can control important functionalities, reducing exposure to threats and enhancing user security.</p>\n<p>Stakers register with three addresses:</p>\n<ul>\n<li><strong>Staking and Unstaking Address:</strong> This address has permission to Stake, add Stake and unstake. This means that it handles large amounts of STRK tokens and is only needed when entering or exiting the protocol. Thus, it can be kept by a cold wallet (minimal activity) to maximize security.</li>\n<li><strong>Rewards Address:</strong> This is the address where rewards will be sent to. It can also be maintained with minimal activity, i.e., as a cold wallet.</li>\n<li><strong>Operational Address:</strong> This address represents the Staker for operational purposes (for example, block attestations in the future) and does not handle large amounts of funds. As it will be frequently used, it should be categorized as a hot address.</li>\n</ul>\n<p>Stake Delegators register with two addresses:</p>\n<ul>\n<li><strong>Entering/Exiting Address:</strong> This address has permission to Delegate Stake, add Stake and unstake. This means that it handles large amounts of STRK tokens and is only needed when entering or exiting the protocol. Thus, it can be kept by a cold wallet (minimal activity) to maximize security.</li>\n<li><strong>Rewards Address:</strong> This is the address where rewards will be sent to. It can also be maintained with minimal activity, i.e., as a cold wallet.</li>\n</ul>\n<p><strong>Permissions:</strong> The protocol uses a hierarchical approach between user roles. Colder addresses, which control larger funds, can replace more active ones if compromised. Specifically, Staker and Stake Delegator addresses can replace the rewards address.</p>\n<h4><a name=\"security-lockup-period-16\" class=\"anchor\" href=\"https://community.starknet.io#security-lockup-period-16\"></a>Security lockup period</h4>\n<p>When exiting, users face a 21-day lockup, during which no rewards are earned, and funds cannot be withdrawn. This disincentivises sudden large withdrawals that could destabilize the network. Future versions will tie the exit process to epochs, maintaining the lockup period for a secure exit mechanism.</p>\n<h2><a name=\"milestones-17\" class=\"anchor\" href=\"https://community.starknet.io#milestones-17\"></a>Milestones</h2>\n<p>This SNIP aims for the first stage of staking to be live on Starknet mainnet in Q4 2024, you can track the implementation progress in the following <a href=\"https://github.com/starkware-libs/starknet-staking\">repo</a>.</p>\n<p>Future stages will include Stakers gradually assigned responsibilities, eventually validating and sequencing blocks. This gradual transition ensures stability and allows for thorough testing and improvements. For more details on the decentralized protocol, check out <a class=\"mention\" href=\"https://community.starknet.io/u/ilia\">@Ilia</a>‚Äôs <a href=\"https://community.starknet.io/t/starknet-decentralized-protocol-i-introduction/2671\">series</a> of blog posts.</p>\n<p>More details and proposals on subsequent stages will be introduced, as we progress. The next step is already in the research and planning stages, set to launch a few months after the first stage. Our objective is to roll out these updates smoothly, with ongoing improvements guided by community feedback.</p>\n<h2><a name=\"feedback-18\" class=\"anchor\" href=\"https://community.starknet.io#feedback-18\"></a>Feedback</h2>\n<p>We want you to share your feedback and ask questions. You can comment here and follow our development on our open-source <a href=\"https://github.com/starkware-libs/starknet-staking\">repo</a>.</p>\n<h2><a name=\"copyright-19\" class=\"anchor\" href=\"https://community.starknet.io#copyright-19\"></a>Copyright</h2>\n<p>This SNIP will be released under an MIT license.</p>\n            <p><small>30 posts - 13 participants</small></p>\n            <p><a href=\"https://community.starknet.io/t/snip-18-staking-s-first-stage-on-starknet/114334\">Read full topic</a></p>","link":"https://community.starknet.io/t/snip-18-staking-s-first-stage-on-starknet/114334","pubDate":"Wed, 10 Jul 2024 13:38:45 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"community.starknet.io-topic-114334"},"source":{"@url":"https://community.starknet.io/t/snip-18-staking-s-first-stage-on-starknet/114334.rss","#text":"SNIP 18: Staking‚Äôs First Stage on Starknet"}},{"title":"SNIP 75: Meta SNIP for Security Council","dc:creator":"eiki","category":"üèõ   Governance","description":"<p>Hi all, I‚Äôm reposting here my SNIP draft PR for laying out the motivation behind a Starknet Security Council. We‚Äôve worked hard during the Starknet ‚ÄúF√™te du SNIP‚Äù with people from Starkware, Starknet Foundation and the Starknet builder community to come up with the foundations of a Security Council!</p>\n<p>Let‚Äôs take the conversation here.</p>\n<h2><a name=\"simple-summary-1\" class=\"anchor\" href=\"https://community.starknet.io#simple-summary-1\"></a>Simple Summary</h2>\n<p>Meta SNIP to lay out the structure, motivation and decisions of the Starknet Security Council.</p>\n<p>Today, <a href=\"https://docs.arbitrum.foundation/dao-constitution#section-3-the-security-council\" rel=\"noopener nofollow ugc\">Arbitrum</a>, <a href=\"https://github.com/ethereum-optimism/OPerating-manual/blob/main/Security%20Council%20Charter%20v0.1.md\" rel=\"noopener nofollow ugc\">Optimism</a> and <a href=\"https://blog.matter-labs.io/security-council-2-0-2337a555f17a\" rel=\"noopener nofollow ugc\">zkSync</a> have created and are continously improving a security committee, a so-called ‚ÄúSecurity Council‚Äù.</p>\n<p>This SNIP answers the network‚Äôs strong desire to create a Security Council.</p>\n<h2><a name=\"abstract-2\" class=\"anchor\" href=\"https://community.starknet.io#abstract-2\"></a>Abstract</h2>\n<p><strong>A Security Council is a committee of Ethereum L1 (possibly Starknet L2) multi-sig signers. It is empowered to perform certain actions on behalf of the network: Emergency Action and Non-Emergency Actions.</strong></p>\n<p>The specific ways in which the Security Council functions are defined by a set of upcoming SNIPs.</p>\n<p>Emergency Actions are the last line of defense against bugs and earthshattering events. They are defined in a specific SNIP. Similarly, Non-Emergency actions frame the normal flow of upgrade and lifetime of the network. They are scoped in a specific SNIP. The Starknet Security Council is elected with the help of the Starknet community, the Starknet Foundation, Starkware and the STRK token holders. The election process and composition of the council is described in a subsequent SNIP.</p>\n<p>We rely on the following set of resources:</p>\n<ul>\n<li>\n<p><a href=\"https://medium.com/l2beat/stages-update-security-council-requirements-4c79cea8ef52\" rel=\"noopener nofollow ugc\">Stages update: Security Council requirements, Luca Donno</a></p>\n</li>\n<li>\n<p><a href=\"https://medium.com/l2beat/introducing-stages-a-framework-to-evaluate-rollups-maturity-d290bb22befe\" rel=\"noopener nofollow ugc\">Introducing Stages ‚Äî a framework to evaluate rollups maturity, Luca Donno</a></p>\n</li>\n<li>\n<p><a href=\"https://docs.arbitrum.foundation/dao-constitution#section-3-the-security-council\" rel=\"noopener nofollow ugc\">The Security Council, Arbitrum</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/ethereum-optimism/OPerating-manual/blob/main/Security%20Council%20Charter%20v0.1.md\" rel=\"noopener nofollow ugc\">Security Council Charter v0.1</a></p>\n</li>\n</ul>\n<h2><a name=\"motivation-3\" class=\"anchor\" href=\"https://community.starknet.io#motivation-3\"></a>Motivation</h2>\n<p>Starknet has framed itself as a secure rollup from day 1. This is the core idea behind STARK proofs and the concept of integrity: ‚Äúdo the right thing, even when no one is watching‚Äù. While this applies at the protocol level, i.e. for state transitions, it does not apply for actions that fall out of pure programmatic security: how the core smart contracts of the Starknet network get upgraded or who can intervene in case of a bug.</p>\n<p>Currently, Starkware operates the Starknet network and oversees its upgrades, as well as emergency processes in case of bug. The Starknet Foundation provides support through diverse ‚Äúcouncils‚Äù (DeFi Council, Builder Council, etc.). While Starkware acts in good faith and aims to maximize transparency, it remains a single point of failure. Additionally, partly thanks to <a href=\"https://l2beat.com/scaling/summary\" rel=\"noopener nofollow ugc\">L2Beats</a> spearheading the effort, the industry is moving towards common security standards. The concept of Security Council paves the way towards sound and standardized processes with regards to network security.</p>\n<h2><a name=\"specification-4\" class=\"anchor\" href=\"https://community.starknet.io#specification-4\"></a>Specification</h2>\n<p>We suggest a series of 3 SNIPs, one for each important characteristic of the Security Council:</p>\n<ul>\n<li>\n<p>Emergency Actions</p>\n</li>\n<li>\n<p>Non-Emergency Actions</p>\n</li>\n<li>\n<p>Election and Composition of the council</p>\n</li>\n</ul>\n<h2><a name=\"examples-and-hypothetical-future-5\" class=\"anchor\" href=\"https://community.starknet.io#examples-and-hypothetical-future-5\"></a>Examples and hypothetical future</h2>\n<p>As a bi-product of the Security Council creation, all upgrades on the Starknet network would be delayed by an amount of time chosen by the Security Council, e.g. 1 month.</p>\n<p>Simple minimal examples of how the Security Council could look like (inspired the current states of other rollups):</p>\n<ul>\n<li>\n<p>Emergency Actions: the Security Council can reduce the upgrade delay time to zero for an emergency.</p>\n</li>\n<li>\n<p>Non-Emergency Action: the Security Council can vote to accept an upgrade proposed by Starkware.</p>\n</li>\n<li>\n<p>Composition: the Security Council is composed of 12 to 15 people from broad set of sectors (Builders, Users, DeFi, Gaming, Wallet, Cryptography, Infra, etc.), covering a large amount of timezones (always 75% of the council is susceptible to be awake at all time ‚ÄúThe Sun never sets on the Security Council‚Äù <img src=\"https://emoji.discourse-cdn.com/twitter/crown.png?v=12\" title=\":crown:\" class=\"emoji\" alt=\":crown:\" loading=\"lazy\" width=\"20\" height=\"20\"> <img src=\"https://emoji.discourse-cdn.com/twitter/eyes.png?v=12\" title=\":eyes:\" class=\"emoji\" alt=\":eyes:\" loading=\"lazy\" width=\"20\" height=\"20\">). Each person in the council has at least 1M vSTRK delegated to them (they must have either skin in the game or a ‚Äúvote of confidence‚Äù from token holders). Council members are reelected by the Starknet Foundation and can be removed by their peers should they misbehave.</p>\n</li>\n</ul>\n<h2><a name=\"copyright-6\" class=\"anchor\" href=\"https://community.starknet.io#copyright-6\"></a>Copyright</h2>\n<p>Copyright and related rights waived via <a>MIT</a>.</p>\n            <p><small>2 posts - 2 participants</small></p>\n            <p><a href=\"https://community.starknet.io/t/snip-75-meta-snip-for-security-council/114326\">Read full topic</a></p>","link":"https://community.starknet.io/t/snip-75-meta-snip-for-security-council/114326","pubDate":"Sat, 06 Jul 2024 13:24:29 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"community.starknet.io-topic-114326"},"source":{"@url":"https://community.starknet.io/t/snip-75-meta-snip-for-security-council/114326.rss","#text":"SNIP 75: Meta SNIP for Security Council"}},{"title":"SNIP-19: get_class_hash_at syscall","dc:creator":"eiki","category":"SNIPs","description":"<p>Taking here the conversation about a new syscall for getting the class hash of a deployed contract, from within a contract execution environment.</p>\n<h2><a name=\"simple-summary-1\" class=\"anchor\" href=\"https://community.starknet.io#simple-summary-1\"></a>Simple Summary</h2>\n<p>Introduce a new syscall <code>get_class_hash_at</code>, aimed to get a contract class hash at a certain address.</p>\n<h2><a name=\"abstract-2\" class=\"anchor\" href=\"https://community.starknet.io#abstract-2\"></a>Abstract</h2>\n<p>Starknet adopted a system of contract classes to reduce duplication of deployed bytecode. It works in the following way: to deploy a piece of code that has never been deployed before, you must first <em>declare</em> it. You are effectively ‚Äúdeclaring‚Äù a class to the Starknet network. From this point onward, one may instantiate this class by requesting the sequencer to deploy it at a certain address. The simple usecase goes: you declare a fungible token contract, the sequencer stores the code once; then, any number of deployments of the exact same smart contract will not further bloat the chain‚Äôs storage. This is different from the way Ethereum and the Ethereum Virtual Machine (EVM) works. In EVM world, if you deploy a hundred times an ERC20 contract, the chain will store a copy of the code a hundred times. More information: <a href=\"https://docs.starknet.io/architecture-and-concepts/smart-contracts/contract-classes/\" rel=\"noopener nofollow ugc\">https://docs.starknet.io/architecture-and-concepts/smart-contracts/contract-classes/</a></p>\n<p>While there is a way for one to check the <a href=\"https://github.com/starkware-libs/starknet-specs/blob/master/api/starknet_api_openrpc.json#L444\" rel=\"noopener nofollow ugc\">class hash of a deployed contract at the RPC level</a> (<code>starknet_getClassHashAt</code> method), there is no way to perform this at the smart contract level. In EVM world, this is achieved using the <code>EXTCODEHASH</code> opcode. The purpose is for a contract to check on-chain whether another contract is an instantiation of a particular class. This is more precise/powerful (and more costly?) than <a href=\"https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-5.md\" rel=\"noopener nofollow ugc\">SNIP-5</a> (inspired by ERC-165).</p>\n<h2><a name=\"motivation-3\" class=\"anchor\" href=\"https://community.starknet.io#motivation-3\"></a>Motivation</h2>\n<p>At Kakarot, we utilize <code>replace_class_hash</code> syscall for upgrades at the contract level, as well as use class hashes as mediums of checking a contract‚Äôs version. We need the ability to check a contract‚Äôs class hash. We currently achieve this by enforcing every Kakarot Account to store its own class hash in a storage variable.</p>\n<p>We would benefit from a syscall that would enable a contract to check a particular class hash at an address.</p>\n<h3><a name=\"simple-use-case-for-kakarot-enable-the-contract-level-orchestration-of-versioning-and-auto-upgrade-of-our-swarm-of-kakarot-account-contracts-4\" class=\"anchor\" href=\"https://community.starknet.io#simple-use-case-for-kakarot-enable-the-contract-level-orchestration-of-versioning-and-auto-upgrade-of-our-swarm-of-kakarot-account-contracts-4\"></a>Simple use-case for Kakarot: enable the contract-level orchestration of versioning and auto-upgrade of our swarm of Kakarot Account Contracts</h3>\n<p>How?</p>\n<ol>\n<li>Set the new version (a class hash) in the Core EVM Kakarot Contract</li>\n<li>Every contract is now able to compare their class hash with the current correct version (situated in Kakarot Core EVM) and decide to self upgrade</li>\n<li>Before calling a contract, one may check that it is in the correct version.</li>\n</ol>\n<h2><a name=\"specification-5\" class=\"anchor\" href=\"https://community.starknet.io#specification-5\"></a>Specification</h2>\n<p>One might want to name the syscall in the same way as the corresponding RPC method.</p>\n<pre data-code-wrap=\"rust\"><code class=\"lang-rust\">extern fn get_class_hash_at_syscall(\n    contract_address: ContractAddress\n) -&gt; SyscallResult&lt;ClassHash&gt; implicits(GasBuiltin, System) nopanic;\n</code></pre>\n<p>Alternative API:</p>\n<pre data-code-wrap=\"rust\"><code class=\"lang-rust\">extern fn class_hash_syscall(\n    contract_address: ContractAddress\n) -&gt; SyscallResult&lt;ClassHash&gt; implicits(GasBuiltin, System) nopanic;\n</code></pre>\n<h3><a name=\"arguments-6\" class=\"anchor\" href=\"https://community.starknet.io#arguments-6\"></a>Arguments</h3>\n<p>contract_address: The contract address one wants to know the class hash of.</p>\n<h3><a name=\"returns-7\" class=\"anchor\" href=\"https://community.starknet.io#returns-7\"></a>Returns</h3>\n<p>Returns the <code>ClassHash</code> if the contract is deployed, an <code>Result::Error</code> if the contract is not deployed. Note that the syscall should never panic. Calling <code>get_class_hash_at_syscall</code> on an address where no contract is deployed will result in a catchable error (equivalent to returning a sentinel value null), not a CairoVM error.</p>\n<h2><a name=\"implementation-8\" class=\"anchor\" href=\"https://community.starknet.io#implementation-8\"></a>Implementation</h2>\n<p>We will require help from the Starkware team to define precisely the implementation.</p>\n<h2><a name=\"copyright-9\" class=\"anchor\" href=\"https://community.starknet.io#copyright-9\"></a>Copyright</h2>\n<p>Copyright and related rights waived via <a>MIT</a>.</p>\n            <p><small>4 posts - 3 participants</small></p>\n            <p><a href=\"https://community.starknet.io/t/snip-19-get-class-hash-at-syscall/114325\">Read full topic</a></p>","link":"https://community.starknet.io/t/snip-19-get-class-hash-at-syscall/114325","pubDate":"Sat, 06 Jul 2024 13:24:26 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"community.starknet.io-topic-114325"},"source":{"@url":"https://community.starknet.io/t/snip-19-get-class-hash-at-syscall/114325.rss","#text":"SNIP-19: get_class_hash_at syscall"}},{"title":"About my thoughts on the second Starknet airdrop","dc:creator":"kkkmoat","category":"üèõ   Governance","description":"<p>Dear Professor Sasson, I am a cairo developer and Starknet user from China. I think I have some personal opinions about your question. I spent 3 hours looking through various materials and websites, hoping to be read by you and receive your comments.</p>\n<p>Let‚Äôs start with the first part: what should we make of this anger? How much of this anger comes from agriculture teams who are trying to rationally influence the standards of this and other rounds (Starknet and other projects)? How many of these represent a broad group of people (\" farmers ‚Äúor‚Äù non-farmers \") who, under different distribution methods, would contribute to Starknet‚Äôs long-term success?</p>\n<p>As for how I view this anger, I think it needs to be analyzed from multiple perspectives:</p>\n<p>We will not discuss the failure to meet expectations. This is due to the excessive consumption of gas costs caused by the abnormal use of Starknet network by the farmer team. They got the airdrop but were not satisfied, or they took the Starknet airdrop as an investment. Expect returns of tens and hundreds of times.</p>\n<p>Let‚Äôs talk about the cost to individuals who have invested time and gas costs but not received airdrops, leading them to feel that their contribution to Starknet is not being treated fairly, which may cause them to be angry, causing them to rationally influence airdrop distribution on Twitter, discord, etc.</p>\n<p>Let‚Äôs look at the active users of Starknet airdrop. I saw through <a href=\"http://Starkscans.co\" rel=\"noopener nofollow ugc\">Starkscans.co</a> that the daily active users almost doubled between August 2023 and November 2023, peaking at 200,000 users in a single day, and then the news of the November snapshot was released. This is also a point that makes many members of the community angry, Starknet‚Äôs snapshot time is even likely to be leaked or internal witch activities, when they know the rules, they will leave 0.005eth, so it is very unfair for community members.</p>\n<p>Next we talk about Starknet‚Äôs broad population, which we can understand as users, developers, farmers, investors, community members, partners, and so on, since this will include farmers. I think the best plan Starknet has done in this airdrop is for Github developers, ECMP, DP, Ethereum contributors, but there is not a good plan for Starknet users and early adopters, and for Straknet users, this is very broad. There are multiple groups of farmers, investors, users, and so on, but Starknet uses multiple scores for a different number of token airdrops, only to be denied a token airdrop because some real people in this broad group don‚Äôt meet one of the requirements, which is quite contradictory, to be honest.</p>\n<p>At this time, let us refer to Arbitrum‚Äôs airdrop, their airdrop is very successful, has won the support of a wide range of people, they will not because of the balance and thus do not allow the standard crowd to receive airdrop, this is only a deduction item, because the need to consider should be the correlation and homogenization of wallet address, not because of the lack of balance and no airdrop.</p>\n<p>That‚Äôs all I have to say, and I move on to the professor‚Äôs second part: ‚ÄúAre today‚Äôs STRK holders a broad and diverse group who will stay to improve, operate, and protect Starknet?‚Äù</p>\n<p>This is a question that I think requires us to analyze the current holders of STRK tokens. What we know is that ordinary users use STRK tokens because they get some equity or use the Starknet network. Community members such as developers, technical teams, governance participants, etc. wish to participate in the governance of the Starknet community by voting with STRK tokens, maintaining the community and participating in proposals for community development. But farmers and liquidity providers, who use STRK tokens to mine liquidity or make investments for income.</p>\n<p>At present, STRk airdrop has been completed, and the coin price will fall, which will increase the turnover rate and reduce the holding rate of farmers. Therefore, STRK holders should all want to invest in STRK or use STRK to pledge to participate in voting and other groups, and they need STRK tokens. Because we don‚Äôt need to know why they are buying and selling, they could be users, developers, governance participants, whatever it is, and I personally think that when this person owns STRK, he is part of the community, he may be bullish on STRK‚Äôs price or technology, or he may be involved in governance, so I think, Today‚Äôs STRK holders are broad, but they all protect Starknet in one direction or another.</p>\n<p>Next is my opinion on the second airdrop of the remaining 400 million STRK. I think the classification of STARK early adopters and Ethereum contributors can be eliminated, because early adopters can be classified as Starknet users, and Ethereum contributors should not get a second airdrop on Starknet.</p>\n<p>I think there are three groups that need to be distinguished: ECMP, Starknet developer members, and Starknet on-chain users.</p>\n<p>Of course, if there is a need for specific rules, I think ECMP and Starknet developers do not need to question, still follow the rules corresponding to the first round of airdrops.</p>\n<p>As for Starknet users, I don‚Äôt think one rule should be used to determine whether a user can get an airdrop, but rather a multidimensional decision, and I personally developed a solution: the data should be after the first airdrop snapshot and before the second airdrop snapshot.</p>\n<p>Cumulative bonus points:</p>\n<p>Daily active use: 30/60/120/180, 1 point for each completed item</p>\n<p>Monthly active use: 5/9/12/15, get 1 point for each completed item</p>\n<p>Tx Active: 30/60/120/180, 1 point for each completed item</p>\n<p>Different contract interactions: 10/30/60/90, 1 point for each completed item</p>\n<p>Single bonus points:</p>\n<p>Use STRK tokens as gas to interact Tx &gt;= 10 strokes and get 1 point</p>\n<p>Pledge the number of vSTRK tokens &gt;= 500 STRK tokens for 1 point</p>\n<p>Hold STRK different NFT sets &gt;= 5 sets for 1 point</p>\n<p>Deduction items:</p>\n<p>LP value + balance &lt;= 0.03 eth, minus 2 points</p>\n<p>Transaction volume &lt;= $1,000, deduct 2 points</p>\n<p>Use</p>\n<p>Rules:</p>\n<p>Tx interaction &gt;= 20 for the same contract in one day is not counted as Tx activity</p>\n<p>Different NFT collections Those parts of mint whose NFT number &gt;= 2 are created by the NFT platform are not counted as different NFT collections</p>\n<p>The total score is 19 points, the total score is less than 5 points will not get the airdrop, divided into 5/9/13/16/19 points five grades to get different numbers of STRK airdrops.</p>\n<p>The exact number will be further confirmed by Professor Sasson.</p>\n<p>Thank you Professor Sasson for watching and looking forward to your reply.</p>\n            <p><small>2 posts - 1 participant</small></p>\n            <p><a href=\"https://community.starknet.io/t/about-my-thoughts-on-the-second-starknet-airdrop/114323\">Read full topic</a></p>","link":"https://community.starknet.io/t/about-my-thoughts-on-the-second-starknet-airdrop/114323","pubDate":"Sat, 06 Jul 2024 08:57:46 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"community.starknet.io-topic-114323"},"source":{"@url":"https://community.starknet.io/t/about-my-thoughts-on-the-second-starknet-airdrop/114323.rss","#text":"About my thoughts on the second Starknet airdrop"}},{"title":"Here are my thoughts and suggestions on a possible re-airdrop","dc:creator":"nxs97","category":"Governance Proposals","description":"<p><a class=\"mention\" href=\"https://community.starknet.io/u/elibensasson\">@elibensasson</a> My suggestion is that Starknet‚Äôs future airdrop rules can be improved in the following aspects to ensure that true supporters and long-term holders get the rewards they deserve:</p>\n<ol>\n<li><strong>Holding time and frequency of use</strong>:</li>\n</ol>\n<p>Reward users who hold and actively use STRK tokens for a long time. Determine airdrop qualifications by analyzing wallet transaction history and token holding time, borrowing zkSync‚Äôs airdrop qualification time-weighted average method.</p>\n<ol start=\"2\">\n<li><strong>Participation in official activities</strong>:</li>\n</ol>\n<p>Prioritize rewards for users who actively participate in official activities, especially those who use STRK tokens for these activities. This not only shows their support for the project, but also shows a deep understanding and trust in the project.</p>\n<ol start=\"3\">\n<li><strong>Encourage long-term investment</strong>:</li>\n</ol>\n<p>Design a reward mechanism to encourage users to hold STRK tokens for a long time rather than engage in short-term speculation. For example, establish a holding reward program, the longer the token is held, the more rewards.</p>\n<p>Users who deposit STRK tokens in platforms such as zklend and Nostra to earn a meager annualized return have demonstrated long-term confidence and loyalty to the project. These users not only did not sell STRK during the market downturn, but also chose to continue holding STRK tokens and use them to participate in official activities. Such behavior undoubtedly deserves more recognition and rewards. Of course, users who participate with ETH or USDC are also true supporters, but their loyalty may not be as good as those who hold STRK tokens for a long time to participate in activities.</p>\n<p>I hope the Starknet team will consider these suggestions and formulate more fair and effective airdrop rules in the future.</p>\n            <p><small>2 posts - 2 participants</small></p>\n            <p><a href=\"https://community.starknet.io/t/here-are-my-thoughts-and-suggestions-on-a-possible-re-airdrop/114313\">Read full topic</a></p>","link":"https://community.starknet.io/t/here-are-my-thoughts-and-suggestions-on-a-possible-re-airdrop/114313","pubDate":"Thu, 04 Jul 2024 10:46:20 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"community.starknet.io-topic-114313"},"source":{"@url":"https://community.starknet.io/t/here-are-my-thoughts-and-suggestions-on-a-possible-re-airdrop/114313.rss","#text":"Here are my thoughts and suggestions on a possible re-airdrop"}},{"title":"SNIP 17: Procedure for introducing Starknet breaking changes","dc:creator":"Ohad-StarkWare","category":"SNIPs","description":"<p><strong>snip</strong> : 17<br>\n<strong>Title:</strong>: Procedure for introducing Starknet breaking changes<br>\n<strong>Author:</strong> <a class=\"mention\" href=\"https://community.starknet.io/u/amanusk\">@amanusk</a><br>\nStatus: Draft<br>\nType: Standards Track<br>\nCreation date: July 4, 2024<br>\nGithub link:</p>\n<h2><a name=\"abstract-1\" class=\"anchor\" href=\"https://community.starknet.io#abstract-1\"></a><strong>Abstract</strong></h2>\n<p>As the Starknet network matures, breaking changes to the stack affect many protocol stakeholders. This document aims to establish best practices for making decisions on protocol changes, ensuring that enough community opinions are heard and that the changes are justified.</p>\n<h2><a name=\"motivation-2\" class=\"anchor\" href=\"https://community.starknet.io#motivation-2\"></a><strong>Motivation</strong></h2>\n<p>The purpose of this SNIP is to formalize the process for proposing, discussing, and implementing core updates that are introducing breaking changes to the Starknet protocol. By providing a clear and structured approach, we aim to facilitate community engagement and transparency in the evolution of Starknet.</p>\n<h2><a name=\"specification-3\" class=\"anchor\" href=\"https://community.starknet.io#specification-3\"></a><strong>Specification</strong></h2>\n<p>The key words ‚ÄúMUST‚Äù, ‚ÄúMUST NOT‚Äù, ‚ÄúREQUIRED‚Äù, ‚ÄúSHALL‚Äù, ‚ÄúSHALL NOT‚Äù, ‚ÄúSHOULD‚Äù, ‚ÄúSHOULD NOT‚Äù, ‚ÄúRECOMMENDED‚Äù, ‚ÄúNOT RECOMMENDED‚Äù, ‚ÄúMAY‚Äù, and ‚ÄúOPTIONAL‚Äù in this document are to be interpreted as described in RFC 2119 and RFC 8174.</p>\n<h3><a name=\"starting-with-snips-4\" class=\"anchor\" href=\"https://community.starknet.io#starting-with-snips-4\"></a><strong>Starting with SNIPs</strong></h3>\n<p>Every core update <strong>MUST</strong> start with a SNIP. The author creates a PR in the Starknet SNIPs repository. And the editor performs syntactic checks as described in <a href=\"https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-1.md#snip-editor-responsibilities\">SNIP-1</a>. After the SNIP is merged to the main branch, the SNIP proposal <strong>SHOULD</strong> change the status to <code>review</code> and start a discussion on the <a href=\"https://community.starknet.io/\">Starknet Community Forum</a>.This is the opportunity for the community to discuss whether the SNIP is desired, whether it solves the problems it set out to solve, and whether there are better solutions.</p>\n<h3><a name=\"snip-acceptance-5\" class=\"anchor\" href=\"https://community.starknet.io#snip-acceptance-5\"></a><strong>SNIP Acceptance</strong></h3>\n<p>SNIPs <strong>MUST</strong> follow the process described in <a href=\"https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-1.md#snip-editor-responsibilities\">SNIP-1</a> to reach the status <code>final</code> . The Starknet Foundation <strong>SHOULD</strong> organise a regular AllCoreDev call so that sufficiently widespread adoption among Starknet operators and full nodes can be reached.</p>\n<h3><a name=\"starknet-version-voting-6\" class=\"anchor\" href=\"https://community.starknet.io#starknet-version-voting-6\"></a><strong>Starknet version &amp; Voting</strong></h3>\n<p>SNIPs introducing breaking changes will be coupled to a Starknet version. Each Starknet version <strong>SHOULD</strong> come with a meta upgrade SNIP. The meta upgrade SNIP should specify the changes included in the hard fork and contains the following fields <code>codename</code> , <code>activation</code> (comes with target block on mainnet / testnet)<code>included SNIPS</code> . Versions with significant changes <strong>MUST</strong> require a community vote. All SNIPs associated with the version will be part of the same vote, and if the vote passes, all changes are introduced together.</p>\n<h3><a name=\"breaking-change-timeline-7\" class=\"anchor\" href=\"https://community.starknet.io#breaking-change-timeline-7\"></a><strong>Breaking Change Timeline</strong></h3>\n<p>The timeline proposed here reflects a minimal time to allow all relevant parties to learn about the breaking change and prepare for it. It is possible that some SNIPs will take longer to reach acceptance and deployment.</p>\n<ul>\n<li><strong>T - 5 months:</strong> The initial SNIP idea is discussed with relevant parties (e.g., Full Nodes, Wallets, StarkWare, etc.).\n<ul>\n<li>A discussion is opened on the Starknet Community Forum.</li>\n</ul>\n</li>\n<li><strong>T - 4 months:</strong> An initial SNIP draft is open as a PR to the Starknet-io SNIP repository.</li>\n<li><strong>T - 3.5 months:</strong>\n<ul>\n<li>Initial comments on the PR are addressed and it is merged into the SNIP repository.</li>\n</ul>\n</li>\n<li><strong>T - 2.5 months:</strong>\n<ul>\n<li>Comments in the community forum are addressed, and there is a temperature gauge for whether the SNIP is accepted by the community.</li>\n</ul>\n</li>\n<li><strong>T - 2 months:</strong>\n<ul>\n<li>The SNIP is discussed in a Community Call hosted by the Starknet Foundation, where the author can discuss more details of the SNIP and its benefits. If there are no objections, the SNIP is en route to being introduced.</li>\n<li>The content of the community call is summarized in a public Github repository, with decisions regarding the SNIP.</li>\n<li>The SNIP is officially on the roadmap to be introduced in a Starknet version upgrade.</li>\n<li>A page summarizing the changes and the effects on relevant parties is added to a SNIPs page on <a href=\"http://starknet.io/\">Starknet.io</a>.</li>\n</ul>\n</li>\n<li><strong>T - 1.5 months:</strong>\n<ul>\n<li>A mailing list is sent announcing the official date when the SNIP will be introduced to Starknet testnet/integration.</li>\n<li>The mailing list will include relevant links to the SNIP such as:\n<ul>\n<li>Link to GH discussions.</li>\n<li>Link to the community forum.</li>\n<li>Link to the relevant community call.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>T - 2 weeks:</strong> Additional reminder is sent with SNIP main bullet points and dates.</li>\n<li><strong>T:</strong> The SNIP is introduced to Starknet integration.</li>\n<li><strong>T + ~1 month:</strong> Provided no major issues, the SNIP is live on Starknet testnet.</li>\n<li><strong>T + ~2 months:</strong> The SNIP is live on Starknet mainnet.</li>\n</ul>\n<h3><a name=\"fast-track-for-non-breaking-changes-8\" class=\"anchor\" href=\"https://community.starknet.io#fast-track-for-non-breaking-changes-8\"></a><strong>Fast track for Non-Breaking Changes</strong></h3>\n<p>As the Starknet network is still in a growing phase a ‚Äúfast track‚Äù is needed for more agility. Thus non-protocol-level SNIPs and SNIPs that do not introduce breaking changes can be ‚Äúfast-tracked‚Äù but <strong>SHOULD</strong> still undergo a regular process to ensure sufficient coverage and comments from relevant community members. Fast-tracked SNIPs can go from <code>draft</code> to <code>last call</code> directly per editor request. However as the network matures more decentralisation will be required and the ‚Äúfast-track‚Äù <strong>MUST</strong> end in a year time.</p>\n<h2><a name=\"roles-and-responsibilities-9\" class=\"anchor\" href=\"https://community.starknet.io#roles-and-responsibilities-9\"></a><strong>Roles and Responsibilities</strong></h2>\n<h3><a name=\"snip-editor-10\" class=\"anchor\" href=\"https://community.starknet.io#snip-editor-10\"></a><strong>SNIP Editor</strong></h3>\n<p>In addition to the responsibilities described in <a href=\"https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-1.md#snip-editor-responsibilities\">SNIP-1</a></p>\n<ul>\n<li>Assess which non-core SNIPs are worthy to be fast-tracked</li>\n</ul>\n<h3><a name=\"snip-proposer-11\" class=\"anchor\" href=\"https://community.starknet.io#snip-proposer-11\"></a><strong>SNIP Proposer</strong></h3>\n<p>You are the SNIP‚Äôs owner. Seeing it through is your goal!</p>\n<ul>\n<li>Discuss improvement ideas with relevant parties, such as wallets, full nodes, Dapps, service providers, etc.</li>\n<li>Write a SNIP and submit a PR to Github.</li>\n<li>Follow discussions on Github and open a Community forum discussion.</li>\n<li>Address concerns and get approval from relevant parties.</li>\n<li>Follow the SNIP towards inclusion on Mainnet.</li>\n</ul>\n<h3><a name=\"starknet-developer-12\" class=\"anchor\" href=\"https://community.starknet.io#starknet-developer-12\"></a><strong>Starknet Developer</strong></h3>\n<p>SNIPs might require you to adapt to breaking changes. Hopefully, it‚Äôs for the best. You are responsible for raising your concerns or supporting upcoming changes and making sure you are ready for them in due time.</p>\n<ul>\n<li>Follow SNIPs and comment on SNIPs concerning you.</li>\n<li>Comment on the community forum on relevant SNIPs and raise concerns/improvements.</li>\n<li>Voice your support for SNIPs you understand will help move the ecosystem forward.</li>\n<li>Join the community calls to discuss SNIPs relevant to you.</li>\n<li>Follow the mailing list to get notified of new upcoming SNIPs and breaking changes.</li>\n</ul>\n<h3><a name=\"starknet-user-13\" class=\"anchor\" href=\"https://community.starknet.io#starknet-user-13\"></a><strong>Starknet User</strong></h3>\n<p>While breaking changes affecting the end user are not easy, they are sometimes necessary.</p>\n<ul>\n<li>You are welcome to participate in any discussion where you feel you can contribute to the conversation.</li>\n<li>Follow the Starknet mailing list and Starknet official social accounts to be notified of any breaking changes where you might be affected.</li>\n<li>Changes affecting end users will be more vocally announced to make sure as many as possible are aware of the upcoming change.</li>\n</ul>\n<h2><a name=\"copyright-14\" class=\"anchor\" href=\"https://community.starknet.io#copyright-14\"></a><strong>Copyright</strong></h2>\n<p>Copyright and related rights waived via <a href=\"https://notes.ethereum.org/LICENSE\">MIT</a>.</p>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://community.starknet.io/t/snip-17-procedure-for-introducing-starknet-breaking-changes/114310\">Read full topic</a></p>","link":"https://community.starknet.io/t/snip-17-procedure-for-introducing-starknet-breaking-changes/114310","pubDate":"Thu, 04 Jul 2024 08:40:57 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"community.starknet.io-topic-114310"},"source":{"@url":"https://community.starknet.io/t/snip-17-procedure-for-introducing-starknet-breaking-changes/114310.rss","#text":"SNIP 17: Procedure for introducing Starknet breaking changes"}},{"title":"From a community member to the Starknet team..","dc:creator":"n1neteen","category":"Governance Proposals","description":"<p>Hello, <a class=\"mention\" href=\"https://community.starknet.io/u/elibensasson\">@elibensasson</a> Starknet is my favorite project and reminds me of the early days of Ethereum. I can literally say that I am a Starknet maxi. Recently I got into a fight and almost got beaten up (no big deal) for saying this in a meeting with friends. So what do you think is the reason for this?</p>\n<p>It‚Äôs because of the lack of communication between the team and the community. The community wants to know that they are listened to. The community wants to know that their opinion matters.</p>\n<p>I want to end my talk with a quote that I like very much.</p>\n<p>Never underestimate a nail. A nail saves a horseshoe, a horseshoe saves a horse, a horse saves a commander, a commander saves an army, an army saves a whole country.</p>\n<p>FORZA STARKNET</p>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://community.starknet.io/t/from-a-community-member-to-the-starknet-team/114296\">Read full topic</a></p>","link":"https://community.starknet.io/t/from-a-community-member-to-the-starknet-team/114296","pubDate":"Wed, 03 Jul 2024 11:27:28 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"community.starknet.io-topic-114296"},"source":{"@url":"https://community.starknet.io/t/from-a-community-member-to-the-starknet-team/114296.rss","#text":"From a community member to the Starknet team.."}},{"title":"New Starknet Wallet<>Dapp API","dc:creator":"amanusk","category":"Starknet Technical Development","description":"<h1><a name=\"tldr-1\" class=\"anchor\" href=\"https://community.starknet.io#tldr-1\"></a>TL;DR</h1>\n<p>After a long and fruitful community effort, the <a href=\"https://www.starknet.io/\" rel=\"noopener nofollow ugc\">Starknet</a> JS stack is being updated with a new Wallet&lt;&gt;Dapp API.<br>\nThe new API simplifies Wallet&lt;&gt;Dapp communication and decouples the dependencies between wallets, <a href=\"https://www.starknet.io/ecosystem/dapps\" rel=\"noopener nofollow ugc\">dapps</a> and starknet.js versions.<br>\nThere is a new starknet.js release with support for the new API, new starknet-react and get-starknet versions, and a new home for Starknet npm packages.<br>\nThe following post summarizes the main changes, how this affects the ecosystem, and what you should do to prepare for the changes.</p>\n<h1><a name=\"the-current-state-of-starknetjs-and-wallet-integration-2\" class=\"anchor\" href=\"https://community.starknet.io#the-current-state-of-starknetjs-and-wallet-integration-2\"></a>The current state of Starknet.js and wallet integration</h1>\n<p>Until now, for a Dapp to connect to a Starknet wallet, it received an <code>Account</code> object injected into the window by the wallets and interacted with the wallet with all the methods supported by the <code>Account</code> class in starknet.js. This meant, in part, that if a new version of Starknet.js was released, both wallets and Dapps were required to upgrade to the new version to stay compatible with the latest Starknet API and Starknet.js features.</p>\n<p>This coupling stifled progress and required redundant coordination overhead to move the ecosystem forward.</p>\n<h1><a name=\"new-starknetjs-stack-3\" class=\"anchor\" href=\"https://community.starknet.io#new-starknetjs-stack-3\"></a>New Starknet.js stack</h1>\n<p>Starting with the Starknet community forum discussion, Argent proposed decoupling wallets from Starknet.js by facilitating a message-based API between wallets and Dapps.</p>\n<p>Moving to an API-based communication means wallets and Dapps no longer need to support specific Starknet.js versions as long as they communicate with the same API.</p>\n<p>After many discussions and reviews of the new API <a href=\"https://github.com/starkware-libs/starknet-specs/pulls?q=is%3Apr+is%3Aclosed\" rel=\"noopener nofollow ugc\">PR</a>, the new official wallet&lt;&gt;Dapp API has been added to the Starknet-specs repository.</p>\n<h3><a name=\"what-is-the-new-api-all-about-4\" class=\"anchor\" href=\"https://community.starknet.io#what-is-the-new-api-all-about-4\"></a>What is the new API all about?</h3>\n<p>Instead of directly invoking <code>Account</code> methods, a PRC message is sent to the wallet. The API supports only methods that require the wallet.</p>\n<p>These methods provide, in part, the functionality to :</p>\n<ul>\n<li>Get account address information</li>\n<li>Send Invoke and Declare transactions</li>\n<li>Sign SNIP-12 typed data</li>\n<li>etc.</li>\n</ul>\n<p>Notably, the new API does not allow to send requests to the wallet that can be solely handled by a Starknet Provider. It is up to the Dapp to use either their own node or one of Starknet‚Äôs RPC providers to get information about the blockchain.</p>\n<p>The new API creates a clear separation of concerns between the Dapp, the wallet and the provider. For example, the API does not externalize any options for fee or transaction type selection, which are handled by the wallet. The Dapp should only be concerned with building the appropriate calls and sending them to the wallet for signing and broadcasting.</p>\n<p>Along with the new API, a new stack of repositories is released to make transitioning to the new API as seamless as possible.</p>\n<h2><a name=\"new-repositories-and-packages-5\" class=\"anchor\" href=\"https://community.starknet.io#new-repositories-and-packages-5\"></a>New repositories and packages</h2>\n<h3><a name=\"types-js-6\" class=\"anchor\" href=\"https://community.starknet.io#types-js-6\"></a>types-js</h3>\n<p>One of the benefits of a unified API is that we can now have a types package, standardizing the expected JS types on both ends. The new <code>types-js</code> repository can be found under</p>\n<ul>\n<li>Github: <a href=\"https://github.com/starknet-io/types-js\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">GitHub - starknet-io/types-js</a></li>\n<li>npm: <code>npm install @starknet-io/types-js</code></li>\n</ul>\n<p>The types repository will follow the versioning of the main Starknet PRC, with only differences to the <code>patch</code> number. The current version is <code>0.7.X</code></p>\n<h3><a name=\"starknetjs-7\" class=\"anchor\" href=\"https://community.starknet.io#starknetjs-7\"></a>Starknet.js</h3>\n<p>Starknet.js version 6 and up will support the new API via a new class, <code>WalletAccount</code>. The class is initiated with a Starknet Provider and a Starknet Wallet, which are provided by the wallet extensions. From that point on, interactions with the account are very similar to the current <code>Account</code> in Starknet.js. All of the communication with the wallet is implemented under the hood.</p>\n<p>You can read more about <code>WalletAccount</code> in the starknet.js <a href=\"https://www.starknetjs.com/docs/next/guides/walletAccount\" rel=\"noopener nofollow ugc\">documentation</a>.<br>\nVersion 5, which supports the old API, will still be available if you specify an exact version.</p>\n<ul>\n<li>npm: <code>npm install starknet</code></li>\n</ul>\n<h3><a name=\"get-starknet-8\" class=\"anchor\" href=\"https://community.starknet.io#get-starknet-8\"></a>get-starknet</h3>\n<p>Get Starknet will be released under a new home on npm, under the <code>@starknet-io</code> organization. The new get-starknet V4 version is available for installation with <code>npm install @starknet-io/get-starknet</code> . The older V3 versions, currently available via <code>npm install get-starknet</code>, will remain available until the old API is End Of Life.</p>\n<ul>\n<li>Github (Develop branch): <a href=\"https://github.com/starknet-io/get-starknet/tree/develop\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">GitHub - starknet-io/get-starknet at develop</a></li>\n<li>npm: <code>npm install @starknet-io/get-starknet</code></li>\n</ul>\n<h2><a name=\"starknet-react-9\" class=\"anchor\" href=\"https://community.starknet.io#starknet-react-9\"></a>starknet-react</h2>\n<p>Starknet-react V3 will be released with support for the new types-js and the new API.  Documentation on Starknet-react V3 is available <a href=\"https://v3.starknet-react.com/docs/getting-started\" rel=\"noopener nofollow ugc\">here</a>.</p>\n<ul>\n<li>npm: <code>npm add @starknet-react/chains@next @starknet-react/core@next</code></li>\n</ul>\n<h1><a name=\"when-will-the-api-become-the-standard-10\" class=\"anchor\" href=\"https://community.starknet.io#when-will-the-api-become-the-standard-10\"></a>When will the API become the standard?</h1>\n<p>Starknet mainnet is planned to be updated to version <strong>0.13.3 around September 2024</strong>. The new Starknet version will ship with and updated RPC version (0.8), and will drop support for old RPC versions older than RPC 0.7.</p>\n<p>Starknet.js versions supporting the old RPC, and the old wallet&lt;&gt;Dapp API will then also be deprecated.</p>\n<h1><a name=\"what-should-you-do-11\" class=\"anchor\" href=\"https://community.starknet.io#what-should-you-do-11\"></a>What should you do?</h1>\n<p>The upcoming months will be a transition period when both API versions will be supported by both Argent and Braavos, with additional wallets onboarding using the new API. So, how does this affect you?</p>\n<h3><a name=\"new-wallets-coming-to-starknet-12\" class=\"anchor\" href=\"https://community.starknet.io#new-wallets-coming-to-starknet-12\"></a>New wallets coming to Starknet</h3>\n<ul>\n<li>See the links below for information about the new API spec and example Dapps working with the new API</li>\n<li>Implement the new wallet&lt;&gt;Dapp communication API</li>\n<li>Submit a PR to get-starknet to add your wallet to get-starknet discovery</li>\n</ul>\n<h3><a name=\"dapp-developers-13\" class=\"anchor\" href=\"https://community.starknet.io#dapp-developers-13\"></a>Dapp developers</h3>\n<p>You are welcome to try out the new stack with the new versions of Starknet-js, starknet-react, and get-starknet. Arget and Braavos are already supporting the new API. While there will be a transition period when some of the other wallets add support for the new API, all existing and new wallets are expected to transition to it by the time of the next Starknet network upgrade (0.13.3).</p>\n<h3><a name=\"users-14\" class=\"anchor\" href=\"https://community.starknet.io#users-14\"></a>Users</h3>\n<p>The change in API shouldn‚Äôt affect you. Both old and new API versions will continue to be available for a while. If you experience any issues with the support of your wallet in a Dapp, you are welcome to contact the Dapp developer or wallet provider.</p>\n<h2><a name=\"thanks-15\" class=\"anchor\" href=\"https://community.starknet.io#thanks-15\"></a>Thanks</h2>\n<p>This important upgrade is a joint work of many parties. Special thanks to <a href=\"https://github.com/janek26\" rel=\"noopener nofollow ugc\">Janek</a> from Argent for the initial SNIP proposal. To <a href=\"https://github.com/avimak\" rel=\"noopener nofollow ugc\">Abraham</a> from Braavos for providing the initial implementation of the SNIP and the accompanying Braavos wallet. To <a href=\"https://github.com/dhruvkelawala\" rel=\"noopener nofollow ugc\">Dhruv</a> and <a href=\"https://github.com/vladutjs\" rel=\"noopener nofollow ugc\">Vladut</a> from Argent. To <a href=\"https://github.com/fracek\" rel=\"noopener nofollow ugc\">Francesco</a> from Apibara for adding support to starknet-react, to <a href=\"https://github.com/tabaktoni\" rel=\"noopener nofollow ugc\">Toni Tabak</a> and the team at SpaceShard for the incredible work on Starknet-js and types.js and for adding support to the new API. To <a href=\"https://github.com/naorye2\" rel=\"noopener nofollow ugc\">Naor</a> and <a href=\"https://github.com/dan-ziv\" rel=\"noopener nofollow ugc\">Dan Ziv</a> form StarkWare for adding the new API to get-starknet. To <a href=\"https://github.com/PhilippeR26\" rel=\"noopener nofollow ugc\">Philippe Rostan</a> from <a href=\"http://critical.devs.fr/\" rel=\"noopener nofollow ugc\">critical.devs.fr</a> for the help testing, reviewing, commenting, and building the demo Dapps for the new API.</p>\n<h1><a name=\"useful-links-16\" class=\"anchor\" href=\"https://community.starknet.io#useful-links-16\"></a>Useful links</h1>\n<ul>\n<li>Wallet <a href=\"https://github.com/starkware-libs/starknet-specs/blob/master/wallet-api/wallet_rpc.json\" rel=\"noopener nofollow ugc\">API</a> on Starknet-specs</li>\n<li>Initial SNIP <a href=\"https://community.starknet.io/t/snip-standardizing-starknet-wallet-connections-with-write-api-and-json-rpc-integration/98049\">discussions</a></li>\n<li>Types-js GitHub: <a href=\"https://github.com/starknet-io/types-js\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">GitHub - starknet-io/types-js</a></li>\n<li>Starknet.js V6 upgrade <a href=\"https://www.starknetjs.com/docs/next/guides/migrate/\" rel=\"noopener nofollow ugc\">instructions</a></li>\n<li>Starknet.js WalletAccount <a href=\"https://www.starknetjs.com/docs/next/guides/walletAccount\" rel=\"noopener nofollow ugc\">documentation</a></li>\n<li>get-starknet GitHub: <a href=\"https://github.com/starknet-io/get-starknet/tree/develop\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">GitHub - starknet-io/get-starknet at develop</a></li>\n<li><a href=\"https://starknet-react-website.vercel.app/\" rel=\"noopener nofollow ugc\">React App by Francesco</a> to test wallet functionality of new API</li>\n<li>Starknet-react V3 upgrade <a href=\"https://starknet-react-website.vercel.app/docs/upgrading-to-v3\" rel=\"noopener nofollow ugc\">instructions</a></li>\n<li><a href=\"https://github.com/PhilippeR26\" rel=\"noopener nofollow ugc\">Philippe ROSTAN</a> created a great Demo <a href=\"https://github.com/PhilippeR26/Starknet-WalletAccount\" rel=\"noopener nofollow ugc\">Dapp</a> which uses the new wallet API</li>\n<li><a href=\"https://github.com/PhilippeR26\" rel=\"noopener nofollow ugc\">Philippe ROSTAN</a> <a href=\"https://github.com/PhilippeR26/Starknet-WalletAccount/blob/main/doc/walletAPIspec.md\" rel=\"noopener nofollow ugc\">explanations</a> of the new API functions, with examples</li>\n</ul>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://community.starknet.io/t/new-starknet-wallet-dapp-api/114295\">Read full topic</a></p>","link":"https://community.starknet.io/t/new-starknet-wallet-dapp-api/114295","pubDate":"Wed, 03 Jul 2024 11:26:58 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"community.starknet.io-topic-114295"},"source":{"@url":"https://community.starknet.io/t/new-starknet-wallet-dapp-api/114295.rss","#text":"New Starknet Wallet<>Dapp API"}},{"title":"Mistakes made and wrong decisions made in the first airdrop","dc:creator":"Quanionxyz","category":"Governance Proposals","description":"<p><a class=\"mention\" href=\"https://community.starknet.io/u/elibensasson\">@elibensasson</a> Since you want to hear this, let me tell you about mistakes. First of all, the requirement for people to have 0.005 eth in their wallets in the first airdrop round was very unreasonable, I say this as someone whose web3 wallet has been hacked 3 times before. I don‚Äôt keep my balances in my cold wallet, my balances are usually in my stock market account and I withdraw and use them whenever I need. I can‚Äôt risk my money again. You will probably say that 0.005 eth is a very low riskable amount. However, this balance is enough for a hacker to steal any NFT assets in my wallet. You could have used different metrics instead. For example, instead of having at least 0.005 eth in the wallet, it is required to interact with at least 5 starknet dapps. Or you could issue NFTs to identify and mark real users at certain milestones since the Starknet network was established. In this way, on the day of the airdrop, you could choose a reward by looking at who followed the Starknet network and how many NFTs they had. It‚Äôs just a simple metric. If you think about it, many different and more comprehensive metrics can be obtained. Now let‚Äôs talk about the second or subsequent airdrops. From the very beginning, we told you to fix the first airdrop allocation first. But you constantly lashed out at the community, telling us that there would be second or third airdrops and that we should continue to use starknet. However, you are forgetting the important point that you do not think about but the users do. Personally, as a starknet user, I did not receive an airdrop allocation even though I had only one wallet in the first airdrop and used the starknet network constantly. That‚Äôs why I stopped using the starknet network. I am not an airdrop farmer. I enjoyed using the Starknet network organically. I got angry at you for the unfair distribution and stopped using your network.  Now, you have been saying for a long time that there will be a second airdrop to appease the community. But I‚Äôm so angry at you that I don‚Äôt even care about the 2nd airdrop. Because probably in the second airdrop, the majority of the beneficiaries are those who qualified for the first airdrop and received 100k stark. You distributed such large amounts of stark to many of them, at our expense, that it became almost impossible for us to compete with them for the 2nd airdrop. You did this. If you had listened to us and remixed the first distribution and distributed it to the entire starknet community. Almost half of the users would use the starks from the first airdrop on the starknet network again. For example, delegating. or like buying quality NFTs. However, you allocated the second airdrop allocation to the people to whom you distributed those high amounts of stark from the very beginning. I hope you understand me. People sold 1 Strk for almost $2 in the first airdrop. The person to whom you gave 100k strk suddenly earned $200k. From the very beginning, it was made impossible for users like us to compete with these people for the 2nd airdrop. If you distribute the second airdrop share to users you did not qualify in the first airdrop without any conditions, you can at least regain maybe 1/3 of the community you lost. Respects</p>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://community.starknet.io/t/mistakes-made-and-wrong-decisions-made-in-the-first-airdrop/114292\">Read full topic</a></p>","link":"https://community.starknet.io/t/mistakes-made-and-wrong-decisions-made-in-the-first-airdrop/114292","pubDate":"Wed, 03 Jul 2024 10:59:17 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"community.starknet.io-topic-114292"},"source":{"@url":"https://community.starknet.io/t/mistakes-made-and-wrong-decisions-made-in-the-first-airdrop/114292.rss","#text":"Mistakes made and wrong decisions made in the first airdrop"}},{"title":"Reflections on the Decentralized Starknet protocol","dc:creator":"_dd","category":"üìú Development Proposals","description":"<h1><a name=\"reflections-on-the-decentralized-starknet-protocol-1\" class=\"anchor\" href=\"https://community.starknet.io#reflections-on-the-decentralized-starknet-protocol-1\"></a><strong>Reflections on the Decentralized Starknet protocol</strong></h1>\n<p>In this post we would like to share some of our thoughts at Nethermind‚Äôs Research group around the Starknet Decentralized protocol. For a well organized and systematic presentation of the protocol, we invite you to read <a href=\"https://community.starknet.io/t/starknet-decentralized-protocol-i-introduction/2671\">Ilia Volokh‚Äôs series of posts</a>.</p>\n<h3><a name=\"h-1-soft-inclusion-mechanisms-for-forced-staking-updates-2\" class=\"anchor\" href=\"https://community.starknet.io#h-1-soft-inclusion-mechanisms-for-forced-staking-updates-2\"></a><strong>1. Soft inclusion mechanisms for forced staking updates</strong></h3>\n<p><em><strong>Context:</strong></em> The L1 Staking Contract can enforce staking updates on L2 via L1 ‚Üí L2 messages. These forced updates have a deadline (measured in L1 blocks, around 24h). In the current proposal, when a deadline is reached without L1 receiving a confirmation from L2 of the forced update, honest L2 nodes perform a <em>staker reset</em> (i.e., revert their state to the last accepted block on L1 and reconfigure their staking set to include the stale updates).</p>\n<p>Staker resets can affect the latency of the protocol and should be used as a last resort mechanism. Instead of optimistically hoping that forced updates will be included in proposals by altruistic nodes, some soft measures can be taken before the deadlines are reached. We identified two measures that are not mutually exclusive:</p>\n<p><strong>A) Decreasing rewards for blocks containing forced updates.</strong> Proposers who used some of their block space for including forced updates should get rewards for this. We propose a decreasing reward scheme in order to avoid the scenario in which proposers avoid including force updates in order to increase the rewards for them. Decreasing rewards can lead to faster inclusion of the forced updates into blocks.</p>\n<p><strong>B) Engage the consensus mechanism for including forced updates.</strong> Proposed blocks should contain forced updates if available. If a new proposal doesn‚Äôt contain a forced update (which has a deadline in some epsilon amount of time), during consensus, (honest) nodes will not vote for this proposal. One has to take into account the time it takes for nodes to sync their views of L1, so this mechanism can be engaged after an amount of time in which we are sure that all nodes learned about a new forced transaction.</p>\n<h3><a name=\"h-2-pool-of-proofs-3\" class=\"anchor\" href=\"https://community.starknet.io#h-2-pool-of-proofs-3\"></a>2. Pool of proofs</h3>\n<p><em><strong>Context:</strong></em> For a block to include txs, it must include a proof for some previous block(s). A block must contain a proof for the latest non-empty block and all intermediary empty blocks in its strand. A proposer is expected to have such a proof to be able to propose a block. Proposers learn in advance when they have to prepare proofs. A proposer can acquire a proof by computing it or by delegation. The protocol offers rewards for blocks and for proofs. The Starknet protocol is using Tendermint as a consensus protocol. We anticipate that proposers for rounds <code>0</code> for any height will be highly incentivized to acquire such proofs, but not proposers for rounds strictly greater than <code>0</code>.</p>\n<p>Nodes learn about a proof only when a proposer makes a proposal containing this proof. We identified some drawbacks around this mechanism. For example:</p>\n<ol>\n<li>The proposer who obtained a certain proof can be offline when they are supposed to propose a block, so the computation resources for that proof are wasted.</li>\n<li>Being a proposer for round <code>1</code> may be a privileged position when it comes to rewards. Suppose in round <code>0</code>, there is a proposal for a valid block <code>b</code> with proof <code>p</code> , <code>2f+1</code> nodes lock on this proposal, but not all nodes commit to it. In this case, the proposer in round <code>1</code> is lucky as they can make the same proposal, reusing the proof  <code>p</code>  and get the rewards.</li>\n<li>Similar with the above situation, (rational) nodes can steal the proofs exposed by previous proposers in order to get rewards. For example, at round <code>r</code> I receive a <code>PROPOSAL</code> message with block <code>b</code> and proof <code>p</code>. I can collude with others and decide not to lock on <code>b</code>. In the next round I am the proposer. As I don‚Äôt want to waste computing power to generate a proof, I propose again <code>(b,p)</code> to collect rewards. Note that such a scenario breaks the trust assumption of <code>2f+1</code> honest nodes of Tendermint.</li>\n<li>When the upper bound on empty blocks (in a strand) is reached, only a block containing a proof can be proposed. In this case, the consensus protocol will be stuck for a considerate amount of time on a certain height before consensus can be reached on a value, as proposers for rounds greater than <code>0</code> may not have had enough time to acquire the necessary proof for making a proposal. Moreover, leaders for rounds greater than <code>0</code> have no guarantee that they will get rewards if they acquire a proof, as previous leaders may have already exposed the proof before them.</li>\n</ol>\n<p>We think that making a proof a ‚Äúpublic good‚Äù as soon as it is computed is a healthy alternative to avoid the above issues. Proofs should be added to a common <strong>pool of proofs</strong> available to all nodes and the entity posting the proof should receive the reward. One disadvantage for having a pool of proofs is that it introduces a new component into the protocol.</p>\n<p>One can start computing the proof of a block as soon as the block is committed to the L2 chain. Let us describe what the proof for block <code>H</code> looks like, depending on the type of block.</p>\n<ul>\n<li><em><strong>Block <code>H</code> is non-empty</strong></em>. The proof for <code>H</code> is the recursive proof of the followings:\n<ul>\n<li>the proof of the execution of the txs in <code>H</code></li>\n<li>the proof of the verification of the proof in <code>H</code></li>\n</ul>\n</li>\n<li><em><strong>Block <code>H</code> is empty.</strong></em> The proof for <code>H</code> is the recursive proof of the followings:\n<ul>\n<li>the proof that block <code>H</code> is empty</li>\n<li>the proof of the previous block in its strand, i.e., block <code>H-k</code></li>\n</ul>\n</li>\n</ul>\n<p>With the above mechanism for computing a proof, a proposer for block <code>H+k</code> must include the proof for block <code>H</code>, independently of whether block <code>H</code> is empty or not.</p>\n<p>In terms of who is in charge of computing the proofs, we can think of several approaches. The simplest one is the current Proof Scheduling mechanism (i.e., the proposer for round <code>0</code> of height <code>H</code> is in charge for computing the proofs for the previous non-empty block <code>H-ik</code>with <code>i &gt; 0,</code> and all empty blocks <code>H-jk</code>, with <code>i &gt; j &gt; 0</code>, in the strand of block <code>H</code>); note that this approach doesn‚Äôt solve the above case 4.  Alternatively, one can allow a general race or a priority race (in which leaders for all rounds for height <code>H+k</code> have priority on proving block <code>H</code>) for computing proofs, enabling a faster access to proofs.</p>\n<p><strong>Unprovable blocks.</strong> One big concern around the Starknet protocol is due to unprovable blocks. Consensus can be reached on unprovable blocks due to, for example, inconsistencies between execution VMs and provers (e.g., an execution VM used during consensus for validating a block may output that the block is valid due to a bug, but the prover cannot actually prove the block). In such cases, a recovery mechanism must be triggered. In the current design, there is no mechanism for signaling that a block is unprovable. However, the system can recover by employing the reset mechanism used for forced staking updates which can take more than 24h.</p>\n<p>A pool of proofs can help dealing with unprovable blocks. The entity who is supposed to provide a proof for a block can submit instead a proof showing that the block is unprovable. For example, if a prover fails to prove the execution of the txs in a block, then the entity can run a prover in a zkVM building a proof showing that the prover failed (and consequently, that the block is unprovable). Even though this mechanism is extremely computational expensive, using it in extreme rare situations can improve the current mechanism for dealing with unprovable blocks.</p>\n<p>Resets can also be avoided when identifying an unprovable block. When there is a proof <code>P</code> in the pool showing that block <code>H</code> (already contained in the chain) is unprovable, nodes can treat block <code>H</code> as an empty block (i.e., a block that doesn‚Äôt change the state) and use the proof <code>P</code> in the recursive proof that will be needed in the next non-empty block.</p>\n<h3><a name=\"h-3-decrease-the-rewards-for-empty-blocks-4\" class=\"anchor\" href=\"https://community.starknet.io#h-3-decrease-the-rewards-for-empty-blocks-4\"></a><strong>3. Decrease the rewards for empty blocks</strong></h3>\n<p><em><strong>Context:</strong></em> When they are missing the expected proof for making a proposal, proposers can propose empty blocks.</p>\n<p>Even though having the option of proposing empty blocks helps in not slowing down the protocol while waiting for proofs to be computed, it raises other problems  For example, malicious/lazy nodes can propose only empty blocks for censoring transactions or for damaging the quality of the chain.</p>\n<p>The protocol should discourage nodes for proposing (only) empty blocks when not necessary. A solution around this would be to halve the rewards for consecutive empty blocks proposed by the same node. The first time a node proposes an empty block, the reward should not be halved.</p>\n<h3><a name=\"summary-5\" class=\"anchor\" href=\"https://community.starknet.io#summary-5\"></a>Summary</h3>\n<p>With this post, we wanted to point out some problems the Decentralized StarkNet protocol can encounter. We made some suggestions for circumventing them which hopefully can improve the robustness of the protocol. We look forward to hear your feedback on these reflections!</p>\n            <p><small>13 posts - 4 participants</small></p>\n            <p><a href=\"https://community.starknet.io/t/reflections-on-the-decentralized-starknet-protocol/114280\">Read full topic</a></p>","link":"https://community.starknet.io/t/reflections-on-the-decentralized-starknet-protocol/114280","pubDate":"Tue, 02 Jul 2024 12:09:49 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"community.starknet.io-topic-114280"},"source":{"@url":"https://community.starknet.io/t/reflections-on-the-decentralized-starknet-protocol/114280.rss","#text":"Reflections on the Decentralized Starknet protocol"}},{"title":"Media Application","dc:creator":"ciaran","category":"üôè Help and Support","description":"<p>Hi everyone</p>\n<p>I‚Äôm the founder of <a href=\"https://olas.info/\" rel=\"noopener nofollow ugc\">this media project</a>. We recently came out of stealth after quite some time spent at mechanism design. Eg we built an entirely novel market based on Bayesian Truth Serum to gauge the quality of opinion articles that we‚Äôre particularly proud of. We‚Äôre now investigating the various options of where to build and are very impressed with the Starknet ecosystem.</p>\n<p>We‚Äôre an app and want to focus on making it as successful as possible. The less we have to focus on building infrastructure, the more we can focus on that goal. So we‚Äôre trying to outsource as many things as possible to stuff that‚Äôs already built. We don‚Äôt want to build our own L1 or our own DID or PoP protocol, etc, etc. Not just from a development perspective but also from the perspective of having to get L1s supported by CEXs, etc, etc. These things take a lot of time and energy and they‚Äôre not core to what we‚Äôre trying to do. So long story, short, the likes of Starknet is a natural place to build.</p>\n<p>The revenue model of the app will rely heavily on micropayments so we‚Äôre an extremely fee sensitive app. From my research of Starknet, to achieve our goals under the assumption that usage of Starknet is going to be a lot higher than it is now in two years time, we‚Äôre either going to have to rely on volitions or spin up our own L3. The volitions integration timeline is a little uncertain but we‚Äôre not going to launch for some time so this is probably not going to be an issue.</p>\n<p>I have a few questions regarding both these possible routes.</p>\n<ol>\n<li>\n<p>When volitions are implemented will contracts that use different DA solutions to each other lose syncrhonous composability on Starknet (this is not a big deal to us BTW I‚Äôm just curious)</p>\n</li>\n<li>\n<p>If we spin up our own L3 can we abstract it away from the user by either employing a bridge that permits synchronous composability (ZK Sync claims to allow this with ZK Porter shards) or at the wallet level using account abstraction and relayers? We really want to avoid having our users manually bridge across from Starknet as the UX of bridges is simply not suitable for the masses in our view.</p>\n</li>\n<li>\n<p>Would anyone be able to provide a rough estimate of the TX fee differences between using a L3 over Starknet and volitions on Starknet directly assuming the same DA layer is used? Second part of this question if we were to use relayers from L2 to L3 for each TX (assuming this is even possible) do any cost advantages it might have evaporate?</p>\n</li>\n</ol>\n<p>If anyone had any insights here they‚Äôd be greatly appreciated.</p>\n            <p><small>4 posts - 2 participants</small></p>\n            <p><a href=\"https://community.starknet.io/t/media-application/114279\">Read full topic</a></p>","link":"https://community.starknet.io/t/media-application/114279","pubDate":"Tue, 02 Jul 2024 08:38:29 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"community.starknet.io-topic-114279"},"source":{"@url":"https://community.starknet.io/t/media-application/114279.rss","#text":"Media Application"}},{"title":"Zero Knowledge Governance for DAOs on Starknet","dc:creator":"Damian995","category":"üìú Development Proposals","description":"<p>By team: Verse</p>\n<p><strong>Overview</strong></p>\n<p>Modern digital identity systems, while enabling complex online interactions, have significant weaknesses due to centralized control, making them vulnerable to coercion, hacking, and misalignment with user interests. Decentralized, cryptographic mechanisms like zkSNARKs offer solutions by enabling credible claims without a trusted authority. This shift allows users to control their identity data, enhancing security and privacy. This has been our greatest inspiration to create the Zero Knowledge Governance Solution for Starknet.</p>\n<p>The Starknet ecosystem is home to several prominent projects like Realms and Ekubo, which are governed and managed by DAOs. These organizations are committed to the principles of transparency, decentralization, and community-driven governance. Despite these ideals, there remains a significant reluctance among community members to engage in governance. The primary concern is the visibility of their voting actions on the blockchain, which can expose sensitive information regarding their decisions and influence.</p>\n<p>While zkSNARKs inspire us to explore technology creating secure, privacy-preserving identity systems,vbuterin‚Äôs vision for minimal anti-collusion infrastructure (MACI) provides a foundational principle for our proposal. MACI focuses on offering collusion resistance with centralized trust while ensuring blockchain guarantees of correct execution and censorship resistance. By using a trusted operator to manage keys and actions, encrypting messages to maintain vote privacy and integrity, this method prevents bribery and ensures votes are counted accurately without exposing individual choices.</p>\n<p>Zero Knowledge (ZK) Governance building on MACI abstracts governance voting to ensure privacy and collusion resistance using encryption and zero-knowledge proofs. With a trusted coordinator managing key changes and actions, providing credible results without revealing individual votes. This approach ensures voting remains private, secure, and verifiable without exposing voters‚Äô identities or their choices. This innovation encourages greater participation in DAO governance by safeguarding the anonymity and confidentiality of each vote, while still maintaining the integrity and trustworthiness of the voting process. When integrated into Starknet‚Äôs governance platform, this solution can significantly enhance participation rates and foster a more inclusive governance environment.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://europe1.discourse-cdn.com/standard20/uploads/starknet1/original/3X/c/8/c84b043fe7e66c31c5984ae2f1116d1727185b69.png\" data-download-href=\"/uploads/short-url/szSdpTAXCiac4zRrhWaUWxwKpkZ.png?dl=1\" title=\"WechatIMG5067\" rel=\"noopener nofollow ugc\"><img src=\"https://europe1.discourse-cdn.com/standard20/uploads/starknet1/original/3X/c/8/c84b043fe7e66c31c5984ae2f1116d1727185b69.png\" alt=\"WechatIMG5067\" data-base62-sha1=\"szSdpTAXCiac4zRrhWaUWxwKpkZ\" width=\"690\" height=\"372\" data-dominant-color=\"F3F3F3\"></a></div><p></p>\n<p>Source: MACI Introduction. <a href=\"https://maci.pse.dev/docs/introduction#credits\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">Introduction to MACI | MACI</a></p>\n<p><strong>Problems with Current On-Chain Governance</strong></p>\n<p>DAOs in the Starknet ecosystem currently face several challenges that hinder active participation in governance:</p>\n<ul>\n<li>\n<p>Lack of Privacy: Voting actions are publicly visible on the blockchain, leading to concerns about exposing decisions and associated assets.</p>\n</li>\n<li>\n<p>Fear of Repercussions: Members may avoid voting on sensitive or controversial issues due to potential social or financial backlash.</p>\n</li>\n<li>\n<p>Transparency vs. Confidentiality: There is a conflict between the need for transparent governance and the desire to keep individual voting choices private.</p>\n</li>\n<li>\n<p>Influence and Bias: Public voting records can lead to undue influence, where the votes of prominent members sway the opinions of others.</p>\n</li>\n<li>\n<p>Low Participation Rates: The visibility of votes discourages engagement, leading to lower participation in governance processes.</p>\n</li>\n<li>\n<p>Data Sensitivity: Voters prefer to keep their voting history and the details of their holdings confidential to avoid revealing personal strategies.</p>\n</li>\n</ul>\n<p><strong>Zero Knowledge Governance Solutions for Starknet</strong></p>\n<p>Zero Knowledge Governance (ZK Governance) offers a comprehensive solution to these challenges by balancing the need for transparency in governance with the privacy of individual voters. Key features of ZK Governance for Starknet DAOs include:</p>\n<ol>\n<li>\n<p>Zero-Knowledge Proofs for Voting Privacy: Utilizes zero-knowledge proofs to validate that a vote was cast by a legitimate wallet address and backed by real assets, without revealing the voter‚Äôs identity or choice. This ensures that voting is private and secure, fostering greater confidence in the voting process.</p>\n</li>\n<li>\n<p>Anonymity in Participation: Ensures that whether a wallet has voted, the direction of the vote (yes or no), and the amount of voting power exercised remain confidential. This privacy encourages members to participate without fear of repercussions or undue influence.</p>\n</li>\n<li>\n<p>Snapshot-based Asset Validation: Assets are validated at the time of voting through a snapshot taken at a specific block height, ensuring the vote‚Äôs legitimacy without exposing details on the blockchain. This method ensures that votes are cast by eligible participants without compromising their privacy.</p>\n</li>\n<li>\n<p>Encouraged Participation: By protecting voters from potential backlash or influence, ZK Governance promotes more active and diverse participation in governance decisions. This leads to a more robust and representative decision-making process within DAOs.</p>\n</li>\n<li>\n<p>Equal Voting Power: Maintains the principle of token-weighted voting without compromising voter privacy. This ensures that all stakeholders have a fair say in governance matters while protecting their anonymity.</p>\n</li>\n<li>\n<p>Secure and Verifiable: The integrity of the voting process is upheld through secure cryptographic methods, ensuring that all votes are counted accurately and fairly. This transparency helps build trust in the governance system.</p>\n</li>\n<li>\n<p>Enhanced Community Trust: By safeguarding individual privacy, ZK Governance fosters a more trusting and open community environment where members feel safe to express their opinions. This trust is crucial for the healthy functioning of DAOs in the Starknet ecosystem.</p>\n</li>\n</ol>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://europe1.discourse-cdn.com/standard20/uploads/starknet1/original/3X/2/5/258cd9f96d7296dee27ed0597dbcaf0a3fc85a68.png\" data-download-href=\"/uploads/short-url/5mbreyYafpn045gJr8p9u9vTE6Y.png?dl=1\" title=\"WechatIMG5069\" rel=\"noopener nofollow ugc\"><img src=\"https://europe1.discourse-cdn.com/standard20/uploads/starknet1/optimized/3X/2/5/258cd9f96d7296dee27ed0597dbcaf0a3fc85a68_2_666x500.png\" alt=\"WechatIMG5069\" data-base62-sha1=\"5mbreyYafpn045gJr8p9u9vTE6Y\" width=\"666\" height=\"500\" srcset=\"https://europe1.discourse-cdn.com/standard20/uploads/starknet1/optimized/3X/2/5/258cd9f96d7296dee27ed0597dbcaf0a3fc85a68_2_666x500.png, https://europe1.discourse-cdn.com/standard20/uploads/starknet1/original/3X/2/5/258cd9f96d7296dee27ed0597dbcaf0a3fc85a68.png 1.5x, https://europe1.discourse-cdn.com/standard20/uploads/starknet1/original/3X/2/5/258cd9f96d7296dee27ed0597dbcaf0a3fc85a68.png 2x\" data-dominant-color=\"C3D5E5\"></a></div><p></p>\n<p><strong>MACI on Starknet‚Äôs Governance</strong><br>\nDetailed Introduction to MACI in Starknet Governance</p>\n<p>Participants</p>\n<ul>\n<li>Voters: Only holders and delegates of L1 (Ethereum) STRK and L2 (Starknet) vSTRK have the right to vote, referred to as voters. Voters need to register with MACI before they can cast their votes.</li>\n<li>Trusted Coordinators: Coordinators help set up and execute MACI voting. They are responsible for deploying the MACI smart contracts, initiating the voting, tallying the final results, and completing the voting process by publishing the final results on-chain.</li>\n</ul>\n<p>Codebase</p>\n<ul>\n<li>Circom Circuits:</li>\n</ul>\n<p>MACI uses multiple circuits to ensure all off-chain computations are done correctly. These circuits generate zero-knowledge proofs (zk-SNARKs) that prove the votes were tallied correctly. Specifically, they enforce that coordinators correctly executed message processing and vote counting. These proofs can then be verified by validator smart contracts on Starknet.</p>\n<p>These zero-knowledge proof circuits are written in Circom 2.0. The main circuits include processMessages.circom and tallyVotes.circom, while other utility templates support the main circuits‚Äô proper functioning. These utilities include floating-point arithmetic, private key transformations, and Poseidon hash/encryption among others.</p>\n<ul>\n<li>Cairo Smart Contracts:</li>\n</ul>\n<p>The MACI smart contracts handle the on-chain aspects of the voting system (functionality and storage). They provide functions for deploying votes, registering voters, and accepting votes. They also store and manage on-chain data from transactions, such as encrypted votes. Finally, they verify zk-SNARK circuit proofs so that everyone can validate the voting results.</p>\n<p>The MACI smart contracts are written in Cairo.</p>\n<ul>\n<li>TypeScript Libraries:</li>\n</ul>\n<p>The TypeScript libraries manage the business logic between the smart contracts and circuit code. They offer various functionalities such as encryption tools, utilities, and a CLI for interacting with MACI (for operations like registration, voting, tallying, and generating proofs).</p>\n<p>Voting Process Workflow</p>\n<ul>\n<li>Registration:</li>\n</ul>\n<p>Before voting, voters must generate a MACI key pair and send their public key to the MACI smart contract. This MACI public key serves as their identity when voting. Voters can delegate their voting rights to themselves or another address, but the message must include a signature from the MACI public key. If the voter holds STRK, the voting address is an Ethereum address. If the voter holds vSTRK, the voting address is a Starknet address.</p>\n<ul>\n<li>Voting:</li>\n</ul>\n<p>Once registered, voters can cast their votes during the open voting period. Voters bundle variables such as the public key, voting options, and the number of votes into a ‚Äúcommand‚Äù and sign it with the MACI public key used during registration. The signed command is then encrypted along with the signature to form a ‚Äúmessage‚Äù. If the message is correctly signed by the MACI public key, it is valid and will be included in the final tally.</p>\n<p>Before sending the vote to Starknet, voters encrypt their votes using a shared key known only to themselves and the coordinator. This prevents anyone from viewing the vote content and allows the coordinator to decrypt the user‚Äôs vote for tallying.</p>\n<ul>\n<li>Processing Messages:</li>\n</ul>\n<p>Once voting ends, coordinators prove they have correctly decrypted each message and updated the state tree. The state tree records all valid votes, without retaining outdated messages overridden by new ones. For example, if a user first voted for option A and later changed their vote to option B, only the vote for option B is counted.</p>\n<p>Coordinators process messages in batches to ensure on-chain proofs do not exceed data limits. A zk-SNARK proof is then created to show that the state tree contains only valid messages, providing the state tree‚Äôs hash and zk-SNARK proof.</p>\n<p>These proofs are sent to the verifier contract on Starknet, which validates the proof. If the verifier contract returns true, it indicates the messages were processed correctly. Coordinators repeat this process until all messages are processed.</p>\n<ul>\n<li>Tallying Results:</li>\n</ul>\n<p>After all messages are processed, coordinators tally the votes of valid messages offline. A zk-SNARK proof is created to show the sum of votes in the state tree and provide the correct tally result‚Äôs hash and zk-SNARK proof.</p>\n<p>Coordinators send these proofs to the verifier contract to ensure their validity. Once verified, users can trust that the votes were tallied correctly. Anyone can see the final tally results and proofs, but individual votes remain confidential, ensuring votes were correctly processed and counted.</p>\n<ul>\n<li>Publishing Results:</li>\n</ul>\n<p>After coordinators process all messages, tally the results, and publish zk-SNARK proofs, the voting is finalized.</p>\n<p>At this point, the final voting results can be announced, and anyone can verify that the results were processed and calculated correctly by the coordinators.</p>\n<p><strong>Integration with Starknet‚Äôs Governance Platform</strong><br>\nStarknet currently hosts a governance voting website designed to facilitate transparent decision-making within the ecosystem. Integrating ZK Governance to the existing governance platform, is to add a privacy layer to Starknet‚Äôs governance, lowering the barrier to participation and reducing the potential for collusion.</p>\n<ul>\n<li>\n<p>Increased Participation: By enhancing privacy, ZK Governance will encourage more community members to engage in governance, leading to higher participation rates and more robust decision-making processes.</p>\n</li>\n<li>\n<p>Improved User Confidence: Addressing privacy concerns will make members feel more comfortable voting on sensitive issues without fear of exposure or backlash.</p>\n</li>\n<li>\n<p>Enhanced Governance Quality: A more engaged community means more representative decisions that better reflect the collective interests of stakeholders.</p>\n</li>\n</ul>\n<p>Key deliverables will be the followings:</p>\n<ol>\n<li>\n<p>An Anonymous Forum Section: Creating a forum section where users can discuss and deliberate without revealing their identities.</p>\n</li>\n<li>\n<p>Anti-Censorship/Anonymous Voting: Implementing a voting mechanism that ensures anonymity and resistance to censorship, promoting fair and free participations.</p>\n</li>\n</ol>\n<p><strong>Benefits to the Starknet Ecosystem</strong><br>\nImplementing Zero Knowledge Governance within the Starknet ecosystem will bring several advantages:</p>\n<ul>\n<li>\n<p>Higher Participation Rates: By ensuring voter privacy, ZK Governance can significantly boost participation rates in governance processes, leading to more democratic and representative outcomes.</p>\n</li>\n<li>\n<p>Stronger Community Engagement: Addressing privacy concerns will foster a more active and involved community, which is vital for the success of DAOs.</p>\n</li>\n<li>\n<p>Improved Decision-Making: With more members participating in governance, decisions will better reflect the community‚Äôs views and interests.</p>\n</li>\n<li>\n<p>Enhanced Security: Zero-knowledge proofs provide a secure mechanism for voting, protecting the integrity of the governance process and reducing the risk of manipulation.</p>\n</li>\n</ul>\n<p><strong>Conclusion</strong></p>\n<p>The Starknet ecosystem, with its leading DAOs like Realms and Ekubo, stands to greatly benefit from the adoption of Zero Knowledge Governance. By addressing privacy concerns and encouraging active participatio</p>\n<p>n, ZK Governance will strengthen the governance framework of DAOs and contribute to a more vibrant and engaged community. We invite the Starknet community to consider this proposal and explore the potential of ZK Governance to enhance the governance processes within their DAOs.</p>\n<p>Reference:</p>\n<ul>\n<li>vbuterin. Minimal anti-collusion infrastructure. <a href=\"https://ethresear.ch/t/minimal-anti-collusion-infrastructure/5413\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">Minimal anti-collusion infrastructure - Applications - Ethereum Research</a></li>\n<li>gubsheep and Sun Yi. ZK Identity: Why and How (Part 1) <a href=\"https://0xparc.org/blog/zk-id-1\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">0xPARC</a></li>\n<li>gubsheep and Sun Yi. ZK Identity: Why and How (Part 2) <a href=\"https://0xparc.org/blog/zk-id-2\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">0xPARC</a></li>\n<li>MACI. Minimal Anti-Collusion Infrastructure (MACI). <a href=\"https://maci.pse.dev/docs/introduction#credits\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">Introduction to MACI | MACI</a></li>\n</ul>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://community.starknet.io/t/zero-knowledge-governance-for-daos-on-starknet/114278\">Read full topic</a></p>","link":"https://community.starknet.io/t/zero-knowledge-governance-for-daos-on-starknet/114278","pubDate":"Tue, 02 Jul 2024 08:38:28 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"community.starknet.io-topic-114278"},"source":{"@url":"https://community.starknet.io/t/zero-knowledge-governance-for-daos-on-starknet/114278.rss","#text":"Zero Knowledge Governance for DAOs on Starknet"}},{"title":"Implimenting interfaces and libraries in a contract","dc:creator":"Sari2003","category":"Support","description":"<p>I have interfaces and libraries in different files and folders,<br>\nI want to use them in a contract in my project,<br>\nhow can I use it ? how do I import them to my contract file?</p>\n            <p><small>2 posts - 2 participants</small></p>\n            <p><a href=\"https://community.starknet.io/t/implimenting-interfaces-and-libraries-in-a-contract/114268\">Read full topic</a></p>","link":"https://community.starknet.io/t/implimenting-interfaces-and-libraries-in-a-contract/114268","pubDate":"Sun, 30 Jun 2024 11:34:52 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"community.starknet.io-topic-114268"},"source":{"@url":"https://community.starknet.io/t/implimenting-interfaces-and-libraries-in-a-contract/114268.rss","#text":"Implimenting interfaces and libraries in a contract"}},{"title":"SNIP-89: Safe Transfer for Fungible Tokens","dc:creator":"boyuanx","category":"SNIPs","description":"<p>Discussion for <a href=\"https://github.com/starknet-io/SNIPs/pull/89\" rel=\"noopener nofollow ugc\">https://github.com/starknet-io/SNIPs/pull/89</a></p>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://community.starknet.io/t/snip-89-safe-transfer-for-fungible-tokens/114254\">Read full topic</a></p>","link":"https://community.starknet.io/t/snip-89-safe-transfer-for-fungible-tokens/114254","pubDate":"Tue, 25 Jun 2024 21:20:06 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"community.starknet.io-topic-114254"},"source":{"@url":"https://community.starknet.io/t/snip-89-safe-transfer-for-fungible-tokens/114254.rss","#text":"SNIP-89: Safe Transfer for Fungible Tokens"}},{"title":"Report of a Scam/Copycat Project Receiving Seed Grant - Negligent Due Diligence Process & Use of Foundation Funds","dc:creator":"rd21bn","category":"üôè Help and Support","description":"<p>Hello Starknet Community,</p>\n<p>I am Winnal Kuo, founder and CEO of Ender Labs, creators of the Ender Protocol. Please visit our <a>Twitter</a> and <a href=\"https://enderprotocol.io\" rel=\"noopener nofollow ugc\">website</a> to learn more about our work.</p>\n<p>Today, I must bring to light a serious issue concerning a project by the name of Primis Protocol, a recent recipient of the Starknet Seed Grant Program‚Äîthat has engaged in the unauthorized use of our copyrighted material, including IP and licensed code. Despite repeated attempts to engage with the Seed Grant Program‚Äôs administration, referred to us by CEO Eli Ben-Sasson, we have faced consistent neglect and non-responsiveness.</p>\n<h3><a name=\"key-issues-1\" class=\"anchor\" href=\"https://community.starknet.io#key-issues-1\"></a>Key Issues</h3>\n<ol>\n<li>\n<p><strong>Unauthorized Use of IP and Licensed Code</strong>:</p>\n<ul>\n<li>Primis Protocol has been using our copyrighted material and licensed code without our consent. This constitutes a severe infringement of our intellectual property rights and poses significant security risks to public users who might interact with their platform.</li>\n</ul>\n</li>\n<li>\n<p><strong>Fraudulent Claims and Metrics</strong>:</p>\n<ul>\n<li>The project has deployed a non-functional testnet application using boilerplate templates and static, hard-coded values. They have been using these metrics to conduct a fraudulent token airdrop aimed at enriching themselves.</li>\n</ul>\n</li>\n<li>\n<p><strong>Misrepresentation of Team Credentials</strong>:</p>\n<ul>\n<li>The founder of Primis Protocol, Khoubaieb Blili, has claimed past affiliations with Meta, Blockfi, and Solana Labs, without evidence or references. Additionally, he falsely claimed to have worked at Ender Labs for two months. Our investigation, backed by substantial evidence, disproves these claims. His social media presence as a rapper and musician during the same timeframe casts further doubt on his supposed technical engagements.</li>\n</ul>\n</li>\n</ol>\n<h3><a name=\"evidence-and-attempts-to-resolve-2\" class=\"anchor\" href=\"https://community.starknet.io#evidence-and-attempts-to-resolve-2\"></a>Evidence and Attempts to Resolve</h3>\n<ul>\n<li>We have detailed video recordings and documentation of the IP and code theft.</li>\n<li>Despite numerous attempts to engage with the Seed Grant Program and its representatives, our concerns have been consistently ignored.</li>\n</ul>\n<h3><a name=\"whats-at-stake-3\" class=\"anchor\" href=\"https://community.starknet.io#whats-at-stake-3\"></a>What‚Äôs at Stake?</h3>\n<p>The unauthorized use of our code not only infringes on our intellectual property rights but poses a significant security risk to users. Primis Protocol has misrepresented itself through social media and testnet applications, displaying falsified metrics and functionality to attract unwarranted attention and potential investment. Their actions suggest a pattern of deceit, aimed at enriching themselves through fraudulent airdrops and promotions.</p>\n<h3><a name=\"the-issue-with-due-diligence-4\" class=\"anchor\" href=\"https://community.starknet.io#the-issue-with-due-diligence-4\"></a>The Issue with Due Diligence</h3>\n<p>Alarmingly, Primis Protocol received a Seed Grant of up to $25,000 with apparently no thorough vetting of its team or founders. The founder, Khoubaieb Blili, has falsely claimed past affiliations with Meta, Blockfi, and Solana Labs‚Äîa claim we have found to be entirely unsubstantiated. Mr. Blili previously applied for a position at Ender Labs, and after we identified several red flags, we chose not to proceed. Regrettably, he then exploited this interaction to misappropriate our work and initiate a competing, illegitimate project.</p>\n<h3><a name=\"further-concerns-about-integrity-5\" class=\"anchor\" href=\"https://community.starknet.io#further-concerns-about-integrity-5\"></a>Further Concerns About Integrity</h3>\n<p>Mr. Blili‚Äôs professional background raises significant concerns. He claims to have been associated with well-known entities such as Meta, Blockfi, and Solana Labs. However, we have not found any references or concrete evidence to substantiate these claims. This lack of verification, combined with his verified false claim of employment at Ender Labs‚Äîwhere he reported working for two months, which is unequivocally untrue‚Äîcasts serious doubts on the validity of his entire professional narrative. During the period he alleges to have been employed at these companies, his social media profiles prominently feature his activities as a rapper and musician, which contradicts the likelihood of simultaneous full-time employment at these companies.</p>\n<h3><a name=\"technical-inadequacies-of-primis-protocols-testnet-6\" class=\"anchor\" href=\"https://community.starknet.io#technical-inadequacies-of-primis-protocols-testnet-6\"></a>Technical Inadequacies of Primis Protocol‚Äôs Testnet</h3>\n<p>The concerns extend beyond just qualifications; they manifest starkly in the output of their projects. Primis Protocol has deployed a testnet application that is ostensibly non-functional. The application uses boilerplate templates and static, hard-coded values that simulate functionality which in actuality does not exist. This completely fake application lacks critical features that would be present in a genuinely developed protocol, such as the capability to claim rewards from bonds or stake these rewards. Since we are the real and original developers of the project and application, we can pinpoint exact and core functionalities that are completely missing, and they are just faking it by showing an incomplete product in hopes that nobody notices.</p>\n<h3><a name=\"negligent-due-diligence-process-use-of-foundation-funds-7\" class=\"anchor\" href=\"https://community.starknet.io#negligent-due-diligence-process-use-of-foundation-funds-7\"></a>Negligent Due Diligence Process &amp; Use of Foundation Funds</h3>\n<p>A critical aspect of this situation that must be underscored is the apparent negligence by the foundation overseeing the Seed Grant Program. The fact that Primis Protocol was able to secure up to $25,000 without adequate background checks on the team or the viability of their project is alarming. This lapse has not only enabled the misappropriation and misuse of intellectual property but also represents a serious mismanagement of foundation funds, which should be allocated to foster genuine innovation and development in the blockchain space.</p>\n<p>The foundation‚Äôs subsequent non-responsiveness to our repeated attempts to address these issues further exacerbates our concerns, suggesting a dismissive approach to accountability. This lack of engagement and oversight raises profound questions about the foundation‚Äôs commitment to upholding the standards and values expected within the Starknet community. It is imperative that the foundation re-evaluates its due diligence processes to prevent similar occurrences in the future and to restore trust among developers and investors who rely on its governance and integrity.</p>\n<h3><a name=\"call-to-action-8\" class=\"anchor\" href=\"https://community.starknet.io#call-to-action-8\"></a>Call to Action</h3>\n<ol>\n<li>\n<p><strong>Immediate Investigation</strong>:</p>\n<ul>\n<li>We urge the foundation to conduct a thorough investigation into Primis Protocol‚Äôs activities, their unauthorized use of Ender Labs‚Äô IP, and Mr. Blili‚Äôs background.</li>\n</ul>\n</li>\n<li>\n<p><strong>Revocation of Seed Grant</strong>:</p>\n<ul>\n<li>Given the fraudulent foundation of their project, we request that the Seed Grant awarded to Primis Protocol be revoked.</li>\n</ul>\n</li>\n<li>\n<p><strong>Public Accountability</strong>:</p>\n<ul>\n<li>We call upon the foundation to address this issue publicly, ensuring transparency and accountability within the community.</li>\n</ul>\n</li>\n<li>\n<p><strong>Review and Improve Due Diligence Processes</strong>:</p>\n<ul>\n<li>We strongly recommend that the foundation review and improve its due diligence processes to prevent similar incidents from occurring in the future.</li>\n</ul>\n</li>\n</ol>\n<p>This behavior is not only unethical but also detrimental to the integrity and safety of the blockchain community. We have gathered substantial evidence, including video recordings and detailed documentation of the infringed works, and are prepared to pursue all necessary legal avenues to address this infringement.</p>\n<p>We urge the community and the administrators of the Seed Grant Program to take immediate action against such fraudulent practices to prevent any further harm to unsuspecting users and investors. We are ready to provide all necessary evidence to support our claims and assist in any investigations.</p>\n<h3><a name=\"commitment-to-legal-action-9\" class=\"anchor\" href=\"https://community.starknet.io#commitment-to-legal-action-9\"></a>Commitment to Legal Action</h3>\n<p>Ender Labs is prepared to pursue legal action against Mr. Khoubaieb Blili and Primis Protocol for their unauthorized use of our intellectual property, misrepresentation, and fraud.</p>\n<p>We hope that the foundation will take immediate action to address these serious concerns and uphold the integrity of our community.</p>\n<p>Thank you for your attention to this critical matter. We are ready to provide all necessary evidence and cooperate fully to resolve this issue. We stand ready to defend our work and ensure the blockchain ecosystem remains a safe and honest environment for all.</p>\n<p>Sincerely,<br>\nWinnal Kuo<br>\nCEO, Ender Labs</p>\n            <p><small>2 posts - 2 participants</small></p>\n            <p><a href=\"https://community.starknet.io/t/report-of-a-scam-copycat-project-receiving-seed-grant-negligent-due-diligence-process-use-of-foundation-funds/114240\">Read full topic</a></p>","link":"https://community.starknet.io/t/report-of-a-scam-copycat-project-receiving-seed-grant-negligent-due-diligence-process-use-of-foundation-funds/114240","pubDate":"Fri, 21 Jun 2024 09:47:46 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"community.starknet.io-topic-114240"},"source":{"@url":"https://community.starknet.io/t/report-of-a-scam-copycat-project-receiving-seed-grant-negligent-due-diligence-process-use-of-foundation-funds/114240.rss","#text":"Report of a Scam/Copycat Project Receiving Seed Grant - Negligent Due Diligence Process & Use of Foundation Funds"}},{"title":"Token Burn Mechanism for STRK","dc:creator":"kubatura5","category":"ü§∑‚Äç‚ôÄÔ∏è All-Purpose Hangout","description":"<p>To maintain the value and scarcity of STRK tokens, we propose to implemen a token burn mechanism.</p>\n<p>Unclaimed STRK Tokens: Any STRK tokens from that remain unclaimed for Starknet Provisions Program will be permanently burned. This reduces the total supply of STRK tokens, thereby increasing their value for existing holders.</p>\n<p>Fee Payment Burn: A portion of the STRK tokens used for transaction fees will be automatically burned. This continuous burning process decreases the circulating supply, ensuring a deflationary effect on the token economy.</p>\n<p>By implementing these burn mechanisms, we aim to enhance the value and stability of the STRK token ecosystem.</p>\n            <p><small>10 posts - 5 participants</small></p>\n            <p><a href=\"https://community.starknet.io/t/token-burn-mechanism-for-strk/114233\">Read full topic</a></p>","link":"https://community.starknet.io/t/token-burn-mechanism-for-strk/114233","pubDate":"Thu, 20 Jun 2024 01:05:48 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"community.starknet.io-topic-114233"},"source":{"@url":"https://community.starknet.io/t/token-burn-mechanism-for-strk/114233.rss","#text":"Token Burn Mechanism for STRK"}},{"title":"Starknet v0.13.2 pre-release notes","dc:creator":"FeedTheFed","category":"üÜô Versions Upgrade","description":"<p><code>Sepolia Testnet</code> ‚Äì August 5<br>\n<code>Mainnet</code> ‚Äì August 26</p>\n<h1><a name=\"conceptual-changes-1\" class=\"anchor\" href=\"https://community.starknet.io#conceptual-changes-1\"></a>Conceptual Changes</h1>\n<p>This version focuses on performance improvements. In addition, we make some necessary adjustments in order to prepare for the transition to a Starknet p2p network between nodes that will happen in a later version. We proceed to describe the version highlights.</p>\n<h2><a name=\"sequencer-parallelization-2\" class=\"anchor\" href=\"https://community.starknet.io#sequencer-parallelization-2\"></a>Sequencer parallelization</h2>\n<p>We‚Äôre reintroducing optimistic parallelization to the new rust-based Starknet sequencer. The gist of optimistic parallelization is to execute transactions in parallel as long as we don‚Äôt find a dependency between them. You can read more about optimistic parallelization <a href=\"https://community.starknet.io/t/optimistic-parallelization-revived/114121#optimistic-parallelization-revived-1\">here</a>. The improvement factor obviously depends on the nature of the common txs on the network.</p>\n<h2><a name=\"starknet-applicative-recursion-3\" class=\"anchor\" href=\"https://community.starknet.io#starknet-applicative-recursion-3\"></a>Starknet applicative recursion</h2>\n<h3><a name=\"what-do-we-mean-by-applicative-recursion-4\" class=\"anchor\" href=\"https://community.starknet.io#what-do-we-mean-by-applicative-recursion-4\"></a>What do we mean by ‚Äúapplicative recursion‚Äù</h3>\n<p>SHARP works in the resolution of proof trains, each train consists of a tree whose leaves are jobs, each corresponding to a Cairo program that needs proving (in the case of Starknet, this is the Starknet OS). The final proof that reaches L1 is a recursive proof for all the leaves in the tree. Unlike verification of the proof on L1 which is shared among all the jobs in the train, there is a fixed cost per job for e.g. recording the associated fact, or publishing data which is done separately for each job. So far, each Starknet block was sent as a separate job. This limited our ability to squash state diffs over several blocks, and prevented us from having a short fixed-time block interval (since in the current architecture, each block publishes one blob, so short enough block times will lead to severe blob under-utilization). Even more importantly, this meant a high fixed cost per block (fact recording on-chain and state-update on the Core contract).</p>\n<p>To overcome the above issues, we want to have only one fact recorded on-chain, attesting to many Starknet blocks. We refer to this feature as ‚ÄúStarknet applicative recursion‚Äù. The idea is, to generate the recursive proof on the Starknet side, and only send one final job for SHARP. For each block, we‚Äôll ask SHARP for a proof of that block, but without the recording on-chain part. Given the proofs, we‚Äôll construct a final recursive job that attests to all the blocks, and squashes all the state diffs between them.</p>\n<h3><a name=\"what-actually-changes-5\" class=\"anchor\" href=\"https://community.starknet.io#what-actually-changes-5\"></a>What actually changes</h3>\n<p>The <a href=\"https://etherscan.io/address/0x47312450b3ac8b5b8e247a6bb6d523e7605bdb60\">L1 verifier contract</a> will change. Instead of verifying the execution of the <a href=\"https://github.com/starkware-libs/cairo-lang/tree/master/src/starkware/cairo/bootloaders\">bootloader program</a>, it will verify a new program, called the ‚Äúapplicative bootloader‚Äù. The applicative bootloader relies on the existence of a ‚Äúbase program‚Äù and an aggregator program.</p>\n<p>To register a new ‚Äúapplicative fact‚Äù on-chain, the verifier contract must see a proof for the successful execution of the applicative bootloader with some base program P, and an aggregator program for P. The way the applicative bootloader works, is to verify (potentially several) proofs of the base program execution, and then use the outputs of the base program as input to the aggregator program. In the case of Starknet, the base program is the Starknet OS, and the aggregator program is a new cairo program that squashes the state diffs of several blocks. This way, we can take individual proofs of OS executions for some block range, and end up with a single program whose valid execution attests to the validity of all blocks within that range, and whose output is the squashed state diff. On Ethereum, the Starknet core contract will verify that an ‚Äúapplicative fact‚Äù was registered on chain, with the expected aggregator program, and that the base program hash (outputted by the aggregator) is that of the Starknet OS.</p>\n<p>We summarize the technical changes induced by the above here:</p>\n<ul>\n<li>The Starknet Core contract now knows of both the aggregator program hash and the OS program hash.</li>\n<li>The <a href=\"https://github.com/starkware-libs/cairo-lang/blob/efa9648f57568aad8f8a13fbf027d2de7c63c2c0/src/starkware/starknet/solidity/Starknet.sol#L36\">LogStateUpdate</a> event for the Starknet core contract will be emitted once for every sequence of blocks, rather than for every block.</li>\n<li>The data published on L1 is now the output of the aggregator. While the format of the <a href=\"https://docs.starknet.io/architecture-and-concepts/network-architecture/data-availability/#v0.11.0_format\">state diffs</a>, the <a href=\"https://github.com/starkware-libs/cairo-lang/blob/efa9648f57568aad8f8a13fbf027d2de7c63c2c0/src/starkware/starknet/core/os/output.cairo#L25\">OsOutputHeader</a> changes. We‚Äôre adding four new fields to the header: <code>prev_block_number</code>, <code>prev_block_hash</code>, <code>os_program_hash</code>, <code>full_output</code>. This means that if you‚Äôre decoding Starknet onchain data from blobs, then you‚Äôll need to start decoding statediffs after the first 10 felts rather than after the first 6.</li>\n</ul>\n<p>The new Cairo programs, namely the aggregator and applicative bootloader, will be published as part of the new <a href=\"https://github.com/starkware-libs/cairo-lang\">cairo-lang</a> release.</p>\n<h2><a name=\"new-block-hash-definition-6\" class=\"anchor\" href=\"https://community.starknet.io#new-block-hash-definition-6\"></a>New block hash definition</h2>\n<p>To prepare for the future transition to p2p communication (as opposed to relying on the centralized sequencer block publications), we‚Äôre making sure that the block hash structure is robust in the sense that it allows nodes to verify all the data given by peers without being susceptible to DOS.</p>\n<p>This change will affect full nodes, and will not be seen externally (past block hashes naturally remain unchanged). You can find a reference implementation to the new block hash calculation in the <a href=\"https://github.com/starkware-libs/starknet-api/tree/15219992b54b170dcf80fa5cceab56847ea2f7f0/src/block_hash\">starknet-api</a> crate.</p>\n<h1><a name=\"api-changes-7\" class=\"anchor\" href=\"https://community.starknet.io#api-changes-7\"></a>API Changes</h1>\n<h2><a name=\"fgw-requestresponse-8\" class=\"anchor\" href=\"https://community.starknet.io#fgw-requestresponse-8\"></a>FGW request/response</h2>\n<ol>\n<li>Block hash definition will change as discussed above, this will affect all endpoints returning the block hash (the response structure remains the same)</li>\n<li>Fix bug where state diff hash used for signatures is affected by 0 length state diff.</li>\n<li>Receipts will get a new total_gas_consumed property, that will only appear in new transactions after 0.13.2. This is an object that includes l1_gas and l1_data_gas. These are the numbers used for the eventual fee computation, and for the receipt hash during the block hash calculation.</li>\n<li>Three new builtins can appear under the builtin_instance_counter property of execution_resources under transaction receipts (which are accessible through the get_block endpoint). The new builtins are <code>add_mod</code>, <code>mul_mod</code>, and <code>range_check96</code>.</li>\n</ol>\n<p>The source of truth for the feeder gateway response is <a href=\"https://github.com/starkware-libs/cairo-lang/blob/v0.13.1a0/src/starkware/starknet/services/api/feeder_gateway/response_objects.py\">FGW response objects</a>.</p>\n<h2><a name=\"stopping-support-for-tracing-on-the-feeder-gateway-on-0132-9\" class=\"anchor\" href=\"https://community.starknet.io#stopping-support-for-tracing-on-the-feeder-gateway-on-0132-9\"></a>Stopping support for tracing on the feeder gateway on 0.13.2</h2>\n<p>The following tracing related methods will not be available post 0.13.2:</p>\n<ul>\n<li>get_block_traces</li>\n<li>get_transaction_trace</li>\n</ul>\n<p>To clarify, these methods will continue to be supported for blocks pre 0.13.2.</p>\n<h2><a name=\"json-rpc-10\" class=\"anchor\" href=\"https://community.starknet.io#json-rpc-10\"></a>JSON RPC</h2>\n<p>No change in 0.13.2</p>\n<p>v0.8.0 will be released alongside Starknet v0.13.3, at which point all support for versions &lt; 0.7.0 will stop.</p>\n<h1><a name=\"cairo-11\" class=\"anchor\" href=\"https://community.starknet.io#cairo-11\"></a>Cairo</h1>\n<p>A new compiler version will be released for 0.13.2, Cairo 2.7.0. This includes a Sierra upgrade to v1.6.0, i.e. contracts compiled with the new compiled will only be accepted on Starknet v0.13.2 onwards.</p>\n<p>The Starknet-related features that will be added in this Cairo version include:</p>\n<ul>\n<li>SHA256 syscall - syscall for computing sha256 on an arbitrary length input\n<ul>\n<li><a href=\"https://github.com/starkware-libs/cairo/blob/f5ac2d1d24ae0a626e9925db0c564bd0c4fea433/corelib/src/sha256.cairo#L24\">High level code</a> for using sha256</li>\n<li><a href=\"https://github.com/starkware-libs/blockifier/blob/b22fb076a7db5e0fcdd2048a6fb579b0b1d25561/crates/blockifier/resources/versioned_constants.json#L284\">Syscall cost</a> - the dominant part of the syscall is ~1.1k bitwise builtin applications which today costs ~180 L1 gas (the 2k steps are negligible in comparison). The syscall is applied once for ~14 u32.</li>\n</ul>\n</li>\n<li>Circuit builtin - the new compiler version will introduce a way to define ad-hoc algebraic circuits in Cairo. Circuits use the new mulmod and addmod builtins under the hood.\n<ul>\n<li>Example usage can be found in <a href=\"https://github.com/starkware-libs/cairo/blob/39095a2a717b5bf3a76c813186f0a9cd0e087948/corelib/src/test/circuit_test.cairo#L24\">circuit_test.cairo</a></li>\n</ul>\n</li>\n</ul>\n<h1><a name=\"execution-changes-12\" class=\"anchor\" href=\"https://community.starknet.io#execution-changes-12\"></a>Execution Changes</h1>\n<h2><a name=\"blockifier-13\" class=\"anchor\" href=\"https://community.starknet.io#blockifier-13\"></a>Blockifier</h2>\n<ol>\n<li>\n<p>Parallelization infrastructure: we‚Äôll add separate modules to the blockifier that will be responsible for running a block with optimistic parallelization. The sequential flow remains mostly be untouched by parallelization. The entry point to the blockifier‚Äôs concurrency handling is <a href=\"https://github.com/starkware-libs/blockifier/blob/df2799eafda4f575e71d63c839d14f5a38ca911d/crates/blockifier/src/concurrency.rs#L1\">concurrency.rs</a>. You can find a short description of the new design in the <a href=\"https://community.starknet.io/t/optimistic-parallelization-revived/114121\">community forum post</a>.</p>\n</li>\n<li>\n<p>VM upgrade: we‚Äôll bump the vm version v1.0.0 (atm we‚Äôre on <a href=\"https://github.com/lambdaclass/cairo-vm/releases/tag/v1.0.0-rc3\">v1.0.0-rc3</a>). This version uses the new lambdaworks felt. The felt change will propagate to the blockifier, compiler and nodes.</p>\n</li>\n<li>\n<p>Errors prettifying: currently, error strings are not very informative and have a lot of redundant data with no information that comes from the back and forth between the blockifier and the VM. Execution errors are becoming more <a href=\"https://github.com/starkware-libs/blockifier/blob/8417325e6990af64e93253b1f76cb70611516cd2/crates/blockifier/src/execution/syscalls/hint_processor.rs#L69\">structured</a>, which will be the basis for better error handling in the next rpc version, resulting in nice error displays by wallets.</p>\n</li>\n</ol>\n<p>Old error template example:</p>\n<pre><code class=\"lang-auto\">\"Transaction execution has failed: Error in the called contract \\\n                 ({account_address_felt}):\nError at pc=0:797:\nGot an exception while executing a hint.\nCairo traceback (most recent call last):\nUnknown location (pc=0:{account_pc_location})\n\nError in the called contract ({address_felt}):\nError at pc=0:8010:\nGot an exception while executing a hint.\nCairo traceback (most recent call last):\nUnknown location (pc=0:{pc_location})\n\nError in the called contract ({address_felt}):\nError at pc=0:{expected_pc}:\nGot an exception while executing a hint.\nCairo traceback (most recent call last):\nUnknown location (pc=0:{pc_location})\n\nError in the called contract ({address_felt}):\nExecution failed. Failure reason: {expected_error}.\n\n</code></pre>\n<p>New error template example:</p>\n<pre><code class=\"lang-auto\">Transaction execution has failed:\n0: Error in the called contract (contract address: {account_address_felt}, selector: \\\n                 {execute_selector_felt}):\nError at pc=0:797:\nCairo traceback (most recent call last):\nUnknown location (pc=0:{account_pc_location})\n\n1: Error in the called contract (contract address: {address_felt}, selector: \\\n                 {invoke_call_chain_selector_felt}):\nError at pc=0:8010:\n</code></pre>\n<h2><a name=\"limits-changes-14\" class=\"anchor\" href=\"https://community.starknet.io#limits-changes-14\"></a>Limits changes</h2>\n<ul>\n<li>\n<p>The maximal number of steps in a single <code>INVOKE</code> transaction increases to 10m.</p>\n</li>\n<li>\n<p>The maximal calldata length increases to 5k felts</p>\n</li>\n</ul>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://community.starknet.io/t/starknet-v0-13-2-pre-release-notes/114223\">Read full topic</a></p>","link":"https://community.starknet.io/t/starknet-v0-13-2-pre-release-notes/114223","pubDate":"Tue, 18 Jun 2024 07:35:27 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"community.starknet.io-topic-114223"},"source":{"@url":"https://community.starknet.io/t/starknet-v0-13-2-pre-release-notes/114223.rss","#text":"Starknet v0.13.2 pre-release notes"}},{"title":"Starknet v0.13.2 and Roadmap Summer Update","dc:creator":"ilia","category":"üÜô Versions Upgrade","description":"<p>In February, we shared a tentative <a href=\"https://community.starknet.io/t/starknet-2024-roadmap-plan-of-intent/113006\">roadmap for 2024</a> ‚Äì a plan of intent.</p>\n<p>Over the past months, we have collected extensive feedback from builders to guide and evolve our roadmap.</p>\n<ul>\n<li>By all accounts, the two original goals of <span class=\"d-wrap\" data-wrap=\"color\" data-color=\"green\" data-bgcolor=\"#\">fee reduction</span> and <span class=\"d-wrap\" data-wrap=\"color\" data-color=\"purple\" data-bgcolor=\"#\">performance</span> are sufficiently fulfilled since <a href=\"https://community.starknet.io/t/starknet-v0-13-1-eip4844-support-more-fee-reductions-stability-quality-of-life/112951\">v0.13.1</a>: transaction fees are extremely low, and Starknet can already sustain over 100 erc-20 transfers a second ‚Äì more than enough to satisfy current demand.</li>\n<li>In light of the above, it‚Äôs time for a new Sheriff in town: <span class=\"d-wrap\" data-wrap=\"color\" data-color=\"red\" data-bgcolor=\"#\">UX &amp; devX</span>! Instead of diving into the meta of defining what exactly this means, let‚Äôs move to some examples with the beloved table, and elaborate afterward.</li>\n</ul>\n<div class=\"md-table\">\n<table>\n<thead>\n<tr>\n<th></th>\n<th>Wen mainnet</th>\n<th>Must-have content</th>\n<th>Effect</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>v0.13.2</td>\n<td>August</td>\n<td><a href=\"https://community.starknet.io/t/optimistic-parallelization-revived/114121\">Parallel execution</a>, <a href=\"https://community.starknet.io/t/upcoming-feature-starknet-applicative-recursion/113868\">SNAR &amp; block-packing</a> aiming at 2 sec confirmation time and reduced block time, <code>execute</code> limit will be increased to ‚â•10M steps</td>\n<td><span class=\"d-wrap\" data-wrap=\"color\" data-color=\"purple\" data-bgcolor=\"#\">Performance</span>, <span class=\"d-wrap\" data-wrap=\"color\" data-color=\"red\" data-bgcolor=\"#\">UX &amp; devX</span></td>\n</tr>\n<tr>\n<td>v0.13.3</td>\n<td>October/November</td>\n<td>Cairo-native (Sierra ‚Üí MLIR) &amp; L2 gas; additional feature <span class=\"d-wrap\" data-wrap=\"color\" data-color=\"gray\" data-bgcolor=\"#\">candidates</span>: nonce channels, try/catch for function call failures</td>\n<td><span class=\"d-wrap\" data-wrap=\"color\" data-color=\"purple\" data-bgcolor=\"#\">Performance</span>, <span class=\"d-wrap\" data-wrap=\"color\" data-color=\"red\" data-bgcolor=\"#\">UX &amp; devX</span></td>\n</tr>\n<tr>\n<td>v0.14.0</td>\n<td>January/February</td>\n<td><span class=\"d-wrap\" data-wrap=\"color\" data-color=\"gray\" data-bgcolor=\"#\">Candidates</span>: Volition, <a href=\"https://ethresear.ch/t/zkthreads-a-canonical-zk-sharding-framework-for-dapps/19619\">zkThreads</a>, mempool, protocol-level paymaster</td>\n<td><span class=\"d-wrap\" data-wrap=\"color\" data-color=\"yellow\" data-bgcolor=\"#\">TBD</span></td>\n</tr>\n</tbody>\n</table>\n</div><p>Now some more words.</p>\n<hr>\n<h1><a name=\"v0132-1\" class=\"anchor\" href=\"https://community.starknet.io#v0132-1\"></a>v0.13.2</h1>\n<p><em>You send a transaction. You wait for confirmation. You are sad. You don‚Äôt want to wait.</em></p>\n<p>Alrighty then! Thanks to <a href=\"https://community.starknet.io/t/upcoming-feature-starknet-applicative-recursion/113868\">applicative recursion on the SHARP front and its complementary Starknet feature ‚Äì <em>block-packing</em></a> ‚Äì v0.13.2 will see reduced block times without increased L1 costs. We aim to reduce block-times until the confirmation time of most transactions averages at around 2 seconds. We <em>expect</em> a block time or somewhere between 20-60 secs. This isn‚Äôt a hard commitment yet, but it‚Äôs definitely the goal: the leap is delicate from the engineering PoV and we want to test everything is stable before taking blood oaths.</p>\n<p><em>‚ÄúAh, but wait‚Äù</em>, you say, <em>‚ÄúWasn‚Äôt this a candidate feature for v0.14.0? How could this be?‚Äù</em><br>\n</p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://europe1.discourse-cdn.com/standard20/uploads/starknet1/original/3X/4/8/48906b7af14e4893b99e98891861abe28f938e5d.jpeg\" data-download-href=\"/uploads/short-url/alVNlGaHoxDMYSAMbjJKzg494iV.jpeg?dl=1\" title=\"image\"><img src=\"https://europe1.discourse-cdn.com/standard20/uploads/starknet1/optimized/3X/4/8/48906b7af14e4893b99e98891861abe28f938e5d_2_333x250.jpeg\" alt=\"image\" data-base62-sha1=\"alVNlGaHoxDMYSAMbjJKzg494iV\" width=\"333\" height=\"250\" srcset=\"https://europe1.discourse-cdn.com/standard20/uploads/starknet1/optimized/3X/4/8/48906b7af14e4893b99e98891861abe28f938e5d_2_333x250.jpeg, https://europe1.discourse-cdn.com/standard20/uploads/starknet1/optimized/3X/4/8/48906b7af14e4893b99e98891861abe28f938e5d_2_499x375.jpeg 1.5x, https://europe1.discourse-cdn.com/standard20/uploads/starknet1/optimized/3X/4/8/48906b7af14e4893b99e98891861abe28f938e5d_2_666x500.jpeg 2x\" data-dominant-color=\"201F5A\"></a></div><br>\nWell‚Ä¶<br>\n<img src=\"https://europe1.discourse-cdn.com/standard20/uploads/starknet1/original/3X/0/4/049974ab3dd4de2d92cbb968d3e035564fdd59c1.gif\" alt=\"Sopranos Christopher Moltisanti GIF - Sopranos Christopher Moltisanti GIFs|832.9999999999999x751.0381526104417\" data-base62-sha1=\"EGGBV1FmvRkJH3zh2FFHbrxiVz\" width=\"498\" height=\"449\" class=\"animated\"><p></p>\n<p>The effort to improve confirmation time via reduction of block time will further be complemented by <a href=\"https://community.starknet.io/t/optimistic-parallelization-revived/114121\">parallel execution</a>! Increased throughput means execution will be even faster, driving down confirmation times.</p>\n<p>Before moving on to v0.13.3, we should also mention some great work behind the scenes on key aspects of the network, including improvements to streamline work on P2P, and major optimizations to the committer ‚Äì the service that computes a commitment to the state. These may not sound like chad features, but they contribute a lot to Starknet‚Äôs eternally sharpening jawline.</p>\n<hr>\n<h1><a name=\"v0133-2\" class=\"anchor\" href=\"https://community.starknet.io#v0133-2\"></a>v0.13.3</h1>\n<p><em>Currently</em>, the only must-have content is Cairo-native. To copy from the <a href=\"https://community.starknet.io/t/starknet-2024-roadmap-plan-of-intent/113006\">first 2024 roadmap post</a>:</p>\n<blockquote>\n<p>Starknet v0.13.3 will feature a joint effort with <a href=\"https://www.nethermind.io/\">Nethermind </a> to integrate the state-of-the-art <a href=\"https://github.com/lambdaclass/cairo_native\">Cairo-native </a> project by <a href=\"https://lambdaclass.com/\">LambdaClass </a> into the sequencer. This is some <s>next level @#$%</s> truly state-of-the-art technology. Here‚Äôs the story. Currently, the sequencer executes transactions using the <a href=\"https://github.com/lambdaclass/cairo-vm\">Cairo VM </a> (efficiently implemented in Rust by LambdaClass too). The VM effectively emulates another machine, which begs the question: can we circumvent any emulation to improve performance? Turns out the answer is ‚Äúvery very yes‚Äù if you‚Äôre blessed with a disturbing amount of brainpower. Enter Cairo-native, which lets the sequencer completely bypass the VM and execute native CPU opcodes. Dark magic, you say? Correct! Behind the scenes, Cairo-native is a Sierra‚ÜíMLIR compiler; the sequencer will use it to compile declared Cairo classes to native bytecode, and run the latter during transaction execution.</p>\n</blockquote>\n<p>The only addition to make now about Cairo-native is to emphasize that faster execution will further improve confirmation times. Alongside it, we mention some more feature ideas that are on the cards for v0.13.3 but yet to be decided.</p>\n<hr>\n<h1><a name=\"v0140-3\" class=\"anchor\" href=\"https://community.starknet.io#v0140-3\"></a>v0.14.0</h1>\n<p>Everything here is TBD. It‚Äôs too early to decide now.</p>\n<h1><a name=\"summary-4\" class=\"anchor\" href=\"https://community.starknet.io#summary-4\"></a>Summary</h1>\n<p>Huge improvements to confirmation times are coming in v0.13.2, and more improvements to UX and devX are on the menu. Stay tuned and contribute! Got questions? Ask! Got ideas? Suggest! We would love feature ideas from you folks! It can be a cool use-case, a concrete feature, or a vague fantasy. SNIPs are especially welcome! <img src=\"https://emoji.discourse-cdn.com/twitter/slight_smile.png?v=12\" title=\":slight_smile:\" class=\"emoji\" alt=\":slight_smile:\" loading=\"lazy\" width=\"20\" height=\"20\"></p>\n<p>Cheerio!</p>\n            <p><small>10 posts - 4 participants</small></p>\n            <p><a href=\"https://community.starknet.io/t/starknet-v0-13-2-and-roadmap-summer-update/114221\">Read full topic</a></p>","link":"https://community.starknet.io/t/starknet-v0-13-2-and-roadmap-summer-update/114221","pubDate":"Mon, 17 Jun 2024 21:20:20 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"community.starknet.io-topic-114221"},"source":{"@url":"https://community.starknet.io/t/starknet-v0-13-2-and-roadmap-summer-update/114221.rss","#text":"Starknet v0.13.2 and Roadmap Summer Update"}},{"title":"SNIP 13 - Index `Transfer` and `Approval` events in ERC20s","dc:creator":"NatanSW","category":"SNIPs","description":"<p><strong>snip</strong>: 13<br>\n<strong>Title:</strong> Index <code>Transfer</code> and <code>Approval</code> events in ERC20s<br>\n<strong>Author:</strong> <a class=\"mention\" href=\"https://community.starknet.io/u/natansw\">@NatanSW</a><br>\nStatus: Draft<br>\nType: Standards Track<br>\nCreation date: May 5, 2024<br>\nGithub link: <a href=\"https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-13.md\">https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-13.md</a></p>\n<hr>\n<h2><a name=\"abstract-1\" class=\"anchor\" href=\"https://community.starknet.io#abstract-1\"></a>Abstract</h2>\n<p>Events in Starknet consist of two felt arrays, <code>keys</code> and <code>data</code>, the former is analogous to topics on Ethereum. Similarly to Ethereum, Starknet‚Äôs json-rpc allows you to filter over event keys via the <code>starknet_getEvents</code> method.</p>\n<p>In this SNIP we suggest updating StarkGate‚Äôs ERC20s (including ETH, STRK, USDC <a href=\"https://github.com/starknet-io/starknet-addresses/blob/master/bridged_tokens/mainnet.json\">and others</a>) to index more fields in the <code>Transfer</code> and <code>Approval</code> events in order to allow filtration over the sender or receiver.</p>\n<h2><a name=\"motivation-2\" class=\"anchor\" href=\"https://community.starknet.io#motivation-2\"></a>Motivation</h2>\n<p>Dapps, for example exchanges that operate on Starknet, need to track transfers from &amp; to specific addresses. At the moment, Starknet‚Äôs json-rpc only allows receiving all <code>Transfer</code> or <code>Approval</code> events from a given ERC20 in a particular block range. This SNIP would enable filtering those events, allowing filteration by <code>from</code> or <code>to</code> in <code>Transfer</code> events and by <code>owner</code> or <code>spender</code> in <code>Approval</code> events.</p>\n<p>This is already the case on Ethereum and other EVM chains. Due to limitations in early iterations of Cairo, events had only one key corresponding to the event name. This lead to only being able to filter over all transfer events, which is far from ideal.</p>\n<h2><a name=\"backward-compatability-3\" class=\"anchor\" href=\"https://community.starknet.io#backward-compatability-3\"></a>Backward Compatability</h2>\n<p><strong>This change is NOT backward compatible</strong>. All DAPPs listenting to ERC20 transfer and approval events will have to adjust their events decoding, in order to look for fields in the <code>keys</code> array instead of in the <code>data</code> array.</p>\n<h2><a name=\"specification-4\" class=\"anchor\" href=\"https://community.starknet.io#specification-4\"></a>Specification</h2>\n<p>Starknet‚Äôs json-rpc <a href=\"https://github.com/starkware-libs/starknet-specs/blob/76bdde23c7dae370a3340e40f7ca2ef2520e75b9/api/starknet_api_openrpc.json#L798\"><code>starknet_getEvents</code> method</a>, takes an <code>EventFilter</code> object, which contains a nested list of keys to be matched against. For example, if the user sent an event filter containing <span class=\"math\">\\big[[k_1, k_2], [\\;], [k_3]\\big]</span>, then the node should return events whose first key is <span class=\"math\">k_1</span> or <span class=\"math\">k_2</span>, and the third key is <span class=\"math\">k_3</span>, and the second key is unconstrained and can take any value. This functionality is supported by variuous Starknet SDKs, for example, see the following <a href=\"https://www.starknetjs.com/docs/guides/events#without-transaction-hash\">starknet.js tutorial</a> to see how to filter events.</p>\n<p>Currently, these are the <code>Transfer</code> and <code>Approval</code> events in all StarkGate‚Äôs ERC20s:</p>\n<pre data-code-wrap=\"rust\"><code class=\"lang-rust\">    /// Emitted when tokens are moved from address `from` to address `to`.\n    #[derive(Copy, Drop, PartialEq, starknet::Event)]\n    struct Transfer {\n        // #[key] - Not indexed, to maintain backward compatibility.\n        from: ContractAddress,\n        // #[key] - Not indexed, to maintain backward compatibility.\n        to: ContractAddress,\n        value: u256\n    }\n\n    /// Emitted when the allowance of a `spender` for an `owner` is set by a call\n    /// to [approve](approve). `value` is the new allowance.\n    #[derive(Copy, Drop, PartialEq, starknet::Event)]\n    struct Approval {\n        // #[key] - Not indexed, to maintain backward compatibility.\n        owner: ContractAddress,\n        // #[key] - Not indexed, to maintain backward compatibility.\n        spender: ContractAddress,\n        value: u256\n    }\n</code></pre>\n<p>This SNIP basically suggests to uncomment the above <code>#[key]</code> annotations:</p>\n<pre data-code-wrap=\"rust\"><code class=\"lang-rust\">    /// Emitted when tokens are moved from address `from` to address `to`.\n    #[derive(Drop, PartialEq, starknet::Event)]\n    struct Transfer {\n        #[key]\n        from: ContractAddress,\n        #[key]\n        to: ContractAddress,\n        value: u256\n    }\n\n    /// Emitted when the allowance of a `spender` for an `owner` is set by a call\n    /// to `approve`. `value` is the new allowance.\n    #[derive(Drop, PartialEq, starknet::Event)]\n    struct Approval {\n        #[key]\n        owner: ContractAddress,\n        #[key]\n        spender: ContractAddress,\n        value: u256\n    }\n</code></pre>\n<p>That is, a transfer from 0x1 to 0x2 of 100 tokens, now emits:</p>\n<p><code>keys</code>: [selector(‚ÄúTransfer‚Äù)]</p>\n<p><code>data</code>: [0x1, 0x2, 100, 0]</p>\n<p>The first two felts in the data array are the values of <code>from</code> and <code>to</code> correspondingly, and the last two felts are the low and high 128bits of the u256 of the amount.</p>\n<p>If this SNIP is accepted, the emitted event will change to:</p>\n<p><code>keys</code>: [selector(‚ÄúTransfer‚Äù), 0x1, 0x2]</p>\n<p><code>data</code>: [100, 0]</p>\n<p>Where <code>selector(x)</code> is the <a href=\"https://docs.starknet.io/documentation/architecture_and_concepts/Cryptography/hash-functions/#starknet_keccak\">sn_keccak</a> of <code>x</code>    .</p>\n<h2><a name=\"security-considerations-5\" class=\"anchor\" href=\"https://community.starknet.io#security-considerations-5\"></a>Security Considerations</h2>\n<p>Dapps who did not change their code to parse events differently may break after the ERC20 contracts are upgraded.</p>\n<p>We considered whether or not the change suggested in this SNIP can be leveraged to cause more damage. The scenario we analyzed is the following: can an exchange that did not change its code be led to thinking that a transfer has been made to its account, thus crediting an account on the exchange, while in fact no such transaction took place.</p>\n<p>We claim that this is not possible. Currently, DAPPs take the <code>from</code> and <code>to</code> values from the first and second members of the <code>data</code> array. After the change, the first and second members of the <code>data</code> array would be <code>amount_low</code> and <code>amount_high</code> correspondingly. Since both <code>amount_low</code> and <code>amount_high</code> are enforced to be 128bit numbers, and thus contain 124 leading zeros, these can not collide with an account address on Starknet, which is <a href=\"https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/contract-address/\">necessarily</a> the result of a hash computation.</p>\n<h2><a name=\"copyright-6\" class=\"anchor\" href=\"https://community.starknet.io#copyright-6\"></a>Copyright</h2>\n<p>Copyright and related rights waived via <a>MIT</a>.</p>\n            <p><small>3 posts - 2 participants</small></p>\n            <p><a href=\"https://community.starknet.io/t/snip-13-index-transfer-and-approval-events-in-erc20s/114212\">Read full topic</a></p>","link":"https://community.starknet.io/t/snip-13-index-transfer-and-approval-events-in-erc20s/114212","pubDate":"Thu, 13 Jun 2024 13:27:13 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"community.starknet.io-topic-114212"},"source":{"@url":"https://community.starknet.io/t/snip-13-index-transfer-and-approval-events-in-erc20s/114212.rss","#text":"SNIP 13 - Index `Transfer` and `Approval` events in ERC20s"}},{"title":"ZK Governance for Starknet","dc:creator":"Mirror-Tang","category":"Starknet Technical Development","description":"<h2><a name=\"overview-1\" class=\"anchor\" href=\"https://community.starknet.io#overview-1\"></a>Overview</h2>\n<p>The Starknet ecosystem hosts several prominent projects, of which many are governed and managed by DAOs, such as Realms and Ekubo. Despite the decentralized nature of these organizations, there is a notable reluctance among community members to participate in governance. The primary issue stems from the transparency of voting actions on the blockchain, which can expose sensitive information and influence decision-making processes.</p>\n<p><em>Votes are conducted publicly, leaving voting systems vulnerable to collusion.</em></p>\n<p>Starknet Governance Hub, designed to facilitate transparent and efficient governance. However, despite these efforts, participation rates remain lower than desired. Our team, with extensive experience in building governance platforms like Frontinus House for Realm, has identified privacy concerns as a significant barrier to active engagement.</p>\n<p>ZK Governance provides a solution to this challenge by using zero-knowledge proofs to ensure that voting is private, secure, and verifiable without revealing voters‚Äô identities or choices. By integrating ZK Governance into Starknet‚Äôs existing governance platform, we can enhance privacy and security, thereby increasing participation rates and strengthening the overall governance of DAOs within the Starknet ecosystem.</p>\n<h2><a name=\"problems-with-current-solutions-2\" class=\"anchor\" href=\"https://community.starknet.io#problems-with-current-solutions-2\"></a>Problems with Current Solutions</h2>\n<p><em>DAOs in the Starknet ecosystem currently face several challenges that hinder active participation in governance:</em></p>\n<ul>\n<li>Lack of Privacy: All voting actions are publicly visible on the blockchain, deterring individuals from participating due to concerns about exposing their decisions and holdings.</li>\n<li>Fear of Repercussions: Members may hesitate to vote on controversial issues for fear of social or financial backlash.</li>\n<li>Transparency vs. Confidentiality: The need for transparent governance conflicts with the desire to keep individual voting choices private.</li>\n<li>Influence and Bias: Public voting records can lead to undue influence or bias, where prominent members‚Äô votes sway community opinions.</li>\n<li>Low Participation Rates: The visibility of votes can discourage engagement, leading to low participation in governance processes.</li>\n<li>Data Sensitivity: Voters may not want their voting history and associated assets exposed, as this can reveal personal strategies and holdings.</li>\n</ul>\n<p><strong>ZK Governance Solutions</strong></p>\n<p>ZK Governance offers a comprehensive solution to these challenges by balancing the need for transparency in governance with the privacy of individual voters. Key features of ZK Governance for Starknet DAOs include:</p>\n<p>A large-scale anonymous electronic voting scheme based on zk-SNARKs (Zero-Knowledge Succinct Non-Interactive Argument of Knowledge) offers unique value and significance in ensuring the <strong>anonymity, security, and reliability</strong> of voting. zk-SNARKs is a cryptographic technology that enables one party (the prover) to prove to another party (the verifier) that a statement is true, without revealing any information other than the truth of the statement itself. Applying zk-SNARKs to electronic voting brings several key advantages:</p>\n<ol>\n<li><strong>Protection of Voter Identity Privacy</strong>: The connection between a voter‚Äôs choice and their personal identity is not disclosed; it‚Äôs impossible to identify from public information whether a specific voter has participated. This also enhances the fairness of the voting system.</li>\n<li><strong>Prevention of Vote Buying and Selling</strong>: Voters participate under pseudonyms and are unable to prove their own voting results. This means voters cannot sell their votes to third parties who may wish to purchase them.</li>\n<li><strong>Verifiable Voting Results</strong>: Everyone can verify the voting results based on the public counting proofs.</li>\n</ol>\n<h1><a name=\"starknet-analysis-3\" class=\"anchor\" href=\"https://community.starknet.io#starknet-analysis-3\"></a>Starknet Analysis</h1>\n<h2><a name=\"participants-composition-4\" class=\"anchor\" href=\"https://community.starknet.io#participants-composition-4\"></a>Participants Composition</h2>\n<p>The electronic voting scheme involves the following five participants: Proposers, STRK Holders <span class=\"math\">IDs=\\{id_1,id_2, ...id_m\\}</span>, Cryptographic Coordinator, Pseudonym Registrar, and Counters <span class=\"math\">Ts=\\{T_1,T_2, ...T_m\\} </span> . Among them, proposers and STRK holders are inherent to Starknet. Proposal-related information and voting results are still published on snapshot.</p>\n<ul>\n<li>Proposers: Also known as project operators, they can initiate proposals and are also STRK holders themselves.</li>\n<li>STRK Holders: Also known as voters, they can lock STRK tokens to vote. They vote under pseudonyms to ensure anonymity. As shown in the figure below, <strong>the voting results published on snapshot will not display the on-chain addresses of STRK holders, but their pseudonyms instead.</strong></li>\n<li>Snapshot: Publishes proposal information, voting information, cryptographic public parameters, voting results, and proofs of correct counting. The voting results include not only those cast by STRK holders but also null ballots cast by snapshot.</li>\n<li>Cryptographic Coordinator: Responsible for generating cryptographic parameters and key pairs, and <strong>publishing the public parameters on snapshot.</strong></li>\n<li>Pseudonym Registrar: Registers pseudonyms for STRK holders after they lock their STRK tokens and signs these pseudonyms.</li>\n<li>Counters: Responsible for calculating and verifying the voting results, and <strong>publishing the results and proofs of correct counting on snapshot</strong>. Counters use partial decryption keys from a k-out-of-n encryption scheme.</li>\n</ul>\n<h2><a name=\"function-definitions-5\" class=\"anchor\" href=\"https://community.starknet.io#function-definitions-5\"></a>Function Definitions</h2>\n<p>The voting scheme is defined by eight functions, namely: <span class=\"math\">VS=(Setup,PseudonymRegister, Register, Vote, ValidVote, Append, Tally, VerifyTally ).</span></p>\n<ol>\n<li>\n<p>Setup</p>\n<p><span class=\"math\">\\text{Setup}(\\lambda, R) \\rightarrow (PP, sk_{T}, sk_{\\sigma}): \\text{On input of the security parameter } \\lambda \\text{ and the relation } R \\\\ \\text{represented as an arithmetic circuit, generate the prover and verifier key pairs }\\\\ (pk, vk) \\leftarrow \\text{KeyGen}(\\lambda, R), \\text{ voting key pair } (pk_{T}, sk_{T}) \\leftarrow \\text{KeyGenE}(\\lambda), \\text{ registrar key pair} \\\\\n(pk_{R}, sk_{R}) \\leftarrow \\text{KeyGenS}(\\lambda), \\text{ commitment parameters from commitment setup} \\\\\nCR \\times T \\leftarrow \\text{Setup}C(\\lambda), \\text{ and public parameters } PP = (G, q, g, H, pk_T, pk_R, (pk, vk)).\n</span></p>\n</li>\n<li>\n<p>PseudonymRegister</p>\n<p><span class=\"math\">\\text{PseudonymRegister}(\\text{id}) \\rightarrow \\left( cr_{\\text{id}}, c_{\\text{id}}, t_{\\text{id}} \\right): \\text{ On implicit input } PP \\text{ and STRK holder}\\\\ \\text{identity id}, \n\\text{randomly select a pseudonym } cr_{\\text{id}} \\leftarrow CR, \\text{ compute } \\left( t_{\\text{id}}, c_{\\text{id}} \\right) \\leftarrow \\\\ \\text{Commit}(PP, cr_{\\text{id}}), \\text{ and return } \\left( cr_{\\text{id}}, c_{\\text{id}}, t_{\\text{id}} \\right), \\text{ where } t_{\\text{id}} \\text{ is randomly selected from } T.</span></p>\n</li>\n<li>\n<p>Register</p>\n<p><span class=\"math\">\\text{Register}(id, c_{id},{L}) \\rightarrow (L, MR_{L}, S_{R}): \\text{On input of the STRK holder identity and}\\\\ \\text{commitment} (id, c_{id}), \\text{ and list } L, \\text{ add } (id, c_{id}) \\text{ to list } L, \\text{ compute } MR_{L}, \\text{ sign } (L, MR_{L})\\\\  \\text{ with the registrar} \\text{private key} sk_{R} \\text{ to produce the signature } S_{R}, \\text{ and then return } \\\\(L, MR_{L}, S_{R}).</span></p>\n</li>\n<li>\n<p>Vote</p>\n<p><span class=\"math\">\\text{Vote}(id, sk_{id}, pk_{r}, v) \\rightarrow \\beta: \\text{On input of STRK holder identity } id, \\text{ voting public key } pk_{r}, \\\\ \\text{ and STRK holder private key } sk_{id} = (t_{id}, cr_{id}), \\text{ it generates a ballot } \\beta = (e_v, cr_{id},{\\pi_{id}}),\\\\  \\text{ where } e_v = \\text{enc}_{pk_{v}}(v;r). \\text{ Additionally, compute a disjoint proof } \\text{Prove}(pk, x, \\omega) \\rightarrow \\pi, \\\\ \\text{ where } \\omega = (r, c_{id},v, t_{id}, )x = (e_v, cr_{id}, MR_{L}), \\text{ and simulate a null ballot proof.}\n</span></p>\n</li>\n<li>\n<p>ValidVote</p>\n<p><span class=\"math\">\\text{ValidVote}(\\beta) \\rightarrow 0/1: \\text{On input of a ballot } \\beta = \\left( e_v, cr_{id},{\\pi_{id}} \\right), \\text{ check if it is valid, i.e.,}\\\\ \\text{whether this proof is correct and well-formed, by completing the verification through}\\\\ \\text{ executing } \\text{Verify}\\left( vk, \\left( e_v, cr_{id} \\right), \\pi_{id} \\right) \\rightarrow 0/1.\n</span></p>\n</li>\n<li>\n<p>Append</p>\n<p><span class=\"math\">\\text{Append}(\\text{snapshot}, \\beta) \\rightarrow \\text{snapshot}: \\text{On input of a ballot } \\beta, \\text{according to } D_t, \\text{ append }\\\\ \\beta \\text{ to snapshot. It generates and appends one or more null ballots } \\left(e_0, c_{id}, \\pi_{id}\\right) \\text{ according}\\\\ \\text{to the probability distribution } D_r \\text{ and } D_t. \\text{ It computes } e_0 = \\text{enc}_{pk_{r}}(0; r) \\text{ and disjoint} \\\\ \\text{proof } \\pi_{id}.</span></p>\n<p><span class=\"math\">\\text{Prove}(pk , x, \\omega) \\rightarrow \\pi_{id}, \\text{where } \\omega = (r, 0), x = \\left(e_0, cr_{id}, MR_{L}\\right), \\text{ and simulates the other }\\\\ \\text{ side} \\text{ of STRK holder proof.}</span></p>\n</li>\n<li>\n<p>Tally</p>\n<p><span class=\"math\">\\text{Tally}(\\text{snapshot}, sk_T) \\rightarrow (s, \\Pi): \\text{ On input of the public snapshot, calculate the }\\\\ text{voting results, return } (s, \\Pi), \\text{ where } s \\text{ is the voting result, } \\Pi \\text{ is the proof of correct}\\\\ \\text{ counting, with the following steps:}\n</span></p>\n</li>\n</ol>\n<ul>\n<li>Run <span class=\"math\">ValidVote(\\beta)</span> and return 0 in case of failure.</li>\n<li>For each <span class=\"math\">cr_id</span> appearing in the ballots, calculate <a href=\"https://community.starknet.io/uploads/short-url/7WPmW8mN6qWVKrLtnHX1OjtcMXn.png\">image|256x108, 50%</a>,where <a href=\"https://community.starknet.io/uploads/short-url/es0ROWYneVLsdgd511193ZiD97z.png\">image|98x72, 50%</a> is the set of <span class=\"math\">(e_v, cr_{id},\\pi_{id})</span> identified by <span class=\"math\">cr_{id}</span>.</li>\n<li>Remove <span class=\"math\">(cri,\\pi_i)</span> from each <span class=\"math\">B_{cr_i}</span>, mix the ballots {<span class=\"math\">{B_{cr_1}, B_{cr_2},..., B_{cr_k}}</span>}, where k is the number of pseudonyms <span class=\"math\">cr_i</span>, and return the mixed ballots <a href=\"https://community.starknet.io/uploads/short-url/pf1bSm3fpy3RR1j5p1AZaIkywXq.png\">image|190x74, 50%</a> and proof of valid mixing.</li>\n<li>For each <span class=\"math\">B_i^{'}</span> and voting option <span class=\"math\"> v \\in V</span>, apply the privacy equivalence test (PET) and provide corresponding proof.</li>\n<li>Calculate the result s for each voting v based on the PET result and publish the proof.</li>\n</ul>\n<ol start=\"8\">\n<li>\n<p>VerifyTally</p>\n<p><span class=\"math\">\\text{VerifyTally}(\\text{snapshot}, s, \\Pi) \\rightarrow 0/1: \\text{ On input of } (s, \\Pi), \\text{ if all proofs are valid, return } 1;\\\\  \\text{ otherwise, return } 0.</span></p>\n</li>\n</ol>\n<h2><a name=\"implementation-phase-6\" class=\"anchor\" href=\"https://community.starknet.io#implementation-phase-6\"></a>Implementation Phase</h2>\n<p>The flowchart of this electronic voting scheme illustrates the process of Starknet‚Äôs private governance as follows.<br>\n</p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://europe1.discourse-cdn.com/standard20/uploads/starknet1/original/3X/5/9/59a385268794461560b7c6a7d2a0818f91ff7c70.png\" data-download-href=\"/uploads/short-url/cMYPM9YWjuHYO0uO6YvwZ4qLObm.png?dl=1\" title=\"54ee0524f5613bf4e96a923d3fcc3f8e0533f29a\" rel=\"noopener nofollow ugc\"><img src=\"https://europe1.discourse-cdn.com/standard20/uploads/starknet1/optimized/3X/5/9/59a385268794461560b7c6a7d2a0818f91ff7c70_2_618x500.png\" alt=\"54ee0524f5613bf4e96a923d3fcc3f8e0533f29a\" data-base62-sha1=\"cMYPM9YWjuHYO0uO6YvwZ4qLObm\" width=\"618\" height=\"500\" srcset=\"https://europe1.discourse-cdn.com/standard20/uploads/starknet1/optimized/3X/5/9/59a385268794461560b7c6a7d2a0818f91ff7c70_2_618x500.png, https://europe1.discourse-cdn.com/standard20/uploads/starknet1/optimized/3X/5/9/59a385268794461560b7c6a7d2a0818f91ff7c70_2_927x750.png 1.5x, https://europe1.discourse-cdn.com/standard20/uploads/starknet1/optimized/3X/5/9/59a385268794461560b7c6a7d2a0818f91ff7c70_2_1236x1000.png 2x\" data-dominant-color=\"A3BCD1\"></a></div><p></p>\n<p>Based on this flowchart, we divide the Starknet private governance process into five stages:</p>\n<ol>\n<li>Setup Phase</li>\n</ol>\n<p>Given security parameters and relation R, the Cryptographic Coordinator runs Setup,R to:</p>\n<ul>\n<li>Generate cryptographic parameters <span class=\"math\">(G,q, g)</span>, counting party threshold tuple <span class=\"math\">(k, n)</span>, voting key pair <span class=\"math\">(pk_T,sk_T)</span>, registrar key pair <span class=\"math\">(pk_R,sk_R)</span>, commitment function and its parameters <span class=\"math\">H:CR * T\\rightarrow C</span>, and the zero-knowledge proof key pair pk,vk for relation R.</li>\n<li>Publish public parameters <span class=\"math\">PP=(G,q, g, H, pk_T, pk_R, (pk, vk ))</span>.</li>\n</ul>\n<ol start=\"2\">\n<li>Registration Phase</li>\n</ol>\n<p>STRK holders (id) run Register(id) to:</p>\n<ul>\n<li>Choose a voting pseudonym <span class=\"math\">cr_{id} \\in CR</span>.</li>\n<li>Compute <span class=\"math\">c_{id} = H(cr_{id}, t_{id}) \\in \\{0,1\\}^{Ôºà0Ôºå\\lambdaÔºâ}</span> using <span class=\"math\">t_{id} \\in T</span> and store <span class=\"math\">(cr_{id}, t_{id})</span> locally.</li>\n<li>The pseudonym registrar adds <span class=\"math\">(id, c_{id})</span> to the pseudonym list <span class=\"math\">L</span></li>\n<li>Compute the merkle tree root <span class=\"math\">MR_L</span> based on the commitment order in list <span class=\"math\">L</span>.</li>\n<li>Finally, sign <span class=\"math\">L</span> and <span class=\"math\">MR_L</span> and publish them on snapshot.</li>\n<li>STRK holders verify <span class=\"math\">c_{id} \\in L</span> and merkle tree root <span class=\"math\">MR_L</span>.</li>\n</ul>\n<ol start=\"3\">\n<li>Voting Phase</li>\n</ol>\n<p>To cast a vote v, STRK holders run <span class=\"math\">Vote(id,sk_{id},pk_T,v)</span>, where <span class=\"math\">sk_{id}=(t_{id}, cr_{id})</span>, including:</p>\n<ul>\n<li>\n<p>Compute <span class=\"math\">e_v = \\text{enc}_{pk_r}(v; r)</span>, where <span class=\"math\">r \\in \\mathbb{Z}_q</span> is a random value for encryption. In the case of revoking a previous vote <span class=\"math\">v_{\\text{pre}}</span> and voting for <span class=\"math\">v_{\\text{new}}</span>, STRK holders set <span class=\"math\">v = v_{\\text{new}} - v_{\\text{pre}}</span>.</p>\n</li>\n<li>\n<p>Calculate zero-knowledge proof <span class=\"math\">\\pi_{id}</span> using proving key <span class=\"math\">pk</span>:<br>\n<a href=\"https://community.starknet.io/uploads/short-url/6pJE5EfW02BhcDbj9o8raaJfqks.png\">image|690x48, 75%</a></p>\n</li>\n<li>\n<p>Submit <span class=\"math\">\\beta = (e_v, cr_{id}, \\pi_{id})</span> to snapshot via an anonymous channel.</p>\n</li>\n<li>\n<p>Snapshot runs <span class=\"math\">\\text{ValidVote}(\\beta)</span>, checks the validity of the proof on the ballot, and verifies if the ballot already exists on snapshot.</p>\n</li>\n<li>\n<p>Snapshot runs <span class=\"math\">\\text{Append}(\\text{snapshot}, \\beta)</span>, appending the ballot <span class=\"math\">\\beta</span> and null ballots to snapshot.</p>\n</li>\n<li>\n<p>STRK holders verify if <span class=\"math\">\\beta</span> is appended to snapshot.</p>\n</li>\n<li>\n<p>Snapshot generates null ballots as follows: Calculate <span class=\"math\">e_0 = \\text{enc}_{pk_r}(0; r)</span>, choose a <span class=\"math\">cr_{id}</span> from <span class=\"math\">\\beta</span> on the snapshot, compute <span class=\"math\">\\pi_{id}</span>:<br>\n<a href=\"https://community.starknet.io/uploads/short-url/pLVNwSFEhG5o9G2XXaRKjkvlBs3.png\">image|690x44, 75%</a></p>\n</li>\n</ul>\n<ol start=\"4\">\n<li>Counting Phase</li>\n</ol>\n<p>Counters run <span class=\"math\">Tally(snapshot,sk_T)</span>, including:</p>\n<ul>\n<li>Verify ballots on snapshot and select those with valid proofs.</li>\n<li>Apply the homomorphic properties of the encryption scheme to calculate the final ballot for each <span class=\"math\">cr_{id}</span> on the snapshot.</li>\n<li>Shuffle, mix, and publish the final ballots without crid, providing proof of correctness.</li>\n<li>Apply PET to the final ballots and select encrypted votes from the voting.</li>\n<li>Decrypt ballots and publish results and decryption proofs on snapshot.</li>\n</ul>\n<ol start=\"5\">\n<li>Verification Phase</li>\n</ol>\n<p>Anyone can verify the correctness of the counting by running <span class=\"math\">VerifyTally(snapshot,s,\\Pi)</span>, which verifies the results and all proofs published during the counting process. This implementation achieves large-scale electronic voting while ensuring anonymity, security, and reliability.</p>\n<h1><a name=\"future-work-7\" class=\"anchor\" href=\"https://community.starknet.io#future-work-7\"></a>Future Work</h1>\n<p><strong>Performance and Scalability:</strong> As the number of voters increases, the system‚Äôs performance and scalability will face challenges. Future research could focus on the study of fully recursive zk-SNARKs to support larger-scale elections.</p>\n<p><strong>User Friendliness:</strong> An important task in promoting ZK technology is to address the current complexity of the system for ordinary users. Simplifying user interfaces and operational processes, and lowering the barrier for user adoption, will contribute to the widespread acceptance and adoption of the system.</p>\n<p><strong>Compliance and Legal Challenges:</strong> Decentralization and compliance have always been antonyms; typically, only the government can prove your identity. However, this leads to the possibility of data being tampered with at the source (but if this identity is recognized by the government, then even the fake becomes real). ZK cannot solve the problem of a trusted source, but we might need to consider: what kind of world it would be if I could prove I am who I am.</p>\n            <p><small>2 posts - 1 participant</small></p>\n            <p><a href=\"https://community.starknet.io/t/zk-governance-for-starknet/114202\">Read full topic</a></p>","link":"https://community.starknet.io/t/zk-governance-for-starknet/114202","pubDate":"Tue, 11 Jun 2024 01:49:51 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"community.starknet.io-topic-114202"},"source":{"@url":"https://community.starknet.io/t/zk-governance-for-starknet/114202.rss","#text":"ZK Governance for Starknet"}},{"title":"StarkHack Hackathon Starts June 13th üë∑","dc:creator":"ethjake","category":"ü§∑‚Äç‚ôÄÔ∏è All-Purpose Hangout","description":"<p>Hello everyone <img src=\"https://emoji.discourse-cdn.com/twitter/wave/3.png?v=12\" title=\":wave:t3:\" class=\"emoji\" alt=\":wave:t3:\" loading=\"lazy\" width=\"20\" height=\"20\"></p>\n<p>Jacob here from the ETHGlobal team to share that we‚Äôre thrilled to be organizing <a href=\"https://ethglobal.com/events/starkhack\" rel=\"noopener nofollow ugc\">StarkHack</a> in collaboration with StarkWare, the Starknet Foundation, and many other Starknet ecosystem contributors.</p>\n<p>StarkHack is our first hackathon built with the Starknet ecosystem at its heart. We‚Äôre excited to see over 500 hackers come together to push what‚Äôs possible with Starknet, Cairo, and STARKs.</p>\n<p>If you‚Äôre a builder in the Starknet ecosystem, a couple key reasons to join:</p>\n<ul>\n<li><img src=\"https://emoji.discourse-cdn.com/twitter/star.png?v=12\" title=\":star:\" class=\"emoji\" alt=\":star:\" loading=\"lazy\" width=\"20\" height=\"20\"> Keynotes, Panels, and a Full Summit: We‚Äôll be kicking off the event with talks from Eli Ben-Sasson, Ariel Elperin, James Strudwick and other ecosystem contributors</li>\n<li><img src=\"https://emoji.discourse-cdn.com/twitter/rocket.png?v=12\" title=\":rocket:\" class=\"emoji\" alt=\":rocket:\" loading=\"lazy\" width=\"20\" height=\"20\"> Hands-on Workshops: Learn from the experts with workshops designed to teach new skills.</li>\n<li><img src=\"https://emoji.discourse-cdn.com/twitter/moneybag.png?v=12\" title=\":moneybag:\" class=\"emoji\" alt=\":moneybag:\" loading=\"lazy\" width=\"20\" height=\"20\"> $100,000+ USD in Prizes: Compete for prizes from different industry leading protocols/</li>\n<li><img src=\"https://emoji.discourse-cdn.com/twitter/bulb.png?v=12\" title=\":bulb:\" class=\"emoji\" alt=\":bulb:\" loading=\"lazy\" width=\"20\" height=\"20\"> Exciting Challenges: Access to a curated list of real-world problems &amp; project ideas and over 50 mentors to bring your ideas to life.</li>\n</ul>\n<p><strong>Why post on the forum?</strong><br>\nTwo reasons.</p>\n<p><strong>Firstly</strong>, I‚Äôd love to know what key Starknet contributors should definitely take part (think projects that have technology that hackers can use or critical libraries to speed up development) and</p>\n<p><strong>Secondly</strong>, I‚Äôd love to curate a wishlist from the community of ideas for projects we can share with the builders!</p>\n<p>In the meantime, if you‚Äôre interested in joining, applications are open now: <a href=\"https://ethglobal.com/events/starkhack\" rel=\"noopener nofollow ugc\">https://ethglobal.com/events/starkhack</a></p>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://community.starknet.io/t/starkhack-hackathon-starts-june-13th/114139\">Read full topic</a></p>","link":"https://community.starknet.io/t/starkhack-hackathon-starts-june-13th/114139","pubDate":"Thu, 30 May 2024 05:49:46 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"community.starknet.io-topic-114139"},"source":{"@url":"https://community.starknet.io/t/starkhack-hackathon-starts-june-13th/114139.rss","#text":"StarkHack Hackathon Starts June 13th üë∑"}},{"title":"Optimistic parallelization revived","dc:creator":"FeedTheFed","category":"üìú Development Proposals","description":"<h1><a name=\"optimistic-parallelization-revived-1\" class=\"anchor\" href=\"https://community.starknet.io#optimistic-parallelization-revived-1\"></a>Optimistic parallelization revived</h1>\n<h2><a name=\"tldr-2\" class=\"anchor\" href=\"https://community.starknet.io#tldr-2\"></a>TL;DR</h2>\n<ul>\n<li>Optimistic parallelization is now being implemented on the Starknet sequencer in Rust</li>\n<li>Moar tps in Starknet 0.13.2</li>\n</ul>\n<h2><a name=\"introduction-3\" class=\"anchor\" href=\"https://community.starknet.io#introduction-3\"></a>Introduction</h2>\n<p><a href=\"https://starkware.co/resource/starknet-performance-roadmap/\">Back</a> in Starknet 0.10.2, we introduced optimistic parallelization to the sequencer as part of a series of efforts to improve the system‚Äôs throughput.</p>\n<p>In parallel, we worked to migrate the larger parts of the codebase to Rust. The result of this effort was the <a href=\"https://github.com/starkware-libs/blockifier\">blockifier</a>, Starknet‚Äôs new execution engine, which in turn relies on the Rust implementation of the <a href=\"https://github.com/lambdaclass/cairo-vm\">cairo-vm</a> by Lambdaclass.</p>\n<p>Given that the transition from Python to Rust outweighed most of the potentiatal performance improvements, the first iterations of the blockifier did not contain optimistic parallelization. After a few Starknet versions that focused on stability and fee reduction, we return to parallelization in order to reach the full potential of the Starknet sequencer.</p>\n<h2><a name=\"what-is-optimistic-parallelization-4\" class=\"anchor\" href=\"https://community.starknet.io#what-is-optimistic-parallelization-4\"></a>What is optimistic parallelization?</h2>\n<p>Naively, executing a block of transactions in parallel is impossible as different transactions may be dependent. This is illustrated in the following example. Consider a block with three transactions from the same user:</p>\n<ul>\n<li>Transaction A: swap USDC for ETH</li>\n<li>Transaction B: pay ETH for an NFT</li>\n<li>Transaction C: swap USDT for BTC</li>\n</ul>\n<p>Clearly, Tx A must happen before Tx B, but Tx C is entirely independent of both and can be executed in parallel. If each transaction requires 1 second to execute, then the block production time can be reduced from 3 seconds to 2 seconds by introducing parallelization.</p>\n<p>The crux of the problem is that we do not know the transaction dependencies in advance. In practice, only when we execute transaction B from our example do we see that it relies on changes made by transaction A. More formally, the dependency follows from the fact that transaction B reads from storage cells that transaction A has written to. We can think of the transactions as forming a dependency graph, where there is an edge from transaction A to transaction B iff A writes to a storage cell that is read by B, and thus has to be executed before B. The following figure shows an example of such a dependency graph:</p>\n<p><img src=\"https://europe1.discourse-cdn.com/standard20/uploads/starknet1/original/3X/d/7/d7f32ac0707740d1b9bf477a66d3adee9cf03e1d.png\" alt=\"image\" data-base62-sha1=\"uOnDCsRQh5UPY3gnq32e8LlS3GB\" width=\"665\" height=\"330\"></p>\n<p>In the above example, each column can be executed in parallel, and this is the optimal arrangement (while naively, we would have executed transactions 1‚Äì9 sequentially).</p>\n<p>To overcome the fact that the dependency graph is not known in advance, we introduce optimistic parallelization, in the spirit of <a href=\"https://malkhi.com/posts/2022/04/block-stm/\">BLOCK-STM</a> developed by Aptos Labs, to the Starknet sequencer. Under this paradigm, we optimistically attempt to run transactions in parallel and re-execute upon finding a collision. For example, we may execute transactions 1‚Äì4 from figure 1 in parallel, only to find out afterward that Tx4 depends on Tx1. Hence, its execution was useless (we ran it relative to the same state we ran Tx1 against, while we should have run it against the state resulting from applying Tx1). In that case, we will re-execute Tx4.</p>\n<h2><a name=\"parallelization-in-the-blockifier-5\" class=\"anchor\" href=\"https://community.starknet.io#parallelization-in-the-blockifier-5\"></a>Parallelization in the blockifier</h2>\n<p>The entry point to the new parallelization infrastructure in the blockifier can be found in <a href=\"https://github.com/starkware-libs/blockifier/blob/df2799eafda4f575e71d63c839d14f5a38ca911d/crates/blockifier/src/concurrency.rs#L1\">concurrency.rs</a>. The Rust implementation follows the original BLOCK-STM paper more closely compared to the previous version of our optimistic parallelization. The scheduler tracks the tasks that remain to be done, these can be either validation tasks or execution tasks. Worker threads then query the scheduler for the next task, and communicate with a versioned state to obtain the latest known storage values. This is illustrated in the following diagram:</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://europe1.discourse-cdn.com/standard20/uploads/starknet1/original/3X/8/5/850099e3e8117db4bb9507e2b399e21e87007798.jpeg\" data-download-href=\"/uploads/short-url/iYAN4uWEkZfIhfQknZ3UBA1S3ig.jpeg?dl=1\" title=\"\"><img src=\"https://europe1.discourse-cdn.com/standard20/uploads/starknet1/optimized/3X/8/5/850099e3e8117db4bb9507e2b399e21e87007798_2_624x316.jpeg\" alt=\"\" data-base62-sha1=\"iYAN4uWEkZfIhfQknZ3UBA1S3ig\" width=\"624\" height=\"316\" role=\"presentation\" srcset=\"https://europe1.discourse-cdn.com/standard20/uploads/starknet1/optimized/3X/8/5/850099e3e8117db4bb9507e2b399e21e87007798_2_624x316.jpeg, https://europe1.discourse-cdn.com/standard20/uploads/starknet1/optimized/3X/8/5/850099e3e8117db4bb9507e2b399e21e87007798_2_936x474.jpeg 1.5x, https://europe1.discourse-cdn.com/standard20/uploads/starknet1/optimized/3X/8/5/850099e3e8117db4bb9507e2b399e21e87007798_2_1248x632.jpeg 2x\" data-dominant-color=\"F4F6F7\"></a></div><p></p>\n<p>Diagram: worker threads request the next task, and work on a versioned state (version i contains the writes of tx i). The execution itself is handled by the same code that handled sequential execution.</p>\n<p>The blockifier‚Äôs implementation contains an additional commit phase that isn‚Äôt part of the original BLOCK-STM paper. The motivation for this phase is to delay fee transfers to the sequencer (which, if unhandled separately, leads any two transactions to collide due to reading &amp; writing the sequencer‚Äôs balance). If all transactions before transaction <code>i</code> are committed, then the fee transfer is applied alongside an additional check to see whether or not the transaction can fit into a block. If both tests pass, the i‚Äôth transaction is committed.</p>\n<h2><a name=\"whats-next-6\" class=\"anchor\" href=\"https://community.starknet.io#whats-next-6\"></a>What‚Äôs next</h2>\n<p>Several potential improvements to the blockifier‚Äôs implementation of BLOCK-STM will be added down the road. At the moment, accesses to VersionedState are mutually exclusive; this can be relaxed to locking only over the particular addresses that we want to read/write from.</p>\n<p>Another direction to explore is adding language features that will allow contract developers to write more ‚Äúparallelizable‚Äù code. For example, when performing a commutative operation on storage values today, one has to read the value, apply the operation, and write the new value. This means that although the underlying operation is commutative, any two transactions that perform it will have a read/write collision. If, however, the smart contract language has primitives that encapsulate ‚Äúatomic storage manipulation‚Äù, then these can be used to enhance parallelization. For example, consider u256 addition. If we want to add some value to a storage slot (as happens when updating the sequencer‚Äôs balance due to fee payments), we can call an ad-hoc <code>increment(storage_address, value)</code> operation that does not necessarily lead two transactions that apply increment to the same address to collide. Collision will only happen if the first operation results in an overflow. This direction was explored in more depth in a <a href=\"https://arxiv.org/pdf/2405.06117\">recent paper</a> by AptosLabs, where they introduce the notion of ‚Äúdeferred object‚Äù to the smart contract language.</p>\n<p>Finally, while mostly targeted for the sequencing layer, the parallelization infrastructure can be used by full nodes to optimize re-execution. The improvement is even more significant for nodes, since they can get the optimal ordering via the dependency graph produced by the original execution.</p>\n<h2><a name=\"summary-7\" class=\"anchor\" href=\"https://community.starknet.io#summary-7\"></a>Summary</h2>\n<p>As of Starknet 0.13.2, parallelization is back on the menu. Parallelization, along with AOT compilation via the <a href=\"https://github.com/lambdaclass/cairo_native\">cairo-native</a> project that is planned for 0.13.3, will unleash the full potential of Starknet, reaching throughput that is only possible on a validity rollup.</p>\n            <p><small>3 posts - 2 participants</small></p>\n            <p><a href=\"https://community.starknet.io/t/optimistic-parallelization-revived/114121\">Read full topic</a></p>","link":"https://community.starknet.io/t/optimistic-parallelization-revived/114121","pubDate":"Sun, 26 May 2024 16:51:38 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"community.starknet.io-topic-114121"},"source":{"@url":"https://community.starknet.io/t/optimistic-parallelization-revived/114121.rss","#text":"Optimistic parallelization revived"}},{"title":"SNIPs: process revival","dc:creator":"ilia","category":"üìú Development Proposals","description":"<h1><a name=\"introduction-1\" class=\"anchor\" href=\"https://community.starknet.io#introduction-1\"></a>Introduction</h1>\n<p>SNIPs (Starknet Improvement Proposals) are the Starknet analogue of Ethereum EIPs. However, in the current state of affairs, there are aspects in which a SNIP differs from an EIP both in its purpose and in its (lack of) processing. As pointed out by the community, little attention has been devoted to the topic over the past few months. The purpose of this text is to revive the SNIP process and propose short-term improvements.</p>\n<h1><a name=\"eip-vs-snip-today-2\" class=\"anchor\" href=\"https://community.starknet.io#eip-vs-snip-today-2\"></a>EIP vs SNIP today</h1>\n<p>The fundamental difference is in handling protocol-level improvement proposals, i.e those which require protocol changes. Ethereum, being decentralized, requires ‚Äúmeta-consensus‚Äù on protocol changes among validators and subsequently among client teams. The Ethereum Foundation is a considerable driving force for EIPs, but it does not directly control block proposals. Starknet, in its currently centralized state, strictly requires involvement of the Starknet core teams in StarkWare to implement protocol changes.</p>\n<p>Since genesis, almost all protocol-level changes (e.g. version features) have not gone through the full SNIP route, having been decided internally instead. Overall we think this is sensible and justified by the need to move and add features much faster than in Ethereum. That being said, the long term objective is clear: when Starknet is decentralized and mature, the process will closely mirror the Ethereum EIP protocol.</p>\n<p>Thus we are left with the question of short-medium term: on the one hand, iterations and versions are still frequent compared to Ethereum. On the other hand, we want to step toward a SNIP process that approaches the ‚Äúreal thing‚Äù over time.</p>\n<h1><a name=\"short-medium-term-proposal-3\" class=\"anchor\" href=\"https://community.starknet.io#short-medium-term-proposal-3\"></a>Short-medium term proposal</h1>\n<p>Following <a href=\"https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-1.md\">SNIP-1</a>, GitHub remains the place to submit SNIPs and is the source of truth for their documentation. Other media are for discussions and ‚Äúadvertising‚Äù.</p>\n<h2><a name=\"the-process-4\" class=\"anchor\" href=\"https://community.starknet.io#the-process-4\"></a>The process</h2>\n<ol>\n<li>Author submits SNIP.</li>\n<li>Following <a href=\"https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-1.md#snip-editor-responsibilities\">SNIP-1#Editor Responsibilities</a>, the editor performs syntactic checks. If the checks pass then merge to main. Otherwise reject.</li>\n<li>After merge to main, the author should change status to review and begin discussions on the community forum, which is the intended domain for discussing SNIPs. The author has edit permissions and is free to modify their proposal at will.</li>\n<li>SNIPs enter stale status after 6 months and require an editor (SW) to revive.</li>\n<li>An editor can change the status to last call which activates a two week timer. Assuming no other actions, a SNIP in last call status automatically becomes final when the timer runs out.</li>\n</ol>\n<h2><a name=\"what-does-it-really-mean-to-finalize-5\" class=\"anchor\" href=\"https://community.starknet.io#what-does-it-really-mean-to-finalize-5\"></a>What does it really mean to finalize?</h2>\n<p>During the centralized phase of Starknet, finalization has two essential steps: entering the roadmap and running in production. In the decentralized phase, finalization means sufficiently widespread adoption among Starknet operators and full nodes.</p>\n<h2><a name=\"what-will-change-now-6\" class=\"anchor\" href=\"https://community.starknet.io#what-will-change-now-6\"></a>What will change now?</h2>\n<p>The Starknet core teams are committed to much greater responsiveness, both on GitHub and in Community Forum discussions. Specifically, feel free to ping <a class=\"mention\" href=\"https://community.starknet.io/u/ilia\">@ilia</a>, <a class=\"mention\" href=\"https://community.starknet.io/u/ohad-starkware\">@Ohad-StarkWare</a>, <a class=\"mention\" href=\"https://community.starknet.io/u/feedthefed\">@FeedTheFed</a>, and <a class=\"mention\" href=\"https://community.starknet.io/u/leo_l\">@Leo_L</a>!</p>\n<h2><a name=\"what-now-7\" class=\"anchor\" href=\"https://community.starknet.io#what-now-7\"></a>What now?</h2>\n<p>Write SNIPs! <img src=\"https://emoji.discourse-cdn.com/twitter/scissors.png?v=12\" title=\":scissors:\" class=\"emoji\" alt=\":scissors:\" loading=\"lazy\" width=\"20\" height=\"20\"><img src=\"https://emoji.discourse-cdn.com/twitter/scissors.png?v=12\" title=\":scissors:\" class=\"emoji\" alt=\":scissors:\" loading=\"lazy\" width=\"20\" height=\"20\"><img src=\"https://emoji.discourse-cdn.com/twitter/scissors.png?v=12\" title=\":scissors:\" class=\"emoji\" alt=\":scissors:\" loading=\"lazy\" width=\"20\" height=\"20\"></p>\n            <p><small>6 posts - 3 participants</small></p>\n            <p><a href=\"https://community.starknet.io/t/snips-process-revival/114075\">Read full topic</a></p>","link":"https://community.starknet.io/t/snips-process-revival/114075","pubDate":"Sun, 12 May 2024 14:41:16 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"community.starknet.io-topic-114075"},"source":{"@url":"https://community.starknet.io/t/snips-process-revival/114075.rss","#text":"SNIPs: process revival"}}]}}}