{"rss":{"@version":"2.0","@xmlns:discourse":"http://www.discourse.org/","@xmlns:atom":"http://www.w3.org/2005/Atom","@xmlns:dc":"http://purl.org/dc/elements/1.1/","channel":{"title":"Ethereum Research - Latest topics","link":"https://ethresear.ch/latest","description":"Latest topics","lastBuildDate":"Sat, 31 Aug 2024 14:57:04 +0000","atom:link":{"@href":"https://ethresear.ch/latest.rss","@rel":"self","@type":"application/rss+xml"},"item":[{"title":"Interpreting MPT branch node values","dc:creator":"josephjohnston","category":"Data Structure","description":"<p>Consider a branch node for an MPT.<br>\nSuppose the 17’th item in the branch node list is supposed to be NULL, because the branch node is not a “terminator” node. Ethereum documentation says NULL is encoded as the empty string.<br>\nSuppose the 17’th item in the list is supposed to be a value because the branch node is a terminator node. Suppose this value happens to be the empty string.<br>\nHow to distinguish these two cases?<br>\nNote this question should be independent of RLP encoding, which only concerns how we encode the list. I’m asking what’s in the list itself, before considering how the list is subsequently encoded.</p>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://ethresear.ch/t/interpreting-mpt-branch-node-values/20368\">Read full topic</a></p>","link":"https://ethresear.ch/t/interpreting-mpt-branch-node-values/20368","pubDate":"Sat, 31 Aug 2024 14:57:04 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20368"},"source":{"@url":"https://ethresear.ch/t/interpreting-mpt-branch-node-values/20368.rss","#text":"Interpreting MPT branch node values"}},{"title":"Exploring Verifiable Continuous Sequencing with Delay Functions","dc:creator":"thedevbirb","category":"Layer 2","description":"<p><em>Thanks to Conor, Lin and Swapnil from the Switchboard team, Cecilia and Brecht from the Taiko team, Alex Obadia, Justin Drake, Artem Kotelskiy and the Chainbound team for review.</em></p>\n<h2><a name=\"p-49826-abstract-1\" class=\"anchor\" href=\"https://ethresear.ch#p-49826-abstract-1\"></a>Abstract</h2>\n<p>Agreeing on time in a decentralized setting can be challenging: wall clocks may drift between machines, agents can lie about their local times, and it is generally hard to distinguish between malicious intent and just unsynchronized clocks or network latencies.</p>\n<p>Ethereum can be thought of as a global clock that ticks at a rate of 1 tick per ~12 seconds. This tick rate is soft-enforced by the consensus protocol: blocks and attestations produced too early or too late will not be considered valid. But what should we do in order to achieve a granularity lower than 12 seconds? Do we always require a consensus protocol to keep track of time?</p>\n<p>We want to explore these questions in the context of untrusted L2 sequencers, who don’t have any incentive to follow the L2 block schedule that is currently maintained by trusted L2 sequencers, and will likely play various forms of timing games in order to maximize their revenue.</p>\n<p>In this article, we introduce mechanisms to enforce the timeliness, safety and non-extractive ordering of sequencers in a decentralized rollup featuring a <strong>rotating leader mechanism</strong>, without relying on additional consensus, honest majority assumptions or altruism. To do so, we use three key primitives:</p>\n<ol>\n<li>Client-side ordering preferences,</li>\n<li>Ethereum as a global 12s-tick clock,</li>\n<li>Verifiable Delay Functions.</li>\n</ol>\n<p>Lastly, we show the case study of MR-MEV-Boost, a modification of MEV-Boost that enables a variation of based preconfirmations, where the same construction explored can be applied to reduce the timing games of the proposer.</p>\n<h2><a name=\"p-49826-rationale-2\" class=\"anchor\" href=\"https://ethresear.ch#p-49826-rationale-2\"></a>Rationale</h2>\n<p>Rollup sequencers are entities responsible for ordering (and in most cases, executing) L2 transactions and occasionally updating the L2 state root on the L1. Currently, centralized sequencers benefit from the reputational collateral of the teams building them to maintain five properties:</p>\n<ul>\n<li><strong>Responsiveness</strong>: responding to user transactions with soft commitments / preconfirmations in a <em>timely</em> manner. We want to highlight that this definition includes the timely broadcast of unsafe heads on the rollup peer-to-peer network.</li>\n<li><strong>Non-equivocation (safety)</strong>: adhering to preconfirmation promises when submitting the ordered batch on the L1, which is what will ultimately determine the total ordering of transactions.</li>\n<li><strong>Non-extractive ordering</strong>: not extracting MEV from users by front-running or sandwiching, or by accepting bribes for front-running privileges.</li>\n<li><strong>Liveness</strong>: posting batches to L1 and updating the canonical rollup state regularly.</li>\n<li><strong>Censorship-resistance:</strong> ensuring that no valid transactions are deliberately excluded by the sequencer regardless of the sender, content, or any external factors.</li>\n</ul>\n<p>In this piece we are concerned with how the first four properties can be maintained in a permissionless, untrusted setting. Note that censorship-resistance is ensured by construction: by introducing multiple organizationally distinct sequencers in different geographies and jurisdictions we have a strong guarantee that any transaction will be accepted eventually.</p>\n<p>Consider a decentralized sequencer set <span class=\"math\">S := \\{S_1,\\dots,S_n\\}</span>  with a predictable leader rotation mechanism and a sequencing window corresponding to a known amount of L1 slots. For simplicity, let’s assume <span class=\"math\">S_{i}</span> is the current leader and <span class=\"math\">S_{i+1}</span> is the next one. At any point in time, only one sequencer is active and has a lock over the rollup state.</p>\n<p>Here are two strategies that sequencer <span class=\"math\">S_i</span> can explore to maximize its expected value:</p>\n<p><strong>1. Delaying the inclusion of transactions</strong></p>\n<p>Suppose a user sends a transaction to <span class=\"math\">S_i</span> at a certain L2 slot. Then, the sequencer could wait some time before inserting the transaction into a block in order to extract more MEV with sandwich attacks in collaboration with searchers or by directly front-running the user. In particular, <a href=\"https://www.youtube.com/watch?v=01dnINiLhAk&amp;t=287s\" rel=\"noopener nofollow ugc\">since MEV grows superlinearly with time</a>, it’s not in the sequencer’s best interest to commit early to a transaction. The worst case scenario would be the sequencer delaying inclusion until the sequencer rotation <span class=\"math\">^1</span>.</p>\n<p><strong>2. Not publishing unsafe heads in the rollup peer-to-peer network</strong></p>\n<p>In this setting the sequencer has low incentives to publish the unsafe heads in the rollup network: since L2 blocks are signed by the sequencer (e.g. in <a href=\"https://docs.optimism.io/builders/node-operators/configuration/consensus-config#p2psequencerkey\" rel=\"noopener nofollow ugc\">Optimism</a>), they act as a binding commitment which can be used by users to slash it in case of equivocations.</p>\n<p>This has a major downstream consequence on the UX of the rollup: both the next sequencer and users need to wait until a batch is included to see the latest transactions. For users it means they won’t know the status of their transactions in a timely manner, while the next sequencers risks building blocks on invalid state.</p>\n<p>We will now explore mechanisms to mitigate these behaviours and introduce slashing conditions for sequencers.</p>\n<h2><a name=\"p-49826-primitive-1-transaction-deadlines-3\" class=\"anchor\" href=\"https://ethresear.ch#p-49826-primitive-1-transaction-deadlines-3\"></a>Primitive 1: Transaction Deadlines</h2>\n<p>We introduce a new EIP-2718 transaction type with an additional field:</p>\n<ul>\n<li><code>deadline</code> - <code>uint256</code> indicating the last L2 block number for which the transaction is considered valid.</li>\n</ul>\n<p>This idea is not entirely new. For instance, the <a href=\"https://limechain.tech/\" rel=\"noopener nofollow ugc\">LimeChain</a> team has explored this in their <a href=\"https://github.com/LimeChain/based-preconfirmations-research/blob/cfc3830c685965fad5e5843533c5586dcb92e873/docs/preconfirmations-for-vanilla-based-rollups.md#preconfirmation-deadline\" rel=\"noopener nofollow ugc\">Vanilla Based Sequencing</a> article. However, in our variant the <code>deadline</code> field is signed as part of the transaction payload and it is not expressed in L1 slots.</p>\n<p>The reasoning behind it is that the sequencer cannot tamper with either the <code>deadline</code> field or <code>block.number</code> (because it is a monotonically increasing counter), and therefore it is easy to modify the L2 derivation pipeline to attribute a fault in case the sequencer inserts the user transaction in a block where <code>block.number &gt; deadline</code>.</p>\n<p>This approach mitigates problem <span class=\"hashtag-raw\">#1</span>. However, it does not in any way solve the <em>responsiveness</em> issue, since sequencers can still delay proposing the block in order to extract more MEV.</p>\n<h2><a name=\"p-49826-primitive-2-ethereum-as-a-global-clock-4\" class=\"anchor\" href=\"https://ethresear.ch#p-49826-primitive-2-ethereum-as-a-global-clock-4\"></a>Primitive 2: Ethereum as a Global Clock</h2>\n<p>A simple rotating sequencer design would be one where <span class=\"math\">S_i</span> loses the power to settle batches after the end of its sequencing window <span class=\"math\">W_i</span>, which is dictated by an L1 smart contract. However, the sequencer still needs some time to post the batch with the latest L2 blocks. We therefore introduce an <em>inclusion window</em> that is shifted <span class=\"math\">n \\geq 1</span> slots ahead of <span class=\"math\">W_i</span>, where <span class=\"math\">S_i</span> still has time to land rollup batches on L1 with the last L2 blocks, even if the responsibility of sequencing has shifted to <span class=\"math\">S_{i+1}</span>.</p>\n<p>In case of any safety fault, the sequencer should be slashed. If the sequencer has not managed to post all their assigned L2 blocks by the end of its inclusion window, it will forego all associated rewards. Optionally, there could also be penalties for liveness faults. This also helps with the problem of collaboration with the next sequencer, by ensuring that the latest blocks will be known to it within <span class=\"math\">n\\cdot12</span> seconds. Ideally, we’d like to keep <span class=\"math\">n</span> as small as possible with a value of <span class=\"math\">1</span>.</p>\n<p>There are still some potential issues here: getting a transaction included on Ethereum is probabilistic, meaning that you can’t be sure that a transaction you send will actually be included in time. In this context it means that the last batch sent by an honest leader may not be included in the L1 by the end of its inclusion window. This can be helped with two approaches:</p>\n<ul>\n<li>A “based” setup, where the sequencer is also the L1 block proposer and can include any transactions right up to the point they have to propose, or</li>\n<li>Using proposer commitments with a protocol like <a href=\"https://boltprotocol.xyz\" rel=\"noopener nofollow ugc\">Bolt</a>. We expand more on this in the <em>”Further work”</em> section below.</li>\n</ul>\n<p>Note that we assume there is a registry smart contract that can be consulted for the currently active sequencer, i.e. it implements some leader election mechanism and takes care of sequencer bonds along with rewards and penalties. It is up to the rollup governance to decide whether the registry can be fully permissionless or if it should use an allowlist. In case of any misbehaviour, governance would be used to temporarily or permanently remove the sequencer from the allowlist.</p>\n<h2><a name=\"p-49826-primitive-3-verifiable-delay-functions-5\" class=\"anchor\" href=\"https://ethresear.ch#p-49826-primitive-3-verifiable-delay-functions-5\"></a>Primitive 3: Verifiable Delay Functions</h2>\n<p><a href=\"https://medium.com/iovlabs-innovation-stories/verifiable-delay-functions-8eb6390c5f4\" rel=\"noopener nofollow ugc\">Verifiable Delay Functions</a> (VDFs henceforth) are a cryptographic primitive that allows a prover to show a verifier that a certain amount of time was spent running a function, and do it in a way that the verifier can check the result quickly.</p>\n<p>For instance, consider a cryptographic hash function <span class=\"math\">h</span> and define the application</p>\n<div class=\"math\">\nH(n,s) := (h \\circ \\underset{n\\ times}\\dots \\circ h)(s),\n</div>\n<p>where <span class=\"math\">s</span> is a byte array an <span class=\"math\">n</span> is a natural number.</p>\n<p>Composing (or chaining) hash functions like SHA-256 cannot be trivially sped up using parallel computations, but the solution lacks efficient verification <span class=\"math\">^2</span> as the only way to verify the result is to recompute the composition of functions. This solution appeared as a naïve VDF in <a href=\"https://eprint.iacr.org/2018/601.pdf\" rel=\"noopener nofollow ugc\">Boneh’s paper</a>, and for this reason it is referred to as <em>weak</em>.</p>\n<p>Another example of VDF is <a href=\"https://people.csail.mit.edu/rivest/pubs/RSW96.pdf\" rel=\"noopener nofollow ugc\">iterated squaring over a group of hidden order</a>, with which it is possible to construct time-lock puzzles. We’ll explore the usage of the latter in the next sections.</p>\n<h3><a name=\"p-49826-why-vdfs-tho-6\" class=\"anchor\" href=\"https://ethresear.ch#p-49826-why-vdfs-tho-6\"></a>Why VDFs tho?</h3>\n<p>VDFs are very useful in the context of sequencing because they can act as a <em>proof of elapsed time</em> for the duration of the block (specifically <code>block_time</code> / <code>max_adversary_speedup</code>, see <em>“Security Considerations”</em>). Consider the following algorithm for the block production pipeline:</p>\n<ol>\n<li>At the beginning of L2 block <span class=\"math\">N</span>, the sequencer starts computing a VDF that takes an L2 block time (or slightly less) to compute for honest players, using the previous block hash as its input.</li>\n<li>After the end of the L2 slot the sequencer builds a block <span class=\"math\">B_N</span> where the header contains the result of the VDF, denoted <span class=\"math\">V_N</span>. We call this <em>sealing</em> a block. This means the block hash digest contains <span class=\"math\">V_N</span>.</li>\n</ol>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/6/8/6802ae3a20554489b1de7ccb7a9ecda502a79c39.png\" data-download-href=\"https://ethresear.ch/uploads/default/6802ae3a20554489b1de7ccb7a9ecda502a79c39\" title=\"\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/6/8/6802ae3a20554489b1de7ccb7a9ecda502a79c39_2_690x317.png\" alt=\"\" data-base62-sha1=\"eQ7oNIzFfBcY49ZF4Xxt37sIgtP\" width=\"690\" height=\"317\" role=\"presentation\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/6/8/6802ae3a20554489b1de7ccb7a9ecda502a79c39_2_690x317.png, https://ethresear.ch/uploads/default/optimized/3X/6/8/6802ae3a20554489b1de7ccb7a9ecda502a79c39_2_1035x475.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/6/8/6802ae3a20554489b1de7ccb7a9ecda502a79c39_2_1380x634.png 2x\" data-dominant-color=\"EFF2F1\"></a></div><p></p>\n<p>This algorithm has the nice property of creating a chain of VDF computations, in some sense analogous to <a href=\"https://solana.com/news/proof-of-history\" rel=\"noopener nofollow ugc\">Solana’s Proof of History</a> from which we inherit the security guarantees. What does this give us in the sequencer context? If we remember that a sequencer has a certain deadline by which it has to post batches set by the L1 slot schedule, we can have the L1 enforce that <em>at least</em> some number of L2 blocks need to be settled. This has two downstream results:</p>\n<ul>\n<li>The sequencer <em>must</em> start producing and sealing blocks as soon as their sequencing window starts. Pairing this with the transaction deadline property results in an upper bound of time for when a transaction can be confirmed. If they don’t follow the block schedule set by the VDF and the L1, they risk not being able to post <em>any</em> batch.</li>\n<li>We mitigate problem <span class=\"hashtag-raw\">#2</span> by taking away the incentive to withhold data (not considering pure griefing attacks): this is because the sequencer cannot tamper with an existing VDF chain, which would require recomputing all the subsequent VDFs and result in an invalid batch.</li>\n</ul>\n<p>In general, for the sake of this post we will consider a generic VDF, provided as a “black box” while keeping the hash chain example in mind which currently has stronger guarantees against ad-hoc hardware such ASICs. See <em>“Security Considerations”</em> below for more insights.</p>\n<h3><a name=\"p-49826-proving-correct-vdfs-7\" class=\"anchor\" href=\"https://ethresear.ch#p-49826-proving-correct-vdfs-7\"></a>Proving correct VDFs</h3>\n<p>If a sequencer provides an invalid VDF in an L2 block header it should be slashed, and ideally we’d like to ensure this at settlement time. However, recalculating a long hash chain on the EVM is simply unfeasible due to gas costs.</p>\n<p>How to show then that the number of iterations of the VDF is invalid? One way could be to enforce it optimistically (or at settlement, in case of ZK-rollups) by requiring a valid VDF chain output in the derivation pipeline of the rollup. In case of equivocation in an optimistic rollup the sequencer can be challenged using fraud proofs.</p>\n<h3><a name=\"p-49826-hardware-requirements-8\" class=\"anchor\" href=\"https://ethresear.ch#p-49826-hardware-requirements-8\"></a>Hardware requirements</h3>\n<p>Since by definition VDFs cannot be sped up using parallelism, it follows that computing a VDF can be done by only using a single core of a CPU, and so it does in our block production algorithm.</p>\n<p>This makes it different and way more lightweight compared to most Proof-of-Work consensus algorithms such as Bitcoin’s which requires scanning for a value such that, when hashed with SHA-256, the hash begins with a certain number of zero bits.</p>\n<p>It’s also worth to note that modern CPUs are optimized to compute the SHA-256 hash function. Since 2016 Intel, starting with the <em>Goldmount</em> family of chips, is offering <a href=\"https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sha-extensions.html\" rel=\"noopener nofollow ugc\">SHA Extensions</a> in the <em>Core</em> and <em>Xeon</em> line-ups on selected models which introduces three new instructions specialized in computing different steps of the hash function algorithm more efficiently.</p>\n<p>Lastly, <a href=\"https://www.man.com/single-core-stagnation-and-the-cloud\" rel=\"noopener nofollow ugc\">single-core performance has stagnated over the years</a> indicating that there is a minor benefit in investing in the latest generation of CPUs, thus lowering down the requirements of the system.</p>\n<h2><a name=\"p-49826-case-study-mr-mev-boost-9\" class=\"anchor\" href=\"https://ethresear.ch#p-49826-case-study-mr-mev-boost-9\"></a>Case Study: MR-MEV-Boost</h2>\n<p><a href=\"https://ethresear.ch/t/based-preconfirmations-with-multi-round-mev-boost/20091\">Multi-Round-MEV-Boost</a>, is a modification of MEV-Boost that enables based preconfirmations by running multiple rounds of MEV-Boost auctions within a single L1 slot. The usage of this primitive is to output after each round a based rollup block built by L2 block builders. As shown in the article, this approach inherits the L1 PBS pipeline and mitigates some of the negative externalities of based preconfirmations as a result.</p>\n<p>Like MEV-Boost, this fork relies on the opted-in proposer to be an auctioneer which ends the sealed auction by calling the <code>getHeader</code> (<a href=\"https://ethereum.github.io/builder-specs/#/Builder/getHeader\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">Builder-API</a>) endpoint of the relays. After having signed the sealed bid, the <code>getPayload</code> (<a href=\"https://ethereum.github.io/builder-specs/#/Builder/submitBlindedBlock\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">Builder-API</a>) is called by the proposer to receive the actual content of the winning bid and to publish the block in the based rollup network.</p>\n<p>In the original protocol, the end of the auction usually coincides with the end of the L1 slot (more precisely, <a href=\"https://mevboost.pics/\" rel=\"noopener nofollow ugc\">near one second after it</a>); delaying it results in a high risk of not being able to broadcast the block in time to gather all the needed attestation and forgo all its associated rewards. As such, a block time is proposed every twelve seconds with consistency, enforced by Ethereum consensus.</p>\n<p>In contrast, given it consists of multiple rounds happening <em>during</em> the slot, in MR-MEV-Boost an <em>untrusted proposer is incentivized to end the auction seconds later or earlier <span class=\"math\">^{3}</span> according to the incoming bids,</em> in order to extract more more MEV. In the worst case, MR-MEV-Boost will reflect L1 block times. Another consequence of this is an inconsistent slot time for the based rollup. This can be seen as a much more serious form of timing games.</p>\n<p>In the article, the discussed possible solutions to this problem are the following:</p>\n<ol>\n<li>Introduce user incentives: if users determine that a proposer is misbehaving, they stop sending transactions to said proposer.</li>\n<li>Introduce a committee (consensus) to attest to timeliness and maintain slot durations.</li>\n</ol>\n<p>We now argue that a trustless solution that strongly limits the proposer without requiring actions from the user does exist, and it leverages the same construction we used for the VDF-powered block production algorithm in the context of decentralized sequencing.</p>\n<p>The construction is fairly simple and consists of computing a VDF that lasts <span class=\"math\">x := 12/r</span> seconds, where <span class=\"math\">r</span> is the number of rounds in an L1 slot (the L2 block time). The proposer must calculate this VDF using the previous based rollup block hash as public input and, at the end of the round, sending it along with the body of a modified <code>getPayload</code> call. The output of the VDF is then stored in the rollup block header and if invalid can result in slashing the proposer after a successful fraud proof.</p>\n<p>With this approach the amount of time a proposer can delay the end of a round is limited: for instance if the first auction ended one second later then during the last round it won’t be able to provide three seconds of computation for the VDF but two, resulting in an invalid block and consequent slashing <span class=\"math\">^4</span>. This is because in order to start computing a valid VDF, it requires the previous block hash as its input, implying a sealed block.</p>\n<h2><a name=\"p-49826-security-considerations-10\" class=\"anchor\" href=\"https://ethresear.ch#p-49826-security-considerations-10\"></a>Security Considerations</h2>\n<p><strong>Are VDFs really safe for this purpose?</strong><br>\nSuppose an adversary owns hardware which is capable of computing the VDF faster compared to the baseline of honest players <em>without getting noticed</em> (otherwise the number of iterations for the VDF is adjusted by the protocol). Then, the faster the attacker (<code>max_adversary_speedup</code>), the less our construction would constrain the space of its possible actions. In particular, the sequencer would be able to commit a bit later to blocks and be able to re-organize some of them for extracting more value.</p>\n<p>However, given we don’t need the “fast proving” property, hash-chains have proven to be robust with Solana’s Proof of History and will continue to be at least in the short-term. Also, our security requirements will not be as strict as something that <a href=\"https://ethresear.ch/t/statement-regarding-the-public-report-on-the-analysis-of-minroot/16670\">needs to be enshrined in Ethereum</a> forever.</p>\n<p>Some solutions and directions to get stronger safety guarantees can be found in the <em>”Further work”</em> section below.</p>\n<h2><a name=\"p-49826-current-limitations-11\" class=\"anchor\" href=\"https://ethresear.ch#p-49826-current-limitations-11\"></a>Current limitations</h2>\n<p><strong>Sequencer credibility</strong></p>\n<p>As with many new services which leverage (re)staking, the credibility of the sequencer has an upper bound which is the amount it has staked: if a MEV opportunity exceeds that, then a rational untrusted actor would prefer to get slashed and take the MEV reward.</p>\n<p><strong>Leader rotation can be a critical moment</strong></p>\n<p>As discussed in the batcher and registry smart contract section, the inclusion window is shifted of one slot forward at minimum compared to the sequencing window. This is needed because of the time required to settle the last batch before rotating leader, but leaves an additional slot time of at least 12 seconds in which the sequencer has room to re-organize the last L2 blocks before publishing them on the rollup peer-to-peer network. As a consequence, liveness is harmed temporarily because <span class=\"math\">S_{i+1}</span> might be building blocks on invalid state if it starts to sequence immediately.</p>\n<p>Lastly, one additional slot might not be enough to settle a batch according to recent data on <a href=\"https://ethresear.ch/t/slot-inclusion-rates-and-blob-market-combinatorics/19817\">slot inclusion rates for blobs</a>. This can be mitigated by leveraging new inclusion preconfirmation protocols, as explained below.</p>\n<p><strong>Sequencer last-look</strong></p>\n<p>Our construction makes very difficult for a sequencer to reorg a block after it has been committed to, however it doesn’t solve front-running in its entirety. In particular, the sequencer may extract value from users transactions while building the block with associated <code>deadline</code> field. A possible solution along with its limitations is explored in the section below.</p>\n<h2><a name=\"p-49826-conclusion-12\" class=\"anchor\" href=\"https://ethresear.ch#p-49826-conclusion-12\"></a>Conclusion</h2>\n<p>In this article, we explored mechanisms to enforce the timeliness, safety, and non-extractive ordering of untrusted L2 sequencers in a decentralized rollup environment.<br>\nThe primitives discussed ensure that sequencers can act more predictably and fairly, mitigating issues such as transaction delays and data withholding. Moreover, these techniques can reduce trust assumptions for existing single-sequencer rollups, aligning with the concept of rollups functioning as <a href=\"https://vitalik.eth.limo/general/2024/06/30/epochslot.html#what-should-l2s-do\" rel=\"noopener nofollow ugc\">“servers with blockchain scaffolding”</a>. These findings provide a robust framework for the future development of decentralized, secure rollup architectures.</p>\n<h2><a name=\"p-49826-further-work-13\" class=\"anchor\" href=\"https://ethresear.ch#p-49826-further-work-13\"></a>Further work</h2>\n<p><strong>Trusted Execution Environments (TEEs) to ensure the sequencer is not running an ASIC</strong></p>\n<p>A <a href=\"https://en.wikipedia.org/wiki/Trusted_execution_environment\" rel=\"noopener nofollow ugc\">Trusted Execution Environment</a> is a secure area of a CPU, often called <em>enclave</em>, that helps the code and data loaded inside it be protected with respect to confidentiality and integrity.<br>\nIts usage in blockchain protocols is an active area of research, with the main concerns being trusting the hardware manufacturer and the <a href=\"https://en.wikipedia.org/wiki/Software_Guard_Extensions\" rel=\"noopener nofollow ugc\">various vulnerabilities found in the past</a> of some implementations (here’s the <a href=\"https://x.com/_markel___/status/1828112469010596347\" rel=\"noopener nofollow ugc\">latest</a>).<br>\nDepending on the use case these trust assumptions and vulnerabilities might be a deal-breaker. However, in our setting we just need a guarantee that the sequencer is not using specialized hardware for computing the VDF, without caring about possible leakage of confidential data from the enclave or manipulation of the wall clock / monotonic clock.</p>\n<p><strong>Adapt existing anti-ASICs Proof-of-Work algorithms</strong></p>\n<p>The <a href=\"https://www.getmonero.org/resources/about/\" rel=\"noopener nofollow ugc\">Monero</a> blockchain, launched in 2014 as a privacy and untraceable-focused alternative to Bitcoin, uses an ASIC-resistant Proof-of-Work algorithm called <a href=\"https://github.com/tevador/RandomX\" rel=\"noopener nofollow ugc\">RandomX</a>. Quoting their <code>README</code>:</p>\n<blockquote>\n<p>RandomX is a proof-of-work (PoW) algorithm that is optimized for general-purpose CPUs. RandomX uses random code execution (hence the name) together with several memory-hard techniques to minimize the efficiency advantage of specialized hardware.</p>\n</blockquote>\n<p>The algorithm however leverages <a href=\"https://github.com/tevador/RandomX/blob/102f8acf90a7649ada410de5499a7ec62e49e1da/README.md#cpu-performance\" rel=\"noopener nofollow ugc\">some degree of parallelism</a>; it is an interesting research direction whether it can adapted into a single-core version, leading to a new weak-VDF.<br>\nThis approach, while orthogonal to using a TEE, can potentially achieve the same result which is having a guarantee that the sequencer is not using sophisticated hardware.</p>\n<p><strong>Time-lock puzzles to prevent front-running</strong></p>\n<p>As mentioned in the <em>“Current limitations”</em> section, our construction doesn’t limit the problem of sequencer front-running the users. Luckily, this can be solved by requiring users to encrypt sensitive transactions using <a href=\"https://people.csail.mit.edu/rivest/pubs/RSW96.pdf\" rel=\"noopener nofollow ugc\">time-lock puzzles</a>, as we will show in more detail in a separate piece. However, this solution doesn’t come free: encrypted transactions or encrypted mempools can incentive spamming and statistical arbitrage, <a href=\"https://collective.flashbots.net/t/it-s-time-to-talk-about-l2-mev/3593\" rel=\"noopener nofollow ugc\">especially when the protocol fees are not very high</a>.</p>\n<p><strong>Inclusion Preconfirmations and Data Availability layers</strong></p>\n<p>Batch submissions to an L1 contract could be made more efficient by leveraging some of the new preconfirmations protocol like <a href=\"https://boltprotocol.xyz\" rel=\"noopener nofollow ugc\">Bolt</a> by Chainbound or <a href=\"https://docs.primev.xyz/concepts/what-is-mev-commit\" rel=\"noopener nofollow ugc\">MEV-Commit</a> by Primev to have guaranteed inclusion in the same slot. In particular, sequencing windows should end precisely in the slot before one where the proposer is running the aforementioned protocols in order to leverage inclusion commitments.</p>\n<p>Additionally, the batch could be posted into an efficient and lightweight Data Availability layer run by proposers to enforce a deadline of a configurable amount of seconds in the beginning of the slot, otherwise the sequencer would be slashed.</p>\n<p><img src=\"https://ethresear.ch/uploads/default/original/3X/b/e/bed5956f14947f6e30a081e3064cd2a196897c95.png\" alt=\"\" data-base62-sha1=\"recjREgksTDOyP0hRd7Jx5a9rUx\" width=\"328\" height=\"190\" role=\"presentation\"></p>\n<hr>\n<h2><a name=\"p-49826-footnotes-14\" class=\"anchor\" href=\"https://ethresear.ch#p-49826-footnotes-14\"></a>Footnotes</h2>\n<ol>\n<li>More precisely, if an operator controls multiple subsequent sequencers it could delay inclusion until the last sequencer rotation.</li>\n<li>In Solana, the verification of a SHA-256 chain is actually parallelised but requires dividing a block associated to a ~400ms computation into 32 shreds which are forwarded to the rest of the validators as soon as they’re computed. As such, verification is sped up by computing the intermediate steps of the hash chain in parallel.</li>\n<li>In general, the proposer will end some rounds earlier as a side effect of delaying other rounds. For example, it could force a longer last round to leverage possible L1 &lt;&gt; L2 arbitrage opportunities.</li>\n<li>There is an edge case where the proposer might not be able to compute all the VDFs even if honest, and it is due to the rotation mechanism: since the public input of the VDF must be the previous rollup block hash, during rotation the next leader will need some time before hearing the block from the rollup network, potentially more than 1s. This could lead the next proposer to be late in computing the VDFs.<br>\nTo reduce this risk, the next proposer could rely on various parties to receive this information such as streaming services and/or trusted relays.</li>\n</ol>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://ethresear.ch/t/exploring-verifiable-continuous-sequencing-with-delay-functions/20362\">Read full topic</a></p>","link":"https://ethresear.ch/t/exploring-verifiable-continuous-sequencing-with-delay-functions/20362","pubDate":"Fri, 30 Aug 2024 14:29:49 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20362"},"source":{"@url":"https://ethresear.ch/t/exploring-verifiable-continuous-sequencing-with-delay-functions/20362.rss","#text":"Exploring Verifiable Continuous Sequencing with Delay Functions"}},{"title":"PeerDas Documentation","dc:creator":"arantxazapico","category":"Sharding","description":"<p>Joint work with <a class=\"mention\" href=\"https://ethresear.ch/u/b-wagn\">@b-wagn</a>, <a href=\"https://eprint.iacr.org/2024/1362.pdf\" rel=\"noopener nofollow ugc\">A Documentation of Ethereum’s PeerDAS</a></p>\n<p>The long-term vision of the Ethereum community includes a comprehensive data availability protocol using polynomial commitments and tensor codes. As the next step towards this vision, an intermediate solution called PeerDAS is about to integrated, to bridge the way to the full protocol. With PeerDAS soon becoming an integral part of Ethereum’s consensus layer, understanding its security guarantees is essential.</p>\n<p>The linked document aims to describe the cryptography used in PeerDAS in a manner accessible to the cryptographic community, encouraging innovation and improvements, and to explicitly state the security guarantees of PeerDAS. We focus on PeerDAS as described in Ethereum’s consensus specifications [<a href=\"https://github.com/ethereum/consensus-specs/commit/54093964c95fbd2e48be5de672e3baae8531a964\" rel=\"noopener nofollow ugc\">Eth24a</a>, <a href=\"https://github.com/ethereum/consensus-specs/tree/dev/specs/_features/eip7594\" rel=\"noopener nofollow ugc\">Eth24b</a>].</p>\n<p>Our intention is two-fold: first, we aim to provide a description of the cryptography used in PeerDAS that is accessible to the cryptographic community, potentially leading to new ideas and<br>\nimprovements that can be incorporated in the future. Second, we want to explicitly state the security and efficiency guarantees of PeerDAS. In terms of security, this document justifies the following claim:<br>\n<strong>Theorem 1</strong> (Main Theorem, Informal): <em>Assuming plausible cryptographic hardness assumptions, PeerDAS is a secure data availability sampling scheme in the algebraic group model, according to the definition in [<a href=\"https://eprint.iacr.org/2023/1079\" rel=\"noopener nofollow ugc\">HASW23</a>].</em></p>\n<p>We hope to receive feedback from the community to make further improvements to this document</p>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://ethresear.ch/t/peerdas-documentation/20361\">Read full topic</a></p>","link":"https://ethresear.ch/t/peerdas-documentation/20361","pubDate":"Fri, 30 Aug 2024 12:56:35 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20361"},"source":{"@url":"https://ethresear.ch/t/peerdas-documentation/20361.rss","#text":"PeerDas Documentation"}},{"title":"Accessible Encryption for Ethereum Rollups with Fairomon","dc:creator":"shakeshack","category":"Layer 2","description":"<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/5/f/5fa5f78d2b4b44708e03133cf29d1de097113e36.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/5fa5f78d2b4b44708e03133cf29d1de097113e36\" title=\"690x435\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/5/f/5fa5f78d2b4b44708e03133cf29d1de097113e36_2_690x435.jpeg\" alt=\"690x435\" data-base62-sha1=\"dE8WqnkBYhOZifIQKA4YkTkYm1w\" width=\"690\" height=\"435\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/5/f/5fa5f78d2b4b44708e03133cf29d1de097113e36_2_690x435.jpeg, https://ethresear.ch/uploads/default/optimized/3X/5/f/5fa5f78d2b4b44708e03133cf29d1de097113e36_2_1035x652.jpeg 1.5x, https://ethresear.ch/uploads/default/original/3X/5/f/5fa5f78d2b4b44708e03133cf29d1de097113e36.jpeg 2x\" data-dominant-color=\"B5B5B8\"></a></div><p></p>\n<p>Co-authored by <a class=\"mention\" href=\"https://ethresear.ch/u/pememoni\">@pememoni</a> and <a class=\"mention\" href=\"https://ethresear.ch/u/shakeshack\">@shakeshack</a>. With special thanks to the rest of the Fairblock team!</p>\n<p>Fairomon is a special fairy type pokemon that combines the work of Fairblock and Monomer - a framework that enables builders to create Ethereum rollups with built-in encryption with minimal lift.</p>\n<h1><a name=\"p-49798-background-1\" class=\"anchor\" href=\"https://ethresear.ch#p-49798-background-1\"></a>Background</h1>\n<p>Monomer is a rollup framework that enables Cosmos SDK app chains to be deployed as rollups on Ethereum. Internally, Monomer is built on top of the OP stack relying on it for chain derivation and settlement while supporting an ABCI interface for a Cosmos SDK app chain to be deployed on top. Fairblock provides threshold MPC encryption that can be utilized in Monomer rollups through a module built for Cosmos SDK chains.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/2/3/2311821ac2a3b134e2df081bbf12f2d71f2c31cc.png\" data-download-href=\"https://ethresear.ch/uploads/default/2311821ac2a3b134e2df081bbf12f2d71f2c31cc\" title=\"451x500\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/2/3/2311821ac2a3b134e2df081bbf12f2d71f2c31cc_2_451x500.png\" alt=\"451x500\" data-base62-sha1=\"50edNT7A2IU2M9DMxkY6SJ1Swxe\" width=\"451\" height=\"500\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/2/3/2311821ac2a3b134e2df081bbf12f2d71f2c31cc_2_451x500.png, https://ethresear.ch/uploads/default/optimized/3X/2/3/2311821ac2a3b134e2df081bbf12f2d71f2c31cc_2_676x750.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/2/3/2311821ac2a3b134e2df081bbf12f2d71f2c31cc_2_902x1000.png 2x\" data-dominant-color=\"F8F8F8\"></a></div><p></p>\n<p>Fairblock enables blockchain developers to integrate pre-execution encryption. This pre-execution encryption is made possible through their threshold MPC network that delivers identity-based encryption (IBE), and soon custom encryption schemes, to partner chains. Fairblock’s MPC network, called Fairyring, generates threshold encryption and decryption keys for each supported Monomer rollup, while the rollups themselves receive and process encrypted transactions natively.</p>\n<h1><a name=\"p-49798-how-it-works-2\" class=\"anchor\" href=\"https://ethresear.ch#p-49798-how-it-works-2\"></a>How it Works</h1>\n<p>FairyRing uses decentralized key generation to issue a master secret key (MSK) for each epoch (every 100 blocks). From each MSK, a master public key (MPK) can be derived. Once the MPK is derived, it is relayed to a Monomer chain where it will be used to encrypt each requested transaction. In parallel, the MSK is split into equal shares for the amount of FairyRing validators participating in the network. For each request for decryption, FairyRing validators use their share of the MSK to collectively derive the associated private keys.</p>\n<p>In threshold IBE, users or developers can program the decryption conditions for transactions. Onchain conditions that could trigger decryption could be a block height, the price of an asset, a smart contract call, verification of a ZK proof, or the end of a governance poll, for example. Identity-based encryption allows for the programmability of decryption and allows for decryption to be triggered by “IDs,” which can be either onchain conditions or on/offchain identifiers or attributes that certain wallets prove ownership of.</p>\n<h1><a name=\"p-49798-whats-possible-with-fairomon-3\" class=\"anchor\" href=\"https://ethresear.ch#p-49798-whats-possible-with-fairomon-3\"></a>What’s Possible with Fairomon</h1>\n<p>MPC encryption can make a number of previously inaccessible applications possible within rollups, most notably encrypted mempools, censorship-resistant sequencing, and DeFi and gaming apps such as encrypted orders, leaderless NFT auctions, ID-gated content, and highest-hand-wins card games like blackjack.</p>\n<p>The transaction flow for an application is as follows:</p>\n<ul>\n<li>User submits an encrypted tx and decryption condition (e.g. target height) to an app</li>\n<li>Chain receives encrypted txs in mempool</li>\n<li>Encrypted txs are sorted by target heights and ordering within a block is committed to inside of the integrated x/pep module</li>\n<li>When target height or decryption condition is reached, the app chain receives decryption key from the Fairyring chain</li>\n<li>Encrypted txs are decrypted and executed inside the BeginBlock method of the x/pep module</li>\n</ul>\n<p>See the architecture diagram below for a detailed description of how Fairyring integrates with a Monomer appchain.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/7/2/723cc342b05947059263449d26d5e63a0010c14a.png\" data-download-href=\"https://ethresear.ch/uploads/default/723cc342b05947059263449d26d5e63a0010c14a\" title=\"690x147\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/7/2/723cc342b05947059263449d26d5e63a0010c14a_2_690x147.png\" alt=\"690x147\" data-base62-sha1=\"giAC8NOqAwl6za4KBt4x9f9JiJk\" width=\"690\" height=\"147\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/7/2/723cc342b05947059263449d26d5e63a0010c14a_2_690x147.png, https://ethresear.ch/uploads/default/optimized/3X/7/2/723cc342b05947059263449d26d5e63a0010c14a_2_1035x220.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/7/2/723cc342b05947059263449d26d5e63a0010c14a_2_1380x294.png 2x\" data-dominant-color=\"F3F2EF\"></a></div><p></p>\n<p>Monomer links:</p>\n<ul>\n<li><a href=\"https://github.com/polymerdao/monomer\" rel=\"noopener nofollow ugc\">Github</a></li>\n<li><a href=\"https://github.com/polymerdao/monomer/tree/main/doc\" rel=\"noopener nofollow ugc\">Docs</a></li>\n</ul>\n<p>Fairblock links:</p>\n<ul>\n<li>\n<p><a href=\"https://www.fairblock.network/\" rel=\"noopener nofollow ugc\">Website</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/Fairblock\" rel=\"noopener nofollow ugc\">Github</a></p>\n</li>\n<li>\n<p><a href=\"https://docs.fairblock.network/docs/basics/overview\" rel=\"noopener nofollow ugc\">Docs</a></p>\n</li>\n</ul>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://ethresear.ch/t/accessible-encryption-for-ethereum-rollups-with-fairomon/20349\">Read full topic</a></p>","link":"https://ethresear.ch/t/accessible-encryption-for-ethereum-rollups-with-fairomon/20349","pubDate":"Wed, 28 Aug 2024 15:45:36 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20349"},"source":{"@url":"https://ethresear.ch/t/accessible-encryption-for-ethereum-rollups-with-fairomon/20349.rss","#text":"Accessible Encryption for Ethereum Rollups with Fairomon"}},{"title":"Outdated encryption stored on blockchain","dc:creator":"knev","category":"Security","description":"<p>Please pardon my ignorance. I’ve read several publications related to blockchain being used in healthcare, construction and the like. Many of these publications state that blockchain allows the storage of secured data.</p>\n<p>My question is this: If data is “securely” stored on blockchain (I assume encrypted) and the encryption algorithm LATER (after long-term usage) is proven to be “cryptographically broken” (e.g., SHA-1) …</p>\n<ul>\n<li>does this not mean all “secured” data on the blockchain using that algorithm is suddenly public?</li>\n<li>are there steps that can be taken to re-encrypt the data to avoid the massive leak of data?</li>\n</ul>\n<p>Kind regards.</p>\n            <p><small>7 posts - 4 participants</small></p>\n            <p><a href=\"https://ethresear.ch/t/outdated-encryption-stored-on-blockchain/20346\">Read full topic</a></p>","link":"https://ethresear.ch/t/outdated-encryption-stored-on-blockchain/20346","pubDate":"Wed, 28 Aug 2024 12:21:08 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20346"},"source":{"@url":"https://ethresear.ch/t/outdated-encryption-stored-on-blockchain/20346.rss","#text":"Outdated encryption stored on blockchain"}},{"title":"Does multi-block MEV exist? Analysis of 2 years of MEV Data","dc:creator":"pascalst","category":"Economics","description":"<h1><a name=\"p-49786-does-multi-block-mev-exist-analysis-of-2-years-of-mev-data-1\" class=\"anchor\" href=\"https://ethresear.ch#p-49786-does-multi-block-mev-exist-analysis-of-2-years-of-mev-data-1\"></a>Does multi-block MEV exist? Analysis of 2 years of MEV Data</h1>\n<p><em>by <a href=\"https://x.com/pascalstichler\" rel=\"noopener nofollow ugc\">Pascal Stichler</a> (<a href=\"https://www.ephema.io/\" rel=\"noopener nofollow ugc\">ephema labs</a>)</em></p>\n<p><em>Many thanks to <a href=\"https://x.com/nero_eth\" rel=\"noopener nofollow ugc\">Toni</a>, <a href=\"https://x.com/_julianma\" rel=\"noopener nofollow ugc\">Julian</a>, <a href=\"https://x.com/sui414\" rel=\"noopener nofollow ugc\">Danning</a>, <a href=\"https://x.com/cshg0x\" rel=\"noopener nofollow ugc\">Chris</a> and <a href=\"https://x.com/marc_nitzsche\" rel=\"noopener nofollow ugc\">Marc</a> for feedback and especially to <a href=\"https://x.com/barnabemonnot\" rel=\"noopener nofollow ugc\">Barnabé</a> for nudging the research in the first place and continuous feedback.</em></p>\n<h2><a name=\"p-49786-tldr-2\" class=\"anchor\" href=\"https://ethresear.ch#p-49786-tldr-2\"></a><em>TL;DR</em></h2>\n<ul>\n<li>We looked at proposer-builder data and MEV-Boost payment data since the merge (September 2022) to identify patterns of multi-block MEV.</li>\n<li>We observe fewer multi-slot sequences of builders than a random Monte Carlo simulation would predict. The longest observed multi-slot sequence is 25 slots.</li>\n<li>Average MEV-Boost payments increase for longer consecutive sequences by the same builder from ~0.05 ETH for single slots to ~0.08 ETH for nine consecutive slots.</li>\n<li>In longer sequences, the payment per slot increases slightly with later slots. This indicates that builders bid higher to get longer sequences or the first slot after a longer sequence.</li>\n<li>There is a weak positive autocorrelation between subsequent MEV-Boost payments. This contradicts the hypothesis that there are generally periods of low and high MEV.</li>\n<li>Comparing builders with periods of low and high base fee volatility shows a low correlation. This indicates that no builder specialization based on base fee volatility has developed yet.</li>\n</ul>\n<p><em>The detailed results can be found in the Jupyter notebook on <a href=\"https://github.com/ephema/MEVBoost-Analysis/blob/762b7626c57cc6a1c350059b41e272a70cda49cf/%5Bephema%5D_MEV_Boost_Multi_Slot_MEV_Analysis.ipynb\" rel=\"noopener nofollow ugc\">Github </a>or <a href=\"https://colab.research.google.com/drive/1kKM-da6xP7St8puzPuyn1Ndag6a6wsg3?usp=sharing\" rel=\"noopener nofollow ugc\">Google Colab</a>.</em></p>\n<h2><a name=\"p-49786-background-3\" class=\"anchor\" href=\"https://ethresear.ch#p-49786-background-3\"></a>Background</h2>\n<p>Multi-block Maximal Extractable Value (MMEV) occurs when one party controls more than one consecutive block. It was first introduced in 2021 by [<a href=\"https://arxiv.org/pdf/2109.04347\" rel=\"noopener nofollow ugc\">1</a>] as k-MEV and further elaborated by [<a href=\"https://eprint.iacr.org/2022/445.pdf\" rel=\"noopener nofollow ugc\">2</a>]. It is commonly assumed that controlling multiple slots in a sequence allows to capture significantly more MEV than controlling them individually. This derives from MEV accruing superlinearly over time. The <a href=\"https://collective.flashbots.net/t/multi-block-mev/457\" rel=\"noopener nofollow ugc\">most discussed</a> multi-block MEV strategies include <a href=\"https://eprint.iacr.org/2022/445.pdf\" rel=\"noopener nofollow ugc\">TWAP oracle manipulation attacks</a> on DEXes and producing forced liquidations by price manipulation.</p>\n<p>After the merge, [<a href=\"https://arxiv.org/pdf/2303.04430\" rel=\"noopener nofollow ugc\">3</a>] have looked into the first four months of data on multi-block MEV and summarized it as <em>“preliminary and non-conclusive results, indicating [that] builders employ super-linear bidding strategies to secure consecutive block space\"</em>.</p>\n<p>With the recent Attester-Proposer-Separation (APS) and pre-confirmation discussions, multi-block MEV has become more of a pressing issue again as it might be prohibitive for some of the proposed designs (For a more in-depth overview, we’ve created a <a href=\"https://miro.com/app/board/uXjVK07aBCU=/?share_link_id=220296247588\" rel=\"noopener nofollow ugc\">diagram of recently proposed mechanism designs</a> and also <a href=\"https://x.com/mikeneuder\" rel=\"noopener nofollow ugc\">Mike Neuder</a> lately gave a <a href=\"https://www.youtube.com/watch?v=ToVi-zsiE4M\" rel=\"noopener nofollow ugc\">comprehensive overview</a>).</p>\n<h2><a name=\"p-49786-methodology-4\" class=\"anchor\" href=\"https://ethresear.ch#p-49786-methodology-4\"></a>Methodology</h2>\n<p>In order to get a better understanding of the historical prevalence of multi-block MEV, we decided to look at all slots from the Merge in September ‘22 until May ‘24 (totalling roughly 4.3 million slots) and analyze the corresponding data on validators and builders and on MEV-boost payments (if applicable). The scope was to identify patterns of unusual consecutive slot sequences and accompanying MEV values. <a href=\"https://mevboost.pics/data.html\" rel=\"noopener nofollow ugc\">The data</a> has been kindly provided by Toni Wahrstätter and contains information per slot on relay, builder pubkey, proposer pubkey and MEV-Boost value as well as a builder pubkey and validator pubkey mapping. In the labeling of validators for our purposes staking pool providers such as Lido or Rocket Pool are treated as one entity.</p>\n<p>MEV-Boost payments are used as a proxy for the MEV per block. We acknowledge that this is only a non-perfect approximation. The ascending MEV-Boost first-price auction by its nature of being public essentially functions like a second price + 1 wei auction (thanks to Julian for pointing this out!). Hence, we strictly speaking only get an estimate of the intrinsic value of the second highest bidder. However, as [<a href=\"https://arxiv.org/pdf/2405.01329\" rel=\"noopener nofollow ugc\">4</a>] have observed more than 88% of MEV-Boost auctions were competitive and [<a href=\"https://arxiv.org/pdf/2407.13931\" rel=\"noopener nofollow ugc\">5</a>] concluded that the average profit margin per top three builder is between 1% and 5.4%, further indicating a competitive market between the top builders. Based on this, despite the limitations we deem it feasible to use the MEV-Boost payments as an approximation for the generated MEV per block.</p>\n<p>To establish a baseline of expected multi-slot sequences, a Monte Carlo simulation was conducted. In this simulation, builders were randomly assigned to each slot within the specified time period, based on their observed daily market share during that period. The frequency of consecutive slots, ranging in length from 1 to 25 (the longest observed sequence in the empirical data), was recorded. This procedure was repeated 100 times, and the average was taken. We decided to use daily market shares for the main analysis as in the investigated time period market shares have strongly shifted [4]. For comparison we also ran the analysis on monthly and overall market shares.</p>\n<p>Further, base fee volatility data has been included to cross-check effects of low and high-volatility periods. Previous research (e.g. [<a href=\"https://arxiv.org/pdf/2305.19150\" rel=\"noopener nofollow ugc\">6</a>] &amp; [<a href=\"https://arxiv.org/pdf/2401.01622\" rel=\"noopener nofollow ugc\">7</a>]) has focused on token price volatility effects based on CEX-prices. As we are interested in low- and high-MEV environments, we deem base fee volatility for our use case more fitting, as it is driven by empty or full blocks which are at least partially a result of the prevalence of MEV opportunities.</p>\n<h2><a name=\"p-49786-empirical-findings-5\" class=\"anchor\" href=\"https://ethresear.ch#p-49786-empirical-findings-5\"></a>Empirical Findings</h2>\n<h3><a name=\"p-49786-finding-1-fewer-multi-slot-sequences-exist-than-assumed-by-random-distribution-6\" class=\"anchor\" href=\"https://ethresear.ch#p-49786-finding-1-fewer-multi-slot-sequences-exist-than-assumed-by-random-distribution-6\"></a>Finding 1: Fewer multi-slot sequences exist than assumed by random distribution</h3>\n<p><strong></strong></p><div class=\"lightbox-wrapper\"><strong><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/b/6/b6ab4921507e70c619d5121b5abf611e67e2138f.png\" data-download-href=\"https://ethresear.ch/uploads/default/b6ab4921507e70c619d5121b5abf611e67e2138f\" title=\"\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/b/6/b6ab4921507e70c619d5121b5abf611e67e2138f_2_533x426.png\" alt=\"\" data-base62-sha1=\"q3XSoYCSA2iCGImNM9PoiLu7vfF\" width=\"533\" height=\"426\" role=\"presentation\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/b/6/b6ab4921507e70c619d5121b5abf611e67e2138f_2_533x426.png, https://ethresear.ch/uploads/default/optimized/3X/b/6/b6ab4921507e70c619d5121b5abf611e67e2138f_2_799x639.png 1.5x, https://ethresear.ch/uploads/default/original/3X/b/6/b6ab4921507e70c619d5121b5abf611e67e2138f.png 2x\" data-dominant-color=\"EFEEED\"></a></strong></div><br>\n<em>Figure 1: Comparison of statistically expected vs. observed multi-slot sequences (note that slots &gt; 25 have been summarized in slot 25 for brevity)</em><p></p>\n<p>Firstly, the prevalence of multi-slot sequences with the same builder proposing the block was investigated to determine if they are more common than would be expected by chance.</p>\n<p>Comparing the results of the Monte Carlo simulation as a baseline in expected distribution (blue) with the observed distribution (orange), it can be seen that significantly fewer multi-slot sequences occur than expected (Figure 1). The longest observed sequence was 25 slots and the longest sequence with the same validator (Lido) and builder (BeaverBuild) was 11 consecutive slots on March 4th, 2024 (more details with descriptive statistics in the <a href=\"https://colab.research.google.com/drive/1kKM-da6xP7St8puzPuyn1Ndag6a6wsg3#scrollTo=5bje4mIWzELq\" rel=\"noopener nofollow ugc\">notebook</a>). Running the same simulation on monthly or total market shares in the time period, the observation shifts to having more longer sequences than expected, however we attribute this to the statistical effect of changing market shares. A detailed analysis can be run in the <a href=\"https://colab.research.google.com/drive/1kKM-da6xP7St8puzPuyn1Ndag6a6wsg3#scrollTo=mz4CTqCQInTv\" rel=\"noopener nofollow ugc\">notebook</a> or be provided upon request.</p>\n<p>In the next step, to understand this in a more-fine-grained manner, the values are compared for each of the top 10 builders based on market shares. Therefore, for each builder, the difference between expected and observed occurrences of multi-slot sequences are plotted with the size of the bubble indicating the delta in Figure 2. The expected occurrences are based on the results of the Monte Carlo simulation. Red bubbles indicate a positive deviation (more observed slots than expected), while blue indicates a negative deviation. Green dots indicate values in line with the expectation. In Figure 2 it is shown in absolute numbers, in the <a href=\"https://colab.research.google.com/drive/1kKM-da6xP7St8puzPuyn1Ndag6a6wsg3#scrollTo=cd07f078-f646-450c-b610-9e91012111f2&amp;line=3&amp;uniqifier=1\" rel=\"noopener nofollow ugc\">notebook</a> it can also be seen on a relative scale.</p>\n<p><strong></strong></p><div class=\"lightbox-wrapper\"><strong><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/e/9/e94454973c4bf844c96e0a1735409a130a0983dd.png\" data-download-href=\"https://ethresear.ch/uploads/default/e94454973c4bf844c96e0a1735409a130a0983dd\" title=\"\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/e/9/e94454973c4bf844c96e0a1735409a130a0983dd_2_628x419.png\" alt=\"\" data-base62-sha1=\"xhzEauFL5pYwNguH7QOHbym4ba5\" width=\"628\" height=\"419\" role=\"presentation\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/e/9/e94454973c4bf844c96e0a1735409a130a0983dd_2_628x419.png, https://ethresear.ch/uploads/default/optimized/3X/e/9/e94454973c4bf844c96e0a1735409a130a0983dd_2_942x628.png 1.5x, https://ethresear.ch/uploads/default/original/3X/e/9/e94454973c4bf844c96e0a1735409a130a0983dd.png 2x\" data-dominant-color=\"F0F2F1\"></a></strong></div><br>\n<em>Image 2: Deviations between expected (Monte Carlo simulation) and observed multi-slot frequencies per builder</em><p></p>\n<p>It can be observed in the relative as well as in the absolute deviation that for the top builders there are more single slot sequences than expected with the exception of ETH-Builder, f1b and Blocknative. For multi-slot sequences with two or more slots, almost all top 10 builders have less than expected. This shows that the trend is not limited to singular entities but derives more from the general market structure.</p>\n<h3><a name=\"p-49786-finding-2-payments-for-multi-slot-sequences-are-higher-on-average-than-for-single-slots-7\" class=\"anchor\" href=\"https://ethresear.ch#p-49786-finding-2-payments-for-multi-slot-sequences-are-higher-on-average-than-for-single-slots-7\"></a>Finding 2: Payments for multi-slot sequences are higher on average than for single slots</h3>\n<p>To understand if multi-slot sequences are valuable, we looked into MEV-Boost payments and compared single-slot to multi-slot sequences (Figure 3).</p>\n<p><strong><img src=\"https://ethresear.ch/uploads/default/original/3X/b/5/b570ac276a9b9dc76883e6e89489c8792b0186e3.png\" alt=\"\" data-base62-sha1=\"pT5OX4pSyEtnUEhV9xaSdpAtBo7\" width=\"467\" height=\"342\" role=\"presentation\"></strong><br>\n<em>Figure 3: Average MEV-Boost payments per Sequence Length</em></p>\n<p>It can be observed that in accordance with previous work of [3], we observe higher average MEV payouts for longer consecutive sequences (from about 0.05 ETH for single slot sequences to around 0.08 ETH for sequences with nine consecutive slots). Note that the gray numbers in Figure 3 provide the sample size for each slot length. So it can be observed that the longer the sequence, almost linearly the average MEV-boost payment per slot in the sequence rises. At this stage of the research we can only speculate why this is the case. It could be driven by a higher value in longer consecutive sequences, but also by alternative effects. For example, Julian rightfully pointed out it could also be driven by an increasing intrinsic value for the second highest-bidder due to accumulating MEV in private order flow and the intrinsic valuation of the winning bidder remains constant. Or as Danning suggested, it might be driven by certain types of proprietary order flow (e.g. CEX-DEX arbitrage) being more valuable in certain time periods (e.g. volatile periods) leading to more consecutive sequences as well as higher MEV-Boost payments on average. For a more comprehensive answer and a more in-depth understanding, an analysis on the true block value (builder profits plus proposer payments) and potentially on individual tx level is necessary. We leave this open for future research.</p>\n<p>This trend also holds when plotting the average payments for each individual builder. The results on this are shown in the <a href=\"https://colab.research.google.com/drive/1kKM-da6xP7St8puzPuyn1Ndag6a6wsg3#scrollTo=e673f535-1bad-41aa-b617-fcdeee234f01&amp;line=3&amp;uniqifier=1\" rel=\"noopener nofollow ugc\">notebook</a>.</p>\n<h3><a name=\"p-49786-finding-3-per-slot-payments-also-increase-with-longer-sequences-8\" class=\"anchor\" href=\"https://ethresear.ch#p-49786-finding-3-per-slot-payments-also-increase-with-longer-sequences-8\"></a>Finding 3: Per Slot Payments also increase with longer sequences</h3>\n<p>Supplementary to the absolute average payment, we also looked into the payment per slot position in longer sequences (Figure 4). E.g. how much was on average paid for the third position in a longer sequence.</p>\n<p><strong><img src=\"https://ethresear.ch/uploads/default/original/3X/3/9/3910c4ca760a17b0ae0a9ec76bb90d27155b5e42.png\" alt=\"\" data-base62-sha1=\"88P8QepGXY3Oj7cs6LD3seQ38SC\" width=\"428\" height=\"333\" role=\"presentation\"></strong><br>\n<em>Figure 4: Average MEV-Boost payments per Sequence Position</em></p>\n<p>Also in the payment per slot analysis a similar trend can be observed, however less prevalent. This suggests that there is slight value in longer sequences, however builders are not willing to bid significantly more for longer consecutive sequences or the first slot after a longer sequence.</p>\n<p>This indicates for us that, at least so far, multi-slot strategies are not applied systematically. In this case, we expect builders would need to pay significantly higher values for later slots to ensure to capture the MEV opportunity prepared earlier.</p>\n<h3><a name=\"p-49786-finding-4-low-auto-correlation-between-consecutive-mev-boost-payments-9\" class=\"anchor\" href=\"https://ethresear.ch#p-49786-finding-4-low-auto-correlation-between-consecutive-mev-boost-payments-9\"></a>Finding 4: Low auto-correlation between consecutive MEV-Boost payments</h3>\n<p><strong></strong></p><div class=\"lightbox-wrapper\"><strong><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/9/d/9db050ae9f5aa540ea6f3c5b6270dee27e111380.png\" data-download-href=\"https://ethresear.ch/uploads/default/9db050ae9f5aa540ea6f3c5b6270dee27e111380\" title=\"\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/9/d/9db050ae9f5aa540ea6f3c5b6270dee27e111380_2_533x321.png\" alt=\"\" data-base62-sha1=\"muYIpGffs7YaMIKuLvKX3WKE9bi\" width=\"533\" height=\"321\" role=\"presentation\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/9/d/9db050ae9f5aa540ea6f3c5b6270dee27e111380_2_533x321.png, https://ethresear.ch/uploads/default/optimized/3X/9/d/9db050ae9f5aa540ea6f3c5b6270dee27e111380_2_799x481.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/9/d/9db050ae9f5aa540ea6f3c5b6270dee27e111380_2_1066x642.png 2x\" data-dominant-color=\"F7F6F5\"></a></strong></div><br>\n<em>Figure 5: Auto-correlation of MEV-Boost Payments</em><p></p>\n<p>We examined auto-correlation in the MEV boost payments to understand if historical MEV data allows us to forecast future MEV and to see if there are low- and high-MEV periods (Figure 5).</p>\n<p>Overall, it can be observed that within the first few slots the correlation strongly decreases until an offset of 2 to 3 slots (we tested for Pearson Correlation Coefficient, Spearman’s Rank Correlation Coefficient and Kendall’s Rank Correlation Coefficient). Based on this we can conclude that not more than one to three slots in advance the MEV value can be moderately predicted based on historical data.</p>\n<p>Further interesting observations can be made. As expected, the Spearman and Kendall correlation coefficients are significantly higher than the Pearson correlation coefficient, underlining that the data is not following a normal distribution but being skewed and having large outliers. Additionally, it is interesting to note that for the Pearson correlation coefficient, the complete data set and the top 50% quantile dataset behave similarly, which is not the case for the Spearman and Kendall coefficients. This might be an indicator that the rank ordering for the lower 50% quantile can be more reliably predicted, further underlying that high MEV values are volatile and spiky, hence difficult to predict.</p>\n<h3><a name=\"p-49786-finding-5-no-indication-of-builder-specialization-on-low-or-high-base-fee-volatility-environment-10\" class=\"anchor\" href=\"https://ethresear.ch#p-49786-finding-5-no-indication-of-builder-specialization-on-low-or-high-base-fee-volatility-environment-10\"></a>Finding 5: No indication of builder specialization on low- or high base fee volatility environment</h3>\n<p>Previous research (e.g. [6] &amp; [7]) has found that certain builders specialize in low- or high token price volatility environments, with volatility being measured on CEX-price changes. Further, [5] observe that different builders have different strategies with some focusing on high-value blocks while others on gaining market share in low-MEV blocks.</p>\n<p>Complementary, to determine whether low or high base fee volatility impacts (multi-block) MEV, we analyzed changes in base fee data to identify periods of high volatility. The base fee fluctuations are driven by whether the gas usage in the previous block was below or above the gas target, as defined by <a href=\"https://eips.ethereum.org/EIPS/eip-1559\" rel=\"noopener nofollow ugc\">EIP-1559</a>. To identify high volatility environments, we employed two methods: (i) a more naive approach that calculated price changes per slot, classifying the highest and lowest (negative) 10% of these changes as high volatility periods, with the remaining 80 % of slots being categorized as low volatility. Consequently, high volatility blocks occur following a block with either minimal or significant MEV and/or priority tips. (ii) Secondly, the Garman-Klass volatility [<a href=\"https://arxiv.org/pdf/0807.3492\" rel=\"noopener nofollow ugc\">8</a>] was calculated on an epoch basis, with slots in the top 20% of GK values designated as high volatility. This approach allows us to examine longer periods characterized by minimal or significant MEV and/or priority tips.</p>\n<p>Initial correlation analysis shows only a low correlation between low and high volatile periods and the respective builders (<a href=\"https://en.wikipedia.org/wiki/Cram%C3%A9r%27s_V\" rel=\"noopener nofollow ugc\">Cramér’s V</a> for the naive approach 0.0664 and for the Garman-Klass 0.0772). This indicates that there seems to be no builder specialization based on the volatility environment of the base fee. So, it can be observed that in contrast to token price volatility for base price volatility there seems to not have a specialization of builders developed (yet). Further research is needed to elaborate on this first finding.</p>\n<h2><a name=\"p-49786-limitations-11\" class=\"anchor\" href=\"https://ethresear.ch#p-49786-limitations-11\"></a>Limitations</h2>\n<p>The research presented here is intended as an initial exploratory analysis of the data rather than a comprehensive study. It is important to note several limitations that affect the scope and conclusions of this analysis. Firstly, it is limited by the considered data set being publicly available MEV-Boost payments data. This leaves out roughly 10 % of non-MEV-Boost facilitated blocks and it does not reflect potential private off-chain agreements. Additionally, the data was partially incomplete and in other parts contained duplicate information (see the <a href=\"https://colab.research.google.com/drive/1kKM-da6xP7St8puzPuyn1Ndag6a6wsg3#scrollTo=0d986969-2492-49ac-ad92-8ff78e2a7fe1&amp;line=2&amp;uniqifier=1\" rel=\"noopener nofollow ugc\">notebook</a> for details). Further, missed slots have been excluded so far, a more detailed analysis in the future might focus on the particular effects missed slots have on the subsequent MEV. Lastly, as outlined in the methodology section, using MEV-Boost payments is only a proxy for captured MEV and the competitive metric used in [4] is only partially applicable for our use case.</p>\n<p>As outlined in section Finding 2 it currently can only be speculated about the causation of the increasing average MEV-Boost payouts. Furthermore, running the analysis on the true block value (proposer payment plus builder profits) might generate further insights and solidify the research findings.</p>\n<p>On the frequency analysis, the approach contains somewhat a chicken and egg-problem. The Monte Carlo simulation is run on market shares, while the market shares potentially derive from multi-slot sequences. We see a daily time window as an appropriate balance between precision and the need to filter out isolated effects, although this can be critically challenged.</p>\n<h2><a name=\"p-49786-conclusions-12\" class=\"anchor\" href=\"https://ethresear.ch#p-49786-conclusions-12\"></a>Conclusions</h2>\n<p>Analyzing block meta-data since the merge, we observe that multi-slot sequences occur less frequently than statistically expected. Further, we observe that the average payments for longer multi-slot sequences increase with the sequence length. Similarly, the payments per slot position in longer sequences also slightly rise. This might indicate that there is generally value in longer consecutive sequences. However, considering the only slight increase in value and the fewer observed multi-slot sequences than expected we so far see no indication of deliberate multi-slot MEV strategies being deployed. Also on individual builder level we currently don’t observe strong deviations from expected distributions. This may also stem from the fact that in the current PBS mechanism, with MEV-Boost operating as a just-in-time (JIT) block auction, creating multi-block MEV opportunities carries inherent risk. This risk arises as creating these opportunities typically requires an upfront investment, and the opportunity might be captured by a competing builder in the next slot, assuming no off-chain collusion between the proposer and builder. This element of risk is a critical factor that could be eliminated by some of the proposed changes to the mechanism (e.g. some APS designs), making it an essential consideration when defining future mechanisms.</p>\n<h2><a name=\"p-49786-references-13\" class=\"anchor\" href=\"https://ethresear.ch#p-49786-references-13\"></a>References</h2>\n<p>[1] Babel K, Daian P, Kelkar M, Juels A. Clockwork finance: Automated analysis of economic security in smart contracts. <em>In 2023 IEEE Symposium on Security and Privacy (SP)</em> 2023 May 21 (pp. 2499-2516). IEEE.</p>\n<p>[2] Mackinga T, Nadahalli T, Wattenhofer R. Twap oracle attacks: Easier done than said?. <em>In 2022 IEEE International Conference on Blockchain and Cryptocurrency (ICBC)</em> 2022 May 2 (pp. 1-8). IEEE.</p>\n<p>[3] Jensen JR, von Wachter V, Ross O. Multi-block MEV. arXiv preprint arXiv:2303.04430. 2023 Mar 8.</p>\n<p>[4] Yang S, Nayak K, Zhang F. Decentralization of Ethereum’s Builder Market. arXiv preprint arXiv:2405.01329. 2024 May 2.</p>\n<p>[5] Öz B, Sui D, Thiery T, Matthes F. Who Wins Ethereum Block Building Auctions and Why?. arXiv preprint arXiv:2407.13931. 2024 Jul 18.</p>\n<p>[6] Gupta T, Pai MM, Resnick M. The centralizing effects of private order flow on proposer-builder separation. arXiv preprint arXiv:2305.19150. 2023 May 30.</p>\n<p>[7] Heimbach L, Pahari V, Schertenleib E. Non-atomic arbitrage in decentralized finance. arXiv preprint arXiv:2401.01622. 2024 Jan 3.</p>\n<p>[8] Meilijson I. The Garman-Klass volatility estimator revisited. arXiv preprint arXiv:0807.3492. 2008 Jul 22.</p>\n            <p><small>4 posts - 2 participants</small></p>\n            <p><a href=\"https://ethresear.ch/t/does-multi-block-mev-exist-analysis-of-2-years-of-mev-data/20345\">Read full topic</a></p>","link":"https://ethresear.ch/t/does-multi-block-mev-exist-analysis-of-2-years-of-mev-data/20345","pubDate":"Wed, 28 Aug 2024 10:31:36 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20345"},"source":{"@url":"https://ethresear.ch/t/does-multi-block-mev-exist-analysis-of-2-years-of-mev-data/20345.rss","#text":"Does multi-block MEV exist? Analysis of 2 years of MEV Data"}},{"title":"A Note on Equivocation in Slot Auction ePBS","dc:creator":"Julian","category":"Proof-of-Stake","description":"<p><em>Thanks to Francesco D’Amato, Barnabé Monnot, Mike Neuder, and Thomas Thiery for feedback and review. Thanks again to Francesco for coming up with the second proposal.</em></p>\n<p>Whether we want to implement slot auctions into ePBS is an <a href=\"https://www.notion.so/Arguments-in-Favor-and-Against-Slot-Auctions-in-ePBS-c7acde3ff21b4a22a3d41ac4cf4c75d6?pvs=21\" rel=\"noopener nofollow ugc\">active discussion area</a>, and support for slot auctions was signaled in the <a href=\"https://youtu.be/fQx_UbaPX-E?si=C8ALtI4zOSmFjRpN\" rel=\"noopener nofollow ugc\">seventh ePBS breakout call</a>. Currently, the ecosystem lacks knowledge about the fork choice safety of slot auctions in the <a href=\"https://ethereum-magicians.org/t/eip-7732-enshrined-proposer-builder-separation-epbs/19634\" rel=\"noopener nofollow ugc\">current ePBS proposal</a>. This note presents two strawman proposals to start discussing the forkchoice safety of slot auction ePBS.</p>\n<p>This note presupposes the reader is familiar with the ePBS proposal (<a href=\"https://ethereum-magicians.org/t/eip-7732-enshrined-proposer-builder-separation-epbs/19634\" rel=\"noopener nofollow ugc\">EIP-7732</a>).  An essential part of this EIP is that a <em>payload boost</em> is applied to a beacon block if the <a href=\"https://ethresear.ch/t/payload-timeliness-committee-ptc-an-epbs-design/16054#proposer-initiated-splitting-18\">Payload-timeliness committee (PTC)</a> reaches a quorum. If an execution payload is seen on time by a majority of the PTC, the beacon block that corresponds to the execution payload receives additional fork-choice weight (Reveal Boost). If the PTC observes a timely message from the builder stating that it withholds its payload, the additional fork-choice weight is given to the parent block of the beacon block corresponding with the withhold message (Withholding Boost).</p>\n<p>In <a href=\"https://mirror.xyz/0x03c29504CEcCa30B93FF5774183a1358D41fbeB1/CPYI91s98cp9zKFkanKs_qotYzw09kWvouaAa9GXBrQ\" rel=\"noopener nofollow ugc\">slot auction</a> ePBS, the beacon proposer does not commit to an execution payload hash, unlike in block auction ePBS. Instead, it commits to a specific builder that can submit an execution payload when it is time to reveal. The first problem is that a builder could submit multiple execution payloads. In this note, we will refer to this as a builder equivocation.</p>\n<p>In block auction ePBS, something similar to equivocation is possible. The builder could wait for at least one PTC member to vote <code>PAYLOAD_ABSENT</code> and then release a withhold message and an execution payload to split the PTC’s view such that none of the three vote options (<code>PAYLOAD_ABSENT</code>, <code>PAYLOAD_WITHHELD</code>, <code>PAYLOAD_PRESENT</code>) reaches the <a href=\"https://discord.com/channels/595666850260713488/874767108809031740/1272916231250382939\" rel=\"noopener nofollow ugc\">quorum of 50%</a> of the votes.</p>\n<p>In block auction ePBS, this equivocation does not benefit the builder much. If the PTC does not reach a quorum, no payload boost is applied, and the honest next-slot validator will take the payload as head. If the builder equivocates, the protocol does not need to guarantee Builder Reveal Safety since the builder does not act as the protocol expects. Still, the builder does not have the flexibility to submit a different execution payload since the beacon block commits to the execution payload hash.</p>\n<p>It could be that the builder is incentivized to play a <a href=\"https://arxiv.org/abs/2305.09032\" rel=\"noopener nofollow ugc\">timing game</a> and eventually decides that it is best if the block were withheld. The builder could submit a withhold message and see if the PTC will reach a quorum on <code>PAYLOAD_WITHHELD</code>. If the PTC does not seem to do so, and the PTC also has not yet reached a quorum on <code>PAYLOAD_ABSENT</code>, the builder reveals its payload after all. This attack seems difficult to pull off, but it allows the builder to check whether it can renege on its promised payment to the proposer while still landing its payload on-chain if it has to pay (assuming an honest next-slot proposer).</p>\n<p>In slot auction ePBS, a builder may be more incentivized to equivocate because it can change the contents of its execution payload. For example, the builder could broadcast a particular execution payload, but a short time later, a significant MEV opportunity appears, and the builder now wants to broadcast a new execution payload.</p>\n<p>Preventing equivocations in slot auction ePBS would be desirable because equivocations would cause insecurity in fork choice. Specifically, we want to obtain the following properties with minimal changes.</p>\n<blockquote>\n<p><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/bulb.png?v=12\" title=\":bulb:\" class=\"emoji only-emoji\" alt=\":bulb:\" loading=\"lazy\" width=\"20\" height=\"20\"><strong>Desiderata</strong></p>\n<ol>\n<li>If the builder reveals precisely one timely execution payload, it should retain the same Builder Reveal Safety guarantees as in block auction eBPS</li>\n<li>If the builder reveals multiple timely and equivocating execution payloads,<br>\na. no execution payload should go on-chain,<br>\nb. but the Unconditional Payment should be as strong as in block auction ePBS</li>\n</ol>\n</blockquote>\n<p>Should slashing or a penalty be applied to equivocating execution payload messages? This question is relevant to block and slot auction ePBS, although the potential benefits of equivocation are likely to be higher in slot auction ePBS. Since ePBS still allows local block construction, it seems unwise to apply harsh slashing or penalties if there is equivocation because this may disincentivize local block construction. Moreover, since it is not clear that there are significant gains to be made from equivocating execution payloads, and if gains are to be made, slashing or penalties do not qualitatively change this, so slashing or penalties are not immediately necessary.</p>\n<h2><a name=\"p-49750-proposal-1-vote-for-execution-payload-hash-1\" class=\"anchor\" href=\"https://ethresear.ch#p-49750-proposal-1-vote-for-execution-payload-hash-1\"></a>Proposal 1: Vote for Execution Payload Hash</h2>\n<p>The first strawman proposal to obtain these properties involves changing the block auction ePBS fork-choice specification as follows.</p>\n<blockquote>\n<p><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/bulb.png?v=12\" title=\":bulb:\" class=\"emoji\" alt=\":bulb:\" loading=\"lazy\" width=\"20\" height=\"20\"> <strong>Proposal 1: Vote for Execution Payload Hash</strong></p>\n<ol>\n<li>Replace <code>PAYLOAD_PRESENT</code> with <code>execution_payload_hash</code></li>\n<li>If no PTC quorum is reached, let the honest next-slot validator use an empty block as its head instead of a full block.</li>\n</ol>\n</blockquote>\n<p>A PTC member would now vote for the <code>execution_payload_hash</code> it has observed instead of simply voting whether a payload is present. Reveal boost is applied if a quorum is reached on <code>execution_payload_hash</code>. Intuitively, this is necessary for slot auctions since the PTC now indicates which execution payload should be used if the block is full and not just that the block is full.</p>\n<p>It seems like desideratum 1—the same Builder Reveal Safety as in block auction ePBS—is immediately satisfied since an honest builder does not release equivocating execution payloads. A PTC member’s <code>execution_payload_hash</code> vote functions the same as a <code>PAYLOAD_PRESENT</code> vote.</p>\n<p>If the builder equivocates but the PTC still reaches a quorum on <code>execution_payload_hash</code>, then the execution payload will make it on-chain in the same way a payload would have made it on-chain if the builder did not equivocate. I believe this is fine because the builder released an equivocating payload that did not split the view of the PTC (sufficiently). This indicates that this equivocating payload is a minor threat to the fork-choice security. Although this outcome contradicts desideratum 2a, the timely requirement in desideratum 2 should be read as the execution payload intends to split the view of the PTC sufficiently.</p>\n<p>If the builder equivocates and the PTC does not reach a quorum, then the next-slot honest proposer should see an empty block as its head. The builder loses some of its Builder Reveal Safety because it could be that the builder reveals only one payload (does not equivocate), yet the PTC does not reach a quorum. However, Builder Reveal Safety is not very strong in block auction ePBS either because a next-slot rational proposer would prefer to build on an empty block than a full block since these are more valuable (the ex-post reorg safety is low if reveal boost is not applied). Changing the default next-slot honest proposer behavior from seeing a full block to an empty block as its head does not change much in Builder Reveal Safety, and the system then satisfies desideratum 2.</p>\n<p>What if the next-slot proposer is dishonest? The builder could collude with the next-slot proposer and broadcast messages such that the PTC does not reach a quorum and include an execution payload late. This is similar to the attack in block auction eBPS, where a builder tries to get Withhold Boost to apply but releases an execution payload if it does not succeed. The builder and next-slot proposer collusion allows the builder to play aggressive timing games while ensuring Builder Reveal Safety. These timing games come at the expense of the execution validation time of the attesting committee. It is not immediately apparent what this attack would gain for the builder and next-slot proposer collusion since the builder timing game gain comes almost entirely from the next-slot proposer’s revenues.</p>\n<p>The downside of this proposal is the problem of free data availability. The PTC could now reach a quorum on an <code>execution_payload_hash</code>. These PTC votes would end up on-chain, and an adversary could use them to show that a piece of data was available to the PTC. Yet the adversary would not have to pay the base fee needed to provide the data on-chain; it only has to pay the proposer to commit to the adversary as the builder.</p>\n<h2><a name=\"p-49750-proposal-2-pretend-payload-absent-2\" class=\"anchor\" href=\"https://ethresear.ch#p-49750-proposal-2-pretend-payload-absent-2\"></a>Proposal 2: Pretend Payload Absent</h2>\n<p>The second strawman proposal does not suffer from the free data availability problem and achieves the desiderata as follows.</p>\n<blockquote>\n<p><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/bulb.png?v=12\" title=\":bulb:\" class=\"emoji\" alt=\":bulb:\" loading=\"lazy\" width=\"20\" height=\"20\"> <strong>Proposal 2: Pretend Payload Absent</strong><br>\nIf the next-slot proposer/attesters observe(s) at least two equivocating payloads, it/they assign(s) no additional fork-choice weight to any empty or full block</p>\n</blockquote>\n<p>The behavior of a PTC member does not change from the block auction ePBS specification. However, suppose a proposer sees that the block producer in the previous slot released equivocating execution payloads. In that case, it ignores the fork-choice weight the PTC may have given to any fork.</p>\n<p>If the builder is honest, this does not change its Builder Reveal Safety since the system works exactly as it does in block auction ePBS. Desideratum 1 is thus immediately satisfied.</p>\n<p>If the builder equivocates, an honest-but-rational proposer will choose to build on an empty block since it allows the proposer to extract the MEV from two slots of time instead of one. The attesters will not object to this since they observed the equivocating payloads and assigned no additional fork-choice weight to any forks. Therefore, if the next-slot proposer and attesters are honest, desideratum 2 is also satisfied.</p>\n<p>The next-slot proposer could collude with the builder. The builder could equivocate, and the next-slot proposer could choose to build on a full block. Similarly to the collusion situation described in the first proposal, though, the gain that a builder gets from this equivocation seems to primarily come from the profits the next-slot proposer could make. It is not clear that the joint utility of the collusion increases by enough to justify the collusion.</p>\n<p>A builder and a next-slot proposer could collude to ensure an execution payload does not become canonical. Consider a builder that submits an execution payload, and the PTC reaches a quorum on whether this payload is timely. Later, the builder regrets the contents of its execution payload and aims to remove it from the canonical chain. It could then release an equivocation payload so the next-slot proposer will not build on the undesirable execution payload. This is similar to a builder not revealing its block in block auction ePBS.</p>\n<p>In conclusion, these strawman proposals seem to achieve the same fork-choice safety under slot auctions as under block auctions with minimal changes. While the first proposal has a problem with free data availability, the second proposal may be more susceptible to builder games, such as reorging its execution payload. The lack of free data availability and being less susceptible to builder games are advantages of slot auctions in ePBS. Further research on a design that simultaneously solves both problems would be very valuable. If you are interested in working on (slot auctions in) ePBS, please see this <a href=\"https://www.notion.so/ePBS-EIP-7732-tracker-9f85f7b086994bd79192bc72bae703a1?pvs=21\" rel=\"noopener nofollow ugc\">page</a>!</p>\n            <p><small>6 posts - 3 participants</small></p>\n            <p><a href=\"https://ethresear.ch/t/a-note-on-equivocation-in-slot-auction-epbs/20331\">Read full topic</a></p>","link":"https://ethresear.ch/t/a-note-on-equivocation-in-slot-auction-epbs/20331","pubDate":"Fri, 23 Aug 2024 16:52:02 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20331"},"source":{"@url":"https://ethresear.ch/t/a-note-on-equivocation-in-slot-auction-epbs/20331.rss","#text":"A Note on Equivocation in Slot Auction ePBS"}},{"title":"The Role of the P2P Market in ePBS","dc:creator":"Julian","category":"Economics","description":"<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/d/1/d178209b1bebdec57cfa0665bfacea6970512e8c.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/d178209b1bebdec57cfa0665bfacea6970512e8c\" title=\"role_of_p2p\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/d/1/d178209b1bebdec57cfa0665bfacea6970512e8c_2_690x389.jpeg\" alt=\"role_of_p2p\" data-base62-sha1=\"tT3a6Eh20ESatNn7IqboSefeEQk\" width=\"690\" height=\"389\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/d/1/d178209b1bebdec57cfa0665bfacea6970512e8c_2_690x389.jpeg, https://ethresear.ch/uploads/default/optimized/3X/d/1/d178209b1bebdec57cfa0665bfacea6970512e8c_2_1035x583.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/d/1/d178209b1bebdec57cfa0665bfacea6970512e8c_2_1380x778.jpeg 2x\" data-dominant-color=\"504F56\"></a></div><br>\n<em>A two-tier auction market: the right resembles the less sophisticated publicly observable P2P market, and the left resembles the more sophisticated private RPC market.</em><p></p>\n<p><em>Thanks to Potuz, Barnabé Monnot, Terence Tsao, and Thomas Thiery for comments and discussion.</em></p>\n<p>The current ePBS proposal, <a href=\"https://eips.ethereum.org/EIPS/eip-7732\" rel=\"noopener nofollow ugc\">EIP-7732</a>, suggests operating a two-tier market where builders can bid to obtain the execution payload construction rights. Large block builders are expected to use the pull-based direct connection market. This market allows for lower latency and more flexibility for the builder, as the builder only needs to commit to its bid once the proposer asks for it. This market, however, requires the proposer to connect to the builder’s RPC and actively pull bid(s) from it. Smaller builders who lack this connectivity with the validator set can use the push-based P2P market. This market has stricter rules for what bidders can do but does not need the proposer to pull bid(s) from it since bids are pushed to the proposer.</p>\n<p>This note explores the role of the P2P market in ePBS. Although there has been some <a href=\"https://ethresear.ch/t/builder-bidding-behaviors-in-epbs/20129\">initial</a> <a href=\"https://hackmd.io/@potuz/HyhN0Nt9A\" rel=\"noopener nofollow ugc\">exploration</a> on the topic, this note presents a clear counterfactual of a world where the P2P market were not included in EIP-7732. This note also emphasizes <a href=\"https://collective.flashbots.net/t/tee-boost/3741/5\" rel=\"noopener nofollow ugc\">multiplexing</a>—the ability of proposers to discover builders—as the most important aspect of the P2P market.</p>\n<p>The three arguments in favor of the P2P market that the author has seen in previous work are: 1) it allows anyone to set a floor price for the auction, 2) it can be used for MEV-Burn in future protocol upgrades, and 3) it lowers entry barriers for new entrants or long-tail builders.</p>\n<p>The first argument is that allowing anyone to bid via the publicly observable P2P market gives all validators the ability to set a floor price for the auction. Validators can bid based on the block that they could locally build. Builders must then bid at least above the bid of these validators to obtain the execution payload construction rights. It has been argued that this is valuable if a cartel of builders intends to keep bids low. The floor price, however, would not break up a cartel. Although proposers would make slightly more revenue in this case, it is unclear what the value of such a floor price is to the protocol.</p>\n<p>The beacon proposer selling the rights may be the ideal party to set a reserve price. As I argue in <a href=\"https://mirror.xyz/0x03c29504CEcCa30B93FF5774183a1358D41fbeB1/8aCbi_a-Gh5DWnkJWstm8zA5fvtoQB-QR5we7C8XC90\" rel=\"noopener nofollow ugc\">this post</a>, a proposer may want to put a higher reserve price than its valuation for the execution payload construction rights to attract higher bids from builders. The P2P market allows the proposer to signal its reserve price to the market. In this sense, the P2P market allows the validator and other participants to express their preferences.</p>\n<p>The second argument states that the P2P market may facilitate <a href=\"https://ethresear.ch/t/mev-burn-a-simple-design/15590\">MEV-Burn</a> in future protocol upgrades. MEV-Burn aims to decouple the rewards from selling execution payload construction rights from being a validator. This has numerous benefits; for example, it decreases the value of using a staking service provider (SSP) since MEV-Burn decreases the variance of validator payoffs. MEV-Burn requires that builder bids be legible to the protocol. Most designs achieve this by having a committee that observes the best available bids. If ePBS would only have the direct connection market, the MEV-Burn designs need to be revisited since a proposer selling the execution rights is incentivized to understate the amount that will be burnt. Still, the P2P market is expected to only reflect a small portion of the value of the execution payload construction rights, hence even ePBS with the P2P market may not be satisfactory for an effective MEV-Burn solution.</p>\n<p>The last reason for the P2P market is that it would allow builders from which proposers are unlikely to pull bids to still compete in the market. Proposers may be unlikely to pull bids from builders that infrequently participate in the auction because they are very specialized or from new builders unknown to the proposer. This could be because proposers have an outdated whitelist of builders from which to pull bids. Allowing these proposers to participate in the push-based P2P market will result in more builder diversity in block construction, which may benefit the protocol.</p>\n<p>This last reason is what we will explore in this post. Specifically, what does the Ethereum ecosystem gain by enshrining the push-based P2P market aside from an out-of-protocol solution that facilitates small builders’ participation in the market?</p>\n<p>Shea Ketsdever recently released a post on <a href=\"https://collective.flashbots.net/t/tee-boost/3741\" rel=\"noopener nofollow ugc\">TEE-Boost</a>, an adaptation of MEV-Boost that uses Trusted Execution Environments. In this post, she highlights the different roles a relay plays. One of the roles is multiplexing, allowing proposers to discover builders who may want to participate in the auction.</p>\n<p>The ePBS P2P market aims to achieve multiplexing. In the context of ePBS, multiplexing has at least two facets: trustlessness and value reflection. Trustlessness is important because ePBS removes the trust that proposers and builders must place in a relay to facilitate the fair exchange. Value reflection is essential because a multiplexing tool that poorly reflects the value bidders assign to the auctioned item will not efficiently match an auctioneer with the correct bidder.</p>\n<p>The ePBS P2P market scores very well on the trustlessness front. Neither a proposer nor a builder must trust anyone since bids are broadcast via the P2P network, and the winning bid is committed to on-chain. The P2P market, however, scores poorly on the value reflection front. Since the P2P network must be DOS resistant, it cannot handle too many bids, so bidders will likely not be allowed to bid as often as they could in MEV-Boost, meaning they have to be strategic about when they bid. Moreover, early bids will not be able to be canceled, which could lead to strategic builders only winning via the P2P market if the valuation of other builders that operate via the direct connection market has decreased (<a href=\"https://www.youtube.com/watch?v=-PXGPFFneMI\" rel=\"noopener nofollow ugc\">adverse selection</a>). Finally, the value reflection of the P2P market relative to the RPC market will worsen as the RPC market becomes more sophisticated while the P2P market becomes stale.</p>\n<p>How would an out-of-protocol actor facilitate multiplexing if ePBS were deployed? In MEV-Boost, relays facilitate multiplexing because submitting blocks to relays is (largely) permissionless, and relays are well-connected to validators. In ePBS, a relay - from no one referred to as a bid curation relay - would look different. A bid curation relay could open an RPC endpoint that proposers connect to and host an auction where builders submit bids, like in MEV-Boost. Bids, however, do not need to contain transaction data since the bid curation relay would not be responsible for the fair exchange problem that is solved via ePBS. Bids in ePBS are a bid value and the hash of the execution payload. A proposer then pulls the highest bid from the bid curation relay and, if it so desires, commits to the highest bid via the in-protocol ePBS system. A winning builder then sees this in-protocol commitment and publishes the block via ePBS.</p>\n<p>It becomes clear that the trust assumptions that proposers and builders must place in a bid curation relay are vastly lower than in MEV-Boost. Essentially, the proposer and builders must trust the bid curation relay to forward the highest-paying bid when the proposer asks for it. The bid curation relay is not trusted with the block contents (<a href=\"https://collective.flashbots.net/t/tee-boost/3741\" rel=\"noopener nofollow ugc\">builder privacy</a> is preserved) and is not responsible for unconditional payment (<a href=\"https://collective.flashbots.net/t/tee-boost/3741\" rel=\"noopener nofollow ugc\">data availability and validation</a> are enforced via the protocol).</p>\n<p>The ePBS relay scores worse on the trustlessness front than the P2P market since the proposer and builders must trust the relay not to censor its bids. On the other hand, the value reflection of such a bid curation relay could be far better. The relay could offer bid cancellations and high-frequency bidding to builders. Moreover, relays could invest in latency reductions and charge for this, as some do in MEV-boost. If a relay successfully reduces latency, more prominent builders may connect to it. This means the value reflection of relays relative to directly connected builders may remain stable or improve over time.</p>\n<p><a href=\"https://collective.flashbots.net/t/tee-boost/3741/5?u=julian\" rel=\"noopener nofollow ugc\">Shea also highlights</a> another option that has been discussed widely before: next to the P2P market; there could be an on-chain registry of builders. There could be a smart contract that any builder could write its RPC endpoint to. Any validator could then see the available RPC endpoints and pull bids from it during its slot. This alternative scores well on the trustlessness front since no trust is required, and it scores well on the value reflection point since it allows all builders to compete on a similar level. The proposer could pull from this registry every time it is supposed to propose a block.</p>\n<p>Why do we care about multiplexing? Multiplexing contributes to the credible neutrality of the network. In the context of ePBS, credible neutrality may mean something like this: the builder with the highest valuation for the execution payload construction rights is allocated these rights. If proposers were to rely solely on directly connected builders, some long-tail builders who happened to have an exceptionally high value for a specific block might be excluded. If proposers rely on bid curation relays, they may not forward the highest-paying bid because they prefer to forward another bid for whatever reason. If proposers rely on an on-chain registry of builders, it may not connect to the newer or smaller builders.</p>\n<p>Allowing multiplexing to contribute to credible neutrality is a trade-off between trustlessness and value reflection. If a completely trustless market is so poor at value reflection that it never surfaces a winning bid, it does not contribute much to credible neutrality. If a perfectly value-reflecting market puts a lot of trust in one party, the benefit of credible neutrality is also nonexistent.</p>\n<p>To conclude, the P2P market is easy to implement, and its maintenance does not require a hard fork so clients can iterate freely. Although the P2P market only contributes a little to the core functionality of ePBS, there are virtually no downsides to implementing it, and it is a nice feature that may benefit some users and could be beneficial for proposers as it increases their revenues and may be helpful for MEV-Burn in the future. Further work could specify the P2P market rules and how an on-chain registry of builder RPC endpoints could work.</p>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://ethresear.ch/t/the-role-of-the-p2p-market-in-epbs/20330\">Read full topic</a></p>","link":"https://ethresear.ch/t/the-role-of-the-p2p-market-in-epbs/20330","pubDate":"Fri, 23 Aug 2024 16:01:14 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20330"},"source":{"@url":"https://ethresear.ch/t/the-role-of-the-p2p-market-in-epbs/20330.rss","#text":"The Role of the P2P Market in ePBS"}},{"title":"An Automatic Technique to Detect Storage Collisions and Vulnerabilities within Solidity Smart Contract","dc:creator":"WaizKhan7","category":"Security","description":"<p>Storage collisions and vulnerabilities within Ethereum smart contracts can lead to unexpected issues like freezing funds, escalating privileges, and financial asset theft. A storage collision occurs when two different storage structs unintentionally use same storage slot(s), or the slot layout is changed during the upgrade of implementation contract. These collision vulnerabilities have been detected in large numbers (worth millions of dollars) in a <a href=\"https://www.ndss-symposium.org/ndss-paper/not-your-type-detecting-storage-collision-vulnerabilities-in-ethereum-smart-contracts/\" rel=\"noopener nofollow ugc\">recent study</a> within smart contracts deployed on the Ethereum network.</p>\n<p>In this topic, we propose a more accurate and complete technique to detect storage vulnerabilities and collisions in Solidity smart contracts. And encourage the Ethereum community to <strong>provide feedback on the proposed technique</strong>.</p>\n<h3><a name=\"p-49742-introduction-1\" class=\"anchor\" href=\"https://ethresear.ch#p-49742-introduction-1\"></a>Introduction</h3>\n<p>We are working on a solution based on advanced static analysis techniques that can identify vulnerabilities within the deep storage of Ethereum Solidity smart contracts. We aim to detect storage collisions in proxy contracts deployed on the Ethereum network like ERC-2535 (Diamond/Multi-Facet Proxy), ERC-1822, upgrade proxy pattern, etc., as complex proxy contracts are more likely to experience a storage collision, like during the upgrade of implementation or facet contracts.</p>\n<p><a href=\"https://www.ndss-symposium.org/ndss-paper/not-your-type-detecting-storage-collision-vulnerabilities-in-ethereum-smart-contracts/\" rel=\"noopener nofollow ugc\">N. Ruaro et al.</a> analyzed Ethereum contracts using contract bytecode to detect storage collisions and reported 14,891 vulnerable contracts. Their technique was able to identify storage slot types correctly with an accuracy of 87.3%. Whereas, we aim to build a solution that will use source code to accurately analyze the storage layout and slot types of the contract. Furthermore, we will also analyze dynamic arrays, mapping variables, and complex nested structs in our analysis.</p>\n<p>Suppose a collision occurs on the state variables’ base slots, our approach will allow us to identify the impact of the collision on dynamic arrays and mapping variables declared consecutively, and arrays data type or mappings key types are same which is a common practice in large contracts like gaming contracts.</p>\n<p>As shown in the below example code, the slot layout was changed during the contract upgrade, and since <code>token_uris</code> and <code>token_version</code> have same key types and data types, both variables will return each other’s data after the upgrade due to collision.</p>\n<pre><code class=\"lang-auto\">library ImplementationStorage1 {\n    struct AddressSlot {\n        address owner; // slot n+0\n        mapping(uint256 =&gt; string) token_uris; // slot n+1\n        mapping(uint256 =&gt; string) token_versions; // slot n+2\n    }\n\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n\n// updated code\nlibrary ImplementationStorage2 {\n    struct AddressSlot {\n        address owner; //slot n+0\n        mapping(uint256 =&gt; string) token_versions; // slot n+1 (shld be token_uris)\n        mapping(uint256 =&gt; string) token_uris; // slot n+2 (shld be token_versions)\n    }\n\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n</code></pre>\n<p><code>token_uris</code> accessing <code>token_versions</code> and vice-versa after the upgrade.</p>\n<pre><code class=\"lang-auto\">       (before upgrade)                        (after upgrade)   \n      _________________                      _________________\n     |     Proxy       |                     |     Proxy       |\n     |_________________|                     |_________________|\n     | * IMPLEMENT_SLOT| --&gt; NFTManager1     | * IMPLEMENT_SLOT| --&gt; NFTManager2\n     | * ADMIN_SLOT    |                     | * ADMIN_SLOT    |\n     |_________________|                     |_________________|\n     | + upgradeTo()   |                     | + upgradeTo()   |\n     | + changeAdmin() |                     | + changeAdmin() |\n     |_________________|                     |_________________|\n              |                                       |\n              v                                       v\n      _________________                       _________________\n     |   NFTManager1   |                     |   NFTManager2   |\n     |_________________|                     |_________________|\n     | - owner         |                     | - owner         |\n     | - token_uris    | **** collision **** | - token_versions|\n     | - token_versions| **** collision **** | - token_uris    |\n     |_________________|                     |_________________|\n\n</code></pre>\n<p>We plan to build a technology that will automatically detect all storage collisions within a Solidity smart contract.</p>\n<h4><a name=\"p-49742-methodology-2\" class=\"anchor\" href=\"https://ethresear.ch#p-49742-methodology-2\"></a>Methodology</h4>\n<p>We have structured our development plan into three distinct phases, outlined as follows:</p>\n<ul>\n<li><strong><strong>Automatic State Variable Detector and Slot Layout Calculator</strong></strong></li>\n</ul>\n<p>In this phase, we focus on developing an automatic state variable detector and slot layout calculator. This component will facilitate the identification of state variables within smart contracts and determine their corresponding slot layout. By automating this process, we aim to streamline the initial analysis procedures.</p>\n<p>Sample output of Slot Calculator</p>\n<pre><code class=\"lang-auto\">slot 0 - mapping ds.selectorToFacetAndPosition[bytes4] = FacetAddressAndPosition;\nslot 1 - mapping ds.facetFunctionSelectors[address] = FacetFunctionSelectors;\nslot 2 - address [] ds.facetAddresses;\nslot 3 - mapping ds.supportedInterfaces[bytes4] = bool;\nslot 4 - address ds.contractOwner;\nslot 5 - mapping ds.tempSelectorsNested[uint256] = FacetAddressAndPosition;\nslot 6 - FacetAddressAndPosition [] ds.FacetAddressAndPositionArray;\nslot 7 - mapping ds.tempMapping[uint256] = uint256;\nslot 8 - mapping ds.tempMapping2[address] = uint256;\n</code></pre>\n<ul>\n<li><strong><strong>Mapping Keys Analyzer and Slot Calculator of Complex Variables</strong></strong></li>\n</ul>\n<p>Building upon the foundation established in phase 1, in this phase we will first extend the slot calculator capability to calculate the slots of complex variables and their entries (for all data types) i.e. slots of mapping keys, dynamic array, complex struct, mappings with complex struct as value.</p>\n<p>This component will also include the approximation of all keys used in mapping variables for saving data using advanced static analysis techniques. By accurately approximating keys and calculating entries, we seek to enhance the precision and breadth of storage slot calculation methodology, which will help detect storage collision within deep storage data of a smart contract.</p>\n<ul>\n<li><strong><strong>Collision Detector for State Variables and Complex Variables All Entries Slots</strong></strong></li>\n</ul>\n<p>The final phase of our methodology focuses on implementing a collision detector for both state variables and complex variable slots. This critical component will identify any potential collisions or conflicts within any type of state variables and their associated variable(s)/value(s) slots. By detecting and addressing collisions, we aim to ensure the integrity and reliability of smart contracts.</p>\n<p>We aim to develop a robust and comprehensive methodology for smart contract storage collision detectors, by systematically progressing through above discussed three development phases.</p>\n<h4><a name=\"p-49742-conclusion-3\" class=\"anchor\" href=\"https://ethresear.ch#p-49742-conclusion-3\"></a>Conclusion</h4>\n<p>The development of our solution will allow developers to ensure that their contract has no potential storage collisions before deployment. It will also be able to detect storage collisions within deep storage of deployed smart contracts and can help in securing contracts worth millions of dollars.</p>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://ethresear.ch/t/an-automatic-technique-to-detect-storage-collisions-and-vulnerabilities-within-solidity-smart-contract/20328\">Read full topic</a></p>","link":"https://ethresear.ch/t/an-automatic-technique-to-detect-storage-collisions-and-vulnerabilities-within-solidity-smart-contract/20328","pubDate":"Fri, 23 Aug 2024 09:35:11 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20328"},"source":{"@url":"https://ethresear.ch/t/an-automatic-technique-to-detect-storage-collisions-and-vulnerabilities-within-solidity-smart-contract/20328.rss","#text":"An Automatic Technique to Detect Storage Collisions and Vulnerabilities within Solidity Smart Contract"}},{"title":"Mechan-stein (alt. Franken-ism)","dc:creator":"mikeneuder","category":"Block proposer","description":"<h1><a name=\"p-49714-mechan-stein-alt-franken-ismbrp-classsmallsmall-choose-your-own-adventurehttpsxcomvitalikbuterinstatus1788489148183019929-either-way-just-trying-to-portmanteau-frankenstein-and-mechanismsmallp-1\" class=\"anchor\" href=\"https://ethresear.ch#p-49714-mechan-stein-alt-franken-ismbrp-classsmallsmall-choose-your-own-adventurehttpsxcomvitalikbuterinstatus1788489148183019929-either-way-just-trying-to-portmanteau-frankenstein-and-mechanismsmallp-1\"></a>Mechan-stein (alt. Franken-ism)<br><p><small><em>^ <a href=\"https://x.com/VitalikButerin/status/1788489148183019929\" rel=\"noopener nofollow ugc\">choose your own adventure</a> – either way, just trying to portmanteau ‘Frankenstein’ and ‘Mechanism.’</em></small></p></h1>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/3/d/3d13edb2750f779fb39f38e943038de48a692422.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/3d13edb2750f779fb39f38e943038de48a692422\" title=\"upload_2936c4a8e65027883c0cacec063f9ea2\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/3/d/3d13edb2750f779fb39f38e943038de48a692422_2_498x500.jpeg\" alt=\"upload_2936c4a8e65027883c0cacec063f9ea2\" data-base62-sha1=\"8IjOZ06fIgkHslXWliL0RLOHwXM\" width=\"498\" height=\"500\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/3/d/3d13edb2750f779fb39f38e943038de48a692422_2_498x500.jpeg, https://ethresear.ch/uploads/default/optimized/3X/3/d/3d13edb2750f779fb39f38e943038de48a692422_2_747x750.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/3/d/3d13edb2750f779fb39f38e943038de48a692422_2_996x1000.jpeg 2x\" data-dominant-color=\"8B9D84\"></a></div><br>\n<sub><em><strong>^“don’t worry bro, just one more auction, i swear. check it out.” h/t Mallesh for the relevant <a href=\"https://x.com/malleshpai/status/1748026472923623619\" rel=\"noopener nofollow ugc\">tweet</a>.</strong></em><br>\n</sub><p></p>\n<p><span class=\"math\">\\cdot</span><br>\n<em>by <a href=\"https://twitter.com/mikeneuder\" rel=\"noopener nofollow ugc\">mike</a> – wednesday; august 21, 2024.</em><br>\n<sub><em>^hbd <a href=\"https://en.wikipedia.org/wiki/Bo_Burnham\" rel=\"noopener nofollow ugc\">Bo</a>. if you, dear reader, haven’t seen <a href=\"https://en.wikipedia.org/wiki/Bo_Burnham:_Inside\" rel=\"noopener nofollow ugc\">“Inside”</a> or <a href=\"https://www.youtube.com/watch?v=5XWEVoI40sE\" rel=\"noopener nofollow ugc\">“Inside Outtakes,”</a> watching them is your homework assignment.</em></sub><br>\n<span class=\"math\">\\cdot</span><br>\n<em>Many thanks to <a href=\"https://x.com/barnabemonnot\" rel=\"noopener nofollow ugc\">Barnabé</a>, <a href=\"https://x.com/_julianma\" rel=\"noopener nofollow ugc\">Julian</a>, <a href=\"https://x.com/soispoke\" rel=\"noopener nofollow ugc\">Thomas</a>, <a href=\"https://x.com/jacobykaufmann\" rel=\"noopener nofollow ugc\">Jacob</a>, <a href=\"https://x.com/mteamisloading\" rel=\"noopener nofollow ugc\">mteam</a>, <a href=\"https://x.com/nero_eth\" rel=\"noopener nofollow ugc\">Toni</a>, <a href=\"https://x.com/drakefjustin\" rel=\"noopener nofollow ugc\">Justin</a>, <a href=\"https://x.com/vitalikbuterin\" rel=\"noopener nofollow ugc\">Vitalik</a>, <a href=\"https://x.com/MaxResnick1\" rel=\"noopener nofollow ugc\">Max</a>, and <a href=\"https://x.com/malleshpai\" rel=\"noopener nofollow ugc\">Mallesh</a> for discussions around these topics and comments on the draft!</em><br>\n<span class=\"math\">\\cdot</span><br>\n<em>The idea for the combined mechanism explored in <a href=\"https://ethresear.ch#p-49714-h-2-mechan-stein-9\">Part 2</a> of this post came from a Baranbé-led whiteboarding session and accompanying <a href=\"https://x.com/barnabemonnot/status/1808444733305258047\" rel=\"noopener nofollow ugc\">tweet thread</a>. These ideas are also explored in the <a href=\"https://efdn.notion.site/Block-construction-session-bd611621250f45948eff05fcf6a34067?pvs=4\" rel=\"noopener nofollow ugc\">this doc</a>, which inspired <a href=\"https://github.com/michaelneuder/talks/blob/268e273b55cf2c753b2479c3ebbb826d41811754/misc2024/sbc.pdf\" rel=\"noopener nofollow ugc\">this talk</a>.</em><br>\n<span class=\"math\">\\cdot</span><br>\n<strong>tl;dr;</strong> <em>We sketch a high-level framing for Ethereum block construction centered around the design goals of encouraging builder competition, limiting the value of validator sophistication, and preserving the neutrality of block space. We then highlight three proposed mechanisms and how they interface with the established desiderata. We conclude by exploring the potential synergies of combining these designs into a single flow, called <code>Mechan-stein</code>.</em><br>\n<span class=\"math\">\\cdot</span><br>\n<strong>Contents</strong><br>\n(1) <a href=\"https://ethresear.ch#p-49714-h-1-the-building-blocks-pun-intended-of-block-space-market-design-2\">The building blocks of block-space market design</a><br>\n&nbsp;&nbsp;  <a href=\"https://ethresear.ch#p-49714-enshrined-pbs-mev-burn-via-ptc-3\">Enshrined PBS &amp; MEV-burn via PTC</a><br>\n&nbsp;&nbsp;  <a href=\"https://ethresear.ch#p-49714-execution-auctions-an-attester-proposer-separation-instatiation-5\">Execution Auctions (an Attester-Proposer Separation instantiation)</a><br>\n&nbsp;&nbsp;  <a href=\"https://ethresear.ch#p-49714-focil-7\">FOCIL</a><br>\n(2) <a href=\"https://ethresear.ch#p-49714-h-2-mechan-stein-9\">Mechan-stein</a><br>\n&nbsp;&nbsp;  <a href=\"https://ethresear.ch#p-49714-potential-issues-with-mechan-stein-10\">Potenital Issues with Mechan-stein</a><br>\n<span class=\"math\">\\cdot</span></p>\n<p><strong>Related work</strong></p>\n<div class=\"md-table\">\n<table>\n<thead>\n<tr>\n<th>Article</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://mirror.xyz/barnabe.eth/QJ6W0mmyOwjec-2zuH6lZb0iEI2aYFB9gE-LHWIMzjQ\" rel=\"noopener nofollow ugc\"><em>More words on Proposer-Builder Separation</em></a></td>\n</tr>\n<tr>\n<td><a href=\"https://efdn.notion.site/Block-construction-session-bd611621250f45948eff05fcf6a34067?pvs=4\" rel=\"noopener nofollow ugc\"><em>Notes from block construction session</em></a></td>\n</tr>\n<tr>\n<td><a href=\"https://ethresear.ch/t/burning-mev-through-block-proposer-auctions/14029\"><em>MEV-burn</em></a></td>\n</tr>\n<tr>\n<td><a href=\"https://ethresear.ch/t/payload-timeliness-committee-ptc-an-epbs-design/16054\"><em>PTC</em></a></td>\n</tr>\n<tr>\n<td><a href=\"https://ethresear.ch/t/fork-choice-enforced-inclusion-lists-focil-a-simple-committee-based-inclusion-list-proposal/19870\"><em>FOCIL</em></a></td>\n</tr>\n</tbody>\n</table>\n</div><hr>\n<h1><a name=\"p-49714-h-1-the-building-blocks-pun-intended-of-block-space-market-design-2\" class=\"anchor\" href=\"https://ethresear.ch#p-49714-h-1-the-building-blocks-pun-intended-of-block-space-market-design-2\"></a>[1] The building blocks (pun intended) of block-space market design</h1>\n<p>Since before the Merge, <a href=\"https://github.com/michaelneuder/mev-bibliography\" rel=\"noopener nofollow ugc\">much</a> has been (and continues to be) written about Ethereum’s transaction supply chain and block-space market design. I still think Vitalik’s <a href=\"https://vitalik.eth.limo/general/2021/12/06/endgame.html\" rel=\"noopener nofollow ugc\"><em>Endgame</em></a> summarizes the best-case outcome most succinctly with,</p>\n<blockquote>\n<p><em>“Block production is centralized, block validation is trustless and highly decentralized, and censorship is still prevented.”</em></p>\n</blockquote>\n<p>We can operationalize each of these statements into a design goal for our system:</p>\n<ol>\n<li><em>“Block production is centralized.”</em> <span class=\"math\">\\rightarrow</span> MEV is a fact of life in financial systems, and some actors will inevitably specialize in its extraction. We can’t expect solo-stakers to run profitable builders, but we can encourage competition and transparency in the MEV markets. When discussing <code>MEV-boost</code>, we usually describe it as aiming to democratize access to MEV for all proposers (which it does extremely well), but one under-discussed element of the existing system is that it <em>encourages builder competition</em> by creating a transparent market for buying block space. There are (and always will be) advantages and economies of scale for being a big builder (e.g., colocation with relays, acquiring exclusive order flow deals, and holding large inventory on various trading venues – for more, see this <a href=\"https://arxiv.org/pdf/2407.13931\" rel=\"noopener nofollow ugc\">recent paper</a> from Burak, Danning, Thomas, and Florian), but anyone can send blocks and compete in the auction. Another important element of <code>MEV-boost</code> is that the auction happens Just-In-Time (JIT) for the block proposal, making <a href=\"https://ethresear.ch/t/on-attestations-block-propagation-and-timing-games/20272\">timing games</a> around the block proposal deadline valuable to the proposer who serves as the auctioneer. Still, the real-time nature of the auction ensures that the builder with the highest value <em>for this specific slot</em> wins the auction (rather than, e.g., the builder with the highest average value for any slot – see <a href=\"https://arxiv.org/pdf/2408.03116\" rel=\"noopener nofollow ugc\">Max &amp; Mallesh’s argument</a> for why ahead-of-time auctions are more centralized). This leads to <strong>design goal <span class=\"hashtag-raw\">#1:</span> encourage builder competition.</strong><a href=\"https://ethresear.ch#fn1dst\"><span class=\"math\">^{[1]}</span></a><a name=\"fn1\"></a></li>\n<li><em>“Block validation is trustless and highly decentralized”</em><a href=\"https://ethresear.ch#fn2dst\"><span class=\"math\">^{[2]}</span></a><a name=\"fn2\"></a> <span class=\"math\">\\rightarrow</span> Ethereum’s primary focus has been preserving the validator set’s decentralization (why this is important in item <span class=\"hashtag-raw\">#3</span> below). This fundamental tenet instantiates itself in both the engineering/technical design and the economic/incentive design. On the engineering front, the <a href=\"https://github.com/ethereum/consensus-specs/tree/dev\" rel=\"noopener nofollow ugc\">spec</a> is written with the <a href=\"https://docs.ethstaker.cc/ethstaker-knowledge-base/hardware/hardware-requirements\" rel=\"noopener nofollow ugc\">minimum hardware requirements</a> in mind. This constraint ensures that participation in Ethereum’s consensus is <em>feasible</em> given (relatively) modest resources. On the economic level, the goal is to minimize the disparity in financial outcomes between at-home stakers and professional operators. Beyond feasibility, this aims to make at-home staking <em>not too irrational.</em> This double negative is tongue-in-cheek but hopefully conveys the message of trying to ensure there is some economic viability to at-home staking rather than staking through a centralized provider. Another lens for interpreting this is keeping the marginal value of sophistication low. We can’t expect at-home operators to have the exact same rewards as Coinbase and Lido (e.g., because they may have higher network latency), but the centralized staking providers shouldn’t benefit greatly from sophistication. This leads to <strong>design goal <span class=\"hashtag-raw\">#2:</span> limit the value of validator sophistication.</strong></li>\n<li><em>“Censorship is prevented.”</em> <span class=\"math\">\\rightarrow</span> Credible neutrality is what differentiates crypto-economic systems from FinTech. If centralized entities determine which transactions land on chain and which do not, it’s over. To ensure the anti-fragility and neutrality of Ethereum, we must rely on a <a href=\"https://collective.flashbots.net/t/decentralized-crypto-needs-you-to-be-a-geographical-decentralization-maxi/1385\" rel=\"noopener nofollow ugc\">geographically distributed</a> validators; the validator set is the most decentralized part of the block production pipeline. In my opinion, (i) the main point of having a decentralized validator set is to allow those validators to express different preferences over the transactions that land on chain (“high preference entropy” – <a href=\"https://ethresear.ch/t/unbundling-staking-towards-rainbow-staking/18683\">h/t Dr. Monnot</a>), and (ii) relying on this decentralization is the only way to preserve neutrality of the chain (c.f., <a href=\"https://ethresear.ch/t/uncrowdable-inclusion-lists-the-tension-between-chain-neutrality-preconfirmations-and-proposer-commitments/19372\"><em>Uncrowdable Inclusion Lists</em></a> for more discussion on chain neutrality). This leads to <strong>design goal <span class=\"hashtag-raw\">#3:</span> preserve the neutrality of Ethereum block space.</strong></li>\n</ol>\n<p>Right. To summarize:</p>\n<ol>\n<li><em>“Block production is centralized.”</em> <span class=\"math\">\\rightarrow</span> <strong>design goal <span class=\"hashtag-raw\">#1:</span> encourage builder competition.</strong></li>\n<li><em>“Block validation is trustless and highly decentralized”</em> <span class=\"math\">\\rightarrow</span> <strong>design goal <span class=\"hashtag-raw\">#2:</span> limit the value of validator sophistication.</strong></li>\n<li><em>“Censorship is prevented.”</em> <span class=\"math\">\\rightarrow</span> <strong>design goal <span class=\"hashtag-raw\">#3:</span> preserve the neutrality of Ethereum block space.</strong></li>\n</ol>\n<p>Ok. This is all great, but let’s talk specifics. Many proposals aim to accomplish some of the design goals above. I am going to focus on three:</p>\n<ol>\n<li><strong>Enshrined <a href=\"https://barnabe.substack.com/p/pbs\" rel=\"noopener nofollow ugc\">Proposer-Builder Separation</a> &amp; <a href=\"https://ethresear.ch/t/burning-mev-through-block-proposer-auctions/14029\"><code>MEV-burn</code></a> via <a href=\"https://ethresear.ch/t/payload-timeliness-committee-ptc-an-epbs-design/16054\">Payload-Timeliness Committee</a></strong> (abbr. <code>PTC</code> onwards).</li>\n<li><strong><a href=\"https://mirror.xyz/barnabe.eth/QJ6W0mmyOwjec-2zuH6lZb0iEI2aYFB9gE-LHWIMzjQ\" rel=\"noopener nofollow ugc\">Execution Auctions</a>/Attester-Proposer Separation</strong>.</li>\n<li><strong><a href=\"https://ethresear.ch/t/fork-choice-enforced-inclusion-lists-focil-a-simple-committee-based-inclusion-list-proposal/19870/5\">Fork-Choice Enforced Inclusion Lists</a></strong> (abbr. <code>FOCIL</code> onwards).</li>\n</ol>\n<p>This may seem jargon-laden, and I apologize; please check out the links for the canonical article on each topic; for even more legibility, I will present a high-level view of each proposal below.</p>\n<h3><a name=\"p-49714-enshrined-pbs-mev-burn-via-ptc-3\" class=\"anchor\" href=\"https://ethresear.ch#p-49714-enshrined-pbs-mev-burn-via-ptc-3\"></a>Enshrined PBS &amp; <code>MEV-burn</code> via <code>PTC</code></h3>\n<p>This design enshrines a JIT block auction into the Ethereum consensus layer. The diagram below summarizes the block production pipeline <em>during the slot</em>.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/2/2/22560b81c3e436b0a3524b9c52a1b6b5aa277003.png\" data-download-href=\"https://ethresear.ch/uploads/default/22560b81c3e436b0a3524b9c52a1b6b5aa277003\" title=\"upload_a40f44ea2cb5821c889733125eb53260\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/2/2/22560b81c3e436b0a3524b9c52a1b6b5aa277003_2_423x500.png\" alt=\"upload_a40f44ea2cb5821c889733125eb53260\" data-base62-sha1=\"4TKAeCidlD1n8QgF0Kg8skLBQVt\" width=\"423\" height=\"500\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/2/2/22560b81c3e436b0a3524b9c52a1b6b5aa277003_2_423x500.png, https://ethresear.ch/uploads/default/optimized/3X/2/2/22560b81c3e436b0a3524b9c52a1b6b5aa277003_2_634x750.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/2/2/22560b81c3e436b0a3524b9c52a1b6b5aa277003_2_846x1000.png 2x\" data-dominant-color=\"F2F1F1\"></a></div><p></p>\n<ol>\n<li><strong>The builder bids</strong> in the auction by sending <code>(block header, bid value)</code> pairs to the proposer and the committee members.</li>\n<li><strong>The proposer commits</strong> to the highest bid value by signing and publishing the winning bid.</li>\n<li><strong>The committee enforces</strong> that the proposer selected a sufficiently high bid according to their view.</li>\n<li><strong>The builder publishes</strong> the block.</li>\n<li><strong>The committee enforces</strong> the timeliness of the builder’s publication.</li>\n</ol>\n<h4><a name=\"p-49714-analysis-4\" class=\"anchor\" href=\"https://ethresear.ch#p-49714-analysis-4\"></a>Analysis</h4>\n<ul>\n<li><code>PTC</code> allows the protocol (through the enforcement of the committee) to serve as the trusted third-party in the <a href=\"https://citeseerx.ist.psu.edu/document?repid=rep1&amp;type=pdf&amp;doi=208b22c7a094ada20736593afcc8c759c7d1b79c\" rel=\"noopener nofollow ugc\">fair-exchange</a> of the sale of the block building rights. <code>MEV-burn</code> (maybe more aptly denoted as “block maximization” because burning isn’t strictly necessary for the bids) asks the attesters to enforce a threshold for the bid selected as the winner by the proposer.</li>\n<li><span><code>PTC</code> primarily implements <strong>design goal <span class=\"hashtag-raw\">#1:</span> encourage builder competition.</strong></span> <code>PTC</code> enshrines <code>MEV-boost</code>, fully leaning into creating a competitive marketplace for block building. As in <code>MEV-boost</code>, the real-time block auction allows any builder to submit bids and encourages competition during each slot. Additionally, the JIT auction and bid-threshold enforcement of <code>MEV-burn</code> reduces the risk of multi-slot MEV by forcing each auction to take place during the slot. Lastly, <code>PTC</code> and other ePBS designs historically were aimed at <a href=\"https://ethresear.ch/t/why-enshrine-proposer-builder-separation-a-viable-path-to-epbs/15710#reasons-to-enshrine-4\">removing relays</a>. With bid thresholds from <code>MEV-burn</code>, the <a href=\"https://ethresear.ch/t/relays-in-a-post-epbs-world/16278\">bypassability of the protocol</a> becomes less feasible (even if the best builder bypasses, the second best can go through the protocol and ensure their bid wins).</li>\n<li><span><code>PTC</code> marginally addresses <strong>design goal <span class=\"hashtag-raw\">#2:</span> limit the value of validator sophistication.</strong></span> By creating an explicit market for MEV-aware blocks, <code>PTC</code> ensures that all validators can access a large portion of the MEV available in their slot. <code>MEV-burn</code> also smooths out the variance in the validator rewards. However, one of the major limitations of this auction design is the “value-in-flight” (h/t Barnabé for <a href=\"https://www.youtube.com/watch?v=KHw7gdJ14uQ\" rel=\"noopener nofollow ugc\">coining</a> the <a href=\"https://mirror.xyz/barnabe.eth/QJ6W0mmyOwjec-2zuH6lZb0iEI2aYFB9gE-LHWIMzjQ\" rel=\"noopener nofollow ugc\">term</a>) problem of the auction taking place during the slot. Because the value of the sold item changes dramatically throughout a slot, the auctioneer’s role benefits from sophistication. Beyond simple <a href=\"https://dataalways.mirror.xyz/-m0-bp3aZpcqa15_QbMX3MD1v9xg7VCcfGtZBR7I9Bg\" rel=\"noopener nofollow ugc\">timing games</a>, more exotic strategies around the fork-choice rule (e.g., using extra fork-choice weight to <a href=\"https://ethresear.ch/t/on-attestations-block-propagation-and-timing-games/20272\">further delay block publication</a>, h/t Toni) are possible, and we are just starting to see these play out.</li>\n<li><span> <code>PTC</code> does not address <strong>design goal <span class=\"hashtag-raw\">#3:</span> Preserve the neutrality of Ethereum block space.</strong></span> Neither <code>PTC</code> nor PBS generally are designed to encourage censorship resistance. The fact that a few builders account for most of Ethereum’s blocks is not surprising, and we should not count on those builders to uphold the credible neutrality of the chain (even if they are right now). While it is true that <code>PTC</code> aims to maintain a decentralized validator set, the fact that the full block is sold counter-acts that effect by still giving discretionary power of the excluded transactions to the builder (e.g., consider the hypothetical where 100% of validators are at-home stakers (maximally decentralized), but they all outsource to the same builder <span class=\"math\">\\implies</span> the builder fully determines the transactions that land onchain).</li>\n</ul>\n<h3><a name=\"p-49714-execution-auctions-an-attester-proposer-separation-instatiation-5\" class=\"anchor\" href=\"https://ethresear.ch#p-49714-execution-auctions-an-attester-proposer-separation-instatiation-5\"></a>Execution Auctions (an Attester-Proposer Separation Instatiation)</h3>\n<p>In contrast to the JIT block auction enabled by <code>PTC</code>, this design enshrines an ahead-of-time slot auction into the Ethereum consensus layer. A <a href=\"https://mirror.xyz/0x03c29504CEcCa30B93FF5774183a1358D41fbeB1/CPYI91s98cp9zKFkanKs_qotYzw09kWvouaAa9GXBrQ\" rel=\"noopener nofollow ugc\">slot auction</a> still allocates the entire block to the winner of the auction, but they no longer need to commit to the specific contents of the block when bidding (e.g., they are buying future block space) – this allows the auction to take place well in advance of the slot itself. The diagram below summarizes the block production pipeline <em>32 slots ahead of time</em> (the 32 is just an arbitrary number; you could run the auction any time in advance or even during the slot itself; the key distinction is the fact that the bids don’t contain commitments to the contents of the block).</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/3/6/36fa041386a05b37b3dad9e959dad6c329d506ba.png\" data-download-href=\"https://ethresear.ch/uploads/default/36fa041386a05b37b3dad9e959dad6c329d506ba\" title=\"upload_ba33d4610c47000f0ac60a5273f91f61\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/3/6/36fa041386a05b37b3dad9e959dad6c329d506ba_2_505x500.png\" alt=\"upload_ba33d4610c47000f0ac60a5273f91f61\" data-base62-sha1=\"7QlrhxVS6jHruAgABd4NJWnGO1k\" width=\"505\" height=\"500\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/3/6/36fa041386a05b37b3dad9e959dad6c329d506ba_2_505x500.png, https://ethresear.ch/uploads/default/optimized/3X/3/6/36fa041386a05b37b3dad9e959dad6c329d506ba_2_757x750.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/3/6/36fa041386a05b37b3dad9e959dad6c329d506ba_2_1010x1000.png 2x\" data-dominant-color=\"F6F6F5\"></a></div><p></p>\n<p>N.B., the first three steps are nearly identical to the <code>PTC</code> process. The only differences are (a) the auction for the <code>Slot N+32</code> block production rights takes place during <code>Slot N</code> and (b) the bid object is a single <code>bid value</code> rather than the <code>(block header, bid value)</code> tuples. The actual building and publication of the block happen during <code>Slot N+32</code>, and <code>Execution Auctions</code> are agnostic to that process.</p>\n<ol>\n<li><strong>The builder bids</strong> in the auction by sending <code>bid value</code> to the proposer and the committee members.</li>\n<li><strong>The proposer commits</strong> to the highest bid value by signing and publishing the winning bid.</li>\n<li><strong>The committee enforces</strong> that the proposer selected a sufficiently high bid according to their view.</li>\n</ol>\n<h4><a name=\"p-49714-analysis-6\" class=\"anchor\" href=\"https://ethresear.ch#p-49714-analysis-6\"></a>Analysis</h4>\n<ul>\n<li><code>Execution Auctions</code> allow the protocol (through the enforcement of the committee) to serve as the trusted third party in the <a href=\"https://citeseerx.ist.psu.edu/document?repid=rep1&amp;type=pdf&amp;doi=208b22c7a094ada20736593afcc8c759c7d1b79c\" rel=\"noopener nofollow ugc\">fair-exchange</a> of the sale of the block building rights for a future slot.</li>\n<li><span><code>Execution Auctions</code> primarily support <strong>design goal <span class=\"hashtag-raw\">#2:</span> limit the value of validator sophistication.</strong></span> With the real-time auction of <code>PTC</code>, we described how the value-in-flight problem results in value from the sophistication of the validators who conduct the auction. In <code>Execution Auctions</code>, the auction occurs apriori, making the value of the object sold less volatile. The validator conducting the auction has a much simpler role that doesn’t benefit from timing games in the way they do in the JIT auction, thereby reducing their value from sophistication.</li>\n<li><span><code>Execution Auctions</code> do not address <strong>design goal <span class=\"hashtag-raw\">#1:</span> encourage builder competition.</strong></span> By running the auction ahead of time, the highest value bidder will always be the builder who is best at producing blocks (h/t Max and Mallesh for <a href=\"https://arxiv.org/pdf/2408.03116\" rel=\"noopener nofollow ugc\">formalizing this</a>). The builder may still choose to sell the block production rights on the secondary market, but only at a premium over the amount they can extract.<a href=\"https://ethresear.ch#fn3dst\"><span class=\"math\">^{[3]}</span></a><a name=\"fn3\"></a></li>\n<li><span><code>Execution Auctions</code> do not address <strong>design goal <span class=\"hashtag-raw\">#3:</span> Preserve the neutrality of Ethereum block space.</strong></span> <code>Execution Auctions</code> are <em>not designed to encourage censorship resistance</em>. We fully expect the future block space and builder markets to remain centralized. Another major concern with <code>Execution Auctions</code> is the risk of multi-slot MEV. Because the auction is not real-time, it is possible to acquire multiple consecutive future slots and launch multi-slot MEV strategies without competing in any auction during the slot itself. (We could try to mitigate this by making the look-ahead only a single slot – e.g., <code>Slot N+1</code> auction during <code>Slot N</code>, but this may open up the same value-in-flight issues around JIT block auctions. More research is needed (and actively being done h/t Julian) here.)</li>\n</ul>\n<h3><a name=\"p-49714-focil-7\" class=\"anchor\" href=\"https://ethresear.ch#p-49714-focil-7\"></a>FOCIL</h3>\n<p>This design allows multiple consensus participants to construct lists of transactions that must be included in a given slot. In contrast to the previous designs, this <em>is not</em> an auction and <em>does not</em> aim to enshrine a MEV marketplace into the protocol. Instead, the focus here is improving the system’s neutrality by allowing multiple parties to co-create a template (in the form of a set of constraints) for the produced block. The diagram below describes the block production process <em>during the slot itself.</em></p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/b/c/bc6cae7b07f724344d704a6bd035e33e82f7500f.png\" data-download-href=\"https://ethresear.ch/uploads/default/bc6cae7b07f724344d704a6bd035e33e82f7500f\" title=\"upload_badb6db529bdfb2640abe1ce4d767dd2\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/b/c/bc6cae7b07f724344d704a6bd035e33e82f7500f_2_455x500.png\" alt=\"upload_badb6db529bdfb2640abe1ce4d767dd2\" data-base62-sha1=\"qSSC2LzxrDmdrY79j3qf78r0d7V\" width=\"455\" height=\"500\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/b/c/bc6cae7b07f724344d704a6bd035e33e82f7500f_2_455x500.png, https://ethresear.ch/uploads/default/optimized/3X/b/c/bc6cae7b07f724344d704a6bd035e33e82f7500f_2_682x750.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/b/c/bc6cae7b07f724344d704a6bd035e33e82f7500f_2_910x1000.png 2x\" data-dominant-color=\"F6F7F7\"></a></div><p></p>\n<ol>\n<li><strong>The IL committee publishes</strong> their inclusion lists to the builder (clumping this together with the proposer for this diagram because the builder must follow the block template) and the attesters.</li>\n<li><strong>The builder publishes</strong> a block that includes an aggregate view of the ILs they received and conforms to the constraints therein.</li>\n<li><strong>The attesters enforce</strong> the block validity conditions, which now check that the builder included a sufficient threshold of observed inclusion lists.</li>\n</ol>\n<h4><a name=\"p-49714-analysis-8\" class=\"anchor\" href=\"https://ethresear.ch#p-49714-analysis-8\"></a>Analysis</h4>\n<ul>\n<li><code>FOCIL</code> increases the protocol’s neutrality by allowing multiple validators to express their preferences in the block co-creation.</li>\n<li><span><code>FOCIL</code> primarily contributes to <strong>design goal <span class=\"hashtag-raw\">#3:</span> preserve the neutrality of Ethereum blockspace.</strong></span> This is the direct goal; more inputs to the block construction seems like a no-brainer (very much in line with the latest thread of <a href=\"https://www.youtube.com/watch?v=mJLERWmQ2uw\" rel=\"noopener nofollow ugc\">concurrent proposer research</a>). Critically, <code>FOCIL</code> intentionally does not give any MEV power to the inclusion list constructors (see <a href=\"https://ethresear.ch/t/uncrowdable-inclusion-lists-the-tension-between-chain-neutrality-preconfirmations-and-proposer-commitments/19372\"><em>Uncrowdability</em></a> for more) to avoid the economic capture of that role. In particular, <code>FOCIL</code> <em>does not</em> aim to constrain the builder’s ability to extract MEV generally; the builder can still reorder and insert transactions at will in their block production process. Instead, it’s their ability to <em>arbitrarily exclude</em> transactions, which <code>FOCIL</code> reduces.</li>\n<li><span><code>FOCIL</code> does not address <strong>design goal <span class=\"hashtag-raw\">#1:</span> encourage builder competition.</strong></span> <code>FOCIL</code> is agnostic to the exact block production process beyond enforcing a block template for transactions that cannot be excluded arbitrarily.</li>\n<li><span><code>FOCIL</code> does not address <strong>design goal <span class=\"hashtag-raw\">#2:</span> limit the value of validator sophistication.</strong></span> <code>FOCIL</code> is agnostic to the exact block production process beyond enforcing a block template for transactions that cannot be excluded arbitrarily.</li>\n</ul>\n<p>Right. That was the “vegetable eating” portion of this article. The critical takeaway is <strong>each of the above proposals primarily addresses one of the cited design goals, but none address all three simultaneously.</strong> This makes it easy to point out flaws in any specific design.<br>\n…<br>\nYou probably see where we are going with this. Let’s not bury the lede. What if we combine them? Each serves a specific role and operates on a different portion of the slot duration; why not play it out?</p>\n<h1><a name=\"p-49714-h-2-mechan-stein-9\" class=\"anchor\" href=\"https://ethresear.ch#p-49714-h-2-mechan-stein-9\"></a>[2] Mechan-stein</h1>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/5/0/508d35ee9a4052135205628aa738a64cbcdd4c51.png\" data-download-href=\"https://ethresear.ch/uploads/default/508d35ee9a4052135205628aa738a64cbcdd4c51\" title=\"upload_bc314953eed471a97f9afd50b068bb14\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/5/0/508d35ee9a4052135205628aa738a64cbcdd4c51_2_440x500.png\" alt=\"upload_bc314953eed471a97f9afd50b068bb14\" data-base62-sha1=\"buAJSXQO5HfSBYYswmTEgmwSzOp\" width=\"440\" height=\"500\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/5/0/508d35ee9a4052135205628aa738a64cbcdd4c51_2_440x500.png, https://ethresear.ch/uploads/default/optimized/3X/5/0/508d35ee9a4052135205628aa738a64cbcdd4c51_2_660x750.png 1.5x, https://ethresear.ch/uploads/default/original/3X/5/0/508d35ee9a4052135205628aa738a64cbcdd4c51.png 2x\" data-dominant-color=\"ADAB9A\"></a></div><p></p>\n<p>With the groundwork laid, we can ~nearly~ combine the three mechanisms directly. There is one issue, however, which arises from both auctions selling the same object – the proposing rights for <code>Slot N+32</code>. The resulting bids in the first auction (the slot auction sale of <code>Slot N+32</code> during <code>Slot N</code>) would thus not carry any economic meaning because bidders would be competing for the slot but would then be forced sellers by the time the slot arrived. To resolve this, the second auction (which happens JIT during the slot) could instead be a Top-of-Block auction (e.g., the first 5mm gas consumed in the block). There are many articles exploring the Top-of-Block/Rest-of-Block split (sometimes called block prefix/suffixes) (see, e.g., <a href=\"https://ethresear.ch/t/how-much-can-we-constrain-builders-without-bringing-back-heavy-burdens-to-proposers/13808\">here</a>, <a href=\"https://github.com/bharath-123/pepc-boost-relay\" rel=\"noopener nofollow ugc\">here</a>, <a href=\"https://ethresear.ch/t/state-lock-auctions-towards-collaborative-block-building/18558\">here</a>), so we won’t go into the details of the consensus changes required to facilitate this exchange. Taking its feasibility for granted, the double-auction design of Mechan-stein makes more sense.<br>\n- <strong>Auction 1 during <code>Slot N</code></strong> sells the block proposing rights for <code>Slot N+32</code> and is conducted by the proposer of <code>Slot N</code>.<br>\n- <strong>Auction 2 during <code>Slot N+32</code></strong> sells the Top-of-Block to a (potentially different) builder who specifies the specific set of transactions to be executed first in the block. This auction is conducted just in time by the builder/winner of Auction 1.</p>\n<p>With this framing, the winner of Auction 1 effectively bought the option to build (or sell) the Rest-of-Block for <code>Slot  N+32</code> – thus the expected value of the bids in that auction would be the average amount of MEV extractable in the block suffix (aside: this might play nicely with <a href=\"https://x.com/barnabemonnot/status/1808444762376020121\" rel=\"noopener nofollow ugc\">preconfs</a>). The diagram below shows the flow at a high level (leaving off many back-and-forths for legibility).</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/8/d/8dd0b952112b0f09ac63c9b1a5fba3e4c718dc60.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/8dd0b952112b0f09ac63c9b1a5fba3e4c718dc60\" title=\"upload_95efb121f762fdc00a15aecb64fe6e54-1\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/8/d/8dd0b952112b0f09ac63c9b1a5fba3e4c718dc60_2_690x373.jpeg\" alt=\"upload_95efb121f762fdc00a15aecb64fe6e54-1\" data-base62-sha1=\"keyvL4i2Ho9QV3E9PximOsHCRcA\" width=\"690\" height=\"373\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/8/d/8dd0b952112b0f09ac63c9b1a5fba3e4c718dc60_2_690x373.jpeg, https://ethresear.ch/uploads/default/optimized/3X/8/d/8dd0b952112b0f09ac63c9b1a5fba3e4c718dc60_2_1035x559.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/8/d/8dd0b952112b0f09ac63c9b1a5fba3e4c718dc60_2_1380x746.jpeg 2x\" data-dominant-color=\"F5F5F5\"></a></div><p></p>\n<ol>\n<li><strong>The <code>Slot N</code> proposer auctions off</strong> the <code>Slot N+32</code> proposing rights.</li>\n<li><strong>The <code>Slot N</code> attesters enforce</strong> the bid threshold of the slot auction.</li>\n<li><em>[32 slots later]</em> <strong>The <code>Slot N+32</code> IL committee publishes</strong> their ILs.</li>\n<li><strong>The <code>Slot N+32</code> builder auctions off</strong> the Top-of-Block for <code>Slot N+32</code>.</li>\n<li><strong>The <code>Slot N+32</code> <code>PTC</code> enforces</strong> the bid threshold of the Top-of-Block auction.</li>\n<li><strong>The <code>Slot N+32</code> <code>PTC</code> enforces</strong> the timeliness of the block publication from the winning builder.</li>\n<li><strong>The <code>Slot N+32</code> attesters enforce</strong> the IL threshold of the final block.</li>\n</ol>\n<p>Yeah, yeah – it’s a lot of steps, but the pitch is pretty compelling.</p>\n<ul>\n<li><span>Mechan-stein addresses <strong>design goal <span class=\"hashtag-raw\">#1:</span> encourage builder competition.</strong></span> The permissionless, JIT Top-of-Block auction helps mitigate the risk of multi-slot MEV in <code>Execution Auctions</code> by <em>forcing</em> the slot auction winner to sell a portion of the block or at least pay a threshold to build the full block themselves.</li>\n<li><span>Mechan-stein addresses <strong>design goal <span class=\"hashtag-raw\">#2:</span> limit the value of validator sophistication.</strong></span> The role of an average validator in block production is now the simple combination of (1) conducting the ahead-of-time slot auction and (2) publishing their inclusion list when part of an IL committee. This greatly reduces the power bestowed on the validator because (1) they are now conducting an auction apriori (thus, latency and timing games play a smaller role) and (2) the inclusion list intentionally does not generate much value for MEV-carrying transactions (because it only guarantees inclusion rather than ordering).</li>\n<li><span>Mechan-stein addresses <strong>design goal <span class=\"hashtag-raw\">#3:</span> preserve the neutrality of Ethereum block space.</strong></span> By allowing many participants to co-create the set of constraints enforced on the builder of each block, high preference entropy is achieved without unduly benefiting the transactions that land in an inclusion list, as block builders can still reorder and insert at their leisure. However, the builder’s ability to exclude is limited, removing some of their monopolist power over the transactions in the block.</li>\n</ul>\n<p>The combined mechanism creates a set of checks and balances where the weaknesses of one design in isolation are the strengths of another. Everything is perfect, right?</p>\n<h3><a name=\"p-49714-potential-issues-with-mechan-stein-10\" class=\"anchor\" href=\"https://ethresear.ch#p-49714-potential-issues-with-mechan-stein-10\"></a>Potential issues with Mechan-stein</h3>\n<p>It might not be only rainbows and butterflies. Without being comprehensive (neither in the list of potential issues nor the responses to said issues), let’s run down a few of the most obvious questions with Mechan-stein and some initial counter-points.</p>\n<ul>\n<li><span><strong>Point <span class=\"hashtag-raw\">#1</span></strong> – complexity, complexity, complexity.</span> This could (and maybe should) count for multiple points (h/t Mallesh for the relevant <a href=\"https://x.com/malleshpai/status/1748026472923623619\" rel=\"noopener nofollow ugc\">tweet</a>). Each of these proposals involves massive changes to the consensus layer of Ethereum with wide-ranging impact (particularly on the fork-choice rule). The devil is truly in the details, and getting something like this spec’ed out and implemented would be an immense research and engineering lift – let’s just say <a href=\"https://en.wikipedia.org/wiki/Occam%27s_razor\" rel=\"noopener nofollow ugc\">William of Ockham</a> would not be impressed.\n<ul>\n<li><span><strong>Counter-point <span class=\"hashtag-raw\">#1</span></strong> – building the future of finance in a permissionless and hyper-financialized world wasn’t going to be simple (“Rome wasn’t built in a day”).</span> It shouldn’t be shocking that there doesn’t seem to be a silver bullet for building an MEV-aware, decentralized, credibly neutral blockchain. Maybe eating the complexity now can leave the chain in a more stable equilibrium. Also, there may be significant synergies in combining designs (e.g., using the same committee for <code>FOCIL</code> and <code>PTC</code>). You could probably do a subset of Mechan-stein and still get some benefits (e.g., <code>FOCIL</code> + <code>PTC</code>).</li>\n</ul>\n</li>\n<li><span><strong>Point <span class=\"hashtag-raw\">#2</span></strong> – how may the ahead-of-time slot auction distort the MEV market?</span> Mostly just reciting <a href=\"https://arxiv.org/pdf/2408.03116\" rel=\"noopener nofollow ugc\">Max and Mallesh’s</a> argument (3rd time referencing that paper in this article lol). By removing the real-time nature of the initial auction, you bias it towards a winner-take-all for the best builder (or the “Best Block Space Future Value Estimator™”). I’d say this is similar in spirit to the Phil Daian view of making the competition as deterministic as possible (e.g., <a href=\"https://youtu.be/SBOGdofF4u8?t=620\" rel=\"noopener nofollow ugc\">“deterministic vs statistical opportunities”</a>).\n<ul>\n<li><span><strong>Counter-point <span class=\"hashtag-raw\">#2</span></strong> – that is the point of still having the <code>PTC</code> conduct a JIT Top-of-Block auction.</span> I think this feels reasonable. However, there is still a slight edge that the auctioneer (who may be a builder themselves) has in the JIT auction, which is they can benefit from the sophistication and latency investments as they are the auctioneer and a participant. As mentioned above, you could consider skipping the <code>Execution Auctions</code> part of Mechan-stein and just going with <code>FOCIL</code> + <code>PTC</code> (or even leave <code>MEV-boost</code> alone as the primary PBS market and just do <code>FOCIL</code>). (h/t Justin for pointing out that you could try to do <code>Execution Auctions</code> where multiple proposers (more than one auction winner) are selected – another combined mechanism that tries to mitigate the multi-slot MEV risk.)</li>\n</ul>\n</li>\n<li><span><strong>Point <span class=\"hashtag-raw\">#3</span></strong> – there is still power in being the block producer.</span> As pointed out in this <a href=\"https://ethresear.ch/t/fork-choice-enforced-inclusion-lists-focil-a-simple-committee-based-inclusion-list-proposal/19870/3\">comment</a> and <a href=\"https://ethresear.ch/t/fork-choice-enforced-inclusion-lists-focil-a-simple-committee-based-inclusion-list-proposal/19870/4\">its response</a> on the <code>FOCIL</code> post, there is still some discretionary power in being the block builder. Namely, they can choose which ILs they exclude from their aggregate up to some protocol-enforced tolerance. This notion of having an IL “aggregator” is the main difference between <code>FOCIL</code> and a leaderless approach like <a href=\"https://www.youtube.com/watch?v=mJLERWmQ2uw\" rel=\"noopener nofollow ugc\">Braid</a>.\n<ul>\n<li><span><strong>Counter-point <span class=\"hashtag-raw\">#3</span></strong> – this seems like a fundamental feature.</span> Again, I find myself leaning on Phil’s comment and mental model for “how economic power expresses itself in the protocol.” In a distributed system with network latency and geographic decentralization, some parties will have advantages over others. Suppose the protocol doesn’t explicitly imbue some participants with power during some period (e.g., by electing a leader). In that case, that power will still manifest somewhere else, likely in a more implicit (thus more sophisticated) way. This is more of a meta point, and I am happy to be convinced otherwise.</li>\n</ul>\n</li>\n</ul>\n<p>All right, going to cut it here; hope you found it interesting. Lot’s to think on still.</p>\n<p><em>thank for reading <img src=\"https://ethresear.ch/images/emoji/facebook_messenger/heart.png?v=12\" title=\":heart:\" class=\"emoji\" alt=\":heart:\" loading=\"lazy\" width=\"20\" height=\"20\"> -mike</em></p>\n<hr>\n<h3><a name=\"p-49714-footnotes-11\" class=\"anchor\" href=\"https://ethresear.ch#p-49714-footnotes-11\"></a>footnotes</h3>\n<p><span class=\"math\">^{[1]}</span><a name=\"fn1dst\"></a>: It is worth noting that, conditioned on having strong censorship resistance properties, the difference between a monopolist builder and a competitive marketplace of builders isn’t so vital. As discussed with Barnabé and Julian, perhaps a more important property is the “replace-ability” of a monopolist builder if they begin abusing their power. All else being equal, I still prefer the outcome where we have multiple builders, even if just for the memetic reality of having a single block builder looks highly centralized, even if the other consensus participants heavily constrain them. Hence, builder competition still feels like a fair desiderata.<a href=\"https://ethresear.ch#fn1\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/leftwards_arrow_with_hook.png?v=12\" title=\":leftwards_arrow_with_hook:\" class=\"emoji\" alt=\":leftwards_arrow_with_hook:\" loading=\"lazy\" width=\"20\" height=\"20\">︎</a></p>\n<p><span class=\"math\">^{[2]}</span><a name=\"fn2dst\"></a>: Vitalik pointed out that when he originally wrote this, he was referring more to the act of validating the blocks (e.g., by verifying a ZK proof) rather than explicitly participating in consensus. The name “validator” denotes someone who engages in consensus, which has been a nomenclatural pain point since the launch of the beacon chain. Despite this, I still like the framing of keeping some form of consensus participation decentralized (mainly as a means to better chain neutrality), so I will slightly abuse the naming confusion. xD <a href=\"https://ethresear.ch#fn2\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/leftwards_arrow_with_hook.png?v=12\" title=\":leftwards_arrow_with_hook:\" class=\"emoji\" alt=\":leftwards_arrow_with_hook:\" loading=\"lazy\" width=\"20\" height=\"20\">︎</a></p>\n<p><span class=\"math\">^{[3]}</span><a name=\"fn3dst\"></a>: It is worth noting that validators could also choose to only sell their block at a premium in the more general case through the use of the <a href=\"https://writings.flashbots.net/the-cost-of-resilience\" rel=\"noopener nofollow ugc\"><code>min-bid</code></a> feature of <code>MEV-boost</code>. See more on <code>min-bid</code> from <a href=\"https://mirror.xyz/0x03c29504CEcCa30B93FF5774183a1358D41fbeB1/8aCbi_a-Gh5DWnkJWstm8zA5fvtoQB-QR5we7C8XC90\" rel=\"noopener nofollow ugc\">Julian</a> and <a href=\"https://hackmd.io/@dataalways/resilience\" rel=\"noopener nofollow ugc\">Data Always</a>. <a href=\"https://ethresear.ch#fn3\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/leftwards_arrow_with_hook.png?v=12\" title=\":leftwards_arrow_with_hook:\" class=\"emoji\" alt=\":leftwards_arrow_with_hook:\" loading=\"lazy\" width=\"20\" height=\"20\">︎</a></p>\n            <p><small>6 posts - 5 participants</small></p>\n            <p><a href=\"https://ethresear.ch/t/mechan-stein-alt-franken-ism/20321\">Read full topic</a></p>","link":"https://ethresear.ch/t/mechan-stein-alt-franken-ism/20321","pubDate":"Wed, 21 Aug 2024 13:23:40 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20321"},"source":{"@url":"https://ethresear.ch/t/mechan-stein-alt-franken-ism/20321.rss","#text":"Mechan-stein (alt. Franken-ism)"}},{"title":"L2 sequencer proving on weak hardware; parallelization and decentralization","dc:creator":"rezahsnz","category":"ZK Rollup","description":"<p><a href=\"https://ethresear.ch/t/vortex-building-a-prover-for-the-zk-evm/14427\">Linea’s sequencer</a> proves a 30m gassed block of transactions in 5 minutes. Here’s its setup:</p>\n<blockquote>\n<ul>\n<li>On a 96 cores machine with 384 GB of RAM (hpc6a.48xlarge on AWS)</li>\n<li>In 5 minutes (only including the inner-proof)</li>\n</ul>\n</blockquote>\n<p>So is it possible to reduce the proving time and, at the same time, obtain decentralization guarantees? We have an idea.</p>\n<h3><a name=\"p-49694-overview-1\" class=\"anchor\" href=\"https://ethresear.ch#p-49694-overview-1\"></a>Overview</h3>\n<p>Almost all of the L2 sequencers are closed-source, intellectual property, and thus protected behind centralized setups. To cram that much power into an entity requires a great deal of justification today. To decentralize the flow, on the other hand, one has to accept certain amounts of delay and noise usually found in decentralized compute networks.</p>\n<h4><a name=\"p-49694-zkvms-recursion-and-risc0s-approach-2\" class=\"anchor\" href=\"https://ethresear.ch#p-49694-zkvms-recursion-and-risc0s-approach-2\"></a>zkVMs, recursion, and Risc0’s approach</h4>\n<p>Any zkVM toolset puts a certain upper bound on the maximum number of cycles(roughly speaking 1 cycle equals 1 operation) it can prove in one go. This is usually done for efficiency reasons. For <a href=\"https://github.com/risc0\" rel=\"noopener nofollow ugc\">Risc0</a>, a RISC-V general zkVM, it is 2^24 ~ 16.78m cycles. With recursion, proving infinitely sized programs are made possible. So the solution is to divide a large program into individual sub-programs(called segment in Risc0 jargon) and have them proved one by one and aggregate the proofs into a final proof as if the whole program was proved in one go. For example, consider proving a 1b cycles program. With 16.78M maximum segment size limit, one ends up proving 60 segments. The upper bound for segment size limit is not the end of story however and one can customize it into a well-known range of [2^13 - 2^24]. Each segment limit size needs specific memory requirements shown on Table 1:<br>\n</p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/b/7/b790b7f5fb18cec94d0e621383844425862ba9fb.png\" data-download-href=\"https://ethresear.ch/uploads/default/b790b7f5fb18cec94d0e621383844425862ba9fb\" title=\"Screenshot from 2024-07-18 14-37-34\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/b/7/b790b7f5fb18cec94d0e621383844425862ba9fb_2_690x387.png\" alt=\"Screenshot from 2024-07-18 14-37-34\" data-base62-sha1=\"qbTqZ7OMhRtwxJFVg1x6kuxiXub\" width=\"690\" height=\"387\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/b/7/b790b7f5fb18cec94d0e621383844425862ba9fb_2_690x387.png, https://ethresear.ch/uploads/default/optimized/3X/b/7/b790b7f5fb18cec94d0e621383844425862ba9fb_2_1035x580.png 1.5x, https://ethresear.ch/uploads/default/original/3X/b/7/b790b7f5fb18cec94d0e621383844425862ba9fb.png 2x\" data-dominant-color=\"FAFAFA\"></a></div><br>\nExtrapolating Table 1’s values, we get 50m cycles for a program that needs 384gb of memory, in order to be proved in Risc0. Recall that Linea’s prover uses 384gb of memory to generate proofs. This is a naive 1-1 translation, but we can treat it as baseline for further testing. So, with this assumption, should one write Linea’s sequencer logic in Risc0, she would end up with a program that is 50m cycles long. Doubling cycles to ~90m, to account for aggregation won’t hurt here.<p></p>\n<h4><a name=\"p-49694-segmentation-parallel-proving-and-decentralization-3\" class=\"anchor\" href=\"https://ethresear.ch#p-49694-segmentation-parallel-proving-and-decentralization-3\"></a>Segmentation, parallel proving, and decentralization</h4>\n<p>Recursion is a powerful idea in zkVM proving. With recursion once can get to prove seemingly large programs very quickly assuming she has a prove-ready network of machines. Table 2 shows a segmented prove session for a 90m cycles program on a pretty weak machine(8+ years old, Intel core i7 5500U(2C 4T), 16gb memory):<br>\n</p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/0/9/091af39f1eb4b3465f1de18222eed6c4d1051edb.png\" data-download-href=\"https://ethresear.ch/uploads/default/091af39f1eb4b3465f1de18222eed6c4d1051edb\" title=\"Screenshot from 2024-07-18 14-47-06\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/0/9/091af39f1eb4b3465f1de18222eed6c4d1051edb_2_690x235.png\" alt=\"Screenshot from 2024-07-18 14-47-06\" data-base62-sha1=\"1iy2x6FkIBx6qV5pfSRvPJE0oKT\" width=\"690\" height=\"235\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/0/9/091af39f1eb4b3465f1de18222eed6c4d1051edb_2_690x235.png, https://ethresear.ch/uploads/default/optimized/3X/0/9/091af39f1eb4b3465f1de18222eed6c4d1051edb_2_1035x352.png 1.5x, https://ethresear.ch/uploads/default/original/3X/0/9/091af39f1eb4b3465f1de18222eed6c4d1051edb.png 2x\" data-dominant-color=\"F0F4EF\"></a></div><p></p>\n<p>As you can see, different segment size limits result in varied proving regimes. In Table 2, two columns are colored in green, 2^18 and 2^19. Consulting Table 1, we would get 2gb and 4gb of required memory to prove them respectively. These columns are sweet spots for any zkVM proving network whose nodes are presumably weak. Focusing on the 2^19 segment size limit, to prove a 90m cycles program, one would need at least 168 nodes in order to prove the program in 4 minutes and 9 seconds. But 168 nodes is a faulty assumption. In reality, if a p2p network is to undertake the proving job, it needs to have redundancy values of 1:4 and above. The redundancy accounts for noise that is a feature of any p2p network. With 1:4 redundant nodes, 1 in every 5 nodes is assumed to be honest and the rest are time wasters. So, a 1:4 redundant p2p network needs at least of 840 nodes to get the job done.<br>\nAssuming that the proving network is p2p, one can expect to obtain decentralized guarantees en route.</p>\n<h3><a name=\"p-49694-conclusion-4\" class=\"anchor\" href=\"https://ethresear.ch#p-49694-conclusion-4\"></a>Conclusion</h3>\n<p>Here we introduced an imaginary setup to decentralize and improve L2 sequencer proving times. If the claim turns out to be legit, we would expect to improve the overall proving time for any zkVM application area. In addition, the setup provides decentralization guarantees as a side effect. While everything looks nice, we, at <a href=\"https://github.com/WholesumNet\" rel=\"noopener nofollow ugc\">Wholesum network</a> would like to put this setup to test and see if it works in action. If successful, a p2p verifiable compute network of 10,000 weak nodes can handle up to 10 Linea like L2s.</p>\n<p>A somewhat more expanded version of this post is also available <a href=\"https://github.com/WholesumNet/docs/blob/779942cf6f650d24fcedf2d8da5a6dd2033a9fee/parallelization/parallelized-proving/report.pdf\" rel=\"noopener nofollow ugc\">here</a>.</p>\n<p>We appreciate your feedback.</p>\n            <p><small>2 posts - 1 participant</small></p>\n            <p><a href=\"https://ethresear.ch/t/l2-sequencer-proving-on-weak-hardware-parallelization-and-decentralization/20313\">Read full topic</a></p>","link":"https://ethresear.ch/t/l2-sequencer-proving-on-weak-hardware-parallelization-and-decentralization/20313","pubDate":"Tue, 20 Aug 2024 15:18:35 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20313"},"source":{"@url":"https://ethresear.ch/t/l2-sequencer-proving-on-weak-hardware-parallelization-and-decentralization/20313.rss","#text":"L2 sequencer proving on weak hardware; parallelization and decentralization"}},{"title":"On Proposer Timing Games and Economies of Scale","dc:creator":"Nero_eth","category":"Economics","description":"<h1><a name=\"p-49689-on-proposer-timing-games-and-economies-of-scale-1\" class=\"anchor\" href=\"https://ethresear.ch#p-49689-on-proposer-timing-games-and-economies-of-scale-1\"></a>On Proposer Timing Games and Economies of Scale</h1>\n<p><a href=\"https://timing.pics\">Timing games</a> are a known phenomenon (<a href=\"https://eprint.iacr.org/2023/760\">[1]</a>, <a href=\"https://arxiv.org/abs/2305.09032\">[2]</a> and <a href=\"https://ethresear.ch/t/deep-diving-attestations-a-quantitative-analysis/20020\">[3]</a>). The concern is that proposer timing games come with a negative impact on the network.</p>\n<p>In the following, I want to show how the success of playing proposer timing games is also a function of economies of scale.</p>\n<p><strong>The main finding is:</strong><br>\n<em><strong> → An entity with 30% market share can delay 0.8s longer than a 5% entity.</strong></em><br>\n<em><strong> → For every 1% increase in validator market share, the delay in block proposals can increase by 0.03 seconds without facing additional reorg risk.</strong></em></p>\n<p><img src=\"https://ethresear.ch/uploads/default/original/3X/c/5/c58fec82d848d1fb7ae0352e8c50c4e8071253c5.png\" alt=\"tgeos\" data-base62-sha1=\"sbIpRwMTj4kkAqp5n8VjmOUp793\" width=\"456\" height=\"318\"></p>\n<p><em>Special thanks to <a href=\"https://x.com/weboftrees\">Anders</a>, <a href=\"https://x.com/mikeneuder\">Mike</a> and <a href=\"https://x.com/casparschwa\">Caspar</a> for feedback!</em></p>\n<h2><a name=\"p-49689-introduction-2\" class=\"anchor\" href=\"https://ethresear.ch#p-49689-introduction-2\"></a>Introduction</h2>\n<p>A proposer must gather at least 40% of these votes to ensure their block is accepted and not reorged by the following proposer. It’s 40% because that’s the proposer boost threshold. Blocks with less than 40% attestations can be reorged by the next proposer leveraging proposer boost. The challenge for a timing-gamer lies in determining the optimal time to propose (or call getHeader). An economically rational validator would want to wait as long as possible (providing the builder with the longest possible time window) without risking a reorg.</p>\n<p>First, let’s revisit the following chart from <a href=\"https://ethresear.ch/t/deep-diving-attestations-a-quantitative-analysis/20020\">this analysis</a>:<br>\n</p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/4/2/42fe46361f7b2a22bd61c0195f719a57df04d64d.png\" data-download-href=\"https://ethresear.ch/uploads/default/42fe46361f7b2a22bd61c0195f719a57df04d64d\" title=\"42fe46361f7b2a22bd61c0195f719a57df04d64d\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/4/2/42fe46361f7b2a22bd61c0195f719a57df04d64d_2_690x304.png\" alt=\"42fe46361f7b2a22bd61c0195f719a57df04d64d\" width=\"690\" height=\"304\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/4/2/42fe46361f7b2a22bd61c0195f719a57df04d64d_2_690x304.png, https://ethresear.ch/uploads/default/optimized/3X/4/2/42fe46361f7b2a22bd61c0195f719a57df04d64d_2_1035x456.png 1.5x, https://ethresear.ch/uploads/default/original/3X/4/2/42fe46361f7b2a22bd61c0195f719a57df04d64d.png 2x\" data-dominant-color=\"FBFBFC\"></a></div><p></p>\n<p><strong>~80% of all attestations are seen until second 5 in the slot</strong>. The <strong>40% threshold is reached somewhere around second 3.8</strong>. Thus, assuming zero latency, a block published at second 3.8 should still be able to receive 60% of attestations.</p>\n<p><strong>In the following, we refer to this curve as <span class=\"math\">C(t)</span>.</strong></p>\n<h2><a name=\"p-49689-initial-setup-3\" class=\"anchor\" href=\"https://ethresear.ch#p-49689-initial-setup-3\"></a>Initial Setup</h2>\n<p>The core idea is to determine how the cumulative votes cast by validators evolve over a slot and how a proposer’s control over a portion of these validators may influence the optimal timing of their block proposal.</p>\n<p>Given that <span class=\"math\">C(t)</span> represents the cumulative percentage of votes cast by time <span class=\"math\">t</span>, the proposer controls <span class=\"math\">x\\%</span> of validators, and needs to ensure that they can still reach at least 40% by the time they propose, we start with the following condition:</p>\n<div class=\"math\">\nx + (1 - C(t)) \\times (1 - x) \\geq 0.4\n</div>\n<p>In this equation:</p>\n<ul>\n<li><strong><span class=\"math\">(1 - C(t)) \\times (1 - x)</span>:</strong> The remaining uncast votes from validators not controlled by the proposer, which could support the proposer’s block.</li>\n</ul>\n<blockquote>\n<p>Note that <strong><span class=\"math\">x \\times C(t)</span></strong> would be the portion of votes from the proposer’s validators already included in <span class=\"math\">C(t).</span></p>\n</blockquote>\n<p>Two assumptions are important to stress:</p>\n<ul>\n<li><strong>Coordination</strong>: It is assumed that validators coordinate when attesting, e.g. using a central oracle that provides the commands.</li>\n<li><strong>Honest Validators</strong>: All validators who have not yet voted at the time of the block proposal will vote for the proposed block (and not the parent block). See <a href=\"https://github.com/ethereum/consensus-specs/blob/b2f2102dad0cd8b28a657244e645e0df1c0d246a/specs/phase0/validator.md#phase-0----honest-validator\">honest validator specs</a>.</li>\n</ul>\n<h3><a name=\"p-49689-simplifying-the-equation-4\" class=\"anchor\" href=\"https://ethresear.ch#p-49689-simplifying-the-equation-4\"></a>Simplifying the Equation</h3>\n<p>We rearrange the initial equation to find the threshold for <span class=\"math\">C(t)</span>, the cumulative percentage of votes that can be cast before the proposer must act:</p>\n<div class=\"math\">\nx + (1 - C(t)) \\times (1 - x) \\geq 0.4\n</div>\n<p>Expanding and simplifying:</p>\n<div class=\"math\">\n(1−C(t))×(1−x) = 1 - x - C(t) + C(t) \\times x \n</div>\n<div class=\"math\">\n1 - C(t) + C(t) \\times x \\geq 0.4\n</div>\n<p>Finally, solving for <span class=\"math\">C(t)</span>:</p>\n<div class=\"math\">\nC(t) \\leq \\frac{0.6}{1 - x}\n</div>\n<p>Find the complete derivation <a href=\"https://hackmd.io/L0A6zeBZSzGew2Ni0AzFVQ\">here</a>.</p>\n<h3><a name=\"p-49689-interpretation-5\" class=\"anchor\" href=\"https://ethresear.ch#p-49689-interpretation-5\"></a>Interpretation</h3>\n<p>This simplified equation <span class=\"math\">C(t) \\leq \\frac{0.6}{1 - x}</span> means that the proposer can safely propose as long as the cumulative attestations <span class=\"math\">C(t)</span> remain below the threshold defined by <span class=\"math\">\\frac{0.6}{1 - x}</span>.</p>\n<ul>\n<li><strong><span class=\"math\">C(t)</span>:</strong> The cumulative percentage of votes cast by time <span class=\"math\">t</span>.</li>\n<li><strong><span class=\"math\">x \\%</span>:</strong> The percentage of total validators controlled by the proposer.</li>\n<li><strong><span class=\"math\">0.4</span>:</strong> The 40% threshold needed to secure a majority (<span class=\"math\">1-0.4=0.6)</span>.</li>\n</ul>\n<p>The equation ensures that the proposer, with their share of validators, can still influence the outcome favorably by proposing before the cumulative attestations exceed this threshold.</p>\n<p>A node operator with many validators can risk a few seconds more than a small-size operator, knowing that their own validators will never vote against them.</p>\n<p><strong>The following chart shows the effects of economies of scale and answers the question of <em>how long a node operator with <em>x%</em> market share can maximally wait until the point it won’t be able to receive at least 40% of all attestations anymore</em>.</strong></p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/e/2/e24d2c92d6d6e9a6965edcac0b21f454c6404795.png\" data-download-href=\"https://ethresear.ch/uploads/default/e24d2c92d6d6e9a6965edcac0b21f454c6404795\" title=\"timing_games_proposer_share\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/e/2/e24d2c92d6d6e9a6965edcac0b21f454c6404795_2_690x383.png\" alt=\"timing_games_proposer_share\" data-base62-sha1=\"whXfGVbSxvX8hcoDUyfDKp6p04B\" width=\"690\" height=\"383\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/e/2/e24d2c92d6d6e9a6965edcac0b21f454c6404795_2_690x383.png, https://ethresear.ch/uploads/default/original/3X/e/2/e24d2c92d6d6e9a6965edcac0b21f454c6404795.png 1.5x, https://ethresear.ch/uploads/default/original/3X/e/2/e24d2c92d6d6e9a6965edcac0b21f454c6404795.png 2x\" data-dominant-color=\"FAF9F9\"></a></div><p></p>\n<p>The “<em>seconds in slot</em>” values on the y-axis are <code>attestation_seen</code> timestamps that are not corrected by the time required for block propagation and verification. Since those numbers are just constants impacting the absolute values on the y-axis, this doesn’t matter in making the relative impact of market share on the limits of timing games visible.</p>\n<p><strong>We can see that a node operator with 30% of the market share can potentially wait 0.8 seconds longer than a node operator with 5% market share while risking the same.</strong></p>\n<h2><a name=\"p-49689-in-python-6\" class=\"anchor\" href=\"https://ethresear.ch#p-49689-in-python-6\"></a>In Python</h2>\n<p>Using Python, we can calculate the latest “safe” proposal time for different percentages of validator control. Here’s the key part of the implementation:</p>\n<pre data-code-wrap=\"python\"><code class=\"lang-python\">import numpy as np\nfrom scipy.interpolate import interp1d\n\n# Provided cumulative attestation data (seconds, % of casted attestations)\ndata = [\n     (0.791, 0.0005390835579514825),\n     # (additional data points omitted for brevity)\n     (2.228, 0.05444743935309973),\n     (2.464, 0.10835579514824797),\n     (2.639, 0.16226415094339622),\n     (2.777, 0.21617250673854446),\n     (2.932, 0.27008086253369273),\n     (3.104, 0.323989218328841),\n     (3.308, 0.3778975741239892),\n     (3.627, 0.43180592991913747),\n     (4.069, 0.4857142857142857),\n     (4.25, 0.539622641509434),\n     (4.407, 0.5935309973045823),\n     (4.576, 0.6474393530997304),\n     (4.723, 0.7013477088948787),\n     (4.898, 0.7552560646900269),\n     (5.039, 0.8091644204851752),\n     (5.245, 0.8630727762803234),\n     (5.521, 0.9169811320754717),\n     (6.187, 0.9708894878706199)\n]\n\n# Extracting the times and cumulative attestation percentages\ntimes = np.array([point[0] for point in data])\ncumulative_attestations = np.array([point[1] for point in data])\n\n# Interpolating the cumulative attestation function\ncumulative_attestation_func = interp1d(times, cumulative_attestations, kind='linear', fill_value=\"extrapolate\")\n\n# Function to calculate the latest time a proposer with x% control can safely propose a block\ndef calculate_latest_proposal_time(x):\n    threshold = 0.5 / (1 - x)\n    \n    for t in np.linspace(times[0], times[-1], 1000):\n        if cumulative_attestation_func(t) &gt; threshold:\n            return t\n    return None\n\n</code></pre>\n<h1><a name=\"p-49689-conclusion-7\" class=\"anchor\" href=\"https://ethresear.ch#p-49689-conclusion-7\"></a>Conclusion</h1>\n<p>By understanding and calculating the relationship between validator market share and cumulative attestations, proposers can optimize their proposal timing to minimize the likelihood of reorgs while maximizing profits.</p>\n<p>Such strategies could be improved by checking which CL client the subsequent validator runs, or, even simpler, the slot index in an epoch. Based on that information one can better estimate the chances of getting reorged (e.g. if it’s Teku, Nimbus, Lodestar, or the last slot in an epoch, then the reorg probability is significantly lower because no honest reorg strategy is implemented).</p>\n<p>Pushing proposer timing games to their limits has a <a href=\"https://ethresear.ch/t/on-attestations-block-propagation-and-timing-games/20272\">negative impact on attesters</a> and can have cascading effects: If validators realize they miss out on profits because they vote for the wrong block too often, they might start delaying their attestation.</p>\n<p><strong>Ultimately, pushing timing games to their limits can have a detrimental impact on the network. Furthermore, validator coordination that goes beyond running multiple validators from a single node shouldn’t be tolerated/supported. Now, it is important to follow/contribute to block construction research and find ways to <a href=\"https://eips.ethereum.org/EIPS/eip-7716\">reduce the profitability of timing games</a> or prevent them entirely.</strong></p>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://ethresear.ch/t/on-proposer-timing-games-and-economies-of-scale/20309\">Read full topic</a></p>","link":"https://ethresear.ch/t/on-proposer-timing-games-and-economies-of-scale/20309","pubDate":"Tue, 20 Aug 2024 05:48:59 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20309"},"source":{"@url":"https://ethresear.ch/t/on-proposer-timing-games-and-economies-of-scale/20309.rss","#text":"On Proposer Timing Games and Economies of Scale"}},{"title":"Decentralized and Verifiable Cloud Service on Ethereum","dc:creator":"0x1cc","category":"Applications","description":"<p><em>by <a href=\"https://x.com/0x_1cc\" rel=\"noopener nofollow ugc\">KD.Conway</a></em></p>\n<h2><a name=\"p-49659-tldr-1\" class=\"anchor\" href=\"https://ethresear.ch#p-49659-tldr-1\"></a>TL;DR</h2>\n<ul>\n<li>\n<p>We propose a decentralized and verifiable cloud service protocol on Ethereum, which can provide computationally intensive service to all web2 or web3 applications, making decentralized ChatGPT, decentralized blockchain explorer reality. By migrating the full stack, including frontend and backend components, to the decentralized cloud, we move toward fully decentralized and verifiable end-to-end Web3 applications.</p>\n</li>\n<li>\n<p>The protocol operates under a minority trust assumption, requiring only one honest node to guarantee service quality. Additionally, the correctness of the cloud service is verifiable on Ethereum.</p>\n</li>\n<li>\n<p>With near-zero on-chain costs, our decentralized cloud service platform can be even more affordable than traditional centralized options.</p>\n</li>\n</ul>\n<h2><a name=\"p-49659-protocol-overview-2\" class=\"anchor\" href=\"https://ethresear.ch#p-49659-protocol-overview-2\"></a>Protocol Overview</h2>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/d/8/d816db0bb6bbc127b1a5f2fa1f320e7c923dbb77.png\" data-download-href=\"https://ethresear.ch/uploads/default/d816db0bb6bbc127b1a5f2fa1f320e7c923dbb77\" title=\"ecs\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/d/8/d816db0bb6bbc127b1a5f2fa1f320e7c923dbb77_2_690x331.png\" alt=\"ecs\" data-base62-sha1=\"uPC6iBUHxlToWnG59kzCXWtSGtF\" width=\"690\" height=\"331\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/d/8/d816db0bb6bbc127b1a5f2fa1f320e7c923dbb77_2_690x331.png, https://ethresear.ch/uploads/default/optimized/3X/d/8/d816db0bb6bbc127b1a5f2fa1f320e7c923dbb77_2_1035x496.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/d/8/d816db0bb6bbc127b1a5f2fa1f320e7c923dbb77_2_1380x662.png 2x\" data-dominant-color=\"F1F2F3\"></a></div><p></p>\n<p>A service contract exists on Ethereum, functioning similarly to a gRPC protobuf. This contract defines the service, and the functions within it specify the methods that can be invoked.</p>\n<p>Each service provider must register and stake on the service contract. For each service, multiple providers will be available to offer the service.</p>\n<p>When a user initiates a service request, such as requesting an AI inference from an LLM model:</p>\n<ul>\n<li>\n<p>The user first utilizes a verifiable Ethereum light client, such as Helios, to retrieve the list of available service providers from the on-chain service contract.</p>\n</li>\n<li>\n<p>The user randomly selects several providers from this list.</p>\n</li>\n<li>\n<p>The user then sends off-chain transactions to these selected providers in parallel. These off-chain transactions are essentially the same as calling the corresponding service function in the smart contract, but they use a different chain ID. This specific chain ID indicates that the transaction is intended to call a cloud service rather than perform an on-chain transaction on Ethereum.</p>\n</li>\n<li>\n<p>The service providers execute the required computations in their local environments according to the program defined in the corresponding function in the service contract. They then return the responses to the user. Each response is signed by the service provider and includes the user’s transaction hash and the results.</p>\n</li>\n<li>\n<p>Upon receiving the responses from the selected providers, the user first verifies the signatures and checks the consistency of the results.</p>\n<ul>\n<li>\n<p>If the results are consistent, the service is considered to have functioned correctly, and no further action is required.</p>\n</li>\n<li>\n<p>If there is a discrepancy in the results, this indicates the presence of at least one malicious service provider. In this case, the user submits the providers’ responses to the on-chain arbitration contract. This triggers a process where the service providers must defend the accuracy of their results. The on-chain arbitration process is detailed in the following section.</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2><a name=\"p-49659-service-contract-3\" class=\"anchor\" href=\"https://ethresear.ch#p-49659-service-contract-3\"></a>Service Contract</h2>\n<p>The design of the service contract is akin to the design of gRPC. A new service contract corresponds to a new service in gRPC, and the functions defined in the service contract specify the methods that can be invoked. Due to the constraints of smart contracts, we cannot implement complex computations, such as AI computations, directly within the smart contract. Instead, we define a standard for writing a program, which is then uploaded to decentralized DA services, with the program’s hash stored in the on-chain smart contract.</p>\n<p>Following the design principle of “Separate Execution from Proving,” there are two implementations for the service program. One is compiled for native execution, optimized for speed, and can leverage multithreaded CPUs and GPUs to accelerate execution. The other implementation is for proving; the service program is compiled into machine-independent code, allowing us to use zkVM (zero-knowledge virtual machine) or fpVM (fraud-proof virtual machine) to generate proofs. This dual-target approach ensures fast execution, while proving is based on the machine-independent code.</p>\n<p>For example, consider matrix multiplication. Native execution utilizes GPU computation (e.g., CUDA) for acceleration. During the proving phase, the service program is compiled into machine-independent instructions, which can be executed in zkVM or fpVM. Both implementations ensure consistent execution results.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/b/1/b1ccfdf9e6f994151293a835a4619dca5e974865.png\" data-download-href=\"https://ethresear.ch/uploads/default/b1ccfdf9e6f994151293a835a4619dca5e974865\" title=\"output\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/b/1/b1ccfdf9e6f994151293a835a4619dca5e974865_2_690x151.png\" alt=\"output\" data-base62-sha1=\"pmTHL7pfXZqNQUG3qbGzDdecvfD\" width=\"690\" height=\"151\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/b/1/b1ccfdf9e6f994151293a835a4619dca5e974865_2_690x151.png, https://ethresear.ch/uploads/default/optimized/3X/b/1/b1ccfdf9e6f994151293a835a4619dca5e974865_2_1035x226.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/b/1/b1ccfdf9e6f994151293a835a4619dca5e974865_2_1380x302.png 2x\" data-dominant-color=\"F8F8F9\"></a></div><p></p>\n<p>When processing user requests, service providers will run the program in the native execution environment and return the results to the users. Only when on-chain arbitration is required will the service providers run the program for proving. This approach allows service providers to handle requests as quickly as possible in most cases.</p>\n<p>Additionally, the service program can be configured to read data from trustworthy sources, such as Ethereum or other blockchains, as well as from decentralized, trustworthy data storage providers. This flexibility allows the service program to function as a blockchain explorer, an AI service, or a decentralized search engine.</p>\n<p>A demo version of the service contract is shown below.</p>\n<pre data-code-wrap=\"solidity\"><code class=\"lang-solidity\">contract Service {\n\n    // address =&gt; web2 domain\n    mapping(address =&gt; string) serviceProviderHost;\n\n    address[] serviceProviders;\n\n    // function selector =&gt; programHash\n    mapping(bytes4 =&gt; bytes32) programHashs;\n\n    event Request(\n        address account,\n        bytes4 functionSelector,\n        bytes32 programHash,\n        bytes input\n    );\n\n    function func1(bytes calldata input) public {\n        emit Request(msg.sender, this.func1.selector, programHashs[this.func1.selector], input);\n    }\n}\n</code></pre>\n<p>Note that <code>func1</code> specifies the method that can be called. When a user wants to call <code>func1</code>, instead of sending an on-chain transaction on Ethereum, the user needs to send an off-chain transaction directly to the service providers. Besides, the user can obtain the list of service provider addresses, along with their corresponding Web2 domains using Ethereum verifiable light client.</p>\n<h2><a name=\"p-49659-onchain-arbitration-4\" class=\"anchor\" href=\"https://ethresear.ch#p-49659-onchain-arbitration-4\"></a>Onchain Arbitration</h2>\n<p>We support multiple proving systems for on-chain arbitration, including zero-knowledge proofs, Trusted Execution Environments (TEE), and fraud-proof systems. For demonstration purposes, we focus on the fraud-proof system, as it offers lower generation costs compared to zero-knowledge proofs and does not require specific hardware. In previous work, we demonstrated the ability to generate fraud proofs for extremely large AI models. For more details, please refer to opML (<a href=\"https://arxiv.org/abs/2401.17555\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">[2401.17555] opML: Optimistic Machine Learning on Blockchain</a>).</p>\n<p>The on-chain arbitration process using the fraud-proof system proceeds as follows:</p>\n<ul>\n<li>\n<p>If a user receives inconsistent results from the service providers, they submit the providers’ responses to the on-chain arbitration contract, initiating an interactive dispute game with all the involved providers.</p>\n</li>\n<li>\n<p>At this point, the service providers must run the proving-version of the service program in their local fraud-proof VMs to generate the fraud proof, which they then submit to the on-chain arbitration contract to defend their results. For more details on the interactive dispute game, refer to the fraud-proof system design.</p>\n</li>\n<li>\n<p>Service providers who supplied incorrect results will lose the dispute game, resulting in their staked amount being slashed. The slashed stake will be distributed to the winners of the dispute game, as well as to the user, as compensation.</p>\n</li>\n</ul>\n<p>This on-chain arbitration mechanism ensures that only one honest node is required to guarantee the correctness of the provided service. As a result, the protocol relies on a minority trust assumption and inherits security from Ethereum. Assuming at least one honest node and the safety of Ethereum, the protocol can guarantee the correctness of the service.</p>\n<p>It’s important to note that on-chain arbitration only occurs when some service providers produce incorrect results. In typical cases, no on-chain interaction is needed, which allows the service to operate as quickly as current centralized cloud service providers.</p>\n<h2><a name=\"p-49659-charging-mechanism-5\" class=\"anchor\" href=\"https://ethresear.ch#p-49659-charging-mechanism-5\"></a>Charging Mechanism</h2>\n<p>There are several possible charging mechanisms:</p>\n<ul>\n<li>\n<p><strong>Subscription Model:</strong> This is similar to the Web2 approach, where the charging mechanism can be conducted off-chain. For example, to use ChatGPT via an API for commercial purposes, you would pay OpenAI a monthly fee to access their services. Multiple service providers can offer the service, allowing for competition and choice.</p>\n</li>\n<li>\n<p><strong>On-Chain Payment Mechanism:</strong> Paying for each request on-chain can be costly due to transaction fees. Batching and rolling up these requests and payments can significantly reduce on-chain transaction costs. One possible approach is to use payment channels to pay for requests. Alternatively, service providers could generate service proofs and claim fees as follows:</p>\n<ul>\n<li>\n<p>A service agreement contract specifies the price for each service request.</p>\n</li>\n<li>\n<p>Users first stake funds into the service agreement contract.</p>\n</li>\n<li>\n<p>Service providers can claim their fees by submitting service proofs to the on-chain service agreement contract. To minimize transaction costs, providers can batch and roll up user requests.</p>\n</li>\n<li>\n<p>The on-chain service proof is a zk-proof, which verifies that the service provider has delivered a certain number of responses to users. The provider can then claim the corresponding service fees according to the agreement contract. This proof ensures the correctness of the user’s request transaction signature, the service provider’s response signature, and the transaction nonce.</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Free Service Model:</strong> Another approach is for companies to cover the service fees by the themselves (currently, the web2 companies pay the cloud service fee by themselves), offering free services to users while generating revenue through other means, such as advertising or VIP services.</p>\n</li>\n</ul>\n<h2><a name=\"p-49659-advantages-6\" class=\"anchor\" href=\"https://ethresear.ch#p-49659-advantages-6\"></a>Advantages</h2>\n<ul>\n<li>\n<p>This decentralized cloud service can be cheaper than centralized cloud services while maintaining similar speed.</p>\n<ul>\n<li>\n<p><strong>Cost-Effectiveness:</strong> Decentralized servers can be significantly cheaper than centralized cloud servers. For example, <a href=\"http://io.net\" rel=\"noopener nofollow ugc\">io.net</a> has shown that the cost of decentralized GPUs can be as low as one-third of the cost of AWS. For services with lower security requirements, such as using LLMs for personal queries, using just two nodes is often sufficient. Additionally, a random check mechanism can be adopted, querying one node most of the time and occasionally checking another to verify correctness. This setup can be more cost-effective than centralized platform.</p>\n</li>\n<li>\n<p><strong>Scalability and Speed:</strong> This platform can outperform centralized systems, especially for computationally intensive tasks. A decentralized cloud service platform operates on an N-to-M model (N users with M servers, where the number of servers can be infinite), whereas centralized platforms use an N-to-1 model (N users with a single super server). This allows a decentralized cloud service platform to scale more effectively. For instance, a centralized AI platform like ChatGPT may slow down during peak times because it can’t scale its computing power quickly enough. In contrast, decentralized platform can dynamically distribute the load across many servers, ensuring faster response times even during heavy usage.</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Trustless and Verifiable:</strong> The protocol operates under a minority trust assumption, requiring only one honest node to guarantee service quality. Additionally, the correctness of the cloud service is verifiable on Ethereum.</p>\n</li>\n<li>\n<p><strong>Censorship-Resilient:</strong> This platform contributes to a more robustly decentralized Web3, enhancing censorship resistance.</p>\n</li>\n</ul>\n<h2><a name=\"p-49659-toward-fully-decentralized-and-verifiable-web3-application-7\" class=\"anchor\" href=\"https://ethresear.ch#p-49659-toward-fully-decentralized-and-verifiable-web3-application-7\"></a>Toward Fully Decentralized and Verifiable Web3 Application</h2>\n<p>With this protocol, we can move toward fully decentralized and verifiable Web3 applications.</p>\n<p><strong>Decentralized and Verifiable Blockchain Explorer:</strong> Currently, blockchain explorers like Etherscan are hosted by centralized entities, and the results they present are not verifiable. If such an explorer were hacked, it could display malicious and misleading information, such as fake transactions or contracts, potentially leading to phishing scams. By migrating the entire blockchain explorer—including both the frontend and backend services—to our platform, we can ensure full verifiability and robust security for the blockchain explorer.</p>\n<p><strong>Decentralized, Verifiable, Faster, and Cheaper AI Platform:</strong> This protocol enables the creation of a fully decentralized, verifiable, and cost-effective AI platform. By moving the entire stack, including both frontend and backend services as well as AI computation, to a decentralized cloud, we can build an AI platform that is not only more affordable but also potentially faster than centralized alternatives.</p>\n<p><strong>Decentralized Cloud Gaming:</strong> Some games require high-end hardware, such as powerful GPUs and CPUs, leading game companies to move their games to cloud services, reducing the hardware requirements for customers. We can similarly bring Web3 games to our platform. Since our platform is verifiable on Ethereum, game reward settlements can be easily managed through smart contracts.</p>\n<h2><a name=\"p-49659-further-discussion-8\" class=\"anchor\" href=\"https://ethresear.ch#p-49659-further-discussion-8\"></a>Further Discussion</h2>\n<h3><a name=\"p-49659-updating-the-state-9\" class=\"anchor\" href=\"https://ethresear.ch#p-49659-updating-the-state-9\"></a>Updating the State</h3>\n<p>In the previous discussion, the service program operates under a stateless design, meaning it does not modify its internal state. However, the data source used by the service program is upgradable. For instance, if a service program uses Ethereum as its data source, users can interact with smart contracts on Ethereum to update the state. The service program can then utilize the latest Ethereum state as its data source, enabling the implementation of a decentralized explorer.</p>\n<p>If updating the internal state of the service program is required, a state machine replication network must be established among the service providers. In this case, each service program would correspond to a layer 2 or layer 3 blockchain on Ethereum. When users invoke a method that updates the internal state, they would send the transaction to the corresponding layer 2 or layer 3 blockchain. The service providers would then reach a consensus on the execution results of that transaction and update the internal state accordingly. Periodically, the layer 2 blockchain would roll up the transactions and its latest state back to Ethereum.</p>\n<h3><a name=\"p-49659-verifiable-fhe-10\" class=\"anchor\" href=\"https://ethresear.ch#p-49659-verifiable-fhe-10\"></a>Verifiable FHE</h3>\n<p>To ensure user privacy, Fully Homomorphic Encryption (FHE) can be integrated into our protocol. In this case, the FHE computation would be incorporated into the service program. Instead of sending plaintext data to the service providers, users would encrypt their input and send only the ciphertext, thereby preserving their privacy. Additionally, if on-chain arbitration is triggered, the FHE service program would be compiled into machine-independent instructions, and a fraud proof or zk-proof would be generated to make the FHE computation fully verifiable.</p>\n<h2><a name=\"p-49659-related-work-and-comparison-11\" class=\"anchor\" href=\"https://ethresear.ch#p-49659-related-work-and-comparison-11\"></a>Related Work and Comparison</h2>\n<p><strong>Comparison with Web3URL</strong></p>\n<p>Web3URL (<a href=\"https://w3url.w3eth.io/\" rel=\"noopener nofollow ugc\">https://w3url.w3eth.io/</a>) is an interesting project that transforms Ethereum into an unstoppable decentralized web server. Our protocol can be seen as a significant extension of Web3URL. In Web3URL, service functions must be written within smart contracts, which naturally limits large-scale applications. In contrast, our protocol supports complex service programs, such as AI computations, and provides flexible access to large-scale data, making decentralized ChatGPT and decentralized explorers a reality.</p>\n<p><strong>Comparison with ICP</strong></p>\n<p>The Internet Computer (ICP: <a href=\"https://internetcomputer.org/\" rel=\"noopener nofollow ugc\">https://internetcomputer.org/</a>) hosts decentralized serverless compute, similar to our goal of creating a decentralized cloud service platform. However, we differ from ICP in several key aspects:</p>\n<ul>\n<li>\n<p><strong>Ethereum Integration:</strong> We are building on Ethereum, allowing us to inherit its security features.</p>\n</li>\n<li>\n<p><strong>Higher Security:</strong> We achieve a higher level of security compared to ICP. While ICP operates in a Byzantine Fault Tolerance (BFT) network under a majority trust assumption—requiring that most nodes in the subnet are honest—we adopt an approach similar to rollups, with on-chain arbitration ultimately reverting to Ethereum. This allows us to guarantee correctness under a minority trust assumption, where just one honest node can ensure the integrity of our protocol.</p>\n</li>\n<li>\n<p><strong>Complex Computation:</strong> Following the design principle of “Separate Execution from Proving,” we can handle complex computations natively, such as LLM inference or even fine-tuning. In contrast, service programs in ICP always run within canisters, which significantly limits their applicability for large-scale computations.</p>\n</li>\n</ul>\n<p>If you are interested in this project or have suggestions for improvements, please feel free to reach out to me.</p>\n            <p><small>3 posts - 2 participants</small></p>\n            <p><a href=\"https://ethresear.ch/t/decentralized-and-verifiable-cloud-service-on-ethereum/20292\">Read full topic</a></p>","link":"https://ethresear.ch/t/decentralized-and-verifiable-cloud-service-on-ethereum/20292","pubDate":"Sat, 17 Aug 2024 11:48:03 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20292"},"source":{"@url":"https://ethresear.ch/t/decentralized-and-verifiable-cloud-service-on-ethereum/20292.rss","#text":"Decentralized and Verifiable Cloud Service on Ethereum"}},{"title":"Censorship Insurance Markets for BRAID","dc:creator":"jonahb27","category":"Block proposer","description":"<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/b/f/bf7665c93b36acdfa0cb7c8ed757aa3ef87f101f.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/bf7665c93b36acdfa0cb7c8ed757aa3ef87f101f\" title=\"BRAID\"><img src=\"https://ethresear.ch/uploads/default/original/3X/b/f/bf7665c93b36acdfa0cb7c8ed757aa3ef87f101f.jpeg\" alt=\"BRAID\" data-base62-sha1=\"rjKRtDgYAP4vmSSayhZ1b1A8Fm7\" width=\"500\" height=\"500\" data-dominant-color=\"495C57\"></a></div><p></p>\n<p>By: <a href=\"https://x.com/_jonahb_\">Jonah Burian</a> and <a href=\"https://x.com/BenLevy0\">Ben Levy</a></p>\n<p><em>Tl;dr: We point out that BRAID’s liquidity requirements lead to poor user UX and suggest censorship insurance markets as a potential solution.</em></p>\n<p><em>Thanks to <a href=\"https://x.com/maxresnick1\">Max Resnick</a> and <a href=\"https://x.com/davidecrapis\">Davide Crapis</a> for the feedback.</em></p>\n<h2><a name=\"p-49651-intro-1\" class=\"anchor\" href=\"https://ethresear.ch#p-49651-intro-1\"></a>Intro</h2>\n<blockquote>\n<p>“The greatness of <s>America</s> <em>Ethereum</em> lies not in being more enlightened than any other <s>nation</s> <em>blockchain</em>, but rather in her ability to repair her faults.” <em>- Alexis de Tocqueville</em></p>\n</blockquote>\n<p>Censorship resistance (CR) is one of the core security properties of a blockchain.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/c/7/c7e58a93fe9b45a91ecf29a6aefa91567c310262.png\" data-download-href=\"https://ethresear.ch/uploads/default/c7e58a93fe9b45a91ecf29a6aefa91567c310262\" title=\"CR\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/c/7/c7e58a93fe9b45a91ecf29a6aefa91567c310262_2_690x180.png\" alt=\"CR\" data-base62-sha1=\"swmO0GJ1QBKqG3t56pVSs0ZWPDA\" width=\"690\" height=\"180\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/c/7/c7e58a93fe9b45a91ecf29a6aefa91567c310262_2_690x180.png, https://ethresear.ch/uploads/default/optimized/3X/c/7/c7e58a93fe9b45a91ecf29a6aefa91567c310262_2_1035x270.png 1.5x, https://ethresear.ch/uploads/default/original/3X/c/7/c7e58a93fe9b45a91ecf29a6aefa91567c310262.png 2x\" data-dominant-color=\"151515\"></a></div><p></p>\n<p>Ethereum gifts proposers with one-slot monopolies on transaction inclusion, creating a principal-agent problem and a single point of failure. A censoring party can bribe the current proposer to censor a transaction.</p>\n<p>There has been considerable work to mitigate this problem. A key insight is that the weak link problem of a single proposer results in weak CR. Multi-proposer schemes like <a href=\"https://www.youtube.com/watch?v=mJLERWmQ2uw\">BRAID</a> and <a href=\"https://ethresear.ch/t/fork-choice-enforced-inclusion-lists-focil-a-simple-committee-based-inclusion-list-proposal/19870/1\">FOCIL</a> can correct this principal-agent problem.</p>\n<p>In this piece, we focus on BRAID, a multi-proposer mechanism that has garnered significant recent attention. It aims to increase CR in a capital-efficient way via a conditional tipping mechanism (explained below).</p>\n<p>One challenge in this approach, the need for a deterministic ordering rule, is already well understood. <em><strong>In this piece we identify another challenge—liquidity requirements that adversely affect UX—and propose a few potential solutions.</strong></em></p>\n<h2><a name=\"p-49651-braid-at-a-high-level-2\" class=\"anchor\" href=\"https://ethresear.ch#p-49651-braid-at-a-high-level-2\"></a>BRAID at a High Level:</h2>\n<p>BRAID runs <span class=\"math\">k</span> subchains in parallel, each with a unique proposer. Block <span class=\"math\">n</span> of Ethereum is the union of transactions from block <span class=\"math\">n</span> of the <span class=\"math\">k</span> subchains, with a special ordering rule applied to order this unordered set.</p>\n<h3><a name=\"p-49651-tipping-in-braid-3\" class=\"anchor\" href=\"https://ethresear.ch#p-49651-tipping-in-braid-3\"></a>Tipping in BRAID</h3>\n<p>Bidders submit a conditional twin tip <span class=\"math\">(t,T)</span> which depends on the number of proposers who include the transaction. If only a single proposer includes a transaction, they receive <span class=\"math\">T</span>; if multiple proposers include the transaction, they split <span class=\"math\">t</span>.</p>\n<h3><a name=\"p-49651-tipping-properties-4\" class=\"anchor\" href=\"https://ethresear.ch#p-49651-tipping-properties-4\"></a>Tipping Properties</h3>\n<p>Let <span class=\"math\">ϕ(t,T)</span> be the minimum cost to censor a BRAID transaction. It has been <a href=\"https://arxiv.org/abs/2301.13321\">shown</a> that <span class=\"math\">ϕ(t,T)=kT</span>.</p>\n<p>The goal of BRAID is that users will most likely never actually have to pay <span class=\"math\">T</span>; instead, they pay <span class=\"math\">t</span>, which can be much lower than <span class=\"math\">T</span>.</p>\n<p>This multi-dimensional tip disentangles the cost of inclusion (for the transacting party) from the cost of censoring such that <span class=\"math\">t&lt;&lt;T</span>.</p>\n<p>Simply put, a user get’s <span class=\"math\">kT</span> worth of CR while (usually) only paying <span class=\"math\">t</span>.</p>\n<p><strong>How Users Will Tip:</strong></p>\n<ul>\n<li><span class=\"math\">T</span>: From a user’s perspective, they set <span class=\"math\">T=\\frac{V}{k}</span> where <span class=\"math\">V</span> is the value the user places in their transaction not being censored.</li>\n<li><span class=\"math\">t</span>: In current BRAID specs, the ordering of transactions depends on <span class=\"math\">t</span>, with more favorable ordering (i.e., coming first) given to those with the highest <span class=\"math\">t</span>. Therefore, a user will choose their <span class=\"math\">t</span> based on where they want to be in the ordering.</li>\n</ul>\n<p><em>Note that if a user does not care about CR, they can set <span class=\"math\">T=t</span> and send their transaction to just one proposer.</em></p>\n<h2><a name=\"p-49651-the-ux-challenge-5\" class=\"anchor\" href=\"https://ethresear.ch#p-49651-the-ux-challenge-5\"></a>The UX Challenge:</h2>\n<p>While a user will only pay <span class=\"math\">t</span> for their transaction, they need to have <span class=\"math\">T</span> available to make a credible promise to the protocol that they can pay <span class=\"math\">T</span>. Hence a user needs to have <span class=\"math\">T</span> of additional available liquidity to make a transaction. We saw before that <span class=\"math\">T \\propto V</span>: <span class=\"math\">T</span> tends to scale with the value of the transaction. This burdens users with a liquidity requirement.</p>\n<p>For example, say a user wants to sell $5M of ETH due to impending interest rate fears and values censorship resistance at $1M. Let’s say there are 4 shards, i.e., <span class=\"math\">k=4</span>. The user needs to have $250k of additional unpledged liquidity available just to exit their position. This hampers the UX of on-chain finance by placing additional and obscure liquidity requirements on participants that scale with the value of their positions.</p>\n<h2><a name=\"p-49651-fixes-6\" class=\"anchor\" href=\"https://ethresear.ch#p-49651-fixes-6\"></a>Fixes:</h2>\n<h3><a name=\"p-49651-proof-of-post-state-liquidity-7\" class=\"anchor\" href=\"https://ethresear.ch#p-49651-proof-of-post-state-liquidity-7\"></a><strong>Proof of Post-State Liquidity</strong></h3>\n<p><strong>Idea:</strong> A user submits a transaction with a proof that they will have enough liquidity to pay <span class=\"math\">T</span> if necessary after their transaction. In the case before, the proof will show that the transaction will give the user $1M of liquidity so they could afford the <span class=\"math\">T=</span> $250k if necessary.</p>\n<p><strong>Problem:</strong> This assumes that a proposer has a good understanding of the post-state of a transaction. Most financial transactions interact with shared state, and as a result, transaction ordering is needed to know the post-state. This knowledge relies on the final ordering so we can’t include it as an input to the transaction. Even when there is a reasonable lower bound on post-state available liquidity, establishing it would (unrealistically) require bespoke proofs for each transaction type.</p>\n<h3><a name=\"p-49651-censorship-insurance-ci-8\" class=\"anchor\" href=\"https://ethresear.ch#p-49651-censorship-insurance-ci-8\"></a>Censorship Insurance (CI)</h3>\n<p><strong>Idea:</strong> A third party–the CI provider–can sponsor the escrow of <span class=\"math\">T</span> for the transaction. Users will have to pay an insurance premium of <span class=\"math\">rT</span> to the CI provider, where <span class=\"math\">r</span> represents the rate (mostly) based on the likelihood of censorship. CI providers are thus assessing the rewards of censoring the transaction in real time to ensure it is below <span class=\"math\">kT</span>.</p>\n<p>To prevent an attack where a user purchases insurance and then only sends their tx to one proposer whom they are colluding with, the CI should be (one of) the relayer(s) for the tx. This mirrors how gas sponsorship works and indeed CI insurance should likely just be included in a gas sponsorship service.</p>\n<p>Effectively a user pays a total of <span class=\"math\">t + rT</span> for their transaction and only needs to have <span class=\"math\">t + rT</span> on hand as opposed to <span class=\"math\">T</span>, which is frequently more than <span class=\"math\">t + rT</span>.</p>\n<p>An additional benefit of this scheme is that a marketplace of at least two CI providers will conveniently alert users when their <span class=\"math\">T</span> is too low and there is a high risk of censorship because they’ll refuse to censorship-insure the transaction at a reasonable rate.</p>\n<p><strong>Problem:</strong> It will be difficult to bootstrap a two-sided marketplace for this from scratch.</p>\n<h3><a name=\"p-49651-ci-market-structure-9\" class=\"anchor\" href=\"https://ethresear.ch#p-49651-ci-market-structure-9\"></a>CI Market Structure</h3>\n<p>In practice applications or wallets will likely claim jurisdiction over this issue. One possible solution to the bootstrapping problem, therefore, is for applications and/or wallets to sign wholesale agreements with CI providers à la PFOF.</p>\n<p>While the above solution likely works fine, another option is to create a proper on-chain market with e.g. an RFQ for each transaction whose sender wishes to purchase censorship resistance for.</p>\n<p><img src=\"https://ethresear.ch/uploads/default/original/3X/0/4/049237e341dc88cd24cde968c71e70ce689c3444.png\" alt=\"snake\" data-base62-sha1=\"ErbepHjP783sZdbfKfWocF9KUQ\" width=\"240\" height=\"240\"></p>\n<p>This market, fittingly, would benefit from the CR properties of BRAID.</p>\n<h2><a name=\"p-49651-conclusion-10\" class=\"anchor\" href=\"https://ethresear.ch#p-49651-conclusion-10\"></a>Conclusion</h2>\n<p>BRAID is still in its early days as a proposal. The UX issue of liquidity requirements has not been sufficiently explored, though there are promising signs that we can reasonably punt the issue to the application layer. For next steps, we suggest further exploration of the feasibility of CI markets.</p>\n<h2><a name=\"p-49651-previous-work-11\" class=\"anchor\" href=\"https://ethresear.ch#p-49651-previous-work-11\"></a>Previous work:</h2>\n<ul>\n<li><a href=\"https://arxiv.org/abs/2301.13321\">Censorship Resistance in On-Chain Auctions</a>: Elijah, Max, Mallesh</li>\n<li><a href=\"https://ethresear.ch/t/concurrent-block-proposers-in-ethereum/18777\">Concurrent Block Proposers in Ethereum</a>: Mike, Max</li>\n<li><a href=\"https://blog.duality.xyz/introducing-multiplicity/\">Introducing Multiplicity</a>: Duality blog</li>\n<li><a href=\"https://efdn.notion.site/ROP-9-Multiplicity-gadgets-for-censorship-resistance-7def9d354f8a4ed5a0722f4eb04ca73b\">ROP-9: Multiplicity gadgets for censorship-resistance</a> RIG</li>\n<li><a href=\"https://www.youtube.com/watch?v=mJLERWmQ2uw\">BRAID: Implementing Multiple Concurrent Block Proposers</a>: Max</li>\n<li><a href=\"https://ethresear.ch/t/fork-choice-enforced-inclusion-lists-focil-a-simple-committee-based-inclusion-list-proposal/19870/1\">Fork-Choice enforced Inclusion Lists (FOCIL): A simple committee-based inclusion list proposal</a>: Thomas, Barnabé, Francesco and Julian</li>\n</ul>\n            <p><small>4 posts - 3 participants</small></p>\n            <p><a href=\"https://ethresear.ch/t/censorship-insurance-markets-for-braid/20288\">Read full topic</a></p>","link":"https://ethresear.ch/t/censorship-insurance-markets-for-braid/20288","pubDate":"Fri, 16 Aug 2024 15:36:38 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20288"},"source":{"@url":"https://ethresear.ch/t/censorship-insurance-markets-for-braid/20288.rss","#text":"Censorship Insurance Markets for BRAID"}},{"title":"Ethereum discv5 DHT Network Health Weekly Reports","dc:creator":"yiannisbot","category":"Networking","description":"<blockquote>\n<p><em>Work presented here has been carried out by the <a href=\"https://probelab.network\" rel=\"noopener nofollow ugc\">ProbeLab</a> team and in particular <a class=\"mention\" href=\"https://ethresear.ch/u/guillaumemichel\">@guillaumemichel</a> <a class=\"mention\" href=\"https://ethresear.ch/u/cortze\">@cortze</a> <a class=\"mention\" href=\"https://ethresear.ch/u/dennis-tra\">@dennis-tra</a> and Steph.</em></p>\n</blockquote>\n<h2><a name=\"p-49640-high-level-description-1\" class=\"anchor\" href=\"https://ethresear.ch#p-49640-high-level-description-1\"></a>High Level Description</h2>\n<p>The ProbeLab team has developed and deployed infrastructure to monitor several critical metrics for Ethereum’s CL discv5 DHT network. In particular, we have adapted the Nebula crawler (<a href=\"https://github.com/dennis-tra/nebula/\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">GitHub - dennis-tra/nebula: 🌌 A network agnostic DHT crawler, monitor, and measurement tool that exposes timely information about DHT networks.</a>) to be compatible with discv5-based networks and are gathering results that reflect the health of the P2P network at the DHT level.</p>\n<p>In this post we’re presenting a summary of what is included in the reports, but for a more complete picture of what’s there, head to: <a href=\"https://probelab.io/ethereum/discv5/2024-29/\" rel=\"noopener nofollow ugc\">https://probelab.io/ethereum/discv5/2024-29/</a> for the latest report.</p>\n<ul>\n<li>\n<p>Reports are produced every Monday for the preceding week.</p>\n</li>\n<li>\n<p>The methodology we follow for DHT Crawling, Data Filtering, Node Classification as well as the differences of our tool to alternatives in the space is given in the Methodology section: <a href=\"https://probelab.io/ethereum/discv5/methodology/\" rel=\"noopener nofollow ugc\">https://probelab.io/ethereum/discv5/methodology/</a>.</p>\n</li>\n<li>\n<p>The crawler used to produce the reports can be found (and can be reused) here: <a href=\"https://github.com/dennis-tra/nebula/\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">GitHub - dennis-tra/nebula: 🌌 A network agnostic DHT crawler, monitor, and measurement tool that exposes timely information about DHT networks.</a>.</p>\n</li>\n</ul>\n<h2><a name=\"p-49640-why-you-should-care-2\" class=\"anchor\" href=\"https://ethresear.ch#p-49640-why-you-should-care-2\"></a>Why you should care</h2>\n<p>The metrics included in the reports:</p>\n<ul>\n<li>\n<p>give an overview of the network structure, size and client adoption breakdown. This helps in understanding the robustness and diversity of the network,</p>\n</li>\n<li>\n<p>provide accurate geographic distribution of nodes in the network per client implementation over time, which can highlight regional trends and potential vulnerabilities or strengths in specific areas,</p>\n</li>\n<li>\n<p>make it easy to spot drastic changes in the structure and setup of the network,</p>\n</li>\n<li>\n<p>allow for monitoring of new protocol version uptake/adoption, and provide insights on whether there are adoption barriers,</p>\n</li>\n<li>\n<p>reveal the infrastructure setup (e.g., data center-hosted vs non-data center-hosted) and cloud provider distribution per client implementation,</p>\n</li>\n<li>\n<p>show the breakdown of nodes supporting particular network-layer protocols,</p>\n</li>\n<li>\n<p>depict the percentage of reachable vs unreachable node records in the DHT network.</p>\n</li>\n</ul>\n<h2><a name=\"p-49640-overview-of-results-3\" class=\"anchor\" href=\"https://ethresear.ch#p-49640-overview-of-results-3\"></a>Overview of Results</h2>\n<p>We’re presenting a small fraction of the results given at <a href=\"https://probelab.io\" rel=\"noopener nofollow ugc\">https://probelab.io</a> to give an idea of the metrics listed. Please head there for the complete reports from Week 11 (mid-March), 2024.</p>\n<p><strong>Client Diversity</strong></p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/4/3/433c4aecd269c5dfd9291dc03bbf58624414061c.png\" data-download-href=\"https://ethresear.ch/uploads/default/433c4aecd269c5dfd9291dc03bbf58624414061c\" title=\"discv5-agents-overall\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/4/3/433c4aecd269c5dfd9291dc03bbf58624414061c_2_489x375.png\" alt=\"discv5-agents-overall\" data-base62-sha1=\"9ANalSHzx5WpILh8Cssu8iqaYS8\" width=\"489\" height=\"375\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/4/3/433c4aecd269c5dfd9291dc03bbf58624414061c_2_489x375.png, https://ethresear.ch/uploads/default/optimized/3X/4/3/433c4aecd269c5dfd9291dc03bbf58624414061c_2_733x562.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/4/3/433c4aecd269c5dfd9291dc03bbf58624414061c_2_978x750.png 2x\" data-dominant-color=\"E7E6E4\"></a></div><p></p>\n<p><strong>Client Diversity Over Time</strong></p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/2/6/2664514f07b9b5aa0f4dea5319bc82fe047fa27b.png\" data-download-href=\"https://ethresear.ch/uploads/default/2664514f07b9b5aa0f4dea5319bc82fe047fa27b\" title=\"discv5-agents-overall-stacked\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/2/6/2664514f07b9b5aa0f4dea5319bc82fe047fa27b_2_489x375.png\" alt=\"discv5-agents-overall-stacked\" data-base62-sha1=\"5tD4y25IZZpEDWS94p6mWrD1iYz\" width=\"489\" height=\"375\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/2/6/2664514f07b9b5aa0f4dea5319bc82fe047fa27b_2_489x375.png, https://ethresear.ch/uploads/default/optimized/3X/2/6/2664514f07b9b5aa0f4dea5319bc82fe047fa27b_2_733x562.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/2/6/2664514f07b9b5aa0f4dea5319bc82fe047fa27b_2_978x750.png 2x\" data-dominant-color=\"DCDAD9\"></a></div><p></p>\n<p><strong>Agent version adoption over time - Example: Lighthouse</strong></p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/a/0/a081c5b9376d2f17792caaa6b6d91b9f2e4353a0.png\" data-download-href=\"https://ethresear.ch/uploads/default/a081c5b9376d2f17792caaa6b6d91b9f2e4353a0\" title=\"discv5-versions-distribution\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/a/0/a081c5b9376d2f17792caaa6b6d91b9f2e4353a0_2_489x375.png\" alt=\"discv5-versions-distribution\" data-base62-sha1=\"mTUqJMBLpLOCgHUELpWOsKX6M4E\" width=\"489\" height=\"375\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/a/0/a081c5b9376d2f17792caaa6b6d91b9f2e4353a0_2_489x375.png, https://ethresear.ch/uploads/default/optimized/3X/a/0/a081c5b9376d2f17792caaa6b6d91b9f2e4353a0_2_733x562.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/a/0/a081c5b9376d2f17792caaa6b6d91b9f2e4353a0_2_978x750.png 2x\" data-dominant-color=\"E6D9D2\"></a></div><p></p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/6/1/61739999c2d736e11817cf8f417008e2c88869dc.png\" data-download-href=\"https://ethresear.ch/uploads/default/61739999c2d736e11817cf8f417008e2c88869dc\" title=\"discv5-agents-versions\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/6/1/61739999c2d736e11817cf8f417008e2c88869dc_2_489x375.png\" alt=\"discv5-agents-versions\" data-base62-sha1=\"dU5Za5KQnDcJp7ETG1KU8ywLkGo\" width=\"489\" height=\"375\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/6/1/61739999c2d736e11817cf8f417008e2c88869dc_2_489x375.png, https://ethresear.ch/uploads/default/optimized/3X/6/1/61739999c2d736e11817cf8f417008e2c88869dc_2_733x562.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/6/1/61739999c2d736e11817cf8f417008e2c88869dc_2_978x750.png 2x\" data-dominant-color=\"DCE3EF\"></a></div><p></p>\n<p><strong>Country distribution of all nodes</strong></p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/3/4/34aa9fb69b64bdf785073d62f018a4c78cbad033.png\" data-download-href=\"https://ethresear.ch/uploads/default/34aa9fb69b64bdf785073d62f018a4c78cbad033\" title=\"discv5-geo-agent-all-bars\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/3/4/34aa9fb69b64bdf785073d62f018a4c78cbad033_2_489x375.png\" alt=\"discv5-geo-agent-all-bars\" data-base62-sha1=\"7vUo5ag1dENh1y4BMFybIb38X99\" width=\"489\" height=\"375\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/3/4/34aa9fb69b64bdf785073d62f018a4c78cbad033_2_489x375.png, https://ethresear.ch/uploads/default/optimized/3X/3/4/34aa9fb69b64bdf785073d62f018a4c78cbad033_2_733x562.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/3/4/34aa9fb69b64bdf785073d62f018a4c78cbad033_2_978x750.png 2x\" data-dominant-color=\"EAF1F6\"></a></div><p></p>\n<p><strong>Client-specific country distribution - Example: Prysm</strong></p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/c/9/c92579370dcf03c6358536d0a358da2d79aeaa51.png\" data-download-href=\"https://ethresear.ch/uploads/default/c92579370dcf03c6358536d0a358da2d79aeaa51\" title=\"discv5-geo-agents-lines-prysm\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/c/9/c92579370dcf03c6358536d0a358da2d79aeaa51_2_489x375.png\" alt=\"discv5-geo-agents-lines-prysm\" data-base62-sha1=\"sHqg0lL70SbHABxWoMx221HSD5v\" width=\"489\" height=\"375\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/c/9/c92579370dcf03c6358536d0a358da2d79aeaa51_2_489x375.png, https://ethresear.ch/uploads/default/optimized/3X/c/9/c92579370dcf03c6358536d0a358da2d79aeaa51_2_733x562.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/c/9/c92579370dcf03c6358536d0a358da2d79aeaa51_2_978x750.png 2x\" data-dominant-color=\"FAF8F8\"></a></div><p></p>\n<p><strong>Cloud provider distribution of all nodes</strong></p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/5/5/55ffef8626b07b1f21845591817184f663c7c88f.png\" data-download-href=\"https://ethresear.ch/uploads/default/55ffef8626b07b1f21845591817184f663c7c88f\" title=\"discv5-cloud-agent-all-bars\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/5/5/55ffef8626b07b1f21845591817184f663c7c88f_2_489x375.png\" alt=\"discv5-cloud-agent-all-bars\" data-base62-sha1=\"cgMVk2NYPDPJDrB20Xy5m9BXqs7\" width=\"489\" height=\"375\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/5/5/55ffef8626b07b1f21845591817184f663c7c88f_2_489x375.png, https://ethresear.ch/uploads/default/optimized/3X/5/5/55ffef8626b07b1f21845591817184f663c7c88f_2_733x562.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/5/5/55ffef8626b07b1f21845591817184f663c7c88f_2_978x750.png 2x\" data-dominant-color=\"EEF3F7\"></a></div><p></p>\n<p><strong>Cloud vs non-cloud distribution of nodes over time</strong></p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/4/7/47638e6a177376cd847949f006ddd6ad91a73368.png\" data-download-href=\"https://ethresear.ch/uploads/default/47638e6a177376cd847949f006ddd6ad91a73368\" title=\"discv5-cloud-rate-agent-all-lines\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/4/7/47638e6a177376cd847949f006ddd6ad91a73368_2_489x375.png\" alt=\"discv5-cloud-rate-agent-all-lines\" data-base62-sha1=\"abxckcFFQ7ZwNhKGcPYplROghmg\" width=\"489\" height=\"375\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/4/7/47638e6a177376cd847949f006ddd6ad91a73368_2_489x375.png, https://ethresear.ch/uploads/default/optimized/3X/4/7/47638e6a177376cd847949f006ddd6ad91a73368_2_733x562.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/4/7/47638e6a177376cd847949f006ddd6ad91a73368_2_978x750.png 2x\" data-dominant-color=\"FCFCFC\"></a></div><p></p>\n<p><strong>Stale Peer Records over time</strong></p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/d/9/d941c8d07f12784b4d26214ce100dcfbb8f1e99e.png\" data-download-href=\"https://ethresear.ch/uploads/default/d941c8d07f12784b4d26214ce100dcfbb8f1e99e\" title=\"discv5-stale-records-mainnet-stacked\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/d/9/d941c8d07f12784b4d26214ce100dcfbb8f1e99e_2_489x375.png\" alt=\"discv5-stale-records-mainnet-stacked\" data-base62-sha1=\"uZWyjY1g91W85mbEt7UXr7lJftk\" width=\"489\" height=\"375\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/d/9/d941c8d07f12784b4d26214ce100dcfbb8f1e99e_2_489x375.png, https://ethresear.ch/uploads/default/optimized/3X/d/9/d941c8d07f12784b4d26214ce100dcfbb8f1e99e_2_733x562.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/d/9/d941c8d07f12784b4d26214ce100dcfbb8f1e99e_2_978x750.png 2x\" data-dominant-color=\"EED8C4\"></a></div><p></p>\n<h2><a name=\"p-49640-how-to-contribute-4\" class=\"anchor\" href=\"https://ethresear.ch#p-49640-how-to-contribute-4\"></a>How to contribute</h2>\n<p>Overall, we believe this set of results give an accurate view of the structure and health of the discv5 DHT network. We hope you’ll find the reports useful.</p>\n<p>If there are important metrics that you believe should be part of these weekly reports, comment below, or get in touch with the team: <a href=\"https://www.probelab.network/contact\" rel=\"noopener nofollow ugc\">probelab.network/contact</a>.</p>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://ethresear.ch/t/ethereum-discv5-dht-network-health-weekly-reports/20282\">Read full topic</a></p>","link":"https://ethresear.ch/t/ethereum-discv5-dht-network-health-weekly-reports/20282","pubDate":"Thu, 15 Aug 2024 16:10:39 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20282"},"source":{"@url":"https://ethresear.ch/t/ethereum-discv5-dht-network-health-weekly-reports/20282.rss","#text":"Ethereum discv5 DHT Network Health Weekly Reports"}},{"title":"Autonomous Competence Identification Protocol","dc:creator":"peersky","category":"Meta-innovation","description":"<p>I’m excited to share my ongoing research on a protocol designed to streamline communication and decision-making around subjective matters, particularly within DAOs and R&amp;D processes. This protocol establishes a ranking system that counters common governance issues, fostering a more collaborative and effective environment.</p>\n<p>I’m posting this in the meta-innovation category because it has implications both for DAO/Consensus research and for potential collaboration tools within the Ethereum community.</p>\n<p><em>Link to paper in progress: <a href=\"https://github.com/peersky/papers/blob/main/acid/whitepaper.pdf\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">papers/acid/whitepaper.pdf at main · peersky/papers · GitHub</a></em></p>\n<h2><a name=\"p-49639-tldr-1\" class=\"anchor\" href=\"https://ethresear.ch#p-49639-tldr-1\"></a>TL’DR</h2>\n<p>The protocol enables subjective decision-making and quantifies proposer ratings. Participants define a context and engage in rounds of discussion, providing and receiving feedback without revealing identities until the round concludes. This mitigates biases like the <a href=\"https://en.wikipedia.org/wiki/Halo_effect\" rel=\"noopener nofollow ugc\">Halo effect</a>, and collusion (sybil attack) risks.</p>\n<p>Protocol streamlines discussions and enables autonomously assign competent decision makers as well as create pre-arranged agenda for any follow up voting systems (hence addresses <a href=\"https://www.sciencedirect.com/science/article/abs/pii/0022053176900405\" rel=\"noopener nofollow ugc\">Agenda Manipulation</a>,  ( casually explained in <a href=\"https://www.youtube.com/watch?v=goQ4ii-zBMw\" rel=\"noopener nofollow ugc\">this youtube video</a> ) problem</p>\n<h2><a name=\"p-49639-motivation-2\" class=\"anchor\" href=\"https://ethresear.ch#p-49639-motivation-2\"></a>Motivation</h2>\n<h3><a name=\"p-49639-communication-complexities-hinder-decision-making-3\" class=\"anchor\" href=\"https://ethresear.ch#p-49639-communication-complexities-hinder-decision-making-3\"></a>Communication Complexities Hinder Decision-Making</h3>\n<p>Effective decision-making is hindered by communication complexities.</p>\n<ul>\n<li>Traditional methods (meetings, chats): don’t scale, leading to information overload and delays.</li>\n<li>More stakeholders exponentially increase communication complexity, leaving less time for effective decisions.</li>\n<li>Individual contributions can get lost, leading to under-appreciation and high turnover.</li>\n</ul>\n<h3><a name=\"p-49639-traditional-organizations-are-sub-optimally-managed-4\" class=\"anchor\" href=\"https://ethresear.ch#p-49639-traditional-organizations-are-sub-optimally-managed-4\"></a>Traditional Organizations are Sub-optimally Managed</h3>\n<p>Despite modern networking and project management technologies, the primary, basis of hierarchical communication hasn’t changed much over centuries. Decisions still require large centralization force, which will step in and cut opinions to shape performance capable decision.</p>\n<ul>\n<li>Centralized decision-making prioritizes efficiency over diverse input, fostering internal politics and biased decisions.</li>\n<li>This breeds internal politics, leading to biased decisions that may harm the organization.</li>\n<li>Current methods lack objective ways to measure and reward valuable contributions, limiting organizational potential.</li>\n<li>Does not let organizations reach their full potential</li>\n</ul>\n<p>This touches every organization, including Ethereum R&amp;D.</p>\n<h3><a name=\"p-49639-icos-do-not-work-well-for-daos-5\" class=\"anchor\" href=\"https://ethresear.ch#p-49639-icos-do-not-work-well-for-daos-5\"></a>ICOs do not work well for DAOs</h3>\n<p>Research shows that many DAOs are highly centralized, with low participation rates and vulnerability to governance attacks. The incentive structures in Proof of Stake (PoS) and Proof of Work (PoW) systems can lead to centralization.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/1/e/1edd6c487afe9524d47e660bb04cf7872abb6008.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/1edd6c487afe9524d47e660bb04cf7872abb6008\" title=\"img\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/1/e/1edd6c487afe9524d47e660bb04cf7872abb6008_2_690x274.jpeg\" alt=\"img\" data-base62-sha1=\"4p2IGe0bCv68xvWg0MwBMFLBkaA\" width=\"690\" height=\"274\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/1/e/1edd6c487afe9524d47e660bb04cf7872abb6008_2_690x274.jpeg, https://ethresear.ch/uploads/default/optimized/3X/1/e/1edd6c487afe9524d47e660bb04cf7872abb6008_2_1035x411.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/1/e/1edd6c487afe9524d47e660bb04cf7872abb6008_2_1380x548.jpeg 2x\" data-dominant-color=\"E1E0DF\"></a></div><br>\n<div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/4/e/4e7ea5b4ee785ee33c7f3664e698a915d71867f8.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/4e7ea5b4ee785ee33c7f3664e698a915d71867f8\" title=\"img2\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/4/e/4e7ea5b4ee785ee33c7f3664e698a915d71867f8_2_690x374.jpeg\" alt=\"img2\" data-base62-sha1=\"bcoAa4OAtZdSFAPJpZhmXLrtm40\" width=\"690\" height=\"374\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/4/e/4e7ea5b4ee785ee33c7f3664e698a915d71867f8_2_690x374.jpeg, https://ethresear.ch/uploads/default/optimized/3X/4/e/4e7ea5b4ee785ee33c7f3664e698a915d71867f8_2_1035x561.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/4/e/4e7ea5b4ee785ee33c7f3664e698a915d71867f8_2_1380x748.jpeg 2x\" data-dominant-color=\"F6F5F5\"></a></div><p></p>\n<h3><a name=\"p-49639-cyber-physical-social-systems-6\" class=\"anchor\" href=\"https://ethresear.ch#p-49639-cyber-physical-social-systems-6\"></a>Cyber-Physical-Social-Systems</h3>\n<p>There’s a growing need for DAOs to bridge traditional management with AI agents and automated infrastructure, as highlighted by research in Cyber-Physical-Social Systems (CPSS).</p>\n<h2><a name=\"p-49639-approach-7\" class=\"anchor\" href=\"https://ethresear.ch#p-49639-approach-7\"></a>Approach</h2>\n<p>The protocol aims to incentivize participation without enabling influence compounding. It builds on a real-world game where participants propose and vote on ideas (like music tracks) without revealing identities until the round ends.</p>\n<h3><a name=\"p-49639-key-requirements-for-the-protocol-8\" class=\"anchor\" href=\"https://ethresear.ch#p-49639-key-requirements-for-the-protocol-8\"></a>Key requirements for the protocol:</h3>\n<ul>\n<li><strong>Mission aligned:</strong> Participant activity directly impacts organizational goals.</li>\n<li><strong>Highly performant</strong>: Organizations using the protocol should outperform traditional structures.</li>\n<li><strong>Centralization resilient</strong>: Financial contributions shouldn’t lead to disproportionate influence.</li>\n<li><strong>Multidimensional</strong>: Support diverse participant interests.</li>\n<li><strong>Rational</strong>: Function even when agents act in their self-interest.</li>\n</ul>\n<h3><a name=\"p-49639-key-features-9\" class=\"anchor\" href=\"https://ethresear.ch#p-49639-key-features-9\"></a>Key features:</h3>\n<ul>\n<li><strong>Competence-based participation</strong>: Participants earn governance rights through demonstrated competence, not just financial contributions.</li>\n<li><strong>Sybil attack resistance</strong>: A tournament ladder structure imposes costs and time requirements, making manipulation difficult.</li>\n<li><strong>Progressive decentralization</strong>: Organizations can evolve by adding governance layers, increasing overall governance surface area.</li>\n</ul>\n<h2><a name=\"p-49639-current-state-10\" class=\"anchor\" href=\"https://ethresear.ch#p-49639-current-state-10\"></a>Current State</h2>\n<ul>\n<li><strong>Research paper in progress</strong>: Seeking feedback and potential co-authors.</li>\n<li><strong>Basic prototype and testing</strong>: Exploring use cases beyond music, such as manage-less code writing.</li>\n<li><strong>Website with Telegram group</strong>: <a href=\"https://rankify.it\" rel=\"noopener nofollow ugc\">https://rankify.it</a></li>\n</ul>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://ethresear.ch/t/autonomous-competence-identification-protocol/20281\">Read full topic</a></p>","link":"https://ethresear.ch/t/autonomous-competence-identification-protocol/20281","pubDate":"Thu, 15 Aug 2024 12:41:30 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20281"},"source":{"@url":"https://ethresear.ch/t/autonomous-competence-identification-protocol/20281.rss","#text":"Autonomous Competence Identification Protocol"}},{"title":"A Threshold Network for “Human Keys” to solve privacy and custody issues","dc:creator":"nanaknihal","category":"Cryptography","description":"<h1><a name=\"p-49627-introduction-1\" class=\"anchor\" href=\"https://ethresear.ch#p-49627-introduction-1\"></a>Introduction</h1>\n<p>In blockchain and PKI more generally, people are represented by keys. A somewhat strange question to ask might be “why don’t keys represent people?” I will argue this is actually an important question and the crux of major privacy and onboarding challenges. We present a a threshold network design dubbed Mishti Network to derive keys from people rather than arbitrary randomness. This network solves a number of problems in ZK identity, compliance, and onboarding.</p>\n<p>What does it mean for a key to be a representation of a person? There are two conditions that should be met:</p>\n<ul>\n<li>A person’s knowledge and/or attributes can always map to the private key</li>\n<li>This person is the sole controller of the key</li>\n</ul>\n<p>In other words, it is a collision-resistant map of personal data and attributes to a high-entropy pseudorandom number. Without collision resistance, multiple people could have the same key. Without high entropy, the key is not secure. Keys can be both standard private keys or also a nullifier that’s useful for secure ZK credentials.</p>\n<p>Human keys are not solely biometrics. They could be from human-friendly data such as security questions, passwords, or any unique knowledge belonging to an individual rather than arbitrary randomness.</p>\n<h1><a name=\"p-49627-solution-oblivious-pseudorandom-function-2\" class=\"anchor\" href=\"https://ethresear.ch#p-49627-solution-oblivious-pseudorandom-function-2\"></a>Solution: Oblivious Pseudorandom Function</h1>\n<p>This solution is based on a threshold verifiable oblivious pseudorandom function (tVOPRF) on private data. An oblivious pseudorandom function (OPRF) takes a private input and computes a pseudorandom function (PRF). PRFs take low-entropy input and create high-entropy output. Adding verifiability via a ZKP makes it into a VOPRF. Verifying individual node contributions is important to decentralizing the network.</p>\n<h1><a name=\"p-49627-why-it-is-helpful-to-ethereum-pki-3\" class=\"anchor\" href=\"https://ethresear.ch#p-49627-why-it-is-helpful-to-ethereum-pki-3\"></a>Why it is helpful to Ethereum + PKI</h1>\n<p>Some of the outstanding issues in Ethereum are onboarding and privacy. Onboarding requires not just simplicity but also self-custody, and recovery. Current onboarding solutions such as social logins and passkeys do not have self-custody (as they can be recovered by web2 accounts), while self-custodial solutions can’t have recovery without extra onboarding step like electing gaurdians.</p>\n<p>A similar need is for ZK identity applications that need to derive nullifiers from their users’ identities, in a way nobody can trace back to the user. This is a common need in proof-of-personhood solutions to ensure that each person only has one corresponding nullifier without a central database or key that links users to their nullifiers.</p>\n<p>Furthermore, the underlying cryptography and network can be repurposed to tackle another pressing challenge: that of satisfying compliance rules with ZK identity. The same underlying elliptic curve multiplication primitive that underlies this design can be used to construct threshold ElGamal decryption over ZK-friendly curves, which can allow ZK proofs to contain encrypted data with flexible access control.</p>\n<h1><a name=\"p-49627-oblivious-pseudorandom-function-4\" class=\"anchor\" href=\"https://ethresear.ch#p-49627-oblivious-pseudorandom-function-4\"></a>Oblivious Pseudorandom Function</h1>\n<p>To generate keys from identities, an oblivious pseudorandom function (OPRF) can be constructed with distributed EC scalar multiplication. This allows private user data such as security questions, biometrics, passwords, or social security numbers, etc. to deterministically generate secret keys. The resulting pseudorandom value is computationally impractical to reverse despite it being from low-entropy input. One can thereby create wallet or nullifier from any (or a combination) of these low-entropy “human” factors. In the 2HashDH OPRF [1], a server or network’s secret is used to give randomness to the client’s input. The oblivious property prevents any server or set of nodes from seeing see this input.</p>\n<p>2HashDH is the following algorithm between a user with a private input <span class=\"math\">x</span> and a server (or network) with a private key <span class=\"math\">s</span>. For a subgroup <span class=\"math\">G</span> of an elliptic curve there are two hash functions:</p>\n<p><span class=\"math\">hashToCurve: \\{0,1\\}^* \\rightarrow G</span><br>\n<span class=\"math\">hashToScalar: G \\rightarrow F_q</span>.</p>\n<p>The 2HashDH OPRF proceeds as follows</p>\n<ol>\n<li>User samples a random mask <span class=\"math\">r</span> and sends <span class=\"math\">M = r * hashToCurve(x)</span></li>\n<li>Server multiplies by its secret, returning <span class=\"math\">s * M</span></li>\n<li>User computes the output by unmasking the server’s response and hashing it: <span class=\"math\">o = HashToScalar(r^{-1} * s * M)</span></li>\n</ol>\n<p><span class=\"math\">o</span> is uniformly pseudorandom in <span class=\"math\">F_q</span>, and the server is information-theoretically blinded from the user’s input.</p>\n<h2><a name=\"p-49627-decentralizing-the-server-5\" class=\"anchor\" href=\"https://ethresear.ch#p-49627-decentralizing-the-server-5\"></a>Decentralizing the server</h2>\n<p>To decentralize the OPRF server, only the step with a server must be decentralized:</p>\n<blockquote>\n<ol start=\"2\">\n<li>Server multiplies by its secret, returning <span class=\"math\">s * M</span></li>\n</ol>\n</blockquote>\n<p>For threshold elliptic curve multiplication, first a linear secret sharing, such as Shamir’s scheme, must be used. The secret key is generated through distributed key generation (DKG) such that each node with index <span class=\"math\">i</span> receives share <span class=\"math\">f(i)</span> for some secret polynomial <span class=\"math\">f</span> known to nobody. There is no node at the <span class=\"math\">0</span> index and <span class=\"math\">f(0)</span> is the secret key of the network. The secret key <span class=\"math\">f(0)</span> can be computed by a set <span class=\"math\">Q</span> of <span class=\"math\">t</span> nodes where <span class=\"math\">t</span> is one more than the degree of <span class=\"math\">f</span>.</p>\n<p><span class=\"math\">f(0) = \\sum_{i \\in Q}{L_{0, Q}(i)*f(i)}</span></p>\n<p>where <span class=\"math\">L_{0,Q}(i)</span> is the Lagrange basis for index <span class=\"math\">i</span> in set <span class=\"math\">Q</span> evaluated at zero.</p>\n<p>Instead of reconstructing <span class=\"math\">f(0)</span>, the nodes can collaborate to construct <span class=\"math\">f(0) * M</span></p>\n<p><span class=\"math\">f(0) * M = \\sum_{i \\in Q}{L_{0, Q}(i)*f(i) * M}</span></p>\n<p>This is sufficient for step</p>\n<blockquote>\n<ol start=\"2\">\n<li>Server multiplies by its secret, returning <span class=\"math\">s * M</span></li>\n</ol>\n</blockquote>\n<p>if the nodes are honest. But if one lies, the result will be wrong and there will be no way of knowing who lied. Thus, each node should prove their individual multiplication using a lightweight zero-knowledge DLEQ proof.</p>\n<h1><a name=\"p-49627-other-interesting-use-case-provable-encryption-with-programmable-privacy-6\" class=\"anchor\" href=\"https://ethresear.ch#p-49627-other-interesting-use-case-provable-encryption-with-programmable-privacy-6\"></a>Other interesting use case: Provable encryption with programmable privacy</h1>\n<p>The same decentralized EC scalar primitive can be used not just for VOPRF but also for ElGamal decryption over ZK-friendly curves. This is helpful when identities must be revealed in certain conditions.</p>\n<p>For example, many private DeFi protocols are interested in ensuring that bad actors do not get the benefits of anonymity, while the average user typically does. Governments are not satisfied with solely ZK because they need access to user data, but currently the only alternative is honeypots where all user data is stored to be turned over to authorities if needed.</p>\n<p>Another use of revealing provably encrypted identities under certain conditions is undercollateralized lending – what if you want an identity or private key to be revealed if a DeFi loan is defaulted on? In this case, you need to prove the proper data is encrypted correctly, then have a smart contract control decryption rights.</p>\n<p>To modify this threshold EC point multiplication to such use cases, little is needed.</p>\n<h3><a name=\"p-49627-encryption-7\" class=\"anchor\" href=\"https://ethresear.ch#p-49627-encryption-7\"></a>Encryption</h3>\n<p>ElGamal encryption is client-side:</p>\n<ol>\n<li>Create an ephemeral keypair <span class=\"math\">(a, A = aG)</span></li>\n<li>Encode the message as an EC point <span class=\"math\">P</span></li>\n<li>Compute Diffie-Hellman shared secret with network public key: <span class=\"math\">aB</span></li>\n<li>Compute the ciphertext <span class=\"math\">(A, aB+P)</span></li>\n</ol>\n<h3><a name=\"p-49627-decryption-8\" class=\"anchor\" href=\"https://ethresear.ch#p-49627-decryption-8\"></a>Decryption</h3>\n<p>Unlike encryption, decryption requires a server or decentralized network.</p>\n<ol>\n<li>Server/network multiply ephemeral public key <span class=\"math\">A</span> by its secret key <span class=\"math\">b</span> to get <span class=\"math\">bA</span> = <span class=\"math\">aB</span></li>\n<li>Decryptor subtracts this value from <span class=\"math\">aB+P</span> to get <span class=\"math\">P</span></li>\n</ol>\n<p>The server/network’s step can be handled by the same threshold multiplication protocol as before!</p>\n<h1><a name=\"p-49627-network-setup-and-collusion-protection-9\" class=\"anchor\" href=\"https://ethresear.ch#p-49627-network-setup-and-collusion-protection-9\"></a>Network Setup and Collusion Protection</h1>\n<p>The team at Holonym has implemented this as as an AVS on Eigenlayer called Mishti Network. High reputation is common among Eigenlayer operators despite the permissionless nature, so it is ideal for threshold networks where collusion is a concern. To further mitigate collusion risk, there is the idea of parallel networks:</p>\n<p>The asynchronous and homomorphic nature of the computations means users can permissionlessly add nodes outside of Mishti Network that they trust to not collude with Mishti Network. E.g. instead of splitting a secret between Mishti Network, half of the secret is between the Mishti Network and the other half in a semi-trusted node elected by the user. Since the whole network just does an EC multiplication, exactly what its individual does do, nodes and networks can be treated the same. A 2/2 scheme could be done between a semi-trusted node and Mishti network, simply by</p>\n<ul>\n<li>Adding their public keys to get the joint public key</li>\n<li>Adding their responses to get a joint response to the computation</li>\n</ul>\n<p>Note this requires no consent from the network and is not limited to 2/2 schemes; it can be done with any combination of semi-trusted nodes and/or independent networks via threshold schemes.</p>\n<h1><a name=\"p-49627-references-10\" class=\"anchor\" href=\"https://ethresear.ch#p-49627-references-10\"></a>References</h1>\n<p>[1] S. Jarecki, A. Kiayias, and H. Krawczyk, “Round-optimal<br>\npassword-protected secret sharing and T-PAKE in the password only model,” in International Conference on the Theory and Application of Cryptology and Information Security. Springer, 2014 pp. 233–253</p>\n<h1><a name=\"p-49627-concluding-notes-11\" class=\"anchor\" href=\"https://ethresear.ch#p-49627-concluding-notes-11\"></a>Concluding Notes</h1>\n<p>If you have any ideas on how to improve or elaborate on this network design for either ZK identity, self-custody, or any other relevant use cases, please reply or reach out.</p>\n            <p><small>3 posts - 2 participants</small></p>\n            <p><a href=\"https://ethresear.ch/t/a-threshold-network-for-human-keys-to-solve-privacy-and-custody-issues/20276\">Read full topic</a></p>","link":"https://ethresear.ch/t/a-threshold-network-for-human-keys-to-solve-privacy-and-custody-issues/20276","pubDate":"Wed, 14 Aug 2024 23:38:38 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20276"},"source":{"@url":"https://ethresear.ch/t/a-threshold-network-for-human-keys-to-solve-privacy-and-custody-issues/20276.rss","#text":"A Threshold Network for “Human Keys” to solve privacy and custody issues"}},{"title":"On Attestations, Block Propagation, and Timing Games","dc:creator":"Nero_eth","category":"Proof-of-Stake","description":"<h1><a name=\"p-49615-on-attestations-block-propagation-and-timing-games-1\" class=\"anchor\" href=\"https://ethresear.ch#p-49615-on-attestations-block-propagation-and-timing-games-1\"></a>On Attestations, Block Propagation, and Timing Games</h1>\n<p>By now, <a href=\"https://timing.pics/\">proposer timing games</a> are no longer a new phenomenon and have been analyzed, <a href=\"https://eprint.iacr.org/2023/760\">here</a>, <a href=\"https://arxiv.org/abs/2305.09032\">here</a> and <a href=\"https://ethresear.ch/t/deep-diving-attestations-a-quantitative-analysis/20020\">here</a>.</p>\n<p>In the following research piece, I want to show the <strong>evolution of <a href=\"https://timing.pics/\">proposer timing games</a></strong> and analyze their impact on attesters. Through a case study of the node operators of Lido, Coinbase, and Kiln, we dive deep into block proposal timing and its impact on Ethereum’s consensus.</p>\n<p><img src=\"https://ethresear.ch/uploads/default/original/3X/1/5/152baa9c8da23d4524a4e75101c4a1c0967ebf83.png\" alt=\"kilnmeme\" data-base62-sha1=\"31hA4vYiC0HXYzLulsE2jgQccYH\" width=\"456\" height=\"413\"></p>\n<p>As of August 2024, the <strong>block building market is largely outsourced</strong>, with <a href=\"https://mevboost.pics/\">~90%</a> handled by <a href=\"https://github.com/flashbots/mev-boost\">mevboost</a> block builders. In practice, two builders, <a href=\"https://www.titanbuilder.xyz/\">Titan Builder</a> and <a href=\"https://beaverbuild.org/\">Beaverbuild</a>, produce approximately <a href=\"https://mevboost.pics/\">80%</a> of all blocks that make it on-chain.</p>\n<p><strong>Kiln is among the entities pushing timing games the furthest</strong>, delaying block proposals to the <strong>3-3.5 second</strong> mark within the slot.</p>\n<blockquote>\n<p>In today’s environment with mevboost, <strong>block propagation is primarily handled by relays.</strong> Although proposers still propagate the block after receiving it from the relay, relays typically have better network connectivity and can therefore do it faster. <strong>However, the timing remains under the control of proposers</strong>, who can delay their <code>getHeader</code> calls to engage in timing games.</p>\n</blockquote>\n<p>This chart shows the <strong>evolution of timing games</strong>. We can see that blocks from Kiln validators appear later and later over time.</p>\n<p><img src=\"https://ethresear.ch/uploads/default/original/3X/8/2/82cad8533f90505055f8eced73ae89d774a96111.gif\" alt=\"proposer_timing_games\" data-base62-sha1=\"iF2FcLalibUbfwkXjgSw3JZDhBv\" width=\"690\" height=\"383\" class=\"animated\"></p>\n<p><strong>This comes with an impact on the network: for blocks proposed by Kiln proposers, the missed/wrong head vote rate is significantly higher:</strong><br>\n</p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/8/d/8d3a31d4dd9d8856d2baaf1b7ad1528312b72923.png\" data-download-href=\"https://ethresear.ch/uploads/default/8d3a31d4dd9d8856d2baaf1b7ad1528312b72923\" title=\"missed_head_votes_over_proposers\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/8/d/8d3a31d4dd9d8856d2baaf1b7ad1528312b72923_2_690x316.png\" alt=\"missed_head_votes_over_proposers\" data-base62-sha1=\"k9m0itcVa1uOzFoLrnC7UEx2Nwv\" width=\"690\" height=\"316\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/8/d/8d3a31d4dd9d8856d2baaf1b7ad1528312b72923_2_690x316.png, https://ethresear.ch/uploads/default/optimized/3X/8/d/8d3a31d4dd9d8856d2baaf1b7ad1528312b72923_2_1035x474.png 1.5x, https://ethresear.ch/uploads/default/original/3X/8/d/8d3a31d4dd9d8856d2baaf1b7ad1528312b72923.png 2x\" data-dominant-color=\"FCFBFB\"></a></div><p></p>\n<p><a href=\"https://ethresear.ch/t/deep-diving-attestations-a-quantitative-analysis/20020\">Previous analysis</a> showed that <strong>the longer one waits, the higher the expected number of missed head votes</strong> (<em>“80% of attestations seen by the second 5 in the slot”</em>). Kiln proposes blocks very late, causing some attesters to miss them and instead vote for the parent block. <strong>Given that there are approximately 32,000 validators assigned to each slot, this results in about 10% of them voting for the wrong block.</strong></p>\n<p>Let’s examine the attesting behavior of three large node operators and compare how they respond to <strong>blocks proposed at different times within a slot.</strong> The chart below illustrates the distribution of correct and timely head votes across the seconds within a slot.<br>\n<img src=\"https://ethresear.ch/uploads/default/original/3X/5/e/5eb241fefdf5cecb08a41d95fbf6d0263dbb573d.gif\" alt=\"attestations_seen_late\" data-base62-sha1=\"dvINsHYiu6PRjUS95UhcOYcA3aB\" width=\"690\" height=\"383\" class=\"animated\"><br>\nFor early blocks, we observe that both <strong>Lido and Coinbase display a characteristic “U”-shape</strong> in their voting patterns that might be caused by different geo locations or client software. In contrast, <strong>Kiln shows a single prominent peak</strong> that slightly lags behind the first peaks of Coinbase and Lido. <strong>However, for late blocks, Kiln attesters also show the “U”-shape pattern.</strong></p>\n<p><strong>When blocks are first seen at the 4-second mark in the p2p network during a slot, most Lido attesters attest up to 2 seconds earlier than most of the Kiln or Coinbase attesters.</strong> This pattern doesn’t necessarily suggest that Kiln is executing “individual strategies.” Instead, it could be attributed to running different clients or using different geographical locations.</p>\n<h3><a name=\"p-49615-but-who-affects-whom-2\" class=\"anchor\" href=\"https://ethresear.ch#p-49615-but-who-affects-whom-2\"></a><em><strong>But who affects whom?</strong></em></h3>\n<p>In the following chart, we compare a node operator’s performance over different proposers. A bar above y=1, for example, the green bar at Lido, indicates that Lido attesters miss more head votes for blocks from Kiln proposers. At the same time, Lido attesters do better for Lido blocks. The dashed line at 1 indicates the average share in missed head votes over all entities as proposers. A bar below 1 means the specific entity misses fewer head votes in conjunction with the respective proposer compared to the average.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/7/8/786e634d534692c6bcef1859d4baf99b6490a363.png\" data-download-href=\"https://ethresear.ch/uploads/default/786e634d534692c6bcef1859d4baf99b6490a363\" title=\"missed_head_votes_over_proposers_percentage\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/7/8/786e634d534692c6bcef1859d4baf99b6490a363_2_690x316.png\" alt=\"missed_head_votes_over_proposers_percentage\" data-base62-sha1=\"hbnNGIDeAWz1uDryDd1jJOu4tMf\" width=\"690\" height=\"316\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/7/8/786e634d534692c6bcef1859d4baf99b6490a363_2_690x316.png, https://ethresear.ch/uploads/default/optimized/3X/7/8/786e634d534692c6bcef1859d4baf99b6490a363_2_1035x474.png 1.5x, https://ethresear.ch/uploads/default/original/3X/7/8/786e634d534692c6bcef1859d4baf99b6490a363.png 2x\" data-dominant-color=\"D5D5CD\"></a></div><p></p>\n<blockquote>\n<p>Importantly, it is expected that each node operator does best with its local blocks. This is expected even without a coordination oracle, simply by co-locating nodes.</p>\n</blockquote>\n<p>To quickly summarize what we see:</p>\n<ul>\n<li>Most node operators are rather stable across different proposers.</li>\n<li><strong>Figment performs significantly worse for Kiln proposers.</strong> The same applies to Lido, Kraken, and EtherFi attesters.</li>\n<li><strong>Kiln and Binance are the only entities performing better for Kiln blocks</strong> (which are, as a reminder, very late).</li>\n</ul>\n<p><strong>Kiln attesters generally do well.</strong> <a href=\"https://ethresear.ch/t/deep-diving-attestations-a-quantitative-analysis/20020\">Earlier analysis</a> showes that Kiln does a more than good job when it comes to running high-performing validators. Refer to <a href=\"https://ethresear.ch/t/deep-diving-attestations-a-quantitative-analysis/20020\">this analysis</a> for further details of Kiln’s attestation performance.</p>\n<p><strong>Kiln causes stress.</strong> Now, we know that Kiln blocks cause stress to other attesters but not necessarily to Kiln’s attesters.</p>\n<p><strong>Explaining how.</strong> The “<em>how</em>?” is difficult to respond to at this point. A possible explanation might be that Kiln’s validators are heavily co-located, with many validators running on the same machine, or have very dense peering. Another reason might be coordinated behavior across multiple nodes, either through custom peering/private mesh networks or through another additional communication layer connecting their validators. The latter is regarded as more centralizing as it leverages economies of scale even more.</p>\n<p>A similar pattern can be observed when examining the (correct &amp; timely) attestation timing of Lido and Coinbase for the blocks proposed by each respective entity (26.07.2024-03.08.2024).<br>\n<img src=\"https://ethresear.ch/uploads/default/original/3X/5/a/5acb3eda53b7f342972637ae3d881d9e7cb44983.gif\" alt=\"attestations_seen_late_by_proposer_misses\" data-base62-sha1=\"cXcqhiQr0Nq9qOt287CRN2Nanon\" width=\"690\" height=\"383\" class=\"animated\"></p>\n<p>Interestingly, Kiln develops a “U”-shape distribution ranging from <span class=\"math\">3.8 \\Rightarrow\n 6.1</span> for their own late blocks, Lido a peak at 4.2s, and Coinbase a plateau starting at second 4 with a small peak at second 6 in the slot.</p>\n<h2><a name=\"p-49615-prevent-reorgs-of-my-own-proposed-blocks-3\" class=\"anchor\" href=\"https://ethresear.ch#p-49615-prevent-reorgs-of-my-own-proposed-blocks-3\"></a>“Prevent reorgs of my own proposed blocks”</h2>\n<p>Let’s shift our focus to reorged blocks. One strategy from the perspective of a node operator might be to <strong>never</strong> vote for reorging out one’s own block. Simply speaking, “<em>never vote for the parent block as the head if the proposer is me</em>”.</p>\n<p>Instead of calling it <em>an entity’s own block</em>, I will use <em>local block</em> in the following.</p>\n<p>The following chart shows the percentage of attesters voting for the reorged block vs voting for the parent block. The red part displays the % of all attesters from that entity that voted for a reorged block built by that entity.<br>\n</p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/f/5/f580dddb61ad6a3e4f577516f312475182d980d7.png\" data-download-href=\"https://ethresear.ch/uploads/default/f580dddb61ad6a3e4f577516f312475182d980d7\" title=\"votes_for_local_reorged_block\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/f/5/f580dddb61ad6a3e4f577516f312475182d980d7_2_690x316.png\" alt=\"votes_for_local_reorged_block\" data-base62-sha1=\"z1P4H8Fvgb5jMRwigHosZfOjwuH\" width=\"690\" height=\"316\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/f/5/f580dddb61ad6a3e4f577516f312475182d980d7_2_690x316.png, https://ethresear.ch/uploads/default/optimized/3X/f/5/f580dddb61ad6a3e4f577516f312475182d980d7_2_1035x474.png 1.5x, https://ethresear.ch/uploads/default/original/3X/f/5/f580dddb61ad6a3e4f577516f312475182d980d7.png 2x\" data-dominant-color=\"A7C3DD\"></a></div><p></p>\n<p>Kiln shows outlier behavior. While most node operators’ attesters correctly vote for the parent block rather than the local block, Kiln’s attesters appear to disregard this norm. <strong>Over 10% of Kiln attesters attempt to keep the local block on-chain by voting for it.</strong> If such strategies are adopted, they might justify the losses from incorrect head votes if they prevent the local block from being reorged. However, these tactics are generally frowned upon within the Ethereum community: “<em>don’t play with consensus</em>”.</p>\n<blockquote>\n<p>The chart uses 365 days of data. Thus, if some sophisticated strategy was implemented during the last year, the red portion would be proportionately smaller.</p>\n</blockquote>\n<h2><a name=\"p-49615-but-how-do-we-feel-about-any-additional-level-of-coordination-4\" class=\"anchor\" href=\"https://ethresear.ch#p-49615-but-how-do-we-feel-about-any-additional-level-of-coordination-4\"></a>But how do we feel about any additional level of coordination?</h2>\n<p>Regarding coordinated attesting, we, as community, seem to accept that validators run on the same node vote for the same checkpoints.</p>\n<p>We probably don’t want any additional efforts that cross the boundaries of physical machines to improve coordination across validators. It’s something that everyone can build that goes beyond <a href=\"https://github.com/ethereum/consensus-specs/blob/b2f2102dad0cd8b28a657244e645e0df1c0d246a/specs/phase0/validator.md#attesting\">what the specs describe</a>. Such coordination could have different forms:</p>\n<ul>\n<li><strong>Level 1 - Fall-backs &amp; Static Peering</strong>: Have a central fall-back/back-up node for multiple physical machines. This can also be a circuit breaker, some particularly fault-tolerant machine acting as a private relayer for information. Setups with improved peering, private mesh networks, or similar might also fall into this category.</li>\n<li><strong>Level 2 - If-else rules</strong>: Have hard-coded rules waiting longer in certain slots. Those would be installed on multiple physical machines, allowing them to “coordinate” based on predefined rules.</li>\n<li><strong>Level 3 - Botnet</strong>: Have a centralized oracle that communicates with all validators and delivers the checkpoints to vote for and the timestamp when they should be published.</li>\n</ul>\n<p>In my opinion, crossing the line into the latter form of coordination (<em>level 2 and 3</em>) is problematic, and node operators should be held accountable. Finally, there may be a <strong>gray area</strong> for strategies involving <strong>static peering</strong> and <strong>private mesh networks</strong>.</p>\n<p><strong>Such setups could be used to run (malicious) strategies such as:</strong></p>\n<ul>\n<li>ensuring to never vote for different checkpoints across multiple physical machines.</li>\n<li>ensuring to never vote for reorging out a block from one’s own proposer.</li>\n<li>coordinating based on the consecutive proposer (<a href=\"https://github.com/ethereum/consensus-specs/pull/3034\">honest reorg client</a> (y/n)).</li>\n<li>censoring attestations of a certain party.</li>\n<li>not voting for the blocks of a certain party.</li>\n<li>etc.</li>\n</ul>\n<p><strong>When discussing <em>coordination</em>, it’s important to distinguish between two types:</strong></p>\n<ol>\n<li>Coordinated behavior that occurs when validators are <strong>run from the same physical machine</strong>.</li>\n<li>Coordinated behavior that arises from running the same <strong>modified client software</strong> or relying on the same <strong>centralized oracle</strong>.</li>\n</ol>\n<p>A potential solution to counter sophisticated coordinated validator behavior is <a href=\"https://ethereum-magicians.org/t/eip-7716-anti-correlation-attestation-penalties/20137\">EIP-7716: Anti-Correlation Penalties\"</a>, which proposes to scale penalties with the correlation among validators.</p>\n<p><em><strong>Find the code for this analysis <a href=\"https://github.com/nerolation/timing-games-and-economies-of-scale\">here</a>.</strong></em></p>\n<h1><a name=\"p-49615-more-on-that-topics-5\" class=\"anchor\" href=\"https://ethresear.ch#p-49615-more-on-that-topics-5\"></a>More on that topics</h1>\n<div class=\"md-table\">\n<table>\n<thead>\n<tr>\n<th>Title</th>\n<th>Author</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://timing.pics\">Timing.pics</a></td>\n<td>DotPics Website</td>\n</tr>\n<tr>\n<td><a href=\"https://ethresear.ch/t/timing-games-implications-and-possible-mitigations/17612\">Timing Games: Implications and Possible Mitigations</a></td>\n<td>Caspar &amp; Mike</td>\n</tr>\n<tr>\n<td><a href=\"https://ethresear.ch/t/deep-diving-attestations-a-quantitative-analysis/20020\">Deep Diving Attestations - A quantitative analysis</a></td>\n<td>Toni</td>\n</tr>\n<tr>\n<td><a href=\"https://www.paradigm.xyz/2023/04/mev-boost-ethereum-consensus\">Time, slots, and the ordering of events in Ethereum Proof-of-Stake</a></td>\n<td>Georgios &amp; Mike</td>\n</tr>\n<tr>\n<td><a href=\"https://arxiv.org/abs/2305.09032\">Time is Money: Strategic Timing Games in Proof-of-Stake Protocols</a></td>\n<td>Caspar et al.</td>\n</tr>\n<tr>\n<td><a href=\"https://eprint.iacr.org/2023/760\">Time to Bribe: Measuring Block Construction Market</a></td>\n<td>Toni et al.</td>\n</tr>\n<tr>\n<td><a href=\"https://ethresear.ch/t/the-cost-of-artificial-latency-in-the-pbs-context/17847\">The cost of artificial latency in the PBS context</a></td>\n<td>Chorus One</td>\n</tr>\n<tr>\n<td><a href=\"https://ethresear.ch/t/empirical-analysis-of-the-impact-of-block-delays-on-the-consensus-layer/17888\">Empirical analysis of the impact of block delays on the consensus layer</a></td>\n<td>Kiln</td>\n</tr>\n<tr>\n<td><a href=\"https://youtu.be/J_N13erDWKw?t=1061\">P2P Presentation on Timing Games (Youtube)</a></td>\n<td>P2P_org</td>\n</tr>\n<tr>\n<td><a href=\"https://www.youtube.com/watch?v=gsFU-inKRQ8\">Time is Money (Youtube)</a></td>\n<td>Caspar</td>\n</tr>\n</tbody>\n</table>\n</div>\n            <p><small>6 posts - 3 participants</small></p>\n            <p><a href=\"https://ethresear.ch/t/on-attestations-block-propagation-and-timing-games/20272\">Read full topic</a></p>","link":"https://ethresear.ch/t/on-attestations-block-propagation-and-timing-games/20272","pubDate":"Wed, 14 Aug 2024 13:04:48 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20272"},"source":{"@url":"https://ethresear.ch/t/on-attestations-block-propagation-and-timing-games/20272.rss","#text":"On Attestations, Block Propagation, and Timing Games"}},{"title":"A Node-Based Solution to Execution Sharding: The KRNL Protocol","dc:creator":"tahir-krnl","category":"Sharded Execution","description":"<p>By <a href=\"https://x.com/asim_eth\" rel=\"noopener nofollow ugc\">Asim Ahmad</a> and <a href=\"https://x.com/Tahir_Mahmood\" rel=\"noopener nofollow ugc\">Tahir Mahmood</a> on behalf of <a href=\"https://krnl.xyz\" rel=\"noopener nofollow ugc\">KRNL</a>.</p>\n<p><strong>1. Abstract</strong></p>\n<p>The evolution of the Web3 ecosystem confronts pivotal challenges such as network fragmentation, scalability constraints, cross-chain integration complexities, and security vulnerabilities. To address these issues, we introduce the KRNL Protocol—an orchestration and verification engine that seamlessly integrates permissionless and composable functions across multiple blockchain networks within the Ethereum transaction lifecycle. By transforming both on-chain and off-chain functions into execution shards called “kernels,” KRNL offers a distributed runtime environment that optimizes resource utilization, enhances modularity, and accelerates deployment. This approach not only improves the responsiveness of decentralized applications (dApps) but also reduces their time-to-market. Our proposal positions KRNL as part of the fabric of the Web3 framework.</p>\n<p><strong>2. Motivation</strong></p>\n<p>The Web3 ecosystem faces several significant challenges, including fragmentation, scalability limitations, cross-chain friction, and security concerns.</p>\n<p><strong>Fragmentation</strong>: The emergence of numerous Layer 1 and Layer 2 solutions has led to the creation of isolated silos. This fragmentation impedes seamless interaction between applications and smart contracts across different environments, undermining the foundational principle of composability in decentralized systems.</p>\n<p><strong>Scalability Constraints</strong>: Ethereum grapples with network congestion and high gas fees. These scalability issues deter the widespread adoption of dApps and erode user experience.</p>\n<p><strong>Cross-Chain Friction</strong>: Facilitating interoperability between Ethereum and other blockchains often demands intricate integrations. The absence of standardized cross-chain communication protocols exacerbates development complexities, stifling innovation and efficiency.</p>\n<p><strong>Security Vulnerabilities</strong>: Ensuring transaction integrity, provenance, and security in a decentralized manner remains a challenge. The proliferation of bridges and interoperability solutions introduces novel attack vectors, heightening security risks.</p>\n<p>To address these challenges, we reimagine the execution paradigm by introducing the concept of kernels - community-built, permissionless, monetizable, and composable execution shards across Web3. We also introduce the KRNL protocol, an orchestration and verification engine that enables smart contracts to integrate execution shards, enriching the logic and state of traditional smart contract operations without the creation of custom infrastructure. With this proposal, we aim to become an essential tool for the development of cross-chain applications.</p>\n<p><strong>3. TL;DR</strong></p>\n<p>Execution Sharding refers to the approach of dividing and distributing the execution of smart contracts across multiple blockchain networks, or “shards”, to enhance scalability and efficiency in blockchain systems. Instead of executing every transaction on a single chain, execution sharding allows transactions and smart contract states to be distributed across multiple chains, each handling a portion of the overall workload.</p>\n<p>Execution sharding is critical for Ethereum’s scalability. The KRNL Protocol integrates permissionless and composable kernels (execution shards) across multiple networks, seamlessly into the native Ethereum transaction lifecycle.</p>\n<p>KRNL manages resources to provide a secure and optimal execution environment for smart contracts. This enables a distributed runtime environment that determines transaction outcome based on selected kernels, operating across different environments. KRNL’s open framework enhances modularity, optimizes resources, ensures stable operations, and accelerates deployment, ultimately improving responsiveness and reducing time to market for applications.</p>\n<p><strong>4. Introducing Kernels</strong></p>\n<p>Within the KRNL Protocol framework, kernels represent execution shards. These kernels transform both on-chain and off-chain functions into modular units characterized by the following attributes:</p>\n<ul>\n<li><strong>Statelessness</strong>: Kernels maintain no intrinsic state, ensuring flexibility and facilitating seamless migration across environments.</li>\n<li><strong>Lightweight Design</strong>: To minimize computational overhead, kernels promote efficient execution.</li>\n<li><strong>Resilience</strong>: Engineered to withstand operational failures, ensuring reliable performance.</li>\n<li><strong>Independent Deployability</strong>: Allowing for deployment across various environments.</li>\n</ul>\n<p>The defining features of kernels include:</p>\n<ul>\n<li><strong>Infrastructure Agnosticism</strong>: Kernels are not tethered to specific infrastructures; they possess the agility to migrate across environments as necessitated.</li>\n<li><strong>Enhanced Modularity and Composability</strong>: By deconstructing applications into discrete kernels, modularity is enhanced, enabling permissionless sharing across multiple applications.</li>\n<li><strong>Accelerated Deployment</strong>: Simplifying the deployment process improves responsiveness and reduces time-to-market for applications.</li>\n</ul>\n<p><strong>5. Vision</strong></p>\n<p><strong>The Pre-Cloud Paradigm</strong></p>\n<p>Before cloud computing, developers bore the burden of constructing, operating, and maintaining all requisite programs and services. This paradigm engendered prohibitive costs, scalability constraints, accessibility challenges, and resource limitations. Cloud computing revolutionized this landscape, introducing managed services where back-end infrastructures are handled by cloud providers.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/5/f/5fe5cbe3446592ada1eea874797faf006e20d182.png\" data-download-href=\"https://ethresear.ch/uploads/default/5fe5cbe3446592ada1eea874797faf006e20d182\" title=\"Before and After Cloud Computing\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/5/f/5fe5cbe3446592ada1eea874797faf006e20d182_2_690x315.png\" alt=\"Before and After Cloud Computing\" data-base62-sha1=\"dGlHawMkk3iJMiae9lxr2f1xP6q\" width=\"690\" height=\"315\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/5/f/5fe5cbe3446592ada1eea874797faf006e20d182_2_690x315.png, https://ethresear.ch/uploads/default/optimized/3X/5/f/5fe5cbe3446592ada1eea874797faf006e20d182_2_1035x472.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/5/f/5fe5cbe3446592ada1eea874797faf006e20d182_2_1380x630.png 2x\" data-dominant-color=\"8791DD\"></a></div><p></p>\n<p><strong>KRNL’s Transformative Potential</strong></p>\n<p>KRNL seeks to catalyze a comparable paradigm shift within the Web3 domain—a permissionless Web3 cloud environment built by the community through contributions of monetizable kernels. This vision aligns with the Function as a Service (FaaS) model, reimagined to suit the decentralized and heterogeneous fabric of blockchain ecosystems.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/0/3/03a9e2f49a0d71e30f39b7ce9368173d25a7b5a6.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/03a9e2f49a0d71e30f39b7ce9368173d25a7b5a6\" title=\"Before and After KRNL\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/0/3/03a9e2f49a0d71e30f39b7ce9368173d25a7b5a6_2_690x301.jpeg\" alt=\"Before and After KRNL\" data-base62-sha1=\"wppAfeD9zl6FmqCPbHVRu57ihE\" width=\"690\" height=\"301\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/0/3/03a9e2f49a0d71e30f39b7ce9368173d25a7b5a6_2_690x301.jpeg, https://ethresear.ch/uploads/default/optimized/3X/0/3/03a9e2f49a0d71e30f39b7ce9368173d25a7b5a6_2_1035x451.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/0/3/03a9e2f49a0d71e30f39b7ce9368173d25a7b5a6_2_1380x602.jpeg 2x\" data-dominant-color=\"97A0E4\"></a></div><p></p>\n<p><strong>Functions as a Service (FaaS) in the Web3 Context</strong></p>\n<p>FaaS is a category of cloud computing services that provide a platform enabling customers to develop, run and manage applications without the complexity of building and maintaining the infrastructure associated with developing and launching an app. Examples of a traditional FaaS include AWS Lambda, Google Cloud Functions, Microsoft Azure Functions, etc.</p>\n<p>The conventional FaaS model does not fit well in distributed and heterogeneous blockchain environments, where each blockchain is a silo and not efficient in the context of the whole Web3 ecosystem. To adapt this concept to Web3, it is essential to ensure decentralized registry, management, and execution of kernels.</p>\n<p><strong>6. Core Concepts</strong></p>\n<p><strong>The Computing Engine</strong></p>\n<p>KRNL enhances an Ethereum Remote Procedure Call (RPC) node with a verification and orchestration-enabled computing engine. This engine abstracts the intricacies associated with integrating smart contract interdependencies.</p>\n<p>The computing engine creates an application and technology agnostic framework that offers a runtime environment to user applications in a distributed manner. It sits between a transaction initiated on any chain and its propagation into a block, determining a transaction’s outcome based on the kernels selected. This approach allows for flexible, efficient scaling and optimization of distributed applications.</p>\n<p><strong>Proof of Provenance (PoP)</strong></p>\n<p>PoP validates that prescribed kernels have run successfully before a transaction is executed, ensuring reliability and security of the KRNL Protocol.</p>\n<p>The KRNL Protocol achieves this by utilizing various schemes including a decentralized token authority that issues a signature token, ERC-1271, cryptography and proof systems. The implementation requires the application developer to implement a Software Development Kit (SDK) as well as the token authority. PoP works with existing standards within the Ethereum ecosystem, combining multiple schemes to ensure an anti-fragile system.</p>\n<p><strong>Decentralized Registry</strong></p>\n<p>An Ethereum based registry for activating and monetizing community built kernels. This registry serves as the definitive repository, maintaining critical information about registered kernels, including their pathways, monetization schemes, and other customizable parameters. Core to the design of KRNL is the concept of a two-sided marketplace where kernels are built and monetized, while being utilized by applications across Web3.</p>\n<p><strong>7. Architecture</strong></p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/d/2/d2b12fc5edd69ae351e74dda8a31b3f6e57a5311.png\" data-download-href=\"https://ethresear.ch/uploads/default/d2b12fc5edd69ae351e74dda8a31b3f6e57a5311\" title=\"Architecture Overview of the KRNL Protocol\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/d/2/d2b12fc5edd69ae351e74dda8a31b3f6e57a5311_2_690x388.png\" alt=\"Architecture Overview of the KRNL Protocol\" data-base62-sha1=\"u3RT8Iirh25DrxmRYUa9aPYd8Jj\" width=\"690\" height=\"388\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/d/2/d2b12fc5edd69ae351e74dda8a31b3f6e57a5311_2_690x388.png, https://ethresear.ch/uploads/default/optimized/3X/d/2/d2b12fc5edd69ae351e74dda8a31b3f6e57a5311_2_1035x582.png 1.5x, https://ethresear.ch/uploads/default/original/3X/d/2/d2b12fc5edd69ae351e74dda8a31b3f6e57a5311.png 2x\" data-dominant-color=\"E5F1ED\"></a></div><p></p>\n<p><strong>Use Case Scenario</strong></p>\n<p>In a hypothetical scenario, a DeFi protocol on Ethereum would like to allow users to trade RWA assets if they are an approved user on Company 1’s RWA platform (and if not, to reject the transaction from this wallet). Say Company 1 has built an RWA platform on Blockchain 2, with dynamic off-chain metadata corresponding to approved users. Additionally, these users need to have an identity score of X as determined by a on-chain DID smart contract on Blockchain 3. In the past, implementing these solutions across various chains would have required multiple complex integrations and in many cases require direct communication with vendors. However, with KRNL, builders now only need to perform a single, one-time permissionless integration.</p>\n<p>There is not currently any application layer that facilitates the conditional logic before state changes are executed, and this is generally built ground-up by builders. Ideally, this would be done in a plug-and-play, permissionless manner that would be reproducible by protocols that want to utilize the RWA platform and identifiers from the DID system.<br>\n</p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/8/6/869c6dc2fe0c134bfb17f32f1b481fadcd6e2704.png\" data-download-href=\"https://ethresear.ch/uploads/default/869c6dc2fe0c134bfb17f32f1b481fadcd6e2704\" title=\"Limitations of Existing Solutions\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/8/6/869c6dc2fe0c134bfb17f32f1b481fadcd6e2704_2_690x323.png\" alt=\"Limitations of Existing Solutions\" data-base62-sha1=\"jcP7Wr7VRTXtKvM9oX2dZTNgfCA\" width=\"690\" height=\"323\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/8/6/869c6dc2fe0c134bfb17f32f1b481fadcd6e2704_2_690x323.png, https://ethresear.ch/uploads/default/optimized/3X/8/6/869c6dc2fe0c134bfb17f32f1b481fadcd6e2704_2_1035x484.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/8/6/869c6dc2fe0c134bfb17f32f1b481fadcd6e2704_2_1380x646.png 2x\" data-dominant-color=\"F6F6F7\"></a></div><p></p>\n<p><strong>8. Decentralization and Security Considerations</strong></p>\n<p><strong>Upholding Decentralization</strong></p>\n<p>KRNL leverages the intrinsic decentralization of existing native blockchains. By integrating with a standard Ethereum RPC node, any Ethereum RPC node can function as a KRNL node without interfering with consensus mechanisms of the underlying network. Node operators are incentivized through the accrual of a proportion of fees generated from kernels, fostering a decentralized and participatory ecosystem.</p>\n<p><strong>Mitigating Malicious Activities</strong></p>\n<p>To preempt and mitigate potential malicious activities, such as replicating KRNL node code to fabricate counterfeit signatures, KRNL employs multiple cryptographic schemes that ensure security by design. The security architecture is flexible, customizable, and predominantly under the control of the dApp developer. This approach ensures that the KRNL Protocol remains permissionless, resilient, and secure.</p>\n<p><strong>Explore more in our <a href=\"https://github.com/KRNL-Labs/krnl-node-sandbox-public\" rel=\"noopener nofollow ugc\">KRNL Developer Sandbox</a></strong></p>\n<p><strong>Learn more about <a href=\"https://docs.krnl.xyz/\" rel=\"noopener nofollow ugc\">KRNL</a></strong></p>\n<p><strong>Supporting Research Papers</strong></p>\n<p><a href=\"https://arxiv.org/html/2404.08151v1\" rel=\"noopener nofollow ugc\">Decentralized FaaS over Multi-Clouds with Blockchain based Management for Supporting Emerging Applications</a></p>\n<p>DeFaaS is a novel decentralized Function-as-a-Service (FaaS) system proposed to address the limitations of centralized FaaS solutions. This system leverages blockchain technology and decentralized API management to create a distributed FaaS platform that offers improved scalability, flexibility, security, and reliability. DeFaaS is designed to support various distributed computing scenarios beyond FaaS, including decentralized applications (dApps), volunteer computing, and multi-cloud service mesh. The proposed system aims to mitigate issues associated with centralized FaaS, such as vendor lock-in and single points of failure.</p>\n<p><a href=\"https://www.sciencedirect.com/science/article/pii/S0306457321000340?ref=pdf_download&amp;fr=RR-2&amp;rr=89e00464f80d773d\" rel=\"noopener nofollow ugc\">Multi-Service Model for Blockchain Networks</a></p>\n<p>Multi-service networks aim to efficiently supply distinct goods within the same infrastructure by relying on a (typically centralized) authority to manage and coordinate their differential delivery at specific prices. In turn, final customers constantly seek to lower costs whilst maximizing quality and reliability. This paper proposes a decentralized business model for multi-service networks using Ethereum blockchain features – gas, transactions, and smart contracts – to execute multiple services at different prices. By employing Ether, to quantify the quality of service and reliability of distinct private Ethereum networks, their model concurrently processes streams of services at different gas prices while differentially delivering reliability and service quality.</p>\n<p><a href=\"https://www.researchgate.net/publication/372662346_Orchestrating_Digital_Wallets_for_On-_and_Off-chain_Decentralized_Identity_Management\" rel=\"noopener nofollow ugc\">Qualified Digital Certificates within Blockchain Networks</a></p>\n<p>This paper examines decentralized digital identities, which use asymmetric cryptography without centralized oversight, focusing on both on-chain (blockchain) and off-chain (self-sovereign) types. Currently, no single wallet manages both types of decentralized identities. To address this, the paper proposes an orchestration solution for a universal wallet that combines both types and validates it using a real-life use case.</p>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://ethresear.ch/t/a-node-based-solution-to-execution-sharding-the-krnl-protocol/20268\">Read full topic</a></p>","link":"https://ethresear.ch/t/a-node-based-solution-to-execution-sharding-the-krnl-protocol/20268","pubDate":"Wed, 14 Aug 2024 11:56:25 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20268"},"source":{"@url":"https://ethresear.ch/t/a-node-based-solution-to-execution-sharding-the-krnl-protocol/20268.rss","#text":"A Node-Based Solution to Execution Sharding: The KRNL Protocol"}},{"title":"DoS on block proposers in PoS and block builders in PBS","dc:creator":"ivan-homoliak","category":"Block proposer","description":"<ol>\n<li>\n<p>In Ethereum 2.0 PoS, the block proposer of the next block is known a certain time (~12s) before she creates the block. It might create an opportunity for attackers to DoS the next proposer who will therefore not create the new block and lose the reward. This might be systematically repeated again. We know that something similar was of concern for Algorand PoS and its VRF-based leader election that avoided this kind of attack.</p>\n</li>\n<li>\n<p>In PBS, the builder reveals the sealed block bid (commitment), and then later reveals the block contents. If the contents are not revealed, the builder will be penalized. So, the attacker already knowing the network address of victim can DoS her and cause severe penalties for not revealing the block on time. This might be systematically repeated again.</p>\n</li>\n</ol>\n<p>My question or point to discuss is how Ethereum protects against this kind of attack?</p>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://ethresear.ch/t/dos-on-block-proposers-in-pos-and-block-builders-in-pbs/20262\">Read full topic</a></p>","link":"https://ethresear.ch/t/dos-on-block-proposers-in-pos-and-block-builders-in-pbs/20262","pubDate":"Tue, 13 Aug 2024 10:28:43 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20262"},"source":{"@url":"https://ethresear.ch/t/dos-on-block-proposers-in-pos-and-block-builders-in-pbs/20262.rss","#text":"DoS on block proposers in PoS and block builders in PBS"}},{"title":"A trustless on-chain anti-MEV solution for Layer2/3","dc:creator":"Lawliet-Chan","category":"Layer 2","description":"<p>We have a solution to resolve the Layer2 MEV onchain trustlessly.<br>\nHere is the arch:<br>\n</p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/a/e/aeec6e16bbf3b6864d66ae84ecf5b663f9c55ce5.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/aeec6e16bbf3b6864d66ae84ecf5b663f9c55ce5\" title=\"image\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/a/e/aeec6e16bbf3b6864d66ae84ecf5b663f9c55ce5_2_336x500.jpeg\" alt=\"image\" data-base62-sha1=\"oXrCZnu1z4Kc3Q9BtlzOm5buc8B\" width=\"336\" height=\"500\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/a/e/aeec6e16bbf3b6864d66ae84ecf5b663f9c55ce5_2_336x500.jpeg, https://ethresear.ch/uploads/default/optimized/3X/a/e/aeec6e16bbf3b6864d66ae84ecf5b663f9c55ce5_2_504x750.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/a/e/aeec6e16bbf3b6864d66ae84ecf5b663f9c55ce5_2_672x1000.jpeg 2x\" data-dominant-color=\"FBFBFB\"></a></div><p></p>\n<ol>\n<li>Users only send their txHash to the L2 chain with some advance charge (to prevent DOS attack)</li>\n<li>The chain accepts these txHashes, sort them based on the amount of tips, and then make a Tx-Order-commitment and broadcast it to the other chain nodes.  Also, user can subscribe this commitment.</li>\n<li>When users see the order-commitments, they will send their tx-content to the L2 chain and the DA-layers.</li>\n<li>Chain accepts the tx-content from users, and also fetch txs from DA-layers ,  pack them according to the previously promised order. If the tx-content does not match the previously tx-hash, chain will put them behind the txs which made order-commitment.<br>\n<strong>All promised txs will be sorted before the unpromised txs.</strong><br>\nNOTICE: In this way, the chain may deduct tx-content and pretend not to receive it.  To prevent this situation. We have to:<br>\ni. Decentralise chain node.<br>\nii. Use DA to complete the txs if one node does not accept the txs.</li>\n</ol>\n<p>In this case, we call it MEVless protocol,   it means you don’t have to trust any group and institution.  You do not have to depend on a privacy node, not through MEVA, to protect your transactions from MEV attack.  Because all the attackers(besides miners themselves) cannot see your tx-content when it orders.   Once the tx-content is packed and executed, it must be packed by the previously commitment, attackers cannot front-run and sandwich attack you.</p>\n<p>We have developed some of it and you can see the running effect:</p><aside class=\"onebox githubfolder\" data-onebox-src=\"https://github.com/yu-org/nine-tripods/tree/main/MEVless\">\n  <header class=\"source\">\n      <img src=\"https://ethresear.ch/uploads/default/original/2X/b/bad3e5f9ad67c1ddf145107ce7032ac1d7b22563.svg\" class=\"site-icon\" data-dominant-color=\"\" width=\"32\" height=\"32\">\n\n      <a href=\"https://github.com/yu-org/nine-tripods/tree/main/MEVless\" target=\"_blank\" rel=\"noopener nofollow ugc\">github.com</a>\n  </header>\n\n  <article class=\"onebox-body\">\n    <h3><a href=\"https://github.com/yu-org/nine-tripods/tree/main/MEVless\" target=\"_blank\" rel=\"noopener nofollow ugc\">nine-tripods/MEVless at main · yu-org/nine-tripods</a></h3>\n\n\n  <p><span class=\"label1\">Contribute to yu-org/nine-tripods development by creating an account on GitHub.</span></p>\n\n  </article>\n\n  <div class=\"onebox-metadata\">\n    \n    \n  </div>\n\n  <div style=\"clear: both\"></div>\n</aside>\n<aside class=\"onebox githubfolder\" data-onebox-src=\"https://github.com/VersechainLabs/versechain/tree/mevless\">\n  <header class=\"source\">\n      <img src=\"https://ethresear.ch/uploads/default/original/2X/b/bad3e5f9ad67c1ddf145107ce7032ac1d7b22563.svg\" class=\"site-icon\" data-dominant-color=\"\" width=\"32\" height=\"32\">\n\n      <a href=\"https://github.com/VersechainLabs/versechain/tree/mevless\" target=\"_blank\" rel=\"noopener nofollow ugc\">github.com</a>\n  </header>\n\n  <article class=\"onebox-body\">\n    <h3><a href=\"https://github.com/VersechainLabs/versechain/tree/mevless\" target=\"_blank\" rel=\"noopener nofollow ugc\">GitHub - VersechainLabs/versechain at mevless</a></h3>\n\n  <p><a href=\"https://github.com/VersechainLabs/versechain/tree/mevless\" target=\"_blank\" rel=\"noopener nofollow ugc\">mevless</a></p>\n\n  <p><span class=\"label1\">A high performance decentralized modular sequencer for Starknet</span></p>\n\n  </article>\n\n  <div class=\"onebox-metadata\">\n    \n    \n  </div>\n\n  <div style=\"clear: both\"></div>\n</aside>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/b/f/bfa58e407bea18228ba10bbc90f904aca2c776aa.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/bfa58e407bea18228ba10bbc90f904aca2c776aa\" title=\"image\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/b/f/bfa58e407bea18228ba10bbc90f904aca2c776aa_2_607x500.jpeg\" alt=\"image\" data-base62-sha1=\"rlnTGRarj8uDU4goSBfHnKuxlx0\" width=\"607\" height=\"500\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/b/f/bfa58e407bea18228ba10bbc90f904aca2c776aa_2_607x500.jpeg, https://ethresear.ch/uploads/default/optimized/3X/b/f/bfa58e407bea18228ba10bbc90f904aca2c776aa_2_910x750.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/b/f/bfa58e407bea18228ba10bbc90f904aca2c776aa_2_1214x1000.jpeg 2x\" data-dominant-color=\"071307\"></a></div><p></p>\n<p>You can see the txHash order-commitment in the above red box and you can try MEV-attacking these txs when they are completed by tx-contents later, then you will find you cannot insert your tx into their order at all.</p>\n            <p><small>8 posts - 4 participants</small></p>\n            <p><a href=\"https://ethresear.ch/t/a-trustless-on-chain-anti-mev-solution-for-layer2-3/20260\">Read full topic</a></p>","link":"https://ethresear.ch/t/a-trustless-on-chain-anti-mev-solution-for-layer2-3/20260","pubDate":"Tue, 13 Aug 2024 04:02:59 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20260"},"source":{"@url":"https://ethresear.ch/t/a-trustless-on-chain-anti-mev-solution-for-layer2-3/20260.rss","#text":"A trustless on-chain anti-MEV solution for Layer2/3"}},{"title":"Proof of Service Integrity (PoSI): Trustless measurement of service integrity","dc:creator":"peshwar9","category":"Security","description":"<h1><a name=\"p-49574-proof-of-service-integrity-posi-trustless-measurement-of-service-integrity-1\" class=\"anchor\" href=\"https://ethresear.ch#p-49574-proof-of-service-integrity-posi-trustless-measurement-of-service-integrity-1\"></a>Proof of Service integrity (PoSI) : Trustless measurement of service integrity</h1>\n<h2><a name=\"p-49574-tldr-2\" class=\"anchor\" href=\"https://ethresear.ch#p-49574-tldr-2\"></a>TL;Dr</h2>\n<p><strong>Proof of Service Integrity (PoSI)</strong> is a byzantine fault tolerant verification protocol for offchain activities.</p>\n<p>It performs three main tasks in a decentralised fashion - <em>deployment</em> of approved service images, <em>measurements</em> of deployed services, and <em>attestation</em> of the integrity of these services in production.</p>\n<p>The problem PoSI solves is that offchain services are growing in volume, size and complexity in modern chain architectures, but they are largely centralised and run in trusted environments while handling millions of dollars of transaction flows. This is incompatible with the goals of crypto systems. Permissionless verification of offchain services using PoSI protocol provides a real-time integrated security view for emerging hybrid crypto protocols that have a mix of on-chain and off-chain activities.</p>\n<p>Offchain services that are verified by PoSI protocol are called <strong>Integrity Verified services</strong> (IVS).</p>\n<h2><a name=\"p-49574-preface-3\" class=\"anchor\" href=\"https://ethresear.ch#p-49574-preface-3\"></a>Preface</h2>\n<p>This post builds on the earlier proposal on integrity proofs (<a href=\"https://ethresear.ch/t/integrity-proofs-to-improve-rollup-security/19437\" class=\"inline-onebox\">Integrity proofs to improve rollup security</a>) with the following main differences:</p>\n<ol>\n<li>Focus on measuring integrity of any off-chain service, rather than just rollup services</li>\n<li>Earlier design was TEE-based, current protocol is primarily BFT-based but uses TEEs as a <em>defense-in-depth</em> mechanism.</li>\n<li>Changes to the architecture</li>\n</ol>\n<h2><a name=\"p-49574-prelude-4\" class=\"anchor\" href=\"https://ethresear.ch#p-49574-prelude-4\"></a>Prelude</h2>\n<p>Traditional distributed systems monitoring/observability involves collecting and analyzing data in order to gain insights into the functioning, performance, security and health of software systems and applications. It involves systematically observing and tracking various metrics, events, logs and distributed traces to construct a visual representation of a system’s hardware and software performance and health. While there are multiple types of distributed systems monitoring data, one  dimension in particular that is not measured in traditional web2 distributed systems is service integrity.</p>\n<p>For this post, let’s define <em>service integrity</em> as the following:</p>\n<ol>\n<li>The correct (authorised and verified) software version has been deployed</li>\n<li>No unauthorised changes have been made to the deployed software in production.</li>\n<li>Anyone can permissionlessly verify proof of <span class=\"hashtag-raw\">#1</span> and <span class=\"hashtag-raw\">#2</span> for any given service either through data provided over a user interface or API, or through verification of a zero-knowledge proof.</li>\n</ol>\n<p>In internet/online systems (web2), <em>services integrity</em> (particularly <span class=\"hashtag-raw\">#1</span> and <span class=\"hashtag-raw\">#2</span>) is the responsibility of the organisation or entity that centrally owns and manages the distributed service, <em>aka trusted deployments</em>. As a consequence, <span class=\"hashtag-raw\">#3</span> is simply not possible.</p>\n<p>When we talk about web3 systems, <em>service integrity</em> becomes paramount. Services are deployed in <em>untrusted environments</em> managed by operators that we do not know or have legal contracts with.</p>\n<p>The way this problem has been solved in blockchain-based systems (Proof-of-stake in particular) is through a carefully designed set of incentives to encourage external operators to run the distributed software with desired behaviours, coupled with a clever mechanism for the distributed network to reach a consensus such that if an operator that is part of the consensus set is detected to perform any malicious action, they can be financially penalised (through onchain mechanisms or social governance).</p>\n<p>This worked reasonably in the early days of evolution of onchain systems where all the logic for onchain protocols were on smart contracts on a single chain, which was invoked from offchain clients. Censorship resistance was largely handled by allowing anyone to run the Json-RPC nodes (which are the user transaction entry points) that communicate with the other distributed network nodes over P2P protocols. This ensured eventual censorship-resistance.</p>\n<h2><a name=\"p-49574-evolution-of-crypto-protocol-architectures-5\" class=\"anchor\" href=\"https://ethresear.ch#p-49574-evolution-of-crypto-protocol-architectures-5\"></a>Evolution of crypto protocol architectures</h2>\n<p>Recent developments in blockchain systems have seen an explosion in the number of layer-1 and layer-2 chains, and the rise of modular architectures with innovations in application protocols, core infrastructure, scaling and interop solutions, developer &amp; user tools. These innovations are aimed at solving problems with scaling throughput, reducing latency, lowering transaction costs, offering greater sovereignty to builders over design choices, solving for both synchronous and async interoperability, unifying liquidity, mev optimisation, and improving user experience in crypto.</p>\n<p>These developments have resulted in increased complexity and sophistication of onchain protocols involving a mix of smart-contract logic and offchain logic. Emerging use cases such as cross-chain swaps involve a mix of smart contract and offchain logic on both the source and destination chains.</p>\n<p>Let’s look at a few of the hybrid onchain-offchain architectures in popular crypto protocols.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/4/9/491a30b1c361107e65615618ea2b29c226245e4d.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/491a30b1c361107e65615618ea2b29c226245e4d\" title=\"Fig 1: Hybrid onchain-offchain design in crypto protocols\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/4/9/491a30b1c361107e65615618ea2b29c226245e4d_2_690x474.jpeg\" alt=\"Fig 1: Hybrid onchain-offchain design in crypto protocols\" data-base62-sha1=\"aqGXZvy6h9CXGrhmEhpaFsnhhGR\" width=\"690\" height=\"474\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/4/9/491a30b1c361107e65615618ea2b29c226245e4d_2_690x474.jpeg, https://ethresear.ch/uploads/default/optimized/3X/4/9/491a30b1c361107e65615618ea2b29c226245e4d_2_1035x711.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/4/9/491a30b1c361107e65615618ea2b29c226245e4d_2_1380x948.jpeg 2x\" data-dominant-color=\"F1EFEF\"></a></div><p></p>\n<p>Fig A shows onchain logic on a single chain encoded as smart contracts. The onchain logic is accessed from a regular web or mobile client application through RPC calls.</p>\n<p>Fig B shows an example of crypto protocol containing a mix of onchain smart contract logic on a single chain and offchain component attached to it. The offchain component typically either supplies data from an online system (eg price feeds through oracle) or performs compute-heavy operations on behalf of the smart contract (eg co-processor). The offchain component can also be a regular web backend of the dapp, if the app developer chooses to keep a portion of the business logic offchain (which is not uncommon in most modern dapps).</p>\n<p>Fig C shows an example of a cross-chain transaction that involves two chains - source and destination chain (e.g., cross-chain swaps or bridging). Here, smart contract logic is present on both the chains, and there are corresponding offchain components.</p>\n<blockquote>\n<p>The main challenge that is being addressed in this post is that a big proportion of the off-chain components that are part of these hybrid onchain-offchain crypto protocols are run in trusted environments. This is incompatible with the main goals of crypto protocols which are trustlessness, censorship resistance and permission-less participation and verifiability.</p>\n</blockquote>\n<p>While the onchain components (aka smart contracts) are secured by consensus, economic incentives and permissionless verification, the same cannot be said about offchain services whose actions cannot be attributed onchain.  These services are, in most cases, centralised,  owned and run by trusted entities, but play critical role in the overall transaction workflows. They are vulnerable to censorship, tampering and other kinds of attacks. Note that only the on-chain logic of the crypto protocols is secured by the blockchain consensus, not the supporting off-chain infrastructure and services which have varying levels of trust assumptions. In some cases, it is not even possible to detect malicious actions performed by such offchain components <em>(non-attributable faults)</em>.</p>\n<p>Figure 2 shows a non-exhaustive list of popular categories of offchain services that are an integral part of many crypto protocols.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/4/b/4b764f4c7ce39d7b0d4769c441ff37392c08d505.png\" data-download-href=\"https://ethresear.ch/uploads/default/4b764f4c7ce39d7b0d4769c441ff37392c08d505\" title=\"Fig 2: Common categories of off-chain services\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/4/b/4b764f4c7ce39d7b0d4769c441ff37392c08d505_2_690x350.png\" alt=\"Fig 2: Common categories of off-chain services\" data-base62-sha1=\"aLzhQdo4QHrT82cTTXJfkN1bRFH\" width=\"690\" height=\"350\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/4/b/4b764f4c7ce39d7b0d4769c441ff37392c08d505_2_690x350.png, https://ethresear.ch/uploads/default/optimized/3X/4/b/4b764f4c7ce39d7b0d4769c441ff37392c08d505_2_1035x525.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/4/b/4b764f4c7ce39d7b0d4769c441ff37392c08d505_2_1380x700.png 2x\" data-dominant-color=\"D4E4EB\"></a></div><p></p>\n<p>What are the types of risks to crypto protocols with such centralised offchain services?</p>\n<p><em>Insider Threats</em>: Employees or contractors within the service development team or the cloud platform provider may misuse their privileged access.<br>\n<em>Unauthorized Modifications</em>: Malicious actors might attempt to alter the service code logic or configuration without detection, leading to unintended consequences inconsistent with the protocol goals.<br>\n<em>Censorship Risks</em>: In case of offchain services, bad actors might attempt to censor certain transactions or user interactions.<br>\n<em>Data and Fund Security</em>: There’s a risk of unauthorized access to sensitive data or funds managed by the service. e.g. a dapp backend managing an embedded wallet may view/steal user wallet keys.</p>\n<h2><a name=\"p-49574-we-need-a-decentralised-verification-protocol-6\" class=\"anchor\" href=\"https://ethresear.ch#p-49574-we-need-a-decentralised-verification-protocol-6\"></a>We need a decentralised verification protocol</h2>\n<p>Hence, a critical requirement for the success of these modular hybrid onchain-offchain architectures is the ability to prove offchain service integrity at scale in a decentralised trustless manner, i.e. a <em>Byzantine fault tolerant service integrity verification system</em>.</p>\n<p>In this post, we present <em>Proof of Service Integrity</em> (<strong>PoSI</strong>), a verification protocol that performs three main tasks - <em>deployment of publicly-identifiable code images</em>, <em>measurement of the correctness  of code deployed periodically</em>, and  <em>attestation of service integrity</em> in the production environment. These correspond respectively to the properties of <em>correctness</em>, <em>integrity</em> and <em>verifiability</em> for the monitored services. Figure 3 shows the key desired properties and relationships between the PoSI nodes that are part of the verification network, and the monitored services.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/1/3/135c0d620ec8bd53705bf83f07fd11c3aff47d42.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/135c0d620ec8bd53705bf83f07fd11c3aff47d42\" title=\"Fig 3: Verification layer for off-chain services\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/1/3/135c0d620ec8bd53705bf83f07fd11c3aff47d42_2_690x163.jpeg\" alt=\"Fig 3: Verification layer for off-chain services\" data-base62-sha1=\"2Lgiaq5fePnbgbxjkz4qhuYRcqK\" width=\"690\" height=\"163\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/1/3/135c0d620ec8bd53705bf83f07fd11c3aff47d42_2_690x163.jpeg, https://ethresear.ch/uploads/default/optimized/3X/1/3/135c0d620ec8bd53705bf83f07fd11c3aff47d42_2_1035x244.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/1/3/135c0d620ec8bd53705bf83f07fd11c3aff47d42_2_1380x326.jpeg 2x\" data-dominant-color=\"EDEFF4\"></a></div><p></p>\n<p>The PoSI nodes that implement the verification protocol itself satisfy the following  properties: 1) <em>Trustless:</em> Service integrity measurements are secure against byzantine attacks by collaborations among the monitoring services and the monitored services. 2) <em>Tamper-proof</em>: The service monitoring service while verifying the tamper-resistance of the monitored services, is itself tamper-resistant  3) <em>Open</em>: The protocol allows anyone to register and provide measurement data , by using cryptographic primitives to ensure that a subset of actors cannot maliciously modify results in their favour.</p>\n<p>A formal security model allows us to establish guarantees of accurate service measurements in the presence of malicious actors. The security guarantees of the PoSI protocol are composable with the onchain state commitments on blockchain ledgers to provide a comprehensive view of protocol security which is not possible by just focusing on smart-contract &amp; consensus-based security.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/f/2/f2a8e22a3c90dfb18ded2bfa3c371ef147452247.png\" data-download-href=\"https://ethresear.ch/uploads/default/f2a8e22a3c90dfb18ded2bfa3c371ef147452247\" title=\"Fig 4: Integrated view of security of crypto protocols with PoSI\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/f/2/f2a8e22a3c90dfb18ded2bfa3c371ef147452247_2_690x201.png\" alt=\"Fig 4: Integrated view of security of crypto protocols with PoSI\" data-base62-sha1=\"yCFnuP5SKhSOn82afjyOjY7e8N9\" width=\"690\" height=\"201\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/f/2/f2a8e22a3c90dfb18ded2bfa3c371ef147452247_2_690x201.png, https://ethresear.ch/uploads/default/optimized/3X/f/2/f2a8e22a3c90dfb18ded2bfa3c371ef147452247_2_1035x301.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/f/2/f2a8e22a3c90dfb18ded2bfa3c371ef147452247_2_1380x402.png 2x\" data-dominant-color=\"E2E8E4\"></a></div><p></p>\n<h2><a name=\"p-49574-proof-of-service-integrity-posi-protocol-overview-7\" class=\"anchor\" href=\"https://ethresear.ch#p-49574-proof-of-service-integrity-posi-protocol-overview-7\"></a>Proof of Service Integrity (PoSI) protocol overview</h2>\n<p>PoSI enables verifiable service integrity through the following:</p>\n<p><em>Authenticated Deployment</em>: PoSI ensures that only authorized and verified code is deployed to the production environment. This prevents the introduction of malicious or unauthorized code during the deployment process.</p>\n<p><em>Continuous Integrity Monitoring</em>: Once deployed, PoSI nodes continuously monitor the service to detect any unauthorized modifications or tampering. Any discrepancies between the running service and its expected state are immediately detected and reported.</p>\n<p><em>Integrity Attestation</em>: Users or dApps can request integrity proofs for any PoSI-enabled service through a permissionless, public interface. Two types of integrity checks can be done on a given service - <em>measurements-based</em> and <em>proof-based</em>. <em>Measurements-based</em> checks involve deriving service integrity from the onchain measurements for the service. <em>Proof-based</em> checks can be done by requesting a SNARK proof of integrity  for the service, which can then be verified either on-chain (SNARK verification) or off-chain (in a web or mobile app).</p>\n<p>Services that are verified by PoSI protocol are called <em>Integrity-verified services</em> (IVS).</p>\n<h2><a name=\"p-49574-architecture-workflows-8\" class=\"anchor\" href=\"https://ethresear.ch#p-49574-architecture-workflows-8\"></a>Architecture workflows</h2>\n<p>PoSI protocol involves the following three workflows:</p>\n<ol>\n<li>Service developer workflow</li>\n<li>Operator workflow</li>\n<li>Verification workflow</li>\n</ol>\n<p>Figure 5 shows an overview of the key actors and actions in the protocol.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/9/2/929487f88493ab7c774f428b5bed736328ff9f72.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/929487f88493ab7c774f428b5bed736328ff9f72\" title=\"Fig 5: Overview of PoSI protocol\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/9/2/929487f88493ab7c774f428b5bed736328ff9f72_2_690x268.jpeg\" alt=\"Fig 5: Overview of PoSI protocol\" data-base62-sha1=\"kUHW6vnV2ngtBuqWAQBGqbXnfl8\" width=\"690\" height=\"268\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/9/2/929487f88493ab7c774f428b5bed736328ff9f72_2_690x268.jpeg, https://ethresear.ch/uploads/default/optimized/3X/9/2/929487f88493ab7c774f428b5bed736328ff9f72_2_1035x402.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/9/2/929487f88493ab7c774f428b5bed736328ff9f72_2_1380x536.jpeg 2x\" data-dominant-color=\"E9F0F5\"></a></div><p></p>\n<p>The architecture of PoSI involves the following components and actors:</p>\n<p><strong>1. Human/Organisational actors:</strong></p>\n<p><em>Service developer</em>: This refers to the developer and owner of the distributed software service. The service developer is the main ‘customer’ for the integrity-verified service, and is the person or entity that is ready to pay a fee to have their service integrity-verified.</p>\n<p><em>Operator:</em> This refers to the provider of the computational infrastructure. The service developer can themselves choose to be the operator by deploying the IVS on a cloud account controlled by them or they can choose to deploy their service on an external operator’s VM through a DePIN service.</p>\n<p><strong>2. PoSI Platform:</strong></p>\n<p><em>PoSI platform onchain:</em> This contains the core smart contracts of the  protocol.</p>\n<p><em>PoSI Offchain</em>: This comprises core offchain services that are part of the protocol.</p>\n<p><strong>3. Applications/ Other chains:</strong></p>\n<p><em>Application</em>:  A web or mobile application that verifies the proof for an IVS.</p>\n<p><em>Other chain:</em> Any other chain can verify the zk proofs generated by the PoSI protocol.</p>\n<h3><a name=\"p-49574-service-developer-workflow-9\" class=\"anchor\" href=\"https://ethresear.ch#p-49574-service-developer-workflow-9\"></a>Service developer workflow</h3>\n<ol>\n<li>Service developer builds the service and registers the service image in a public repository.</li>\n<li>Service developer registers the service image along with other service metadata with the PoSI onchain smart contracts. They also deposit rewards amount, along with service level expectations (e.g. frequency of measurements).</li>\n<li>Service developer can trigger the PoSI smart contract to trigger the service deployment either on their self-hosted VM, their cloud VM or on a DePIN VM.</li>\n<li>The PoSI protocol pays out the rewards to the operators based on the tasks performed by them, from the service developer’s account.</li>\n</ol>\n<h3><a name=\"p-49574-operator-workflow-10\" class=\"anchor\" href=\"https://ethresear.ch#p-49574-operator-workflow-10\"></a>Operator workflow</h3>\n<ol>\n<li>Operator registers their VM with the PoSI registration service. The operator can choose to perform two kinds of tasks - host <em>service images</em>, or host the <em>PoSI host program</em> that performs measurements on other services. For the former, any regular VM of the configuration required by service developers would be accepted. For the latter, TEE-based VMs will be required.</li>\n<li>Note that service developer can choose to deploy their service on their own VM, in which case they need to register it like other external operators. For TEE-based VMs, the quote has to be generated by the operator and submitted to the registration service along with in-enclave generated public key.</li>\n<li>Operator stakes the minimum specified tokens as part of registration. If the service developer hosts the service on their own VM, this step is not required.</li>\n<li>The PoSI registration service verifies the registered VM and registers it with the PoSI onchain contract. The PoSi registration service itself runs within a TEE enclave.</li>\n<li>When the service developer triggers deployment of a service, the PoSI host program retrieves the registered service image from public repository and deploys the service on the service developer (or external operator’s VM based on the configuration).</li>\n<li>If an operator has registered to host the PoSI protocol, the PoSI master  deploys the PoSI host program on the operator’s VM. This enables the operator to then perform service measurements on other services.</li>\n<li>Based on the specification of the service developer, the operator set is established for verifying that service, which runs the consensus mechanism to determine the final service measurements. The votes of all  operators in the operator set are aggregated and recorded onchain, along with the measurements.</li>\n<li>At periodic intervals, measurements of the performance of the verious operators are taken by the PoSI measurement service, and rewards are computed for the operators. Any incorrect measurements attributable to any of the operators in operator set is penalized through slashing of their stake, in a manner defined in the PoSI protocol.</li>\n</ol>\n<h3><a name=\"p-49574-verification-workflow-11\" class=\"anchor\" href=\"https://ethresear.ch#p-49574-verification-workflow-11\"></a>Verification workflow</h3>\n<ol>\n<li>Any web or mobile application can ask the PoSI protocol servers for attestation of any particular service. The PoSI protocol returns the proof to the web/mobile application.</li>\n<li>Two kinds of proofs can be requested from the PoSI protocol for a service: <em>state proofs</em> and <em>SNARK-proofs</em>. <em>State proofs</em> simple return the onchain state of a service computed from the measurements submitted by operators. SNARK proofs that are returned by the PoSI protocol can be verified either off-chain within the web/mobile application, or submitted to another on-chain smart contract for verification.</li>\n</ol>\n<p>An integrated view of the various workflows for the PoSI protocol is shown in figure.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/3/2/32045a0a10edcc50ab33324a649080621d79a8ac.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/32045a0a10edcc50ab33324a649080621d79a8ac\" title=\"Fig 6: Integrated view of PoSI workflows\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/3/2/32045a0a10edcc50ab33324a649080621d79a8ac_2_690x309.jpeg\" alt=\"Fig 6: Integrated view of PoSI workflows\" data-base62-sha1=\"78tcdo34Msy6Rrfp7XfBKSRiAgY\" width=\"690\" height=\"309\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/3/2/32045a0a10edcc50ab33324a649080621d79a8ac_2_690x309.jpeg, https://ethresear.ch/uploads/default/optimized/3X/3/2/32045a0a10edcc50ab33324a649080621d79a8ac_2_1035x463.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/3/2/32045a0a10edcc50ab33324a649080621d79a8ac_2_1380x618.jpeg 2x\" data-dominant-color=\"EFF3EF\"></a></div><p></p>\n<p>Note: Figure 6 shows only a single host program taking the service measurements (for reducing clutter in diagram), but it can be visualised as a set of nodes that participate and arrive at a consensus before posting the measurements on-chain.</p>\n<h2><a name=\"p-49574-conclusion-12\" class=\"anchor\" href=\"https://ethresear.ch#p-49574-conclusion-12\"></a>Conclusion</h2>\n<p>Trustfree measurement of offchain service integrity is an unsolved problem in decentralised networks. <strong>Proof of Service Integrity (PoSI)</strong> addresses this core requirement by providing a secure, byzantine resistant verification layer for offchain services while allowing open participation for operators and service developers to benefit from the protocol. All components of the protocol can be operated by community-run protocol nodes controlled by the onchain protocol smart contracts. PoSI incorporates a layered security model that includes <em>consensus-based</em>, <em>hardware-based</em> and <em>crypto-economic security</em>. PoSI requires the participating offchain services to have open source code, a publicly verifiable service image, reproducible build process and dockerized deployment.</p>\n<h2><a name=\"p-49574-faq-13\" class=\"anchor\" href=\"https://ethresear.ch#p-49574-faq-13\"></a>FAQ</h2>\n<h3><a name=\"p-49574-what-kind-of-services-can-benefit-from-the-posi-protocol-14\" class=\"anchor\" href=\"https://ethresear.ch#p-49574-what-kind-of-services-can-benefit-from-the-posi-protocol-14\"></a>What kind of services can benefit from the PoSI protocol?</h3>\n<p>Any in-protocol or out-of-protocol offchain service can benefit from PoSI protocol. A non-exhaustive list of offchain services was mentioned earlier in the post, and is reproduced here:</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/4/b/4b764f4c7ce39d7b0d4769c441ff37392c08d505.png\" data-download-href=\"https://ethresear.ch/uploads/default/4b764f4c7ce39d7b0d4769c441ff37392c08d505\" title=\"Fig 7: Popular categories of off-chain services\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/4/b/4b764f4c7ce39d7b0d4769c441ff37392c08d505_2_690x350.png\" alt=\"Fig 7: Popular categories of off-chain services\" data-base62-sha1=\"aLzhQdo4QHrT82cTTXJfkN1bRFH\" width=\"690\" height=\"350\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/4/b/4b764f4c7ce39d7b0d4769c441ff37392c08d505_2_690x350.png, https://ethresear.ch/uploads/default/optimized/3X/4/b/4b764f4c7ce39d7b0d4769c441ff37392c08d505_2_1035x525.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/4/b/4b764f4c7ce39d7b0d4769c441ff37392c08d505_2_1380x700.png 2x\" data-dominant-color=\"D4E4EB\"></a></div><p></p>\n<h3><a name=\"p-49574-what-are-the-alternative-architectures-available-to-secure-offchain-services-15\" class=\"anchor\" href=\"https://ethresear.ch#p-49574-what-are-the-alternative-architectures-available-to-secure-offchain-services-15\"></a>What are the alternative architectures available to secure offchain services?</h3>\n<p>For offchain services to transition from <em>trusted</em> to <em>trust-minimised</em> / <em>trustless</em> architectures, here is a comparison of the various design approaches.</p>\n<div class=\"md-table\">\n<table>\n<thead>\n<tr>\n<th>Design approach</th>\n<th>Description</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Security model</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Consensus-based</td>\n<td>Build a BFT-consensus with own operator set</td>\n<td>Trustless</td>\n<td>It is expensive and cumbersome for a service developer</td>\n<td>Depends on size of the operator set</td>\n</tr>\n<tr>\n<td>ZK-based</td>\n<td>Build a custom zk circuit or a program that can be proven in a general purpose zkVM</td>\n<td>Trustless</td>\n<td>Involves rewrite of the service using zk DSLs or using Rust. Expensive to generate zk-proofs</td>\n<td>Restricted to what can be proven in zk circuits</td>\n</tr>\n<tr>\n<td>EigenLayer AVS-based</td>\n<td>Convert the service into Eigenlayer AVS</td>\n<td>Inherit Ethereum security without bootstrapping an operator set</td>\n<td>Requires rewrite of the code to comply with AVS protocol. Also AVS can only detect and penalise operator faults if they are observable on-chain.</td>\n<td>Economic security</td>\n</tr>\n<tr>\n<td>PoSI IVS-based</td>\n<td>Deploy existing code in docker containers with no code rewrite.</td>\n<td>Ability to detect non-attributable faults (those that are not normally visible on-chain such as censorship, or unauthorized upgrades of service algorithms). Small, configurable cost.</td>\n<td>Services should meet pre-requisites: open-source code, a publicly verifiable service image, a reproducible build process and dockerized deployment</td>\n<td>Multi-layered security model incorporating <em>consensus-based</em>, <em>TEE</em>, and <em>crypto-economic security</em> constructs.</td>\n</tr>\n</tbody>\n</table>\n</div><h2><a name=\"p-49574-credits-16\" class=\"anchor\" href=\"https://ethresear.ch#p-49574-credits-16\"></a>Credits</h2>\n<p>The concept and design for PoSI protocol and Integrity-verified services was initially developed as a collaboration between <a class=\"mention\" href=\"https://ethresear.ch/u/peshwar9\">@peshwar9</a> and <a class=\"mention\" href=\"https://ethresear.ch/u/mohsinriaz17\">@mohsinriaz17</a> with contribution from several others to refine and enhance it.</p>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://ethresear.ch/t/proof-of-service-integrity-posi-trustless-measurement-of-service-integrity/20255\">Read full topic</a></p>","link":"https://ethresear.ch/t/proof-of-service-integrity-posi-trustless-measurement-of-service-integrity/20255","pubDate":"Sun, 11 Aug 2024 17:44:55 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20255"},"source":{"@url":"https://ethresear.ch/t/proof-of-service-integrity-posi-trustless-measurement-of-service-integrity/20255.rss","#text":"Proof of Service Integrity (PoSI): Trustless measurement of service integrity"}},{"title":"Efficient Data Distribution with Reed-Solomon Codes for Sharded Storage","dc:creator":"snjax","category":"ZK Rollup","description":"<h2><a name=\"p-49526-introduction-1\" class=\"anchor\" href=\"https://ethresear.ch#p-49526-introduction-1\"></a>Introduction</h2>\n<p>This writeup presents an efficient method for distributing N data elements across n nodes using Reed-Solomon (RS) encoding, specifically designed for blockchain <a href=\"https://ethresear.ch/t/blockchain-sharded-storage-web2-costs-and-web3-security-with-shamir-secret-sharing/18881\">sharded storage</a> solutions. We address the challenge of scaling blockchain storage by introducing techniques that achieve O(N log n) decoding complexity, where N is the total amount of data and n is the number of nodes.</p>\n<p>A naive approach would be to simply blow up the data from N to bN, where b is the blowup factor. However, this would result in O(N log N) decoding complexity. Our method, by representing data as a table and creating data shards, achieves O(N log n) decoding complexity, which is significantly faster.</p>\n<p>It’s crucial to note that we don’t need to apply RS codes to all data together. This is because a node can only go offline as a whole - there can’t be a situation where two nodes lose half of their data each, requiring RS codes to recover the data. A node either loses all its data or provides it entirely.</p>\n<p>While our method doesn’t significantly improve the speed of calculating polynomial commitments (which remains O(N log N) for FRI), it greatly optimizes the data encoding-decoding procedure.</p>\n<h3><a name=\"p-49526-naive-approach-2\" class=\"anchor\" href=\"https://ethresear.ch#p-49526-naive-approach-2\"></a>Naive approach</h3>\n<p><img src=\"https://ethresear.ch/uploads/default/original/3X/6/9/691031aaa0990298d3f1755f55e1cc286cb49197.svg\" alt=\"\" data-base62-sha1=\"eZqPs9a40I3bVsvwbBOzjLaDker\" role=\"presentation\" width=\"600\" height=\"150\"></p>\n<h3><a name=\"p-49526-our-approach-3\" class=\"anchor\" href=\"https://ethresear.ch#p-49526-our-approach-3\"></a>Our approach</h3>\n<p><img src=\"https://ethresear.ch/uploads/default/original/3X/6/a/6a6eea46c44a4be6f7311ec8edbab96cf8f81cd0.svg\" alt=\"\" data-base62-sha1=\"fbyfhphCEh9idtAFNcOR36DdiFi\" role=\"presentation\" width=\"600\" height=\"240\"></p>\n<h2><a name=\"p-49526-notation-and-definitions-4\" class=\"anchor\" href=\"https://ethresear.ch#p-49526-notation-and-definitions-4\"></a>Notation and Definitions</h2>\n<p>Before proceeding with the detailed description of our method, let’s define the key terms and symbols used throughout this writeup:</p>\n<ul>\n<li>N: Total amount of data elements</li>\n<li>n: Number of nodes in the network</li>\n<li>k: Minimum number of nodes required to recover the original data</li>\n<li>b: Blowup factor, defined as b = n/k</li>\n<li>m: Number of rows in the data table representation</li>\n</ul>\n<h2><a name=\"p-49526-h-2-adicity-fields-case-5\" class=\"anchor\" href=\"https://ethresear.ch#p-49526-h-2-adicity-fields-case-5\"></a>2-Adicity Fields Case</h2>\n<p>We consider a 2-adic prime field, specifically the BabyBear field with prime p = 15 * 2^27 + 1.</p>\n<p>Let’s consider we have a vector <span class=\"math\">{a_i}</span> of N elements of field <span class=\"math\">F_p</span>. We want to distribute this vector among n servers, such that any k servers can recover the original vector. We use Reed-Solomon codes to achieve this.</p>\n<p>We represent the vector <span class=\"math\">{a_i}</span> as a table <span class=\"math\">{a_{ij}}</span> of size <span class=\"math\">m \\times k</span> with <span class=\"math\">m</span> rows and <span class=\"math\">k</span> columns.</p>\n<p>We define a bivariate polynomial <span class=\"math\">f(x,y)</span> to represent our data:</p>\n<p><span class=\"math\">f(x,y) = \\sum\\limits_{ij} a_{ij} L_i(x) \\lambda_j(y)</span></p>\n<p>where <span class=\"math\">L_i(x)</span> is a Lagrange polynomial of degree <span class=\"math\">m-1</span> and <span class=\"math\">\\lambda_j(y)</span> is a Lagrange polynomial of degree <span class=\"math\">k-1</span>.</p>\n<p>After performing FFT over each row of the table, <span class=\"math\">f(x,y)</span> takes the following form:</p>\n<p><span class=\"math\">f(x,y) = \\sum\\limits_{ij} b_{ij} L_i(x) y^j = \\sum\\limits_{j} f_j(x) y^j</span></p>\n<p>where <span class=\"math\">f_j(x)=\\sum\\limits_{i} b_{ij} L_i(x)</span> is a polynomial of degree <span class=\"math\">m-1</span>.</p>\n<p>Each node should receive a unique linear combination of the columns of the table. Then we can recover the original vector by solving a system of linear equations. Let’s represent the data shard as <span class=\"math\">f(x,y_0)</span>, where <span class=\"math\">y_0</span> is a fixed value for each shard.</p>\n<p><span class=\"math\">f(x,y) - f(x,y_0) = \\sum\\limits_{j} (y^j - y_0^j) f_j(x) = (y-y_0) q(x,y)</span></p>\n<p>where <span class=\"math\">q(x,y)</span> is a quotient polynomial.</p>\n<p>We make the substitution <span class=\"math\">y=x^m</span> without loss of any inner polynomial structure. This substitution effectively concatenates all columns of the table, one after another, which is convenient for creating a polynomial commitment.</p>\n<p>After the substitution, we get the following polynomial equation to check that the shard is a valid part of the original data:</p>\n<p><span class=\"math\"> f(x,x^m) - f(x, y_0) = (x^m - y_0) q(x,x^m) </span></p>\n<h2><a name=\"p-49526-circle-fields-case-6\" class=\"anchor\" href=\"https://ethresear.ch#p-49526-circle-fields-case-6\"></a>Circle Fields Case</h2>\n<p>We now consider the M31 field with p = 2^32 - 1. [HLP24] proposed a method called CFFT (Circular Fast Fourier Transform), which is analogous to FFT but works with polynomials defined on a complex circle.</p>\n<p>In the circle representation, the polynomial takes the form <span class=\"math\">f(x,y)=\\Re(f(z))</span>, where <span class=\"math\">|z|=1</span>.</p>\n<p>Due to the circle constraint <span class=\"math\">|z|^2 = x^2 + y^2 = 1</span>, the polynomial can be represented as:</p>\n<p><span class=\"math\">f(x,y) = f_0(x) + y f_1(x)</span></p>\n<p>where <span class=\"math\">f_0(x)</span> and <span class=\"math\">f_1(x)</span> are polynomials of degree <span class=\"math\">N/2-1</span>. Note that we have two polynomials of this degree, providing sufficient degrees of freedom.</p>\n<p>Let’s represent the data vector <span class=\"math\">{a_i}</span> as a table <span class=\"math\">{a_{ij}}</span> of size <span class=\"math\">m \\times k</span> with <span class=\"math\">m</span> rows and <span class=\"math\">k</span> columns. We perform circle FFT (CFFT) on each row of the table, resulting in <span class=\"math\">m</span> vectors of size <span class=\"math\">n</span>.</p>\n<p><span class=\"math\">f(x,y,u,v) = \\sum\\limits_{ij} a_{ij} L_i(x,y) \\lambda_j(u,v)</span></p>\n<p>It’s important to note that the function <span class=\"math\">f(x,y,u,v)</span> is defined on a torus: <span class=\"math\">x^2+y^2=1</span>, <span class=\"math\">u^2+v^2=1</span>.</p>\n<p>Let’s consider <span class=\"math\">f(x,y,u,v)</span> as <span class=\"math\">v</span>-even function. This approach is not useful directly for SNARKs, because then we have even constraint on function values and next row could be dependent on the previous one. However, it’s useful for data distribution.</p>\n<p>Then</p>\n<p><span class=\"math\">f(x,y,u,v) = f(x,y,u) = \\sum\\limits_{ij} a_{ij} L_i(x,y) \\Lambda_j(u) </span>,<br>\nwhere <span class=\"math\">\\Lambda_j(u)</span> is even Lagrange basis on the circle.</p>\n<p>After applying CFFT over each row, we get:</p>\n<p><span class=\"math\">f(x,y,u) = \\sum\\limits_{ij} b_{ij} L_i(x,y) u^j = \\sum\\limits_{j} f_j(x,y) u^j</span></p>\n<p>where <span class=\"math\">f_j(x,y)=\\sum\\limits_{i} b_{i} L_i(x,y)=f_{j,0}(x) + y f_{j,1}(x)</span> and each polynomial is <span class=\"math\">(m/2-1)</span>-ordered.</p>\n<p>Let’s consider <span class=\"math\">f(x,y,u_0)</span> as a data shard, where <span class=\"math\">u_0</span> is a fixed value for each shard.</p>\n<p><span class=\"math\">f(x,y,u) - f(x,y,u_0) = \\sum\\limits_{j} (u^j - u_0^j) f_j(x,y) = (u-u_0) q(x,y,u)</span></p>\n<p>where <span class=\"math\">q(x,y,u)</span> is a quotient polynomial.</p>\n<p>We make the substitution <span class=\"math\">u=x^{m/2}</span> in <span class=\"math\">f(x,y,u)</span>. This substitution does not result in information loss because <span class=\"math\">f_j(x,y)=f_{j,0}(x) + y f_{j,1}(x)</span>, where the degrees of <span class=\"math\">f_{j,0}(x)</span> and <span class=\"math\">f_{j,1}(x)</span> are <span class=\"math\">m/2-1</span>. The resulting polynomial <span class=\"math\">f(x,y,x^{m/2})</span> maintains the structure <span class=\"math\">f_0(x) + y f_1(x)</span> and remains defined on a circle, albeit with each one-dimensional component now of degree <span class=\"math\">N/2-1</span>. This substitution effectively concatenates all columns of the table, similar to the 2-adicity case.</p>\n<p>After the substitution, we get the following polynomial equation to check that the shard is a valid part of the original data:</p>\n<p><span class=\"math\">f(x,y,x^{m/2}) - f(x,y,u_0) = (x^{m/2}-u_0)q(x,y,x^{m/2})</span></p>\n<h2><a name=\"p-49526-applications-7\" class=\"anchor\" href=\"https://ethresear.ch#p-49526-applications-7\"></a>Applications</h2>\n<h3><a name=\"p-49526-recovering-the-source-data-8\" class=\"anchor\" href=\"https://ethresear.ch#p-49526-recovering-the-source-data-8\"></a>Recovering the source data</h3>\n<p>Any <span class=\"math\">k</span> shards are enough to recover the original data.</p>\n<p><span class=\"math\">f(x,y,u) = \\sum\\limits_{j} c_{ij} L_i(x,y) \\mu(u),</span></p>\n<p>where <span class=\"math\">\\{\\mu_i(u)\\}</span> is a Lagrange polynomial basis on the evaluation domain <span class=\"math\">H=\\{u_i\\}</span>, and <span class=\"math\">u_i</span> are fixed values for each shard.</p>\n<p><span class=\"math\"> \\mu_i(u) = d_i Z_{H}(u)/(u-u_i),</span><br>\nwhere <span class=\"math\">Z_{H}(u)</span> is a polynomial that is zero at all points of <span class=\"math\">H</span>, <span class=\"math\">d_i</span> is a normalization factor, so</p>\n<p><span class=\"math\"> \\mu_i(u) = \\begin{cases}\n1, &amp; u = u_i \\\\\n0 &amp; u \\neq u_i\n\\end{cases}\n</span></p>\n<p>The source values could be computed as<br>\n<span class=\"math\">a_{ij} = f(g^i.x, g^i.y, h^j.x)</span></p>\n<h3><a name=\"p-49526-polynomial-storing-9\" class=\"anchor\" href=\"https://ethresear.ch#p-49526-polynomial-storing-9\"></a>Polynomial storing</h3>\n<p>In some cases, we want to store something directly related to the polynomial commitment of <span class=\"math\">f</span> instead of <span class=\"math\">a_{ij}</span>. This is important for zk applications, like rollups.</p>\n<p>Due to the inner structure of coefficient representation, we can represent <span class=\"math\">g(x,y)</span> as <span class=\"math\">f(x,y,x^{m/2})</span>. That means that we can store rollup block data as a set of shards, keeping the source polynomial structure, keeping the source commitment. Then <span class=\"math\">a_{ij}</span> will be some kind of intermediate representation of the committed data.</p>\n<h2><a name=\"p-49526-algorithm-description-10\" class=\"anchor\" href=\"https://ethresear.ch#p-49526-algorithm-description-10\"></a>Algorithm description</h2>\n<pre data-code-wrap=\"python\"><code class=\"lang-python\">\ndef get_shards_and_commitments(data: List[M31], m:int, n:int, k:int, cd:Domain, rd:Domain, xrd:Domain)\n    # data is a list of N elements\n    # m is the number of rows in the table\n    # n is the number of nodes\n    # k is the number of nodes required to recover the original data\n    # cd is the evaluation domain for the columns\n    # rd is the evaluation domain for the rows\n    # xrd is evaluation domain for the shards (blown up rows)\n    # Returns polynomial commitments and prover data for all the data and shards\n    \n    # create a table of size m x k, fulfilled row by row\n    table = create_table(data, m, k)\n    \n    # perform cfft on each row of the table\n    for row in table:\n        row[:] = cfft(row, rd)\n    \n    # create shards\n    shards = [icfft(fit_to_domain_with_zeros(row, rd, xrd), xrd) for row in table]\n    \n    # convert to col-ordered table\n    shards = to_col_ordered(shards)\n\n    # convert table to col_ordered\n    table = to_col_ordered(table)\n\n    # compute monomial representation of $f(x,y,x^{m/2})$\n    f = concat([cfft(col, cd) for col in table])\n\n    return pcs_monomial_repr(f), [pcs(shard) for shard in shards]\n\n</code></pre>\n<h2><a name=\"p-49526-distributing-the-data-over-a-cluster-of-nodes-11\" class=\"anchor\" href=\"https://ethresear.ch#p-49526-distributing-the-data-over-a-cluster-of-nodes-11\"></a>Distributing the data over a cluster of nodes</h2>\n<p>In practice, the client should deliver the data to <span class=\"math\">n</span> nodes, and the total amount of data is <span class=\"math\">bN</span>. However, for big files, it could be inefficient due to the client’s limited bandwidth.</p>\n<p>Instead of this client-centralized approach, <span class=\"math\">b</span> nodes could deliver <span class=\"math\">N \\cdot (1-1/k)</span> total data to <span class=\"math\">k-1</span> nodes. There is no bottleneck at the client side (the client sends just <span class=\"math\">N</span> data to one node), but total network data bandwidth is <span class=\"math\">b N \\cdot (2-1/k) \\approx 2bN</span>.</p>\n<p><img src=\"https://ethresear.ch/uploads/default/original/3X/3/b/3be891968cd29eb75294d6219b0d063ddb3bb8f2.svg\" alt=\"\" data-base62-sha1=\"8xYrHU7QvO5070y1umvRyJ6kB9g\" role=\"presentation\" width=\"195\" height=\"493\"></p>\n<p>There is no valuable computational overhead to compute the shards vectors because with fft or cfft each node can perform a unique coset shift instead of blowup (and the sum of all shifted evaluation domains is the evaluation domain for the blowup).</p>\n<p><img src=\"https://ethresear.ch/uploads/default/original/3X/2/0/2015d84ea59b9b3aea04f0aa12ff6cc33087367f.svg\" alt=\"\" data-base62-sha1=\"4zQ53Q3ojMbyUkZQDmigfqHZ5BJ\" role=\"presentation\" width=\"340\" height=\"250\"></p>\n<h2><a name=\"p-49526-conclusion-12\" class=\"anchor\" href=\"https://ethresear.ch#p-49526-conclusion-12\"></a>Conclusion</h2>\n<p>We have extended our method of data representation to the M31 field, providing a robust framework for efficient data distribution in blockchain storage. By representing data as a table and using FFT/CFFT techniques, we achieve O(N log n) decoding complexity, significantly optimizing the data encoding-decoding procedure. This approach is particularly valuable in blockchain systems where nodes can only fail as a whole, and efficient data recovery is crucial.</p>\n<p>While the complexity of polynomial commitment calculations remains O(N log N) for FRI, our method provides substantial benefits in the overall data handling process, making it a promising solution for scalable blockchain storage.</p>\n<h2><a name=\"p-49526-references-13\" class=\"anchor\" href=\"https://ethresear.ch#p-49526-references-13\"></a>References</h2>\n<p><a href=\"https://eprint.iacr.org/2024/278\" rel=\"noopener nofollow ugc\">HLP24</a></p>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://ethresear.ch/t/efficient-data-distribution-with-reed-solomon-codes-for-sharded-storage/20232\">Read full topic</a></p>","link":"https://ethresear.ch/t/efficient-data-distribution-with-reed-solomon-codes-for-sharded-storage/20232","pubDate":"Wed, 07 Aug 2024 22:32:41 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20232"},"source":{"@url":"https://ethresear.ch/t/efficient-data-distribution-with-reed-solomon-codes-for-sharded-storage/20232.rss","#text":"Efficient Data Distribution with Reed-Solomon Codes for Sharded Storage"}},{"title":"Aligning DAO contributions with objectives","dc:creator":"lajarre","category":"Economics","description":"<h1><a name=\"aligning-dao-contributions-with-objectives-1\" class=\"anchor\" href=\"https://ethresear.ch#aligning-dao-contributions-with-objectives-1\"></a>Aligning DAO contributions with objectives</h1>\n<p>In this post, we’re approaching how to align DAO contributions in a setting where a clear goal is already defined.</p>\n<p>We will define an Objective Alignment Engine (OAE) as a class of mechanisms that fulfill this objective. We aim to define the contour of such mechanisms so that they optimize resource allocation and provide economic guarantees on the efficacy of incentives.</p>\n<p><em>A more complete description along with more concrete examples is available at <a href=\"https://www.notion.so/r-ag-oae-Objective-Alignment-Engine-6984df3b33cc468e85264a9b975437eb?pvs=21\" rel=\"noopener nofollow ugc\">[r.ag.oae] Objective Alignment Engine</a>.</em></p>\n<h2><a name=\"motivation-2\" class=\"anchor\" href=\"https://ethresear.ch#motivation-2\"></a>Motivation</h2>\n<p>Suppose a DAO where governance contributors are compensated based on a simple rule, like “the top 10 delegates by total votes delegates are paid $10k / month”. As protocol designers, this sounds suboptimal as we have no guarantees that the treasury is spent on the delegates who produce the most useful contributions to governance (e.g. produce the most complete proposals, or vote most consistently). Also, any such rules-based process inevitably becomes gameable under <a href=\"https://en.wikipedia.org/wiki/Goodhart%27s_law\" rel=\"noopener nofollow ugc\">Goodhart’s law</a>.</p>\n<p>We’d prefer that contributions were picked individually and reward contributors based on how aligned these contributions are with the overarching goals of the network (e.g., how much are such contributions participating in growth? or decentralization?).</p>\n<p>Importantly, we’d also prefer that there is an objective notion of alignment, enabling a mechanism that relies not only on individual preferences but as much as possible on eliciting information (as suggested in <a href=\"https://ethresear.ch/t/governance-mixing-auctions-and-futarchy/10772\">this post on mixing auctions and futarchy</a>).</p>\n<h2><a name=\"background-3\" class=\"anchor\" href=\"https://ethresear.ch#background-3\"></a>Background</h2>\n<p>On-chain protocols often struggle to align contributor incentives with network goals. While blockchains are designed to optimize resource spending for security, producing alignment with agreed-upon goals is typically left to external governance systems. OAE mechanisms bring contributions and incentives within the purview of the protocol designer.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/c/c/cc4f46fea1dfde8237a19aac23844864e00fd24f.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/cc4f46fea1dfde8237a19aac23844864e00fd24f\" title=\"image\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/c/c/cc4f46fea1dfde8237a19aac23844864e00fd24f_2_690x389.jpeg\" alt=\"image\" data-base62-sha1=\"t9pfNEuGQSnrmwbAWB8K12AvcAv\" width=\"690\" height=\"389\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/c/c/cc4f46fea1dfde8237a19aac23844864e00fd24f_2_690x389.jpeg, https://ethresear.ch/uploads/default/optimized/3X/c/c/cc4f46fea1dfde8237a19aac23844864e00fd24f_2_1035x583.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/c/c/cc4f46fea1dfde8237a19aac23844864e00fd24f_2_1380x778.jpeg 2x\" data-dominant-color=\"33332F\"></a></div><p></p>\n<p>This approach aligns with the “skin in the game” and futarchy-like solutions suggested in <a href=\"https://vitalik.eth.limo/general/2021/08/16/voting3.html\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">Moving beyond coin voting governance</a>. We’ll rely on the notion that there is a jury that is incentivized to produce a good judgment of whether contributions are aligned and scale this with additional mechanisms.</p>\n<h2><a name=\"assumptions-objective-definition-4\" class=\"anchor\" href=\"https://ethresear.ch#assumptions-objective-definition-4\"></a>Assumptions: objective definition</h2>\n<p>A central assumption that we take is that the DAO has a clearly defined objective. While this is theoretically difficult to achieve in a decentralized setting, most protocol values and visions are set initially by the core team and steered by a Foundation.</p>\n<p>For example, Ethereum focuses today on <a href=\"https://ethereum.org/en/roadmap/vision/\" rel=\"noopener nofollow ugc\">Scalability, Security, and Sustainability</a>, whereas Optimism has the <a href=\"https://optimism.io/vision\" rel=\"noopener nofollow ugc\">Superchain vision</a>.</p>\n<p>In the rest of this post, we assume an existing process produces a clear definition of an objective <span class=\"math\">o</span> (hence, the <em>Objective</em> part of the Alignment Engine).</p>\n<p>The existence of such an objective enables designing mechanisms that rely only on eliciting information from participants, namely whether a contribution is aligned or not with the objective.</p>\n<h2><a name=\"alignment-engine-5\" class=\"anchor\" href=\"https://ethresear.ch#alignment-engine-5\"></a>Alignment engine</h2>\n<h3><a name=\"jury-6\" class=\"anchor\" href=\"https://ethresear.ch#jury-6\"></a>Jury</h3>\n<p>Once an objective is defined, we want to set up a jury that can review any contribution and evaluate how aligned it is with the objective. This is the central part of this design.</p>\n<p>The main function of the jury is to produce ratings “aligned” / “misaligned” on contributions that are produced on the protocol.</p>\n<p>To produce alignment within the jury itself, we rely on mechanisms that incentivize truthful reporting but don’t rely on verifiable outcomes (like, BTC/USD quote). Possible such mechanisms are SchellingCoin or <a href=\"https://arxiv.org/abs/2306.04305\" rel=\"noopener nofollow ugc\">self-resolving prediction markets for unverifiable outcomes</a> (Srinivasan et al, 2023).</p>\n<p>To enable incentivization and notably negative rewards, we expect jurors to stake tokens ($ALIGN) and receive token emissions as rewards.</p>\n<h3><a name=\"dispute-resolution-7\" class=\"anchor\" href=\"https://ethresear.ch#dispute-resolution-7\"></a>Dispute resolution</h3>\n<p>Here we assume that most contributions can be unequivocally qualified as “aligned” or “misaligned” (ie there is a <em>clear</em> way to rate most contributions, as long as <span class=\"math\">o</span> is well defined).</p>\n<p>But equivocal cases will inevitably appear. When a contestable result is produced, a dispute resolution mechanism needs to be enforced (either an external one like a Kleros court or an Augur-style ALIGN token fork).</p>\n<h3><a name=\"calibration-8\" class=\"anchor\" href=\"https://ethresear.ch#calibration-8\"></a>Calibration</h3>\n<p>In general, a juror can be an agent making use of any tools available, including AI and prediction markets, to produce the best evaluations. But this leaves open the question of how to incentivize jurors to get better at their jobs so the jury doesn’t degenerate into a static committee.</p>\n<p>If part of the contributions have a ground truth to which their ratings can be compared (e.g. growth contributions that aim at increasing a key metric like TVL for a DeFi protocol or fees for an L2), jurors can be rewarded accordingly. This way, the mechanism can still leverage objective outcomes to improve its accuracy (or <em>be <a href=\"https://www.overcomingbias.com/p/meta-jury-markets\" rel=\"noopener nofollow ugc\">calibrated</a></em>).</p>\n<h3><a name=\"scaling-9\" class=\"anchor\" href=\"https://ethresear.ch#scaling-9\"></a>Scaling</h3>\n<p>Armed with such a jury, DAO contributions can theoretically be evaluated. To handle large numbers of contributions, two scaling options are available:</p>\n<ul>\n<li>Prediction markets: bettors predict jury decisions, creating “Aligned” and “Misaligned” tokens.</li>\n<li>Peer prediction: raters evaluate contributions, with a small percentage reviewed by the jury.</li>\n</ul>\n<p>Spam protection through staked curation or auctions ensures only valuable contributions are evaluated.</p>\n<h2><a name=\"rewards-distribution-10\" class=\"anchor\" href=\"https://ethresear.ch#rewards-distribution-10\"></a>Rewards distribution</h2>\n<p>With contribution evaluation in place, the last bit is to distribute contribution rewards to incentivize the most aligned contributions to be produced in the future.</p>\n<p>Aligned contributions receive rewards from treasury or token emissions, proportional to their alignment rating. Highly aligned contributions may be automatically implemented in proposal-like scenarios</p>\n<p>This produces a positive feedback loop where:</p>\n<ol>\n<li>Better-aligned contributions receive more rewards</li>\n<li>This incentivizes more aligned contributions in the future</li>\n<li>The protocol becomes more resistant to misaligned or captured governance over time.</li>\n</ol>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/7/e/7e67510d59620761b9c2941d8a4067b859bc6ebb.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/7e67510d59620761b9c2941d8a4067b859bc6ebb\" title=\"image\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/7/e/7e67510d59620761b9c2941d8a4067b859bc6ebb_2_543x500.jpeg\" alt=\"image\" data-base62-sha1=\"i2dvZRif0cghJQd24wAFAIaZ6Nd\" width=\"543\" height=\"500\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/7/e/7e67510d59620761b9c2941d8a4067b859bc6ebb_2_543x500.jpeg, https://ethresear.ch/uploads/default/optimized/3X/7/e/7e67510d59620761b9c2941d8a4067b859bc6ebb_2_814x750.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/7/e/7e67510d59620761b9c2941d8a4067b859bc6ebb_2_1086x1000.jpeg 2x\" data-dominant-color=\"32322E\"></a></div><p></p>\n<h2><a name=\"attacks-11\" class=\"anchor\" href=\"https://ethresear.ch#attacks-11\"></a>Attacks</h2>\n<p>Some potential limitations and related attacks include:</p>\n<ol>\n<li><strong>Equivocal objective definition.</strong> Attackers may exploit ambiguous objectives to reward misaligned contributions. This can be mitigated by updating the objective when the DAO observes that equivocation happens.</li>\n<li><strong>Jurors collusion and bribing.</strong> This can be countered with staking mechanisms, reputation systems, random juror selection, or shielded voting.</li>\n<li><strong>Peer prediction and prediction markets manipulation.</strong> Usual caveats and mitigations apply.</li>\n</ol>\n<h2><a name=\"questions-12\" class=\"anchor\" href=\"https://ethresear.ch#questions-12\"></a>Questions</h2>\n<p>Such OAE mechanisms rely on the existence of an objective <span class=\"math\">o</span>. We haven’t answered how such an objective can be defined in a general setting. There is an argument that leaving it to regular token-voting just pushes the problem around and the overall mechanism inherits some of the issues of both sub-mechanisms. However, it appears that splitting the problem in two has benefits, as, once an objective is defined, more deterministic outcomes can be achieved through mechanism design.</p>\n<p>Also, other kinds of mechanisms can be devised that rely on subjective evaluations. Including subjective evaluations might render objective definition superfluous. But relying on a jury whose jurors input their own preferences leaves the question open of how the jury achieves legitimacy. A solution would be to rely on a measure of juror reputation, as pioneered by Backfeed.</p>\n            <p><small>2 posts - 2 participants</small></p>\n            <p><a href=\"https://ethresear.ch/t/aligning-dao-contributions-with-objectives/20204\">Read full topic</a></p>","link":"https://ethresear.ch/t/aligning-dao-contributions-with-objectives/20204","pubDate":"Thu, 01 Aug 2024 23:46:47 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20204"},"source":{"@url":"https://ethresear.ch/t/aligning-dao-contributions-with-objectives/20204.rss","#text":"Aligning DAO contributions with objectives"}},{"title":"ShardDAG: Ordering and Exploitation in Sharded Blockchains","dc:creator":"JamesHenderson","category":"Sharding","description":"<p><em>This article was prepared by James A. Henderson from</em> <a href=\"https://nil.foundation/\" rel=\"noopener nofollow ugc\">=nil; Foundation</a></p>\n<h2><a name=\"tldr-1\" class=\"anchor\" href=\"https://ethresear.ch#tldr-1\"></a>tl;dr</h2>\n<p>Ethereum’s design has moved away from state sharding; however, L2 architectures like zkSharding provide a unified protocol in which L2 dApps are composable yet scalable via state sharding, avoiding the need for state fragmentation emerging across distinct L2s. However, sharded systems are not without challenges. In particular, state sharding amplifies MEV exploitation and censorship problems that exist in non-sharded blockchains.</p>\n<p>We propose a shardDAG architecture for state sharded blockchains or multi-chain systems, combining protocol rules, rewards and penalties that constrain transaction exploitation [<a href=\"https://arxiv.org/abs/1904.05234\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">[1904.05234] Flash Boys 2.0: Frontrunning, Transaction Reordering, and Consensus Instability in Decentralized Exchanges</a>] and external influences like regulatory censorship  [<a href=\"https://www.mevwatch.info/\" rel=\"noopener nofollow ugc\">https://www.mevwatch.info/</a>, <a href=\"https://home.treasury.gov/news/press-releases/jy0916\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">U.S. Treasury Sanctions Notorious Virtual Currency Mixer Tornado Cash | U.S. Department of the Treasury</a>]. Constraints on exploitation and censorship are achieved using a DAG architecture that links shard blocks to each other. The DAG provides an enforceable order in which cross-shard transactions must be processed by each shard, thereby constraining manipulation of transaction processing order.</p>\n<h2><a name=\"motivation-2\" class=\"anchor\" href=\"https://ethresear.ch#motivation-2\"></a>Motivation</h2>\n<p>State sharded blockchains inherit magnified MEV exploitation and censorship problems that exist in non-sharded blockchains because transaction completion can require block proposers in many distinct shards, and each block proposer could exploit or censor transactions. Further, more severe transaction exploits are possible via inserting other exploitative transactions in intermediate blocks that occur between starting and finishing transaction processing.</p>\n<p>To understand this, the example below demonstrates a simple exploit scenario.</p>\n<p><em><strong>Exploit Example</strong></em></p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/d/b/db208f14e2f3355a7d1d888bbc8b90e969102b97.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/db208f14e2f3355a7d1d888bbc8b90e969102b97\" title=\"BasicExploit\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/d/b/db208f14e2f3355a7d1d888bbc8b90e969102b97_2_690x445.jpeg\" alt=\"BasicExploit\" data-base62-sha1=\"vguk2i1o9S5mmhCMuXMDyExsNQb\" width=\"690\" height=\"445\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/d/b/db208f14e2f3355a7d1d888bbc8b90e969102b97_2_690x445.jpeg, https://ethresear.ch/uploads/default/optimized/3X/d/b/db208f14e2f3355a7d1d888bbc8b90e969102b97_2_1035x667.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/d/b/db208f14e2f3355a7d1d888bbc8b90e969102b97_2_1380x890.jpeg 2x\" data-dominant-color=\"4E4E4E\"></a></div><br>\nFigure 1: Two shard chains. Blocks 0 and 1 of shard <em>A</em> each contain cross-shard transactions <em>t</em> and <em>u</em>  respectively, whose destinations are shard <em>B</em>. Suppose <em>t</em> can be exploited if in shard <em>B</em> <em>u</em> is processed earlier than <em>t</em>. Then the system is dangerous for <em>t</em>’s user without enforceable ordering rules that ensure <em>t</em> must be processed before <em>u</em> in shard <em>B</em>.<p></p>\n<h2><a name=\"why-cross-shard-transaction-data-availability-matters-3\" class=\"anchor\" href=\"https://ethresear.ch#why-cross-shard-transaction-data-availability-matters-3\"></a>Why Cross-Shard Transaction Data Availability Matters</h2>\n<p>Punishment for censoring a cross-shard transaction (CST), or processing in an incorrect, exploitative order can only be enforced provided that</p>\n<p>i) It can be established that all the required data was available to the shard, and</p>\n<p>ii) The shard subsequently failed to process the data correctly.</p>\n<p>Therefore, a mechanism is required for establishing <em>verifiable</em> cross-shard (or cross-chain, or cross-rollup) transaction data availability. The broad steps in achieving this are illustrated in Fig. 2. Preventing exploitation requires enforceable rules for ordering the processing of transactions and CSTs; however, enforcing processing order requires that each shard receives the CSTs that it is required to process. To be able to receive CSTs, that CST data must be available. Thus, constraining exploitation rests upon ensuring CST data availability.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/7/b/7bee56e632f92d068ac45ccb5bf63a201b085725.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/7bee56e632f92d068ac45ccb5bf63a201b085725\" title=\"ShardDAG StrategySteps\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/7/b/7bee56e632f92d068ac45ccb5bf63a201b085725_2_690x154.jpeg\" alt=\"ShardDAG StrategySteps\" data-base62-sha1=\"hGlmRB3Rv32vxqCpxC8FzlMm0lv\" width=\"690\" height=\"154\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/7/b/7bee56e632f92d068ac45ccb5bf63a201b085725_2_690x154.jpeg, https://ethresear.ch/uploads/default/optimized/3X/7/b/7bee56e632f92d068ac45ccb5bf63a201b085725_2_1035x231.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/7/b/7bee56e632f92d068ac45ccb5bf63a201b085725_2_1380x308.jpeg 2x\" data-dominant-color=\"5C5C5C\"></a></div><br>\nFigure 2: Goal: ShardDAG ordering aims to constrain manipulation, exploitation and censorship of transactions and cross-shard transactions. Step 3: These constraints require enforceable protocol rules for ordering the processing of transactions and cross-shard transactions. Step 2: Fairly enforcing ordering rules requires on-chain acknowledgement of receipt of cross-shard transactions. Step 1: Receipt of cross-shard transactions requires cross-shard transaction data availability.<p></p>\n<h2><a name=\"step-3-a-preview-how-dags-provide-order-4\" class=\"anchor\" href=\"https://ethresear.ch#step-3-a-preview-how-dags-provide-order-4\"></a>Step 3. A Preview: How DAGs Provide Order</h2>\n<p>Our solution to the transaction and cross-shard transaction ordering problem involves linking shard chains into a shard directed acyclic graph or shardDAG, and then ordering processing according to the partial order specified within shard block subgraphs.</p>\n<p>ShardDAG ordering is previewed in Fig. 3. The distinct shard chains are connected to form a shardDAG, providing an enforceable ordering of cross-shard transactions amongst the shard chains. Unlike in Fig. 1, in Fig. 3’s shardDAG, an exploitative CST in a later block cannot be processed before a CST in an earlier block.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/4/8/48bb4910acfa00365d8e0b97b45be64b0e32e732.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/48bb4910acfa00365d8e0b97b45be64b0e32e732\" title=\"ShardDAG NonOverloaded Ordering\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/4/8/48bb4910acfa00365d8e0b97b45be64b0e32e732_2_193x500.jpeg\" alt=\"ShardDAG NonOverloaded Ordering\" data-base62-sha1=\"anpDmZETjVUw8C8k2cvC2lRyo2S\" width=\"193\" height=\"500\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/4/8/48bb4910acfa00365d8e0b97b45be64b0e32e732_2_193x500.jpeg, https://ethresear.ch/uploads/default/optimized/3X/4/8/48bb4910acfa00365d8e0b97b45be64b0e32e732_2_289x750.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/4/8/48bb4910acfa00365d8e0b97b45be64b0e32e732_2_386x1000.jpeg 2x\" data-dominant-color=\"3F423A\"></a></div><br>\nFigure 3: Unlike the distinct shard chains in Fig. 1, the shardDAG (top) depicted here defines a partial ordering of shard blocks that fall under any particular block (here shard B block 2) and the cross-shard transactions that the blocks contain. (Middle) A Hasse diagram can be constructed to visualise a partial ordering of the shard blocks (for clarity lines connecting blocks have not been included). The shardDAG is topologically sorted (bottom) to produce a block containing an ordered set of transactions and CSTs. In general many topological sorts are possible, the block builder selects one, likely based on MEV.<p></p>\n<h2><a name=\"a-sharddag-for-data-availability-5\" class=\"anchor\" href=\"https://ethresear.ch#a-sharddag-for-data-availability-5\"></a>A ShardDAG for Data Availability</h2>\n<p>To establish cross-shard transaction data availability, the simple set of shard chains in Fig. 1 is extended to become a shardDAG that is crafted to incentivize data sharing. In this system all validators participate in a synchronization chain which aggregates and finalises state updates from shards that are each operated by distinct subsets of the total validator set. Transaction and CST processing is performed within shards only, hence the synchronization chain is not a processing bottleneck. Here the details of the synchronization chain are restricted to its involvement in the shardDAG—the broader function of the synchronization chain in the sharded system is beyond the scope of this post.</p>\n<p>To form a shardDAG, shard blocks include links to other shard blocks in the form of:</p>\n<ul>\n<li><strong>a hash to the previous shard block in the same shard, as in a typical blockchain,</strong></li>\n<li><strong>a set of hashes to other shards blocks in other shards,</strong></li>\n<li><strong>a hash to a (valid) synchronization block, equal to or later than the most recent synchronization block already used by prior shard blocks that are included in the subgraph.</strong></li>\n</ul>\n<p>The formation of a shardDAG is illustrated in Fig. 4, where for clarity only edges in the subgraph of the white block are shown. The thick arrows are the white block’s hashes to other blocks.</p>\n<p>The following is a central concept in the function of the shardDAG.</p>\n<p><strong>When a shard <span class=\"math\">A</span> creates a shard block that includes the hash <span class=\"math\">h</span> of another shard block or synchronization block, this inclusion acts as an acknowledgement that shard <span class=\"math\">A</span> has received the block headers and outboxes of cross-shard transactions for <span class=\"math\">h</span> and <span class=\"math\">h</span><em>’s</em> entire subgraph in the shardDAG.</strong></p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/b/2/b2ba419c59a01907d08a616eb2b464634114c1d3.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/b2ba419c59a01907d08a616eb2b464634114c1d3\" title=\"SubGraphLowDetail\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/b/2/b2ba419c59a01907d08a616eb2b464634114c1d3_2_690x469.jpeg\" alt=\"SubGraphLowDetail\" data-base62-sha1=\"pv62BsYMnjDFdt1gNae1HRBjMA3\" width=\"690\" height=\"469\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/b/2/b2ba419c59a01907d08a616eb2b464634114c1d3_2_690x469.jpeg, https://ethresear.ch/uploads/default/optimized/3X/b/2/b2ba419c59a01907d08a616eb2b464634114c1d3_2_1035x703.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/b/2/b2ba419c59a01907d08a616eb2b464634114c1d3_2_1380x938.jpeg 2x\" data-dominant-color=\"383838\"></a></div><br>\nFigure 4: Illustration of the white block’s subgraph in the shard DAG. The white block’s header contains a list of hashes to other shard blocks (thick white arrows), and well as a single hash to a synchronization block (thick grey arrow). Thin grey edges trace the subgraph of the white block, beyond the blocks explicitly included in its header.<p></p>\n<h2><a name=\"step-2-enforcing-cst-receipt-6\" class=\"anchor\" href=\"https://ethresear.ch#step-2-enforcing-cst-receipt-6\"></a>Step 2. Enforcing CST Receipt</h2>\n<h3><a name=\"enforcing-cst-receipt-via-shard-chains-7\" class=\"anchor\" href=\"https://ethresear.ch#enforcing-cst-receipt-via-shard-chains-7\"></a>Enforcing CST Receipt via Shard Chains</h3>\n<p>To enforce shards to continually acknowledge receipt of new shard block data, the protocol specifies conditions on block validity. Suppose we have a shard block <span class=\"math\">b_i</span> and <span class=\"math\">b_i</span><em>’s</em> prior shard block <span class=\"math\">b_{i-1}</span> in the same shard as <span class=\"math\">b_i</span>.</p>\n<ul>\n<li><strong>[PARENT CONDITION]: For <span class=\"math\">b_i</span> to be a valid shard block, the graph difference of <span class=\"math\">b_i</span><em>’s</em> subgraph minus <span class=\"math\">b_{i-1}</span><em>’s</em> subgraph must contain shard blocks created by more than <span class=\"math\">F&gt;1</span> shards, where <span class=\"math\">F</span> is a system parameter controlling the branching of the DAG.</strong></li>\n</ul>\n<p><em>Example:</em></p>\n<p><em>In Fig. 4, the subgraph of the white shard A block only contains two blocks that are not in the subgraph of the previous shard A block, i.e. the white block itself, and the middle shard B block. If in this example F=1, then the white block is valid; however, if F&gt;1 then the white block is invalid.</em></p>\n<h3><a name=\"enforcing-cst-receipt-via-the-synchronization-chain-8\" class=\"anchor\" href=\"https://ethresear.ch#enforcing-cst-receipt-via-the-synchronization-chain-8\"></a>Enforcing CST Receipt Via the Synchronization Chain</h3>\n<p>The parent condition enforces receipt of CSTs, but does not guarantee that each CST reaches its destination so that transactions complete. Without additional rules it is possible (though unlikely) for sets of shards to create shard blocks whose subgraphs do not span all shards and therefore do not acknowledge receipt of CSTs from all shards, as illustrated in Fig. 6.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/c/9/c95bce910ccff1c8dbd9ffbaa913b546c5db043d.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/c95bce910ccff1c8dbd9ffbaa913b546c5db043d\" title=\"consensusParentCondition\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/c/9/c95bce910ccff1c8dbd9ffbaa913b546c5db043d_2_690x444.jpeg\" alt=\"consensusParentCondition\" data-base62-sha1=\"sJiFlI0Hn0xlOFVQMTnxxXf2x1X\" width=\"690\" height=\"444\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/c/9/c95bce910ccff1c8dbd9ffbaa913b546c5db043d_2_690x444.jpeg, https://ethresear.ch/uploads/default/optimized/3X/c/9/c95bce910ccff1c8dbd9ffbaa913b546c5db043d_2_1035x666.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/c/9/c95bce910ccff1c8dbd9ffbaa913b546c5db043d_2_1380x888.jpeg 2x\" data-dominant-color=\"444343\"></a></div><br>\nFigure 6: Despite the parent condition for valid shard blocks, it is possible (though unlikely) for shard subgraphs to not acknowledge receipt of CSTs from some other shards via shard block edges, indicated by the vertical dashed line. However, the synchronization parent condition eventually forces all shards to acknowledge all CSTs via synchronization block edges. Here the synchronization parent condition forces shard 4 to acknowledge receipt of the red CST (via the red edges) and therefore process it, because the dashed blue edge exceeds the limit (here <em>S</em>=2) of consecutive synchronization block hashes. For clarity only the subset of synchronization blocks edges that are relevant to illustrating the above point are shown.<p></p>\n<p>This is unlikely to occur in the shardDAG; however, the synchronization chain is used to ensure that it <em>cannot</em> occur via a further block validity condition:</p>\n<ul>\n<li><strong>[SYNCHRONIZATION PARENT CONDITION]: A valid shard block <em>b</em> cannot have more than <span class=\"math\">S</span> prior blocks from the same shard using the same synchronization block hash.</strong></li>\n</ul>\n<p>The value of <span class=\"math\">S</span> should be chosen depending on the ratio of rates of synchronization block to shard block creation. It is expected that synchronization blocks will be produced at a slower rate compared to shard blocks.</p>\n<p>A malicious shard can only produce <span class=\"math\">S</span> shard blocks before being forced to acknowledge receipt of new shard blocks via the synchronization chain. In Fig. 5, the red CST shard block will eventually be included in a synchronization block, in a worst case scenario waiting until a shard 1 validator becomes the synchronization block proposer. Thus, eventually all shards will acknowledge receiving the red CST, including the red CST’s destination shard, as indicated by the red arrows. The dashed blue arrow indicates that shard 4 block 3 would be invalid if it used this hash because more than <span class=\"math\">S</span> (here 2) consecutive shard blocks would hash to the same synchronization block.</p>\n<p>In this way, economically motivated validators (and especially synchronization block proposers) are motivated to share data so that finality can be reached and economic rewards can be distributed.</p>\n<h2><a name=\"step-1-enforcing-cst-data-availability-via-dag-edges-between-shards-9\" class=\"anchor\" href=\"https://ethresear.ch#step-1-enforcing-cst-data-availability-via-dag-edges-between-shards-9\"></a>Step 1. Enforcing CST Data Availability Via DAG Edges Between Shards</h2>\n<p>While the parent, and synchronization parent conditions force shards to acknowledge receipt of data, these rules do not force shards to <em>distribute</em> shard block data and establish data availability. Thus, the protocol specifies a rule on shard block finality to align data availability with economic incentives.</p>\n<ul>\n<li><strong>[CHILD CONDITION]: For a shard block <span class=\"math\">b</span> to be finalised within the synchronization chain, within the subgraph of any synchronization block, <span class=\"math\">b</span> must have child shard blocks created by more than <span class=\"math\">F</span> shards.</strong></li>\n</ul>\n<p>When a block satisfies the child condition its CSTs have been acknowledged as received by more than <em>F</em> other shards and the shard has therefore distributed its CST data.</p>\n<p>The child condition is illustrated in Fig. 5. For a shard block to acquire child shard blocks, other (honest) shards must first receive its subgraph data. Thus, shards are economically incentivised to possess and distribute data in their subgraphs.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/1/b/1b0c569adc1421ca246f774a9b776cda2aaa6465.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/1b0c569adc1421ca246f774a9b776cda2aaa6465\" title=\"ChildConditionEthREsearch\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/1/b/1b0c569adc1421ca246f774a9b776cda2aaa6465_2_688x500.jpeg\" alt=\"ChildConditionEthREsearch\" data-base62-sha1=\"3RhkeDD46aGIjVlhSUgVjmt1D25\" width=\"688\" height=\"500\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/1/b/1b0c569adc1421ca246f774a9b776cda2aaa6465_2_688x500.jpeg, https://ethresear.ch/uploads/default/optimized/3X/1/b/1b0c569adc1421ca246f774a9b776cda2aaa6465_2_1032x750.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/1/b/1b0c569adc1421ca246f774a9b776cda2aaa6465_2_1376x1000.jpeg 2x\" data-dominant-color=\"353535\"></a></div><br>\nFigure 5: Illustration of the child condition for the subgraph of the upper left synchronization block. In this example <em>F</em>=2. The white block in finalised because it has child shard blocks from three shards, indicated by thick white arrows. In contrast, the bottom right shard block is not finalised because it only has one child shard block indicated by the thick grey arrow.<p></p>\n<h2><a name=\"step-3-an-enforceable-dag-partial-order-of-transaction-and-cst-processing-10\" class=\"anchor\" href=\"https://ethresear.ch#step-3-an-enforceable-dag-partial-order-of-transaction-and-cst-processing-10\"></a>Step 3. An Enforceable DAG Partial Order of Transaction and CST Processing</h2>\n<p>The shardDAG provides a verifiable, enforceable ordering of transactions and CSTs, which constrains exploits and guarantees (eventual) transaction processing. Transactions and cross-shard transactions must be processed in an order consistent with the partial order of the shard blocks that they are each created in.</p>\n<p>Suppose that shard <em>B</em> creates a new shard block <em>b</em>. As illustrated in Fig.3, the the steps involved in ordering the processing of CSTs and transactions are:</p>\n<ol>\n<li>First <span class=\"math\">b</span><em>’s</em> hashes (DAG edges) to other shard blocks and a synchronization block are chosen. Hashes are only chosen if corresponding subgraph CST data is available, otherwise correct ordering cannot be known and penalties may ensue.</li>\n<li>The protocol rules described earlier require that the validator creating and proposing <span class=\"math\">b</span> has all the CST data from <span class=\"math\">b</span><em>’s</em> subgraph, call these <span class=\"math\">T</span>. The set of pending CSTs <span class=\"math\">P</span> whose destination is shard <span class=\"math\">B</span>, and which have not already been processed in an existing shard <span class=\"math\">B</span> block are extracted from <span class=\"math\">T</span> and any new transactions are added to <span class=\"math\">P</span>.</li>\n<li>The set of pending transactions and CSTs, <span class=\"math\">P</span> are (partially) ordered according to the shardDAG ordering of the shard blocks that they were created in, retaining the order of multiple CSTs created within a single block. <span class=\"math\">P</span> is topologically sorted to create a totally ordered set of transactions and CSTs.</li>\n<li>Block size limits may constrain the number of transactions and cross-shard transactions included in a shard block. If this occurs, it is optional to introduce priority of transactions and CSTs as illustrated in Fig. 7, whereby block proposers select transactions and CSTs to include based on priority fees, and MEV. However, this comes at the cost of potentially allowing exploitative transaction insertion. Pending transactions and CSTs must be processed if allowed by block size limits; any unused block space must be too small to contain any unprocessed transaction or CST.</li>\n<li>New transactions that do not fit into block processing can be included in a shard block’s outbox of CSTs. Such transactions enter the shardDAG for ordering and will therefore be processed in a later block along with other pending transactions and CSTs not included in <span class=\"math\">b</span>.</li>\n</ol>\n<p>Validators should only sign a proposed block once they have verified that the block proposer has followed this protocol ordering. If an invalid ordering is used then the block is invalid and/or the signing validators are subjected to penalties. We reiterate that because ordering rules involve only on-chain data, data availability of CSTs and block headers enables any validator or node to verify correctness of ordering.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/0/9/09afd7f7cf81fd6dacfe88bcc2f4b6c7eab46c0f.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/09afd7f7cf81fd6dacfe88bcc2f4b6c7eab46c0f\" title=\"ShardDAG Overloaded Ordering Only\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/0/9/09afd7f7cf81fd6dacfe88bcc2f4b6c7eab46c0f_2_690x407.jpeg\" alt=\"ShardDAG Overloaded Ordering Only\" data-base62-sha1=\"1nH2vxvlS1jBdkATbBGafTTa63Z\" width=\"690\" height=\"407\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/0/9/09afd7f7cf81fd6dacfe88bcc2f4b6c7eab46c0f_2_690x407.jpeg, https://ethresear.ch/uploads/default/optimized/3X/0/9/09afd7f7cf81fd6dacfe88bcc2f4b6c7eab46c0f_2_1035x610.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/0/9/09afd7f7cf81fd6dacfe88bcc2f4b6c7eab46c0f_2_1380x814.jpeg 2x\" data-dominant-color=\"424138\"></a></div><br>\nFigure 7: An extension of Fig.3 when shard B is overloaded and unprocessed transactions and CSTs exceed maximum block size (left). The block builder selects transactions and CSTs to remove from the topological sort for the new block (middle), so that the remaining transactions and CSTs do not exceed block size limits (right). Removed CSTs will be processed in later blocks. This removal of transactions and CSTs is expected to be based on priority fees and MEV. Unprocessed new transactions (b2’) may be included in an outbox as data so that they enter shardDAG ordering for processing in a later block, like b0 and b1 in earlier blocks, but these outboxed transactions are not processed in the current block.<p></p>\n<h2><a name=\"summary-11\" class=\"anchor\" href=\"https://ethresear.ch#summary-11\"></a>Summary</h2>\n<p>In state-sharded blockchains, censorship and insertion of exploitative transactions part-way through transaction processing can be constrained by shardDAG transaction and CST ordering. These shardDAG constraints are derived from ordering, which enforces processing of earlier transactions and CSTs before later ones. ShardDAG ordering rests upon economic incentives that motivate validators to suitably participate in the shardDAG to receive block rewards and avoid penalties.</p>\n<p>DAGs are a natural tool to be used in ordered systems. The shardDAG broadens the use of DAGs in blockchain, beyond their more common application in consensus mechanisms. The shardDAG has been presented here in a unified state sharded system, but the ideas can be applied to sets of distinct rollups or blockchains.</p>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://ethresear.ch/t/sharddag-ordering-and-exploitation-in-sharded-blockchains/20203\">Read full topic</a></p>","link":"https://ethresear.ch/t/sharddag-ordering-and-exploitation-in-sharded-blockchains/20203","pubDate":"Thu, 01 Aug 2024 23:12:07 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20203"},"source":{"@url":"https://ethresear.ch/t/sharddag-ordering-and-exploitation-in-sharded-blockchains/20203.rss","#text":"ShardDAG: Ordering and Exploitation in Sharded Blockchains"}},{"title":"Inclusion List Timing Constraints","dc:creator":"terence","category":"Block proposer","description":"<p>Special thanks to <a class=\"mention\" href=\"https://ethresear.ch/u/julian\">@Julian</a>, <a class=\"mention\" href=\"https://ethresear.ch/u/barnabe\">@barnabe</a> and <a class=\"mention\" href=\"https://ethresear.ch/u/manav2401\">@manav2401</a> for the reviews</p>\n<h2><a name=\"background-1\" class=\"anchor\" href=\"https://ethresear.ch#background-1\"></a>Background</h2>\n<p>Inclusion list have been an active topic since the <a href=\"https://notes.ethereum.org/@vbuterin/pbs_censorship_resistance\" rel=\"noopener nofollow ugc\">early</a> <a href=\"https://ethresear.ch/t/how-much-can-we-constrain-builders-without-bringing-back-heavy-burdens-to-proposers/13808\">days</a>. <a href=\"https://notes.ethereum.org/@fradamt/forward-inclusion-lists\" rel=\"noopener nofollow ugc\">Various</a> <a href=\"https://notes.ethereum.org/@fradamt/H1TsYRfJc\" rel=\"noopener nofollow ugc\">designs</a> have emerged over time, each with inevitable trade-offs concerning <strong>What can be constrained within a single Ethereum slot?</strong>.<br>\nThis post explores these trade-offs from the perspectives of <strong>different actors</strong> involved in ILs and defines the dependencies required for each actor to fulfill their role in integrating ILs into the protocol. We will compare and contrast multiple designs, focusing on the limitations related to <strong>timing, security, and feasibility</strong>.</p>\n<p>First, we will outline some definitions.</p>\n<h2><a name=\"il-definitions-2\" class=\"anchor\" href=\"https://ethresear.ch#il-definitions-2\"></a>IL Definitions</h2>\n<p><strong>Slot Time</strong>: In the context of Ethereum, a slot refers to a fixed interval currently set at 12 seconds. During each slot, the proposer/builder proposes a block, attesters vote on the block, and an aggregator aggregates the votes. The proposer of subsequent slot includes aggregated votes in their block, and the cycle repeats. Today out-of-protocol builders have an ~8-second window to prepare for the next slot’s block. All actions are synchronized with these validator duty intervals, and <strong>IL should not extend the current slot time</strong>.</p>\n<p><strong>Inclusion List:</strong> An inclusion list (IL) is a list of transactions that a block proposer commits to including in a block. Depends on the conditional vs unconditional constraint, if these transactions are not included in the block, then the block cannot be considered canonical, assuming honest attesters who will vote against the block. The IL consists of the following options and requirements.</p>\n<ol>\n<li><strong>Satisfactory Requirement</strong>:\n<ul>\n<li><strong>Conditional</strong>: The IL does not need to be satisfied if the target block is full.\n<ul>\n<li><strong>Forward-Looking</strong>: If the IL cannot be satisfied in the current target block, does it still apply to subsequent blocks? <a href=\"https://ethresear.ch/t/cumulative-non-expiring-inclusion-lists/16520\">More in this post</a></li>\n</ul>\n</li>\n<li><strong>Unconditional</strong>: The IL needs to be satisfied. This typically means the IL has its own gas limit.</li>\n</ul>\n</li>\n<li><strong>Satisfactory Time</strong>:\n<ul>\n<li><strong>Same Slot IL</strong>: The IL is satisfied within the same slot, similar to users sending a transactions wanting to be included on chain. With sufficient base fee and tip, we can expect the transaction to be included the slot of. For example, an IL transaction for slot <code>n+1</code> is satisfied in slot <code>n+1</code>.</li>\n<li><strong>Next Slot IL</strong>: The IL is satisfied in the subsequent slot with one slot delay. For example, an IL transaction for slot <code>n+1</code> is satisfied in slot <code>n+2</code>.</li>\n</ul>\n</li>\n<li><strong>IL constructor</strong>: The actor responsible for preparing and broadcasting the IL to the network. This role can be fulfilled by a single entity (like a proposer) or by a committee where the protocol reaches consensus on individual ILs from its members. The consensus of IL may be reached by IL aggregate which represents IL committee’s vote.</li>\n<li><strong>IL Gas Limit</strong>: IL gas limit has an implication on the size of IL which dirrectly affects the network propagation time and node’s verification time.</li>\n<li><strong>IL Ordering In Block</strong>: When the IL becomes part of the block, the transactions may be required to be placed in a specific order. This order could be:\n<ul>\n<li><strong>Top of the Block</strong>: Transactions are placed at the beginning of the block.</li>\n<li><strong>Anywhere in the Block</strong>: Transactions are placed anywhere within the block.</li>\n<li><strong>Bottom of the Block</strong>: Transactions are placed at the end of the block.</li>\n</ul>\n</li>\n<li><strong>Liveness Guarantee</strong> The IL must be made available to the block builder to avoid stalling the chain’s liveness. The delivery method of the IL to the builder varies based on the trust model. If a single person constructs the IL, stricter requirements may be necessary, such as additional attester validation along with the block.</li>\n<li><strong>No Free DA</strong> An IL that has not been satisfied in execution cannot be part of the consensus, as it would grant free DA. Free DA has to be tightly coupled with consensus and should not be mistaken for free bandwidth or temporary data storage. While nodes can use a small amount of bandwidth or store temporary data with anti-dos measures in place, this should not be conflated with free DA.</li>\n</ol>\n<p><strong>Block Builder</strong>: The actor tasked with fulfilling the IL and broadcasting the resulting product (ie. a block that fulfills the IL) over the network. In the case of a solo validator, the block proposer serves as the block builder, and the product is the execution payload of the block. For a MEV-boost validator, the block builder handles the fulfillment, which returns the signed header to proposer, and the relay broadcasts the final block to the network. It is often the case that the block proposer cannot verify the satisfactory fulfillment of the IL when signing the header request. Relays have to verify the payload satisfies IL ahead of time or assume optimistic.</p>\n<p><strong>IL Transaction Invalidation</strong>: Transactions in an IL may become <strong>not includable</strong> at the time of inclusion due to invalidations, such as an incorrect nonce or insufficient balance. This situation can arise under different conditions. For example, when multiple parties are involved in constructing their version of ILs, the transactions from each party might render each other not includable. Similarly, if one party constructs the IL while another party broadcasts the block at the same moment, there can also be invalidations, leading to mutual exclusion of the IL transactions and block transactions.</p>\n<p><strong>Head Block</strong>: Often referred to as the parent block, the IL should be constructed on top of the chain’s head from the perspective of the node. The builder, responsible for constructing the block and satisfying the IL, should also build on top of the head block in order to make sure that block and inclusion list are aligned.<br>\n<strong>Constraint</strong>: If an IL is built on head <code>a</code>, then to satisfy the IL, the builder’s block must also be built on top of head <code>a</code>.</p>\n<h2><a name=\"il-timings-3\" class=\"anchor\" href=\"https://ethresear.ch#il-timings-3\"></a>IL Timings</h2>\n<p><strong>IL Preparation Time</strong>: This is the time required for a party to prepare the IL, which is constructed on top of the head block. The larger the IL may require longer time to prepare.</p>\n<p><strong>IL Propagation Time</strong>: This is the time required for the IL to propagate across the network to other nodes. Factors influencing this time include the size of the IL, the number of ILs (committee size), and the network’s gossip rules.</p>\n<p><strong>IL Verification Time</strong>: This is the time required to verify the IL. The IL must be valid, otherwise builders can get grieved. In some scenarios, attesters must verify the IL before considering the current slot block as the head (. In other cases, the proposer must verify the IL before proposing the next slot block. The point is that some parties must verify the IL beforehand, and it’s crucial to consider who is bearing this cost.</p>\n<p><strong>Block Preparation Time</strong>: This is the time required to build an execution block. The block can be constructed either by the proposer or the builder. The IL’s satisfactory requirements must be met in the block. This means the block builder must verify the IL, parent block and ensure that the block satisfies IL requirements.</p>\n<p><strong>Block Propagation Time</strong>: This is the time taken for a block to be transmitted across the network and received by all participants. It’s crucial that the block is received and verified by attesters promptly, as delays can lead to the block not being considered as the head of the chain, increasing the risk of reorg.</p>\n<p><strong>Block Verification Time</strong>: This is the time taken for a node to verify the block and IL. The focus here is on execution verification time, as consensus verification is typically fast. A block must be verified as execution valid and meet the IL requirements before it can be considered the head of the chain.</p>\n<p>Based on the timing definition provided, we can outline the following dependencies:</p>\n<ul>\n<li>The parent head block <code>n</code> must be released before attestation cut off. The difference is between start of the slot. Head release time = <span class=\"math\">T_{HR}</span></li>\n<li>The head block must be propagated to peers on time. Head propagation time = <span class=\"math\">T_{HP}</span></li>\n</ul>\n<ul>\n<li>The IL constructor must see and validate the parent head block before creating the IL. Head validator time = <span class=\"math\">T_{HV}</span></li>\n<li>The IL must be constructed and released using for example a local mem pool. IL construction time = <span class=\"math\">T_{ILC}</span></li>\n<li>The IL must propagate through the network to reach the builders. IL propagation time = <span class=\"math\">T_{ILP}</span></li>\n<li>The block builder needs to verify the IL before submitting a bid.  IL verification time = <span class=\"math\">T_{ILV}</span>\n<ul>\n<li>This requirement may change in the context of slot auctions.</li>\n</ul>\n</li>\n<li>The proposer must see the bids before submitting a block. Bid propagation time = <span class=\"math\">T_{BP}</span></li>\n<li>The attester must verify the block <code>n+1</code> before considering it as the head. We can reuse head verification time above.</li>\n</ul>\n<p>In short, we could summarize: A single Ethereum slot should not exceed the following durations, ensuring that the end-to-end IL is applied, and the block remains canonical on the chain: <span class=\"math\">SLOT &gt;= T_{HR}+T_{HP}+2 * T_{HV}+T_{ILC}+T_{ILP}+T_{ILV}+T_{BP}</span></p>\n<h1><a name=\"different-versions-of-il-4\" class=\"anchor\" href=\"https://ethresear.ch#different-versions-of-il-4\"></a>Different versions of IL</h1>\n<p>Different versions of IL have varying constraint trade-offs. Some examples taken from <a href=\"https://eips.ethereum.org/EIPS/eip-7547\" rel=\"noopener nofollow ugc\">EIP-7547</a> and <a href=\"https://ethresear.ch/t/fork-choice-enforced-inclusion-lists-focil-a-simple-committee-based-inclusion-list-proposal/19870\">FOCIL</a>.</p>\n<h4><a name=\"eip-7547-in-mev-boost-5\" class=\"anchor\" href=\"https://ethresear.ch#eip-7547-in-mev-boost-5\"></a>EIP-7547 in MEV-Boost</h4>\n<ul>\n<li>The block builders for slot <code>n</code> constructs a block for slot <code>n</code> after verifying the block for slot <code>n-1</code>.</li>\n<li>The block proposer of slot <code>n</code> constructs an IL for slot <code>n+1</code> after verifying the block for slot <code>n-1</code>.</li>\n<li>The IL for slot <code>n+1</code> and the block for slot <code>n</code> may invalidate each other if they are sent by different parties.</li>\n<li>The block proposer/builder of slot <code>n+1</code> requires the IL and the block for slot <code>n</code> to build a block.</li>\n<li>The block proposer of slot <code>n+1</code> needs the IL and the block for slot <code>n</code> to build an IL.</li>\n<li>Attesters for slot <code>n+1</code> need the IL and the block for slot <code>n</code> to attest to the block. The block for slot <code>n+1</code> must link to a valid IL <code>n+1</code>, or it cannot be canonical.</li>\n</ul>\n<h4><a name=\"eip-7547-in-epbs-eip-7732-6\" class=\"anchor\" href=\"https://ethresear.ch#eip-7547-in-epbs-eip-7732-6\"></a>EIP-7547 in ePBS (EIP-7732)</h4>\n<ul>\n<li>The block proposer of slot <code>n</code> selects the builder’s bid of slot <code>n</code> after verifying the execution block for slot <code>n-1</code>.</li>\n<li>The block proposer of slot <code>n</code> constructs an IL for slot <code>n+1</code> after verifying the execution block for slot <code>n-1</code>.</li>\n<li>Since the bid commits to the transactions, the IL for slot <code>n+1</code> and the bid for slot <code>n</code> may conflict. This is different in slot auction.</li>\n<li>The builder reveals the execution block at slot <code>n</code>’s 6-seconds mark.</li>\n<li>Subsequent block builders require the execution block at slot <code>n</code> and the IL for slot <code>n+1</code> to place bids for slot <code>n+1</code>. This is different in slot auction.</li>\n<li>Attesters for slot <code>n+2</code> verify that the execution block for slot <code>n+1</code> satisfies the IL and is valid. We gain an extra slot time for validation due to <a href=\"https://ethresear.ch/t/advantage-of-pipelining-consensus-and-execution-delayed-execution/19668\">delayed execution property</a>.</li>\n</ul>\n<h4><a name=\"focil-in-mev-boost-ignoring-il-aggregation-step-7\" class=\"anchor\" href=\"https://ethresear.ch#focil-in-mev-boost-ignoring-il-aggregation-step-7\"></a>FOCIL in MEV-Boost (Ignoring IL Aggregation Step)</h4>\n<ul>\n<li>The block builder of slot <code>n</code> constructs a block for slot <code>n</code> after verifying the block for slot <code>n-1</code>.</li>\n<li>The IL committee builds the IL for slot <code>n</code> after verifying the block for slot <code>n-1</code>.</li>\n<li>The IL committee for slot <code>n</code> releases the IL during slot <code>n-1</code>.</li>\n<li>Attesters for slot <code>n</code> lock their view on the ILs.</li>\n<li>The builder of slot <code>n</code> includes the IL transactions into the block for slot <code>n</code></li>\n<li>At the start of slot <code>n</code>, the proposer requests the builder’s head, signs it, and broadcasts it.</li>\n<li>Attesters for slot <code>n</code> verify that the block satisfies the IL committee’s requirements according to their locked view in slot <code>n-1</code>.</li>\n</ul>\n<h4><a name=\"focil-in-epbs-same-slot-version-8\" class=\"anchor\" href=\"https://ethresear.ch#focil-in-epbs-same-slot-version-8\"></a>FOCIL in ePBS (Same Slot Version)</h4>\n<ul>\n<li>The block proposer of slot <code>n</code> selects the builder’s bid for slot <code>n</code> after verifying the execution block for slot <code>n-1</code>.</li>\n<li>The IL committee for slot <code>n+1</code> constructs the IL for slot <code>n+1</code> after the builder reveals the execution block for slot <code>n</code>.</li>\n<li>Builders for slot <code>n+1</code> verify the IL and make bids for slot <code>n+1</code>.</li>\n<li>The block proposer of slot <code>n+1</code> selects the builder’s bid for slot <code>n+1</code>.</li>\n<li>Attesters for slot <code>n+2</code> verify that the execution block for slot <code>n+1</code> satisfies the IL and is valid, providing close to an extra slot time due to delayed execution.</li>\n</ul>\n<h4><a name=\"focil-in-epbs-next-slot-version-9\" class=\"anchor\" href=\"https://ethresear.ch#focil-in-epbs-next-slot-version-9\"></a>FOCIL in ePBS (Next Slot Version)</h4>\n<ul>\n<li>The block proposer of slot <code>n</code> selects the builder’s bid for slot <code>n</code> after verifying the execution block for slot <code>n-1</code>.</li>\n<li>The IL committee for slot constructs the IL for slot <code>n+2</code> after the builder reveals the execution block for slot <code>n</code>.</li>\n<li>Builders for slot <code>n+2</code> verify the IL and make bids for slot <code>n+2</code>.</li>\n<li>The block proposer of slot <code>n+2</code> selects the builder’s bid for slot `n+2.</li>\n<li>Attesters for slot <code>n+3</code> verify that the execution block for slot <code>n+2</code> satisfies the IL and is valid, providing close to an extra slot time due to delayed execution.</li>\n</ul>\n<h2><a name=\"il-contentions-10\" class=\"anchor\" href=\"https://ethresear.ch#il-contentions-10\"></a>IL Contentions</h2>\n<p>ILs may compete with initiatives as the following:</p>\n<p><strong>Shorter Slot Time Contentions with IL</strong>: With shorter slot times, ILs may not be constructed and fulfilled on time. A proposer that cannot fulfill an IL results in a liveness fault. One way to address this is to extend the IL satisfactory rule to the next slot or to multiple subsequent slots, but this approach introduces risks of denial-of-service (DoS) attacks and more transaction invalidation concerns. There is a trade-off here.</p>\n<p><strong>Higher Gas Limit Contentions with IL</strong>: With a higher block gas limit, it takes longer to verify the block, which reduces the time available to construct the IL after verifying the block. Additionally, with a higher IL gas limit, it takes longer to propagate and verify the IL, reducing the time available to fulfill the IL by building the block.</p>\n<p><strong>DVT Contentions with IL</strong>: Distributed Validator Technology (DVT) requires more exchanges between validators before signing. This process includes beacon chain duties such as attesting, proposing, and submitting ILs. These additional exchanges require time, and there is a need to ensure that the IL, especially in more complex forms, does not make DVT operations impractical.</p>\n<p><strong>AVS Contentions with IL</strong>: Active Validator Service (AVS) also require more actions from validators. The specific details depend on the AVS implementation, but generally, requiring more time from validators to perform certain tasks can create contention with fulfilling IL obligations.</p>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://ethresear.ch/t/inclusion-list-timing-constraints/20198\">Read full topic</a></p>","link":"https://ethresear.ch/t/inclusion-list-timing-constraints/20198","pubDate":"Thu, 01 Aug 2024 16:02:42 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20198"},"source":{"@url":"https://ethresear.ch/t/inclusion-list-timing-constraints/20198.rss","#text":"Inclusion List Timing Constraints"}},{"title":"Cross-rollup Synchronous Atomic Execution","dc:creator":"HankyungKo","category":"Layer 2","description":"<ul>\n<li><em>by Hankyung Ko(<a href=\"https://ethresear.ch/u/hankyungko\">@HankyungKo</a>) and Chanyang Ju(<a href=\"https://ethresear.ch/u/wooju\">@wooju</a>), Researcher at <a href=\"https://twitter.com/radius_xyz\" rel=\"noopener nofollow ugc\">Radius</a> . Thanks to</em> <a href=\"https://twitter.com/Hyunxukee\" rel=\"noopener nofollow ugc\"><em>Tariz</em></a> <em>and</em> <a href=\"https://twitter.com/ZeroKnight_eth\" rel=\"noopener nofollow ugc\"><em>AJ</em></a> <em>for reviewing this post.</em></li>\n<li><em>Your feedback and opinions are highly valued.</em></li>\n</ul>\n<p><em>Radius has designed a synchronous atomic execution solution for cross-rollup composability. This development is driven by our commitment to support rollups seeking improved composability and enhanced user experience. We will enable rollups to create their own shared sequencing layer, offering this as a service to make it widely accessible. By doing so, we ensure that atomic execution of bundled transactions is coordinated effectively across participating rollups.</em></p>\n<h1><a name=\"h-1-introduction-1\" class=\"anchor\" href=\"https://ethresear.ch#h-1-introduction-1\"></a>1. Introduction</h1>\n<hr>\n<p>Synchronous atomic execution allows multiple transactions from different rollups to be executed simultaneously and atomically in an all-or-nothing manner, significantly reducing latency compared to sequential execution. A naive approach to executing multiple cross-rollup transactions require each transaction to be finalized sequentially on L1. For <span class=\"math\">n</span> transactions, the total latency would be <span class=\"math\">n</span> times the L1 finalization period. In contrast, <strong><code>synchronous atomic execution</code></strong> enables all transactions to be executed at the same time, significantly reducing latency.</p>\n<p>While executing transactions simultaneously can reduce latency, it may raise concerns about security. For example, in a bundled transaction involving minting-and-burning across different rollups, there’s a risk that the burn could fail while the mint succeeds. To address this, we’ve designed our system to verify the atomicity of bundled transactions faster than the time it takes for block finalization. This approach ensures that security is maintained even with simultaneous execution. Our innovation improves composability across multiple rollups, providing a seamless, efficient, and secure user experience with real-time, all-or-nothing execution of cross-rollup transactions without delays.</p>\n<p>To implement this convenient and secure solution, Radius introduces a shared sequencer for rollups to guarantee the atomic execution of bundled transactions. Users create bundled transactions that depend on transactions across multiple rollups, and the shared sequencer manages the sequencing of bundled transactions for successful execution.</p>\n<blockquote>\n<p><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/point_right.png?v=12\" title=\":point_right:\" class=\"emoji\" alt=\":point_right:\" loading=\"lazy\" width=\"20\" height=\"20\"> It’s important to note that this shared sequencer is not a single entity controlled by Radius, but rather a set formed by aggregating existing sequencers from each rollup. A leader is selected from this set through a predefined process (<a href=\"https://docs.theradius.xyz/testnets/loggia-testnet-with-radius-avs/decentralized-sequencing\" rel=\"noopener nofollow ugc\">reference</a>) to manage sequencing.</p>\n<p>To prevent potential power abuse by the shared sequencer, Radius employs decentralized sequencing techniques, including encrypted mempool (<a href=\"https://ethresear.ch/t/mev-resistant-zk-rollups-with-practical-vde-pvde/12677\">PVDE</a> and <a href=\"https://ethresear.ch/t/radius-skde-enhancing-rollup-composability-with-trustless-sequencing/19185\">SKDE</a>). The shared sequencer has two main functions: determining transaction order and enforcing transaction reverts to maintain bundle atomicity.</p>\n<p>This article details on how our architecture addresses the second function, ensuring atomicity. Preventing potential abuse of the first function, transaction ordering, is also crucial. Radius addresses this concern through the encrypted mempool, ensuring that the shared sequencer cannot abuse its power regarding transaction ordering.</p>\n</blockquote>\n<h2><a name=\"h-1-requirements-of-the-synchronous-atomicity-solution-2\" class=\"anchor\" href=\"https://ethresear.ch#h-1-requirements-of-the-synchronous-atomicity-solution-2\"></a>1) Requirements of the synchronous atomicity solution</h2>\n<ul>\n<li><strong><code>Convenience</code>:</strong> Users can achieve greater benefits by utilizing atomic execution of cross-rollup bundled transactions, without compromising security.\n<ul>\n<li><strong>Bundle transactions</strong>: Users can bundle and execute multiple transactions across different rollups as one.</li>\n<li><strong>Atomic execution:</strong> The bundle transaction is guaranteed to execute simultaneously without failures. If a failure occurs, it is guaranteed to fail simultaneously.</li>\n<li><strong>Fast execution for bundle while maintaining security</strong>: Transactions are guaranteed to be executed faster than sequential execution (where each transaction waits for the previous one to finish). This allows users to strategize their next transactions more quickly. Additionally, atomic execution is cryptographically verified before finalization, ensuring that the security of the transactions is maintained even though they are executed more quickly.</li>\n</ul>\n</li>\n<li><strong><code>Security</code></strong>\n<ul>\n<li><strong>Minimized trust level</strong>: Aims to minimize the amount of trust users must place in key network participants like the shared sequencer and executors by:\n<ul>\n<li>Minimizing the number of parties that need to be trusted.</li>\n<li>Minimizing the duration for which trust is necessary.</li>\n<li>Ensuring early detection and verification of any malicious behavior by the shared sequencer and executors before blockchain finalization.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2><a name=\"h-2-main-idea-3\" class=\"anchor\" href=\"https://ethresear.ch#h-2-main-idea-3\"></a>2) Main Idea</h2>\n<p>We propose an architecture for synchronous atomic execution using the <code>shared sequencer</code>, <code>data availability (DA)</code>, and a <code>verification layer</code>.</p>\n<h3><a name=\"why-shared-sequencer-4\" class=\"anchor\" href=\"https://ethresear.ch#why-shared-sequencer-4\"></a>Why shared sequencer?</h3>\n<ul>\n<li>To satisfy the desired properties of convenience and security, it is necessary to handle bundled transactions across multiple rollups. Therefore, we propose a new entity called the shared sequencer, which is responsible for confirming the blocks of multiple rollups.</li>\n<li>The shared sequencer receives a cross-chain bundle and determines the block order for atomic execution.</li>\n<li>The shared sequencer is responsible to ensure the atomic execution of bundled transactions before confirming the block.</li>\n</ul>\n<h3><a name=\"new-responsibility-of-the-executor-5\" class=\"anchor\" href=\"https://ethresear.ch#new-responsibility-of-the-executor-5\"></a>New responsibility of the executor</h3>\n<ul>\n<li><strong>The executor, in agreement with the shared sequencer, has an added constraint:</strong> it must execute the transaction list committed by the shared sequencer.</li>\n</ul>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/5/5/553162b8f7a0148ceedbd7bddbf19ce91d944f58.png\" data-download-href=\"https://ethresear.ch/uploads/default/553162b8f7a0148ceedbd7bddbf19ce91d944f58\" title=\"SAE_figure1\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/5/5/553162b8f7a0148ceedbd7bddbf19ce91d944f58_2_690x130.png\" alt=\"SAE_figure1\" data-base62-sha1=\"c9Eony1QNisRB3JvW0e2JVRmnhu\" width=\"690\" height=\"130\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/5/5/553162b8f7a0148ceedbd7bddbf19ce91d944f58_2_690x130.png, https://ethresear.ch/uploads/default/optimized/3X/5/5/553162b8f7a0148ceedbd7bddbf19ce91d944f58_2_1035x195.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/5/5/553162b8f7a0148ceedbd7bddbf19ce91d944f58_2_1380x260.png 2x\" data-dominant-color=\"F2F2F1\"></a></div><br>\n[Figure 1] The definition of roles and responsibilities of shared sequencer and executors<p></p>\n<h3><a name=\"conditions-for-synchronous-atomicity-6\" class=\"anchor\" href=\"https://ethresear.ch#conditions-for-synchronous-atomicity-6\"></a>Conditions for synchronous atomicity</h3>\n<ul>\n<li>Synchronous atomicity for bundle transaction is achieved if the following two conditions are independently verified:\n<ol>\n<li>All bundled transaction in the block committed by the shared sequencer should be atomic.</li>\n<li>The executor executes the same block as committed by the shared sequencer.</li>\n</ol>\n</li>\n</ul>\n<h2><a name=\"h-3-our-contributions-7\" class=\"anchor\" href=\"https://ethresear.ch#h-3-our-contributions-7\"></a>3) Our Contributions</h2>\n<ul>\n<li><strong>Designed a synchronous atomic execution solution</strong>:\n<ul>\n<li><strong>Security requirements definition</strong>: We have defined the security requirements for each entity involved in synchronous atomic execution, ensuring that all components operate securely and reliably.</li>\n<li><strong>Architecture design</strong>: We have designed a robust architecture that ensures security and efficiency. This architecture includes:\n<ul>\n<li><strong>User’s bundle transaction</strong>: We defined the structure and format of bundle transactions that users can create. These bundled transactions enable users to execute multiple transactions across different rollups simultaneously, ensuring atomic execution.</li>\n<li><strong>The bundler contract</strong>: We designed and implemented the bundler contract, which is responsible for handling and processing bundled transactions. This contract is called by the shared sequencer, and performs several critical functions:\n<ul>\n<li>Acts as a gateway smart contract for users to call the actual contracts they intend to execute.</li>\n<li>Allows the shared sequencer to enforce transaction reverts to guarantee the atomicity of the bundle transactions.</li>\n<li>Verifies the legitimacy of transactions initially created by the user.</li>\n<li>Charges transaction fees to users.</li>\n</ul>\n</li>\n<li><strong>Coordination process for the shared sequencer</strong>:  We developed a coordination process for the shared sequencer, which includes interaction with the full nodes (simulators) of each rollup. This process ensures that the shared sequencer can effectively manage and sequence transaction across multiple rollups, guaranteeing atomic execution.</li>\n<li><strong>Verification logic</strong>: We defined the verification logic to ensure that all transactions within a bundle meet the defined security requirements before finalization.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>Demonstrated the feasibility of the architecture:</strong>\n<ul>\n<li><strong>Implementation</strong>: We have implemented the entire architecture, demonstrating its feasibility and effectiveness. Our implementation includes all components of the synchronous atomic execution solution, from the user’s bundle transaction creation to the coordination process for the shared sequencer.\n<ul>\n<li>The user’s bundled transaction is signed using MetaMask.</li>\n<li>Implemented on two Polygon CDKs:\n<ul>\n<li>Each Polygon CDK has an API that responds to the shared sequencer’s simulation requests.</li>\n<li>Each Polygon CDK has a deployed Bundler contract.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>Demo</strong>: The demo scenario involves transferring tokens from Rollup A to Rollup B. In this scenario, the bundled transaction consists of two operations: burning the wrapped token on Rollup A and mint it on Rollup B. This demonstrates the practical application of our solution. (<a href=\"https://x.com/radius_xyz/status/1809120936270123468\" rel=\"noopener nofollow ugc\">Check out our Demo here!</a>)</li>\n</ul>\n</li>\n</ul>\n<h1><a name=\"h-2-definition-8\" class=\"anchor\" href=\"https://ethresear.ch#h-2-definition-8\"></a>2. Definition</h1>\n<hr>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/0/b/0bec5c1463e929939d860e125c34e05cbc6b4c34.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/0bec5c1463e929939d860e125c34e05cbc6b4c34\" title=\"SAE_figure2\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/0/b/0bec5c1463e929939d860e125c34e05cbc6b4c34_2_690x243.jpeg\" alt=\"SAE_figure2\" data-base62-sha1=\"1HtEkouONQUBdF8sbZ5D2nVphFq\" width=\"690\" height=\"243\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/0/b/0bec5c1463e929939d860e125c34e05cbc6b4c34_2_690x243.jpeg, https://ethresear.ch/uploads/default/optimized/3X/0/b/0bec5c1463e929939d860e125c34e05cbc6b4c34_2_1035x364.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/0/b/0bec5c1463e929939d860e125c34e05cbc6b4c34_2_1380x486.jpeg 2x\" data-dominant-color=\"F4F4F4\"></a></div><br>\n[Figure 2] Overview of transaction flow<p></p>\n<blockquote>\n<p><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/pushpin.png?v=12\" title=\":pushpin:\" class=\"emoji\" alt=\":pushpin:\" loading=\"lazy\" width=\"20\" height=\"20\"> <strong>The proposed architecture is based on the following assumptions.</strong></p>\n<ul>\n<li><strong>Scenario</strong>\n<ul>\n<li>Each Bundle Tx consists of two transactions: a <strong>Burn</strong> transaction and a <strong>Mint</strong> transaction of ERC20 contract (rToken), occurring on different chains (inspired by Hyperlane bridge scenario).</li>\n</ul>\n</li>\n<li><strong>Rollups</strong>\n<ul>\n<li>Each rollup has a simulation API implemented.</li>\n<li>The <code>Radius’ Bundler contract</code> is deployed on each rollup.</li>\n<li>The ERC20 rToken contract is also implemented on each rollup.</li>\n<li>The execute function of the Radius’ Bundler contract is accessible only by whitelisted <code>shared sequencers</code>.</li>\n<li>The ERC20 contract (rToken) grants burn and mint access rights to the Radius’ Bundler contract.</li>\n</ul>\n</li>\n<li><strong>Incentives and Penalties</strong> (Future work)\n<ul>\n<li>There are sufficient incentives for correct behavior and penalties for incorrect behavior for the <code>shared sequencer</code> and <code>Executor</code>.</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h2><a name=\"h-1-operational-roles-and-security-requirements-of-entities-9\" class=\"anchor\" href=\"https://ethresear.ch#h-1-operational-roles-and-security-requirements-of-entities-9\"></a>1) Operational Roles and Security Requirements of Entities</h2>\n<p>In this section, we define the correct behavior and adversarial behavior of each entity in the architecture. The adversarial behaviors defined here will be analyzed in Section 4.</p>\n<ul>\n<li><strong><code>User</code>:</strong> The entity that generates cross-rollup bundled transactions and sends them to the shared sequencer for atomic execution.\n<ul>\n<li><strong>Adversarial behaviors</strong>\n<ul>\n<li>Creates invalid Bundle Tx:\n<ul>\n<li>The value of the BURN Tx and the MINT Tx do not match.</li>\n<li>Insufficient account balance for the tokens intended to be burned.</li>\n<li>Lacks the ability to pay the gas fee required for executing the transaction on at least one chain.</li>\n<li>Incorrectly signs the Bundle Tx.</li>\n</ul>\n</li>\n<li>Calls the MINT function without the shared sequencer’s assistance:\n<ul>\n<li>Attempts to execute the MINT Tx without creating a Bundle Tx.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong><code>Shared sequencer</code>:</strong> The entity responsible for receiving bundled transactions from users, creating and submitting blocks for multiple rollups, and ensuring the atomic execution of bundled transactions.\n<ul>\n<li><strong>Adversarial behaviors</strong>\n<ul>\n<li>Calls bundler contract without user’s consent.</li>\n<li>Fails to verify whether the Bundle Tx is executed atomically across all rollups.</li>\n<li>Forces the valid Bundle Tx to revert unnecessarily.</li>\n<li>Sends a different transaction list to the executor than the one committed to the DA after confirming the block.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong><code>Executor</code>:</strong> The entity specific to each rollup that executes the transaction list determined by the shared sequencer and uploads the resulting blocks to the Data Availability layer.\n<ul>\n<li><strong>Adversarial behaviors</strong>\n<ul>\n<li>Does not execute the transaction list as confirmed and provided by the shared sequencer.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong><code>Shared Prover</code>:</strong> The entity that generates zero-knowledge proofs to validate the atomic execution of bundled transactions across different chains based on data from the Data Availability layer.</li>\n</ul>\n<h2><a name=\"h-2-additional-components-10\" class=\"anchor\" href=\"https://ethresear.ch#h-2-additional-components-10\"></a>2) Additional Components</h2>\n<ul>\n<li><strong><code>Simulator</code>:</strong> The simulator refers to the full node of each rollup that the shared sequencer communicates with to validate the atomicity of bundled transactions before committing the block. This entity could be the same as the executor mentioned above.</li>\n<li><strong><code>Data Availability Layer (DA)</code>:</strong> The DA is a layer for storing data committed by the shared sequencer and executor to prove their honesty. The shared prover uses this information to verify the honesty of both entities.\n<ul>\n<li>Given a reliable <code>DA</code>, if the shared sequencer and executor each commit the minimum necessary information for the verification of synchronous atomicity to the DA, it can be quickly <code>verified</code> based on that information.</li>\n</ul>\n</li>\n<li><strong><code>Verification layer</code>:</strong> The verification layer is responsible for verifying the proofs generated by the shared prover and assisting with the appropriate actions if verification fails. This layer can either be part of the settlement layer or a dedicated layer focused solely on verification.</li>\n</ul>\n<h1><a name=\"h-3-synchronous-atomic-execution-architecture-11\" class=\"anchor\" href=\"https://ethresear.ch#h-3-synchronous-atomic-execution-architecture-11\"></a>3. Synchronous atomic execution architecture</h1>\n<hr>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/e/a/ea8cbd6739d8f45ec741d82a13f6f55f94907b38.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/ea8cbd6739d8f45ec741d82a13f6f55f94907b38\" title=\"SAE_figure3\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/e/a/ea8cbd6739d8f45ec741d82a13f6f55f94907b38_2_690x349.jpeg\" alt=\"SAE_figure3\" data-base62-sha1=\"xsVgev0pCd8U09hhDeFfOLb1CAw\" width=\"690\" height=\"349\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/e/a/ea8cbd6739d8f45ec741d82a13f6f55f94907b38_2_690x349.jpeg, https://ethresear.ch/uploads/default/optimized/3X/e/a/ea8cbd6739d8f45ec741d82a13f6f55f94907b38_2_1035x523.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/e/a/ea8cbd6739d8f45ec741d82a13f6f55f94907b38_2_1380x698.jpeg 2x\" data-dominant-color=\"F0F0F0\"></a></div><br>\n[Figure 3] The process of synchronous atomic execution architecture<p></p>\n<p>The architecture of Radius’s synchronous atomic execution ensures that bundled transactions are executed in an all-or-nothing manner within the same cycle, coordinated by the shared sequencer. Initially, the shared sequencer’s coordination is trusted optimistically, allowing each transaction to be executed independently on its respective rollup. Subsequently, the atomicity of these transactions is verified before the rollup blocks are finalized on L1.</p>\n<p>It can be divided into three main components: <strong>the bundler contract</strong>, <strong>the coordination process</strong>, and <strong>the verification process</strong>. This section will describe each of these components in detail.</p>\n<h2><a name=\"h-1-smart-contract-for-bundle-transaction-radiuss-bundler-contract-12\" class=\"anchor\" href=\"https://ethresear.ch#h-1-smart-contract-for-bundle-transaction-radiuss-bundler-contract-12\"></a>1) Smart <strong>Contract for Bundle Transaction (Radius’s Bundler contract)</strong></h2>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/0/b/0bec5c1463e929939d860e125c34e05cbc6b4c34.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/0bec5c1463e929939d860e125c34e05cbc6b4c34\" title=\"SAE_figure2\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/0/b/0bec5c1463e929939d860e125c34e05cbc6b4c34_2_690x243.jpeg\" alt=\"SAE_figure2\" data-base62-sha1=\"1HtEkouONQUBdF8sbZ5D2nVphFq\" width=\"690\" height=\"243\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/0/b/0bec5c1463e929939d860e125c34e05cbc6b4c34_2_690x243.jpeg, https://ethresear.ch/uploads/default/optimized/3X/0/b/0bec5c1463e929939d860e125c34e05cbc6b4c34_2_1035x364.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/0/b/0bec5c1463e929939d860e125c34e05cbc6b4c34_2_1380x486.jpeg 2x\" data-dominant-color=\"F4F4F4\"></a></div><br>\n[Figure 4] Overview of transaction flow<p></p>\n<p>We introduce a new smart contract called <code>Radius’s bundler contract</code>, designed to handle and process the users’ bundled transactions. It acts as a gateway to execute the users’ intended contracts.</p>\n<p>For example, as shown in the figure, suppose a user creates a bundled transaction that includes calling the Burn function of the rToken contract on Rollup A and the Mint function of the rToken contract on Rollup B. The shared sequencer receives this bundle and wraps it into a transaction that calls the Radius’s bundler contract. Each rollup then processes the transaction through a series of verification via the Radius contract, ultimately executing the user’s intended contract calls.</p>\n<h3><a name=\"key-features-of-the-bundler-contract-13\" class=\"anchor\" href=\"https://ethresear.ch#key-features-of-the-bundler-contract-13\"></a>Key features of the Bundler contract</h3>\n<ul>\n<li>Acts as a gateway smart contract for users to call the actual contracts they intend to execute.</li>\n<li>Allows the shared sequencer to enforce transaction reverts to guarantee the atomicity of the bundle transactions.</li>\n<li>Verifies the legitimacy of transactions initially created by the user.</li>\n<li>Charges transaction fees to users.</li>\n</ul>\n<h3><a name=\"how-is-the-bundler-contract-implemented-14\" class=\"anchor\" href=\"https://ethresear.ch#how-is-the-bundler-contract-implemented-14\"></a>How is the Bundler contract implemented?</h3>\n<p>The Bundler contract includes the following functions:</p>\n<ul>\n<li><code>execute</code>: Called by the shared sequencer, this function executes the user’s transaction after a series of verifications.</li>\n<li><code>deposit</code>: Allows users to deposit transaction fees in advance.</li>\n<li><code>withdraw</code>: Allows users to withdraw their deposited funds.</li>\n<li><code>addWhitelist</code>: Adds a sequencer to the whitelist.</li>\n<li><code>removeWhitelist</code>: Removes a specific sequencer from the whitelist</li>\n</ul>\n<h3><a name=\"how-is-the-execute-function-implemented-15\" class=\"anchor\" href=\"https://ethresear.ch#how-is-the-execute-function-implemented-15\"></a>How is the <code>execute</code> function implemented?</h3>\n<blockquote>\n<p><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/pushpin.png?v=12\" title=\":pushpin:\" class=\"emoji\" alt=\":pushpin:\" loading=\"lazy\" width=\"20\" height=\"20\"> The input parameters for the execute function are as follows:</p>\n<ul>\n<li><code>from</code>: User address</li>\n<li><code>bundle_tx_list</code>: Information of all transactions within the Bundle Tx</li>\n<li><code>index</code>: Current transaction’s index within the <code>bundle_tx_list</code></li>\n<li><code>bundle_tx_signature</code>: User’s signature for the Bundle Tx</li>\n<li><code>revert_flag</code>: Flag for enforcing revert\n<ul>\n<li>The sequencer includes a <strong>“revert_flag”</strong> in the data, which is set by the sequencer to forcibly revert the user’s transaction. If this value is set to true, the Bundler contract will revert the user’s transaction. This mechanism is designed to ensure the atomicity of the transactions defined in the bundle, preventing the execution of the remaining transactions if even one included in the bundle fails to execute.</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<ol>\n<li>Access control:\n<ul>\n<li>Verify that the call is made by a shared sequencer listed in the whitelist.</li>\n</ul>\n</li>\n<li>Check <code>revert_flag</code>:\n<ul>\n<li>If <code>revert_flag</code> == true, forcibly reverts the transaction.</li>\n</ul>\n</li>\n<li>Verify user’s transaction:\n<ul>\n<li>Decode the transaction’s data field.</li>\n<li>Ensure the user’s deposit is greater than the transaction fee.</li>\n<li>Verify the user’s bundled transaction signature.</li>\n<li>Check the Bundle Transaction validity\n<ul>\n<li>(In this scenario) Verify that the values to be minted and burned are identical.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Deduct transaction fee from user’s deposit (Exception handling required for early reverts):\n<ul>\n<li>Transfer the transaction fee to the shared sequencer from the contract’s deposited assets.</li>\n<li>Deduct the transaction fee from the user’s deposit.</li>\n</ul>\n</li>\n<li>Execute user’s intended contract:\n<ul>\n<li>Call the contract that the user intended to execute.</li>\n</ul>\n</li>\n</ol>\n<h2><a name=\"h-2-coordination-process-for-the-shared-sequencer-16\" class=\"anchor\" href=\"https://ethresear.ch#h-2-coordination-process-for-the-shared-sequencer-16\"></a>2) Coordination process for the shared sequencer</h2>\n<p>Radius’s shared sequencing technique separates the roles of sequencing and execution. The shared sequencer is responsible for deciding the block that atomically executes the user’s bundle transactions, while the block is built by each rollup’s executor. Therefore, if it can be ensured that the shared sequencer has coordinated the atomic execution of the bundle transactions and the executor has executed the block as determined by the shared sequencer, synchronous atomic execution is achieved.</p>\n<p>Coordination involves requesting simulations to the full nodes of each rollup for the respective transaction lists, collecting the simulated results, and, if some transactions within the bundle need to be reverted to maintain atomicity, forcibly reverting the remaining transactions to produce a transaction list that will be executed atomically. In other words, if the simulation results of the two transaction defined in the bundle are not the same (i.e., one is a revert and the other is a success), the transaction that yields a successful result is modified by setting its <code>revert_flag</code> to 1 to forcibly revert it. The transaction list is then updated with the modified transaction.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/4/d/4d77403de3cd9cacd9e96500481eda982fd6f53f.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/4d77403de3cd9cacd9e96500481eda982fd6f53f\" title=\"SAE_figure5\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/4/d/4d77403de3cd9cacd9e96500481eda982fd6f53f_2_690x493.jpeg\" alt=\"SAE_figure5\" data-base62-sha1=\"b3ig4ljMV1QnzIgzur7aNEnACcL\" width=\"690\" height=\"493\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/4/d/4d77403de3cd9cacd9e96500481eda982fd6f53f_2_690x493.jpeg, https://ethresear.ch/uploads/default/optimized/3X/4/d/4d77403de3cd9cacd9e96500481eda982fd6f53f_2_1035x739.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/4/d/4d77403de3cd9cacd9e96500481eda982fd6f53f_2_1380x986.jpeg 2x\" data-dominant-color=\"F7F6F6\"></a></div><br>\n[Figure 5] Example of a Simulation Process<p></p>\n<p>After finalizing the block, the shared sequencer commits to it. Later, the block information committed by the shared sequencer can be compared with the block executed by the executor to verify that the executor executed the block as agreed. The atomicity of the bundle transactions can be verified by examining the receipt committed by the executor after building the block, which shows the success status of each transaction and ensures that the shared sequencer did not forcibly revert all transactions. These two processes can be verified off-chain using ZKP systems such as RiscZero or SP1. This process is detailed in section 3.3.</p>\n<h2><a name=\"h-3-verification-process-for-the-shared-prover-17\" class=\"anchor\" href=\"https://ethresear.ch#h-3-verification-process-for-the-shared-prover-17\"></a>3) Verification process for the shared prover</h2>\n<p>We design a zk prover called  “Shared Prover” which allows us to verify that the shared sequencer and executor acted in accordance with the protocol’s intentions. The shared prover generates proof for the <strong>atomicity of the bundle transactions</strong> and their <strong>valid execution result</strong> according to the commitment.</p>\n<p>We leverage the DA layer to facilitate the sharing of the sequencer’s commitments and execution data across different chains. Utilizing the DA layer for data storage offers enhanced transparency and accessibility. Based on the DA (Data Availability) data, it can be confirmed that the user’s bundle transactions were executed atomically, and the validity of the execution result on different chains can be verified.</p>\n<p>The shared sequencer communicates with simulators to finalize the the list of transactions to be performed while ensuring atomicity, and the executor processes this list and then it uploads the resulting data to the DA layer.</p>\n<h3><a name=\"information-stored-in-the-da-18\" class=\"anchor\" href=\"https://ethresear.ch#information-stored-in-the-da-18\"></a>Information stored in the DA</h3>\n<ul>\n<li>\n<p><strong>Shared sequencer’s transactions list commitment</strong></p>\n<p>To settle transaction list, shared sequencer commits the following data with signature to the DA:</p>\n<ul>\n<li><code>chain ID</code></li>\n<li><code>block height</code></li>\n<li><code>transaction MPT root</code></li>\n<li><code>bundle transaction list</code></li>\n</ul>\n</li>\n<li>\n<p><strong>Executed Block data</strong></p>\n<p>After a block is executed on each chain, the entity who executed the block uploads the results to the DA.</p>\n</li>\n</ul>\n<h3><a name=\"atomicity-proofs-shared-sequencers-honesty-19\" class=\"anchor\" href=\"https://ethresear.ch#atomicity-proofs-shared-sequencers-honesty-19\"></a>Atomicity proofs (Shared sequencer’s honesty)</h3>\n<p>The shared prover retrieves the block execution results stored in the DA by the executor. In the atomicity proof, the following aspects are verified using zero-knowledge proofs:</p>\n<ul>\n<li>\n<p><strong>All-or-Nothing execution</strong></p>\n<ul>\n<li>\n<p>The receipt status for the bundle transactions must have the same value.</p>\n<p><span class=\"math\">\\text{assert!} (\\text{receipt}(\\text{tx}_A).\\text{status} = \\text{receipt}(\\text{tx}_B).\\text{status})</span></p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Prevention of arbitrary manipulation of the shared sequencer’s revert flag</strong></p>\n<ul>\n<li>\n<p>There is a potential attack where a valid bundled transaction is reverted entirely, collecting fees from the user without executing the transaction. To prevent this, the atomicity proof checks that not all revert flags for the transactions are set to 1.</p>\n</li>\n<li>\n<p>Therefore, revert flags cannot be set to 1 simultaneously.</p>\n<p><span class=\"math\">\\text{assert!}(\\text{tx}_A.\\text{revert_flag} \\times \\text{tx}_B.\\text{revert_flag} = 0)</span></p>\n</li>\n</ul>\n</li>\n</ul>\n<h3><a name=\"proof-of-rollup-executors-honesty-20\" class=\"anchor\" href=\"https://ethresear.ch#proof-of-rollup-executors-honesty-20\"></a>Proof of Rollup executor’s honesty</h3>\n<p>To verify that the executor has honestly executed the block according to the transaction list committed by the shared sequencer, the shared prover also includes the relationship between the values committed by the shared sequencer and the MPT root of the transactions uploaded by the executor.</p>\n<h1><a name=\"h-4-security-analysis-21\" class=\"anchor\" href=\"https://ethresear.ch#h-4-security-analysis-21\"></a>4. Security analysis</h1>\n<hr>\n<ul>\n<li><strong>Individual Transaction Validity</strong>: The validity of individual transactions (e.g., insufficient user’s balance) is verified by the Bundler Contract, and transactions will fail if they do not pass this check.</li>\n<li><strong>Bundle Transaction Validity</strong>: The validity of the bundled transaction (e.g., discrepancy between mint and burn amounts) is also verified by the Bundler Contract, and the bundle will fail if it does not pass this check.</li>\n<li><strong>Atomicity of Successful Bundle Transactions</strong>: The shared sequencer is responsible for ensuring the atomicity of successfully executed bundled transactions. The honesty of the shared sequencer is verified by the shared prover and the verification layer.</li>\n<li><strong>Honesty of the Executor</strong>: If the shared sequencer has legitimately determined and committed the blocks for each rollup, the honesty of the executor is verified by the shared prover and the verification layer.</li>\n<li><strong>Prevention of Manipulation</strong>: Additionally, neither the shared prover nor the rollup executor can manipulate the user’s bundle transaction. The user’s signature prevents such tampering.</li>\n<li><strong>Integrity of Proofs and Verification</strong>: The shared prover and the verification layer perform proofs and verification based on authenticated data available in the Data Availability (DA) layer. As a result, they cannot alter the proof content. The worst they can do is to withhold performance.</li>\n</ul>\n            <p><small>2 posts - 2 participants</small></p>\n            <p><a href=\"https://ethresear.ch/t/cross-rollup-synchronous-atomic-execution/20193\">Read full topic</a></p>","link":"https://ethresear.ch/t/cross-rollup-synchronous-atomic-execution/20193","pubDate":"Thu, 01 Aug 2024 08:57:29 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20193"},"source":{"@url":"https://ethresear.ch/t/cross-rollup-synchronous-atomic-execution/20193.rss","#text":"Cross-rollup Synchronous Atomic Execution"}},{"title":"Preconfirmation Bidding Increased Block Values on Holesky","dc:creator":"Evan-Kim2028","category":"Data Science","description":"<h1><a name=\"tldr-1\" class=\"anchor\" href=\"https://ethresear.ch#tldr-1\"></a>TLDR</h1>\n<ul>\n<li>Since July 10, mev-commit 0.4.3 has enabled over 800 execution preconfirmations on Holesky, with increasing network participation.</li>\n<li>Providers issued 807 preconfirmations across 415 blocks. Bidders sent 4.24 ETH worth of bids.</li>\n<li>Average mev-commit block value was 0.0093 ETH compared to 0.0044 ETH for a vanilla block.</li>\n<li>Average total preconfirmation bids per mev-commit block was 0.0049 ETH, slightly higher than the average priority fees in the mev-commit block of 0.0045 ETH.</li>\n<li>Data shows that preconf bids contribute significantly to overall block value, despite limited participation for the nascent network.</li>\n</ul>\n<h1><a name=\"overview-2\" class=\"anchor\" href=\"https://ethresear.ch#overview-2\"></a>Overview</h1>\n<p>Since July 10, mev-commit 0.4.3 has been facilitating execution preconfirmations on Holesky tesnet. There has been an upwards trend of participation with currently 1 relay, 3 providers, 9 bidders, and <a href=\"https://validators.mev-commit.xyz/\" rel=\"noopener nofollow ugc\">27,000 validators</a> participating. From July 10 to July 29 (Holesky block range 1902173 to 2027932), providers have issued 807 preconfirmations across 415 Holesky blocks. Some examples of preconfirmation blocks:</p>\n<ul>\n<li><a href=\"https://holesky.etherscan.io/block/1943039\" rel=\"noopener nofollow ugc\">1943039</a> with 21 preconfs and .016 ETH worth of bids</li>\n<li><a href=\"https://holesky.etherscan.io/block/1986732\" rel=\"noopener nofollow ugc\">1986732</a> with 7 preconfs and .04 ETH worth of bids</li>\n<li><a href=\"https://holesky.etherscan.io/block/1986963\" rel=\"noopener nofollow ugc\">1986963</a> with 5 preconfs and .022 ETH worth of bids</li>\n</ul>\n<p>There are two caveats to these initial results. The first is that network participation is still growing. As more actors onboard or opt in to the network, the flow of preconfs is likely to increase. The second caveat is that Holesky does not have the same competitive use cases for preconfs as mainnet, and does not mirror mainnet Ethereum transacting behavior as closely as desired.</p>\n<p>The notebook used for analytics <a href=\"https://github.com/Evan-Kim2028/preconf_analytics/blob/e6fdb9886c600315d531b59cb13e6efccc7d56bd/notebooks/preconfs.ipynb\" rel=\"noopener nofollow ugc\">can be found here</a>. The data for these results can be replicated using the <a href=\"https://github.com/primev/mev_commit_sdk_py\" rel=\"noopener nofollow ugc\">mev-commit-sdk-py</a> repository to collect mev-commit events powered by Hypersync indexer. There is also <a href=\"http://explorer.testnet.mev-commit.xyz/app/discover\" rel=\"noopener nofollow ugc\">an explorer</a>, which is currently in development.</p>\n<h1><a name=\"bidding-behavior-3\" class=\"anchor\" href=\"https://ethresear.ch#bidding-behavior-3\"></a>Bidding Behavior</h1>\n<p>We observe 815 preconfirmation transactions, indicating a niche but valuable market segment compared to 4 million regular transactions. This significant difference suggests preconfs are currently used by a smaller subset of users who are testing preconfirmations.</p>\n<p>A total of 9 bidders participated, sending 4.24 ETH in bids compared to 0.13 ETH in priority fees, with an average preconfirmation bid of 0.005 ETH versus 0.00016 ETH for priority fees on the same transaction, indicating a heavier bidding preference for preconfirmations over priority fees.<br>\n</p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/0/4/04d6296e99153e73f2e018b8c21b727582d0c89e.png\" data-download-href=\"https://ethresear.ch/uploads/default/04d6296e99153e73f2e018b8c21b727582d0c89e\" title=\"image\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/0/4/04d6296e99153e73f2e018b8c21b727582d0c89e_2_563x500.png\" alt=\"image\" data-base62-sha1=\"GMKt8FrnwQuZOK2nZOerrm5xPE\" width=\"563\" height=\"500\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/0/4/04d6296e99153e73f2e018b8c21b727582d0c89e_2_563x500.png, https://ethresear.ch/uploads/default/original/3X/0/4/04d6296e99153e73f2e018b8c21b727582d0c89e.png 1.5x, https://ethresear.ch/uploads/default/original/3X/0/4/04d6296e99153e73f2e018b8c21b727582d0c89e.png 2x\" data-dominant-color=\"E2E5F5\"></a></div><p></p>\n<p>Overall, priority fees totaled 544 ETH with the average preconfirmation bid being 0.0049 ETH, slightly higher than the average priority fee of 0.0045 ETH.</p>\n<h1><a name=\"block-value-4\" class=\"anchor\" href=\"https://ethresear.ch#block-value-4\"></a>Block Value</h1>\n<p>We hypothesized that preconfs would add an increase in block value, resulting in higher validator rewards per mev-commit block. On average, we observe 1.95 preconfirmation transactions per block compared to 42.3 total transactions. Average mev-commit block value was 0.0093 ETH compared to 0.0044 ETH for a vanilla block.</p>\n<p><img src=\"https://ethresear.ch/uploads/default/original/3X/d/9/d97a557eefe85c83cef80122c55b8695d60307b1.png\" alt=\"image\" data-base62-sha1=\"v1TI2Nvm8aPn7KBQkY6u4YweQs9\" width=\"542\" height=\"474\"></p>\n<p>One limitation in comparing mev-commit blocks to vanilla Holesky blocks is that there are only ~400 mev-commit blocks compared to ~50,000 Holesky blocks. This is primarily due to the nascent mev-commit network participation rates. Additionally the average bid amount at 0.005 ETH seems on the higher side for Holesky blocks and may not accurately reflect mainnet amounts. However accurately pricing preconfirmations is a difficult task and has to be balanced with the presence of mev spikes on mainnet that can greatly skew results. We are actively researching how to price preconfirmations more effectively.</p>\n<p>We illustrate the block revenue breakdown over several days in the chart below for mev-commit blocks, showing the breakdown between preconfirmation bids and priority fees:</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/c/0/c04ec97bff2be44d3e1f79915157487def6eb685.png\" data-download-href=\"https://ethresear.ch/uploads/default/c04ec97bff2be44d3e1f79915157487def6eb685\" title=\"image\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/c/0/c04ec97bff2be44d3e1f79915157487def6eb685_2_690x409.png\" alt=\"image\" data-base62-sha1=\"rretr7OQhAPC33Y6NOinTJKlrSJ\" width=\"690\" height=\"409\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/c/0/c04ec97bff2be44d3e1f79915157487def6eb685_2_690x409.png, https://ethresear.ch/uploads/default/original/3X/c/0/c04ec97bff2be44d3e1f79915157487def6eb685.png 1.5x, https://ethresear.ch/uploads/default/original/3X/c/0/c04ec97bff2be44d3e1f79915157487def6eb685.png 2x\" data-dominant-color=\"F2EEEB\"></a></div><p></p>\n<p>Preconfirmation bids significantly contributed to increasing block value. On days such as July 11th, 18th, and 24th, preconfirmation bids markedly boosted total block value, highlighting their substantial impact.</p>\n<p>The charts below illustrate an outsized impact that preconfirmation bids on block value:</p>\n<ul>\n<li><strong>Preconf Bids per Block</strong>: Despite a smaller number of transactions, preconfirmation bids are consistently higher, often reaching up to 0.02 ETH.</li>\n<li><strong>Priority Fees per Block</strong>: While more frequent, priority fees are generally lower, seldom exceeding 0.01 ETH.</li>\n</ul>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/4/3/43fe06dfdd10788ec3344bc9e8592e3773cf34a6.png\" data-download-href=\"https://ethresear.ch/uploads/default/43fe06dfdd10788ec3344bc9e8592e3773cf34a6\" title=\"image\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/4/3/43fe06dfdd10788ec3344bc9e8592e3773cf34a6_2_690x312.png\" alt=\"image\" data-base62-sha1=\"9HueUEehY9LRUy9vWq2rczt99Vc\" width=\"690\" height=\"312\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/4/3/43fe06dfdd10788ec3344bc9e8592e3773cf34a6_2_690x312.png, https://ethresear.ch/uploads/default/original/3X/4/3/43fe06dfdd10788ec3344bc9e8592e3773cf34a6.png 1.5x, https://ethresear.ch/uploads/default/original/3X/4/3/43fe06dfdd10788ec3344bc9e8592e3773cf34a6.png 2x\" data-dominant-color=\"DDE8F2\"></a></div><p></p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/1/0/1078d70fc113dfd6d3a0d5a291ef56a81a12f361.png\" data-download-href=\"https://ethresear.ch/uploads/default/1078d70fc113dfd6d3a0d5a291ef56a81a12f361\" title=\"image\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/1/0/1078d70fc113dfd6d3a0d5a291ef56a81a12f361_2_690x317.png\" alt=\"image\" data-base62-sha1=\"2lIxmTkri3RHFlLatO9KiCOQ7ct\" width=\"690\" height=\"317\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/1/0/1078d70fc113dfd6d3a0d5a291ef56a81a12f361_2_690x317.png, https://ethresear.ch/uploads/default/original/3X/1/0/1078d70fc113dfd6d3a0d5a291ef56a81a12f361.png 1.5x, https://ethresear.ch/uploads/default/original/3X/1/0/1078d70fc113dfd6d3a0d5a291ef56a81a12f361.png 2x\" data-dominant-color=\"D4E4F0\"></a></div><p></p>\n<p>A notable example is block <a href=\"https://holesky.etherscan.io/block/1943039\" rel=\"noopener nofollow ugc\">1943039</a>, which had the highest number of preconfs with 21 out of 48 transactions. In this block, preconf bid revenue was 0.008 ETH, vastly outpacing the 0.0009 ETH from priority fees.</p>\n<p>These observations demonstrate that even a few preconfirmation transactions can substantially enhance block value due to their higher bid amounts.</p>\n<h1><a name=\"limitations-5\" class=\"anchor\" href=\"https://ethresear.ch#limitations-5\"></a>Limitations</h1>\n<p>As mentioned earlier, the caveats to our initial findings is that Holesky is a testnet and does not have the same types of competitive opportunities as Mainnet. Users tend to have less urgency on Holesky and this is reflected in smaller block sizes and lower priority fees.</p>\n<p>As a result, the preconf bids may not have the same relationship to priority fees on mainnet compared to testnet and may not accurately reflect the user’s true bidding preferences since testnet tokens are being used.</p>\n<h1><a name=\"closing-remarks-6\" class=\"anchor\" href=\"https://ethresear.ch#closing-remarks-6\"></a>Closing Remarks</h1>\n<p>This report initially touches on some preconfirmation bidding behavior observed through early mev-commit usage and offers insights into how preconf bids can increase validator rewards. We plan to follow up with a more detailed report on mev-commit protocol details such as the decay mechanism, rewards and slashing, settlement process, and revenue.</p>\n<p>We plan to onboard more bidders, providers and validators into the mev-commit ecosystem and conduct more tests in an environment that mimics mainnet more closely. We invite you to participate starting at <a href=\"https://docs.primev.xyz/get-started/welcome-to-primev\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">Welcome to Primev - Documentation</a></p>\n            <p><small>10 posts - 5 participants</small></p>\n            <p><a href=\"https://ethresear.ch/t/preconfirmation-bidding-increased-block-values-on-holesky/20190\">Read full topic</a></p>","link":"https://ethresear.ch/t/preconfirmation-bidding-increased-block-values-on-holesky/20190","pubDate":"Thu, 01 Aug 2024 02:58:46 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20190"},"source":{"@url":"https://ethresear.ch/t/preconfirmation-bidding-increased-block-values-on-holesky/20190.rss","#text":"Preconfirmation Bidding Increased Block Values on Holesky"}},{"title":"Affiliated AMMs and permissionless solving for uniform price batch auctions","dc:creator":"sergioyuhjtman","category":"Decentralized exchanges","description":"<p>The idea of mitigating MEV through batch auctions is as old as the concept of MEV itself. They can both be traced back to <a href=\"https://www.reddit.com/r/ethereum/comments/2d84yv/miners_frontrunning/\" rel=\"noopener nofollow ugc\">this Reddit post</a> from August 2014<sup class=\"footnote-ref\"><a href=\"https://ethresear.ch#footnote-49420-1\" id=\"footnote-ref-49420-1\">[1]</a></sup>. Today, ten years later, this is still an ongoing discussion (see for instance <a href=\"https://ethresear.ch#references\">[UNIX]</a>, <a href=\"https://ethresear.ch#references\">[COW]</a>). To what extent can we reduce MEV by using batch auctions? Can we build batch auction protocols that are better than those existing today? In this article we propose an optimistic point of view for the first question and a candidate affirmative answer to the second question through concrete mechanisms.</p>\n<p><strong>Note:</strong> This article was primarily conceived while working at Flashbots Research for a year spanning 2023 and 2024. Special thanks to Christoph Schlegel.</p>\n<p>The article assumes that the reader is familiar with the concepts of MEV, batch auctions and AMMs in the context of decentralized exchange (DEX).</p>\n<h3><a name=\"a-cooperative-endeavour-between-traders-1\" class=\"anchor\" href=\"https://ethresear.ch#a-cooperative-endeavour-between-traders-1\"></a>A cooperative endeavour between traders</h3>\n<p>In the long term, on-chain traders will use those DEX protocols that are most convenient for them. Ideally, they would trade at market prices with no fee other than the gas cost, equalling the gas price of a transfer. Even though Ethereum’s reality is far from this, in my opinion we shouldn’t rush to dismiss the possibility. Carefully designed smart contracts jointly with off-chain mechanisms might help traders get close to this ideal<sup class=\"footnote-ref\"><a href=\"https://ethresear.ch#footnote-49420-2\" id=\"footnote-ref-49420-2\">[2]</a></sup>. It is likely that these clever designs are not out there yet.</p>\n<p>A very powerful idea is that the smart contract that settles trade orders does so in batches, enforcing uniform clearing prices. This has two fundamental properties:</p>\n<p>(a) The execution does not depend on the ordering of the trade orders.</p>\n<p>(b) Uniform clearing prices ensure that a user trading in one direction receives the same price as the other users trading in that same direction, and is a direct counterpart to the users trading in the other directions, with no room for intermediaries between them.</p>\n<p>The most famous (or even the only) live system implementing this mechanism on a blockchain is CoW protocol <a href=\"https://ethresear.ch#references\">[COW]</a> (see also <a href=\"https://ethresear.ch#references\">[SPEEDEX]</a>). Unfortunately, the sole existence of a uniform price batch auction mechanism is not enough to reach the ideal situation described above. MEV occurs through the reordering, censoring, or insertion of data by a privileged player. While according to (a) reordering trade orders has no effect in our case, it is still possible that privileged players censor and insert data. As a matter of fact, for the players who write a transaction or a block, it will always be physically possible to ignore some data and to include their own data, maybe even pretending that this new data was produced by someone else. Therefore, here we will simply abandon the search of a protocol that logically guarantees no censorship nor privileged insertions. Nevertheless, we will not rule out the possibility of a mechanism such that in normal market conditions and assuming wide adoption, the privileged players will be incentivized not to censor, and enjoy only a marginal advantage from last moment inclusions.</p>\n<p>While CoW protocol has achieved an interesting degree of adoption, it represents only a small fraction of Ethereum DEX activity —<a href=\"https://defillama.com/aggregators/chains/ethereum\" rel=\"noopener nofollow ugc\">around 1% these days</a>. CoW runs a centralized solving protocol.</p>\n<h3><a name=\"uniform-clearing-prices-and-walrasian-equilibrium-2\" class=\"anchor\" href=\"https://ethresear.ch#uniform-clearing-prices-and-walrasian-equilibrium-2\"></a>Uniform clearing prices and Walrasian equilibrium</h3>\n<p>A trade order can be understood as a mathematical function of the clearing prices. The output of the function is the traded amounts for each asset. Given a set of trade orders, there is typically only a limited set of valid clearing price vectors, maybe even only one. This situation perfectly corresponds to the concept of Walrasian equilibrium in a pure exchange market (see <a href=\"https://ethresear.ch#references\">[RGGM]</a>, <a href=\"https://ethresear.ch#references\">[FY]</a> and references therein). A Walrasian equilibrium is a vector of prices at which the supply of each good equals the demand for that good.</p>\n<p>Under very mild hypothesis, we can guarantee the existence of at least one equilibrium. The computational problem of finding equilibrium price vectors translates to the search of fixed points of a certain mapping.</p>\n<h3><a name=\"affiliated-amms-3\" class=\"anchor\" href=\"https://ethresear.ch#affiliated-amms-3\"></a>Affiliated AMMs</h3>\n<p>Decentralized exchange predominantly occurs through automated market makers (AMMs). Many researchers and industry actors have pointed out that AMM liquidity providers (LPs) typically receive worse prices than what the market has to offer at each time. This phenomenon is usually referred to as loss vs. rebalancing (LVR) and described as MEV suffered by the liquidity providers <a href=\"https://ethresear.ch#references\">[LVR]</a>, <a href=\"https://ethresear.ch#references\">[WLVR]</a>.</p>\n<p>There is a natural mechanism to attack this issue that no one seems to have considered yet<sup class=\"footnote-ref\"><a href=\"https://ethresear.ch#footnote-49420-3\" id=\"footnote-ref-49420-3\">[3]</a></sup>. Special AMMs may participate in a uniform price batch auction just like any other trader. These would be the affiliated AMMs. They would allow certain swaps depending on their state and execution price, only admitting the price from the batch. We can think of the allowed swaps as preprogrammed trade orders. To implement this, the contract that executes batches should be prepared to call affiliated swaps passing the batch prices. From now on, let us call <em>W</em> the smart contract that executes batches, i.e. the main contract of the system under consideration. Specially designed affiliated AMMs may be added <em>a posteriori</em> following specifications determined by the <em>W</em> contract<sup class=\"footnote-ref\"><a href=\"https://ethresear.ch#footnote-49420-4\" id=\"footnote-ref-49420-4\">[4]</a></sup>. It is possible that affiliated AMMs benefit by only allowing swaps coming from <em>W</em>. However, we do not need to discuss it at this point: the scheme allows to decouple the problem of choosing a specific AMM design. A multiplicity of them may coexist, and liquidity migration can happen seamlessly at any time. The existence of multiple AMMs affiliated to the same <em>W</em> contract does not entail liquidity fragmentation.</p>\n<p>Assuming wide adoption of the <em>W</em> contract and low incidence of censorship, we have clearing prices that are actual market prices, thus mitigating LVR and MEV.</p>\n<p>\n<br>\n</p><p><img src=\"https://ethresear.ch/uploads/default/original/3X/4/8/4824aef76acd0078806fd0c5418d95c44555a648.png\" data-base62-sha1=\"aicYfI24TxpRpYbEBhFkMxm5CYg\" alt=\"diagram\" width=\"642\" height=\"451\"></p>\n<p></p>\n<h3><a name=\"permissionless-solving-4\" class=\"anchor\" href=\"https://ethresear.ch#permissionless-solving-4\"></a>Permissionless solving</h3>\n<p>Once we have truly accepted that we cannot enforce censorship resistance for trade orders at code level, we may reasonably conjecture that the best we can do is to open the gates as much as possible in order to minimize censorship and democratize the system. The proposal is to let <em>W</em> allow anyone to execute a batch, as long as there are no price inconsistencies within each block. The block proposers, as always, will exercise their right to choose the transactions they prefer, possibly through a PBS mechanism <a href=\"https://ethresear.ch#references\">[PBS]</a>, <a href=\"https://ethresear.ch#references\">[MEV-BOOST]</a>. This feature achieves the maximum degree of decentralization possible at smart contract level for a batch auction system. The auction will occur at block building level. This is analogous to the usual permissionless access to AMMs, which is only regulated by the PBS apparatus or whatever mechanism adopted by the block proposers. Another example is UniswapX: their reactors allow anyone to be a <a href=\"https://docs.uniswap.org/contracts/uniswapx/guides/createfiller\" rel=\"noopener nofollow ugc\">filler</a>, though they don’t enforce uniform clearing prices.</p>\n<p>Let us explain why it is reasonable to expect that this mechanism will work well, i.e., that potential price manipulations by censoring orders are expected to be under control. The flow of the reasoning is as follows. We will first imagine the system flourished, running a large portion of Ethereum’s DEX volume. We will try to visualize this scenario and assess whether it is stable or if we should expect frequent price manipulations. Let us list some properties of the flourished scenario:</p>\n<p><strong>(1)</strong> Since there are many important tokens on Ethereum blockchain, we expect to have a main cluster of several tokens interconnected by swaps at each batch. This is desirable because it means the liquidity in one pair can benefit traders in other pairs (e.g., an order in pair A/B can be settled against orders in pairs B/C and C/A).</p>\n<p><strong>(2)</strong> By looking at how prices vary, it turns out that very-short-term volatility is easy to estimate. Only as an example, on a normal day the price of ETH measured in USD typically varies less than 0.1% in a 12s period, with some larger jumps occasionally. Uninformed traders may use this kind of magnitude for the slippage tolerance. Furthermore, public tools that monitor real time price movements can aid users to reduce the slippage tolerance depending on their preferences. Meanwhile, informed traders doing statistical arbitrage or plain arbitrage are expected to use very low values for the slippage tolerance when trading liquid assets. This will set a tight bound on the bounty that a malicious solver can obtain by deviating the price.</p>\n<p><strong>(3)</strong> We may assume the existence of honest solvers. As usual, the batch that generates more income for the block proposer should make it to the chain. Honest solvers will aim to maximize that income by maximizing inclusion. They will frequently need to discard some orders for various reasons, such as limited block space, or computation deadlines. As a result, we will often have more than one honest proposed batch. Trusted execution environments can be useful in increasing the transparency of honest solvers.</p>\n<p>When a malicious solver tries to manipulate the price, they have to beat the best honest solution. To this end, they will censor every order in one direction for a given pair A/B exceeding certain price threshold. By doing so, they will not only miss out on the gas fees of the censored orders, but also on orders in other pairs due to operating away from the market equilibrium prices (recall (1)). Because of this and (2) it is possible that in most cases it will not be profitable to manipulate the prices of the batch. In addition, we may have other off-chain mechansims to further prevent malicious solving. One such mechanism can be to use private channels between traders and honest solvers in certain cases.</p>\n<h3><a name=\"mev-a-zoom-out-analysis-5\" class=\"anchor\" href=\"https://ethresear.ch#mev-a-zoom-out-analysis-5\"></a>MEV: a zoom-out analysis</h3>\n<p>Total MEV extraction from Ethereum has been stable during the last two years, at levels above 250 kETH per year<sup class=\"footnote-ref\"><a href=\"https://ethresear.ch#footnote-49420-5\" id=\"footnote-ref-49420-5\">[5]</a></sup>. During this period, there haven’t been many innovations generating optimism about MEV reduction. This has led many people to believe that such levels of MEV are inevitable. The fundamental economic reason for the existence of MEV can be summarized by the concept of block proposer monopoly. If traders want to improve their situation, they need to coordinate by adopting a mechanism that gives them more bargaining power, a trade union. This is the principle underlying the concrete proposals presented here. A system that integrates the different types of liquidity and unifies the execution prices helps traders coordinate their orders around true market prices as described in (2).</p>\n<p>Reducing the incidence of MEV would be a great achievement, since it would allow the DEX volume to grow. On-chain trading would become more convenient than centralized alternatives in many cases, thus increasing the global value of the blockchain.</p>\n<h3><a name=\"final-remarks-6\" class=\"anchor\" href=\"https://ethresear.ch#final-remarks-6\"></a>Final remarks</h3>\n<p>(I) The above description of <em>W</em> is incomplete. Possibly the most important undefined aspect is how to cover gas and trade fees (by <em>gas fee</em> we mean the cost of gas usage as if it were a transfer). What kind of regulations should <em>W</em> implement regarding the operational cost or trade fees? Can the system work well at zero trade fee? See footnote [2]. These questions don’t seem very easy to answer. Fortunately, we will be able to continue iterating theory and practice.</p>\n<p>(II) If there are non-affiliated AMMs coexisting with <em>W</em>, the solvers of <em>W</em> can extract profit from them. Every time there is a price movement, it will be possible to find surplus-generating solutions. To find them, they need to consider non-affiliated AMMs as virtual agents of the batch, following a procedure explained in <a href=\"https://ethresear.ch#references\">[FY]</a>. This mathematical fact should act as an attractor of liquidity from traditional to affiliated AMMs.</p>\n<h3><a name=\"references-7\" class=\"anchor\" href=\"https://ethresear.ch#references-7\"></a>References</h3>\n<p><strong>[COW]</strong> CoW protocol, <a href=\"https://docs.cow.fi/cow-protocol\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">CoW Protocol | CoW Protocol Documentation</a>;</p>\n<p>Felix Leupold, <em>Gnosis Protocol v2 Fighting the MEV Crisis with Batch Auctions one CoW at a time</em>, <a href=\"https://www.youtube.com/watch?v=6MfcZGVeQsQ\" rel=\"noopener nofollow ugc\">https://www.youtube.com/watch?v=6MfcZGVeQsQ</a></p>\n<p><strong>[CF]</strong> Andrea Canidio, Robin Fritsch, <em>Arbitrageurs’ profits, LVR, and sandwich attacks: batch trading as an AMM design response</em>, <a href=\"https://arxiv.org/abs/2307.02074\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">[2307.02074] Arbitrageurs' profits, LVR, and sandwich attacks: batch trading as an AMM design response</a></p>\n<p><strong>[FB2]</strong> Philip Daian, Steven Goldfeder, Tyler Kell, Yunqi Li, Xueyuan Zhao, Iddo Bentov, Lorenz Breidenbach, Ari Juels, <em>Flash Boys 2.0: Frontrunning, Transaction Reordering, and Consensus Instability in Decentralized Exchanges</em> <a href=\"https://arxiv.org/abs/1904.05234\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">[1904.05234] Flash Boys 2.0: Frontrunning, Transaction Reordering, and Consensus Instability in Decentralized Exchanges</a></p>\n<p><strong>[FY]</strong> Sergio Yuhjtman, Flashbots, <em>Walraswap: a solution to uniform price batch auctions</em>, <a href=\"https://arxiv.org/abs/2310.12255\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">[2310.12255] Walraswap: a solution to uniform price batch auctions</a></p>\n<p><strong>[LVR]</strong> Jason Milionis, Ciamac C. Moallemi, Tim Roughgarden, Anthony Lee Zhang, <em>Automated Market Making and Loss-Versus-Rebalancing</em>, <a href=\"https://arxiv.org/pdf/2208.06046\" rel=\"noopener nofollow ugc\">https://arxiv.org/pdf/2208.06046</a></p>\n<p><strong>[MEV-BOOST]</strong> Flashbots, <em>MEV-Boost in a Nutshell</em>, <a href=\"https://boost.flashbots.net/\" rel=\"noopener nofollow ugc\">https://boost.flashbots.net/</a></p>\n<p><strong>[PBS]</strong> Ethereum Foundation, <em>Proposer-builder separation</em>, <a href=\"https://ethereum.org/en/roadmap/pbs/\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">Proposer-builder separation | ethereum.org</a></p>\n<p><strong>[RGGM]</strong> Geoffrey Ramseyer, Mohak Goyal, Ashish Goel, David Mazières,</p>\n<p><em>Augmenting Batch Exchanges with Constant Function Market Makers</em>, <a href=\"https://arxiv.org/abs/2210.04929\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">[2210.04929] Augmenting Batch Exchanges with Constant Function Market Makers</a></p>\n<p><strong>[SPEEDEX]</strong> Geoffrey Ramseyer, Ashish Goel, and David Mazières, <em>SPEEDEX: A Scalable, Parallelizable, and Economically Efficient Decentralized EXchange</em>, <a href=\"https://www.usenix.org/conference/nsdi23/presentation/ramseyer\" rel=\"noopener nofollow ugc\">https://www.usenix.org/conference/nsdi23/presentation/ramseyer</a>, <a href=\"https://stellar.org/blog/developers/building-speedex-a-novel-design-for-decentralized-exchanges\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">Stellar | Building SPEEDEX – A Novel Design for a Scalable Decentralized Exchange</a></p>\n<p><strong>[UNIX]</strong> Hayden Adams, Noah Zinsmeister, Mark Toda, Emily Williams, Xin Wan, Matteo Leibowitz, Will Pote, Allen Lin, Eric Zhong, Zhiyuan Yang, Riley Campbell, Alex Karys, Dan Robinson, <em>UniswapX</em> <a href=\"https://uniswap.org/whitepaper-uniswapx.pdf\" rel=\"noopener nofollow ugc\">https://uniswap.org/whitepaper-uniswapx.pdf</a></p>\n<p><strong>[WLVR]</strong> Cow DAO, <em>What is Loss-Versus-Rebalancing (LVR)?</em>, <a href=\"https://cow.fi/learn/what-is-loss-versus-rebalancing-lvr\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">What is Loss-Versus-Rebalancing (LVR)? - CoW DAO</a></p>\n<hr class=\"footnotes-sep\">\n\n<ol class=\"footnotes-list\">\n<li id=\"footnote-49420-1\" class=\"footnote-item\"><p>Though the origin of the name MEV and its systematic study started at <a href=\"https://ethresear.ch#references\">[FB2]</a>. <a href=\"https://ethresear.ch#footnote-ref-49420-1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"footnote-49420-2\" class=\"footnote-item\"><p>An example of a scenario close to this ideal is to allow a small trade fee that is sublinear in the traded amount. <a href=\"https://ethresear.ch#footnote-ref-49420-2\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"footnote-49420-3\" class=\"footnote-item\"><p>The same general approach can be found in <a href=\"https://ethresear.ch#references\">[CF]</a>, as is apparent from the title. However the concrete mechanism described there is different from the one proposed here. Additionally, <a href=\"https://ethresear.ch#references\">[RGGM]</a> studies uniform price batches where AMMs swap at the prices of the batch. <a href=\"https://ethresear.ch#footnote-ref-49420-3\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"footnote-49420-4\" class=\"footnote-item\"><p>This can be implemented without calling ERC20 approvals between contracts. <a href=\"https://ethresear.ch#footnote-ref-49420-4\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"footnote-49420-5\" class=\"footnote-item\"><p>Most of the extracted MEV is being distributed through MEV-BOOST. See some numbers at <a href=\"https://mevboost.pics/\" rel=\"noopener nofollow ugc\">https://mevboost.pics/</a> and <a href=\"https://eigenphi.io/\" rel=\"noopener nofollow ugc\">https://eigenphi.io/</a>. <a href=\"https://ethresear.ch#footnote-ref-49420-5\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n            <p><small>7 posts - 3 participants</small></p>\n            <p><a href=\"https://ethresear.ch/t/affiliated-amms-and-permissionless-solving-for-uniform-price-batch-auctions/20187\">Read full topic</a></p>","link":"https://ethresear.ch/t/affiliated-amms-and-permissionless-solving-for-uniform-price-batch-auctions/20187","pubDate":"Wed, 31 Jul 2024 22:17:33 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20187"},"source":{"@url":"https://ethresear.ch/t/affiliated-amms-and-permissionless-solving-for-uniform-price-batch-auctions/20187.rss","#text":"Affiliated AMMs and permissionless solving for uniform price batch auctions"}},{"title":"Ethereum + Industry of Integrations (IOI)","dc:creator":"knev","category":"Layer 2","description":"<p>(This is my first post here, so I hope that I have not missed any protocol)</p>\n<p>I’ve been integrating systems using IPSME, which lead to the Industry of Integrations concept <a href=\"https://root-interface.se/IOI\" rel=\"noopener nofollow ugc\">IOI</a>. IPSME defines an evolutionary architecture for integrations developed by the community.</p>\n<p>Demos of my work can be found here:<br>\n            <iframe src=\"https://www.youtube.com/embed/videoseries?list=PLc_eusB5PhcwzCIWFj3iLxlaRTBSEEIEG&amp;wmode=transparent&amp;rel=0&amp;autohide=1&amp;showinfo=1&amp;enablejsapi=1\" width=\"480\" height=\"360\" frameborder=\"0\" allowfullscreen=\"\" class=\"youtube-onebox\" seamless=\"seamless\" sandbox=\"allow-same-origin allow-scripts allow-forms allow-popups allow-popups-to-escape-sandbox allow-presentation\"></iframe>\n</p>\n<p>The concept of the IOI is such that: if any two system interfaces (APIs) are known and accessible, that (via the conventions of <a href=\"https://ipsme.dev\" rel=\"noopener nofollow ugc\">IPSME</a>) a translation can be created integrating the two APIs …​ And! That that translation can be monetized.</p>\n<p>The Ethereum blockchain is often linked to Oracles or Oracles services that are off-chain. AFAIK, Ethereum already support a pubsub (the basis for IPSME). The question is then if an IOI can be created within the Ethereum network. Namely, can integrations to external services be smart contracts so that integrations are on-chain and are re-usable by other developers. Is it possible that smart contract integration contains the logic so that the original developer can possibly monetize off building the integration. If the integrations can be reused, then the complexity for integrating with external systems can be reduced through the property of transitivity i.e., if A integrates with B and B with C, then A is integrated with C.</p>\n<p>I’m interested in doing exploratory research to see if IOI can be applied to Web3. I would like to ask here:</p>\n<ul>\n<li>Does this idea sound feasible with the Ethereum network?</li>\n<li>Are smart contacts powerful enough for protocol communication?</li>\n<li>Is it correct that Ethereum supports pubsub and can it be utilized for this?</li>\n<li>Would this idea alleviate the need for Oracle services/networks?</li>\n</ul>\n<p>I’m looking forward to your feedback.</p>\n            <p><small>7 posts - 2 participants</small></p>\n            <p><a href=\"https://ethresear.ch/t/ethereum-industry-of-integrations-ioi/20167\">Read full topic</a></p>","link":"https://ethresear.ch/t/ethereum-industry-of-integrations-ioi/20167","pubDate":"Sun, 28 Jul 2024 19:52:10 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20167"},"source":{"@url":"https://ethresear.ch/t/ethereum-industry-of-integrations-ioi/20167.rss","#text":"Ethereum + Industry of Integrations (IOI)"}}]}}}