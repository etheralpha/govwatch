{"rss":{"@version":"2.0","@xmlns:discourse":"http://www.discourse.org/","@xmlns:atom":"http://www.w3.org/2005/Atom","@xmlns:dc":"http://purl.org/dc/elements/1.1/","channel":{"title":"Ethereum Research - Latest topics","link":"https://ethresear.ch/latest","description":"Latest topics","lastBuildDate":"Tue, 10 Sep 2024 00:14:12 +0000","atom:link":{"@href":"https://ethresear.ch/latest.rss","@rel":"self","@type":"application/rss+xml"},"item":[{"title":"Introducing CCTP Express: a faster and cheaper way to use CCTP","dc:creator":"0xwels","category":"Applications","description":"<p>By <a href=\"https://twitter.com/wels_eth\" rel=\"noopener nofollow ugc\">Wel</a> and <a href=\"https://twitter.com/alau1218\" rel=\"noopener nofollow ugc\">Alan</a> on behalf of CCTP Express<br>\n<em>For most recent information about CCTP Express, please visit <a href=\"https://twitter.com/cctpexpress\" rel=\"noopener nofollow ugc\">our X</a>.</em></p>\n<h1><a name=\"p-49895-motivation-1\" class=\"anchor\" href=\"https://ethresear.ch#p-49895-motivation-1\"></a>Motivation</h1>\n<p>We recognize the vital role stablecoins play in the Web3 ecosystem, especially within DeFi. Among them, USDC stands out for its high transparency and regulatory compliance. Circle, the issuer of USDC, introduced the Cross-Chain Transfer Protocol (CCTP) to securely transfer USDC across chains using a native burn-and-mint mechanism.</p>\n<p>CCTP is a game-changing tool that drives USDC adoption in the multichain world, allowing developers to create applications that offer secure, 1:1 USDC transfers across blockchains. This eliminates the added risks of using bridges.</p>\n<p>However, CCTP has a key limitation: wait time. Its off-chain attestation service requires block confirmations on the source chain to ensure finality before minting USDC on the destination chain. This process can take anywhere from 20 seconds to 13 minutes, which is not ideal for users needing instant transfers. To address this, CCTP Express was designed to provide instant USDC bridging while leveraging CCTP. We position CCTP Express as a booster tool of CCTP, enabling users to benefit from faster and cheaper transactions.</p>\n<p>We believe CCTP Express is an essential tool to achieve chain abstraction by providing an instant USDC bridging experience.</p>\n<h1><a name=\"p-49895-tldr-2\" class=\"anchor\" href=\"https://ethresear.ch#p-49895-tldr-2\"></a>TL;DR</h1>\n<ul>\n<li>CCTP Express is positioned as a booster tool to use CCTP, where users enjoys a faster and cheaper experience;</li>\n<li>It is an intent-base bridging system built upon CCTP, instant USDC bridging is enabled by the ‚ÄúFiller-Pay-First‚Äù mechanism;</li>\n<li>CCTP Express is a trustless design, allowing anyone to participate as a filler or datadaemon without permission;</li>\n<li>To mitigate the reorg risk exposed to the fillers, CCTP Express introduces an insurance fee that varies based on the user-defined initiateDeadline.;</li>\n<li>In order to lower the transaction costs, repayment and rebalancing transactions are bundled, cross-chain messages are transmitted as hashes to reduce data size.</li>\n</ul>\n<h1><a name=\"p-49895-primary-principles-3\" class=\"anchor\" href=\"https://ethresear.ch#p-49895-primary-principles-3\"></a>Primary principles</h1>\n<p><strong>1. CCTP Dependency</strong><br>\nCCTP Express is specifically designed to enhance CCTP. All fund rebalancing must be done exclusively through CCTP to avoid exposure to potential risks associated with other bridges.</p>\n<p><strong>2. Decentralization</strong><br>\nThe system must be trustless to ensure maximum protection for everyone‚Äôs assets. Players in the system, including Fillers and Datamaemon, are permissionless.</p>\n<p><strong>3. Win-Win-Win</strong><br>\nThe design should benefit all stakeholders ‚Äî users, fillers, and CCTP. Users gain a faster and more cost-effective experience, fillers receive satisfactory rewards while their funds are safeguarded, and CCTP grows stronger through the support of CCTP Express.</p>\n<h1><a name=\"p-49895-key-concepts-4\" class=\"anchor\" href=\"https://ethresear.ch#p-49895-key-concepts-4\"></a>Key concepts</h1>\n<p>CCTP Express is an intent based cross-chain bridging system built upon CCTP. The key to speed up the transaction is the adoption of the ‚ÄúFiller-pay-first‚Äù mechanism.</p>\n<p>When a user submits a bridging intent, fillers initiate an order on the origin chain, then immediately call a fillOrder on the destination chain and transfer funds to the user accordingly.</p>\n<p>The system periodically validates the payments and repays to fillers in batches. Rebalancing across domains is done across CCTP if needed. This settlement process is out of the scene of the users, the repayments and rebalancing are bundled to save costs.</p>\n<h1><a name=\"p-49895-dive-deeper-5\" class=\"anchor\" href=\"https://ethresear.ch#p-49895-dive-deeper-5\"></a>Dive Deeper</h1>\n<p>CCTP Express adopts a Hub-and-Spoke architecture, it can be broken down into a 3-layered system: a request for quote mechanism to obtain users‚Äô bridging intent, enabling a filler network to claim and fill those orders, and lastly a settlement layer periodically repay fillers through CCTP and utilizing attestation service from Iris (Circle‚Äôs off-chain attestation service).</p>\n<p>Our design adheres to ERC-7683, emphasizing the importance of aligning with industry standards. This ensures that cross-chain intent systems can interoperate and share infrastructure like order dissemination services and filler networks. By fostering this interoperability, we enhance the end-user experience by increasing competition for fulfilling user intents. Below is a diagram of the architecture of CCTP Express:</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/0/3/037c645827e04b44e5ed2f79fedaddff4f92eab3.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/037c645827e04b44e5ed2f79fedaddff4f92eab3\" title=\"Architecture of CCTP Express\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/0/3/037c645827e04b44e5ed2f79fedaddff4f92eab3_2_690x451.jpeg\" alt=\"Architecture of CCTP Express\" data-base62-sha1=\"uPWl7t566CJPaVuOQdAqXPfgQ3\" width=\"690\" height=\"451\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/0/3/037c645827e04b44e5ed2f79fedaddff4f92eab3_2_690x451.jpeg, https://ethresear.ch/uploads/default/optimized/3X/0/3/037c645827e04b44e5ed2f79fedaddff4f92eab3_2_1035x676.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/0/3/037c645827e04b44e5ed2f79fedaddff4f92eab3_2_1380x902.jpeg 2x\" data-dominant-color=\"E6F4EC\"></a></div><p></p>\n<p><strong>Order initiation</strong></p>\n<ol>\n<li>User signs an off-chain message defining the parameters of an order:</li>\n</ol>\n<pre><code class=\"lang-auto\"> function deposit(\n        bytes32 recipient,\n        bytes32 inputToken,\n        bytes32 outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint32 destinationDomainId,        \n        bytes32 exclusiveFiller,\n        uint32 exclusivityDeadline,\n        uint32 initiateDeadline,\n        uint32 fillDeadline,\n        bytes calldata message\n    ) external;\n</code></pre>\n<ol start=\"2\">\n<li>The order is disseminated to Fillers. The Filler calls <code>initiate</code> on the origin chain SpokePool. A <code>CrossChainOrder</code> will be created and the user‚Äôs funds are transferred to the SpokePool for escrow.</li>\n<li>The SpokePool on origin chain submits a <code>Deposit</code> message to Circle‚Äôs off-chain attestation service, Iris, for attestation and subsequently a <code>DepositAttestation</code> will be generated.</li>\n</ol>\n<p><strong>Filler Network Fills Order</strong></p>\n<ol start=\"4\">\n<li>\n<p>Fillers call <code>fillOrder</code> on the destination SpokePool with their own assets which are then transferred to the user from the SpokePool.</p>\n</li>\n<li>\n<p>The SpokePool on destination chain submits a <code>Fill</code> message to Iris and a <code>FillAttestation</code> will be generated.</p>\n</li>\n</ol>\n<p><strong>Settlement</strong></p>\n<ol start=\"6\">\n<li>\n<p>A permissionless Datadaemon retrieves the <code>DepositAttestation</code> and <code>FillAttestation</code> and relays to the Hub Pool on the Settlement Chain.</p>\n</li>\n<li>\n<p>Periodically, the Datadaemon calls <code>repayFunds</code> and <code>rebalanceFunds</code> at the Hub Pool, which would collect all the attestations and perform the following steps:</p>\n</li>\n</ol>\n<ul>\n<li>\n<p>Iterate through a list of attestations, a valid filled order is supported by both <code>Deposit</code> and <code>Fill</code> attestation.</p>\n</li>\n<li>\n<p>Determine the aggregate settlement sum from all valid fills for each filler.</p>\n</li>\n<li>\n<p>If there is sufficient funds on SpokePool to repay filler, a <code>repayFunds</code> message in the form of merkle root hash is sent to Iris.</p>\n</li>\n<li>\n<p>For the remaining outstanding payment, the Hub Pool will send a <code>rebalanceFunds</code> message in the form of merkle root hash to Iris, which indicates how much a SpokePool with surplus funds would send to another pool in deficit to fulfill the need for repayment.</p>\n</li>\n</ul>\n<ol start=\"8\">\n<li>\n<p>Once the <code>repayFunds</code> and <code>rebalanceFunds</code> messages get attested by Iris, they are sent to respective SpokePools. Datamaemon will call <code>repayFunds</code> and <code>rebalanceFunds</code> on SpokePools with merkle root hash and their respective transaction details. Accordingly, funds would be repaid to fillers and sent to other SpokePools to ensure sufficient funds for handling repayments.</p>\n</li>\n<li>\n<p>Repay funds to fillers from the SpokePool on destination chain, and rebalance funds across SpokePools on different chains via CCTP.</p>\n</li>\n</ol>\n<p><strong>Cctp Fill Settlement</strong></p>\n<ol start=\"10\">\n<li>\n<p>In case of an order initiated by Fillers not being filled, anyone can call <code>cctpFill</code> and mark the order status on destination chain SpokePool to <code>RequestCctpFill</code> and block any filler from filling it. At the same time, the SpokePool will emit a <code>CctpFill</code> message to Iris for attestation.</p>\n</li>\n<li>\n<p>The <code>CctpFillAttestation</code> will be used to replace the <code>FillAttestation</code> mentioned in 5. and allow the user fund to be transferred via the CCTP route.</p>\n</li>\n</ol>\n<h1><a name=\"p-49895-risk-and-solutions-6\" class=\"anchor\" href=\"https://ethresear.ch#p-49895-risk-and-solutions-6\"></a>Risk and solutions</h1>\n<p><strong>Reorg risk</strong><br>\nThe reorg risk is uniquely borne by fillers. If the filler fills the intent too fast without waiting for the finality on the source chain, the source chain may reorg and cause a loss to the filler since the intent has been filled on the destination chain and the filler would end up in empty hand.</p>\n<p>The reorg risk is effectively mitigated by the <strong>Insurance Fee</strong>, which varies based on the <code>initiateDeadline</code> specified by the user. If the <code>initiateDeadline</code> is sufficiently long, the filler can reinitiate the <code>CrossChainOrder</code> on the origin chain in the event of a reorg, ensuring the user‚Äôs funds are transferred again. The insurance fee is calculated using below formula:</p>\n<p><img src=\"https://ethresear.ch/uploads/default/original/3X/8/f/8f2626d45b13f0ec864c696fa581f0af9f7491b6.png\" alt=\"Formula of Insurance Fee\" data-base62-sha1=\"kqm16Gbo8AMcgEmDkpqHrZAM1hQ\" width=\"244\" height=\"96\"></p>\n<p>Where:<br>\n<em>f(t)</em> is the insurance fee which is a function varies with <em>t</em><br>\n<em>V</em> is the trading volume, representing the maximum insurance fee<br>\n<em>e</em> is the base of the natural logarithm<br>\n<em>k</em> is a constant that control the descending rate of the fee<br>\n<em>t</em> is the time between order creation time and the initiateDeadline<br>\n<em>T</em> is the time required for finality on the origin chain</p>\n<p>The insurance fee varies with the <code>initiateDeadline</code>- it decreases with the increment of time between the order creation time and the <code>initiateDeadline</code>:</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/1/6/1626648dc74ed8b71e5d3e7f66c0b1d9731baba1.png\" data-download-href=\"https://ethresear.ch/uploads/default/1626648dc74ed8b71e5d3e7f66c0b1d9731baba1\" title=\"\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/1/6/1626648dc74ed8b71e5d3e7f66c0b1d9731baba1_2_321x250.png\" alt=\"\" data-base62-sha1=\"39WL9r77jU6FzR8aXfcwxvDkyRj\" width=\"321\" height=\"250\" role=\"presentation\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/1/6/1626648dc74ed8b71e5d3e7f66c0b1d9731baba1_2_321x250.png, https://ethresear.ch/uploads/default/optimized/3X/1/6/1626648dc74ed8b71e5d3e7f66c0b1d9731baba1_2_481x375.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/1/6/1626648dc74ed8b71e5d3e7f66c0b1d9731baba1_2_642x500.png 2x\" data-dominant-color=\"FDFAFA\"></a></div><p></p>\n<p>Since the insurance fee decreases significantly when the <code>initiateDeadline</code> is long (it drops to nearly zero if it is 2x of the time needed for finality on the origin chain), a normal user is likely to set a long initiateDeadline to avoid paying the fee, minimizing the reorg risk for the filler.</p>\n<p><strong>High system costs</strong><br>\nThe complexity of the design apparently implies higher costs compared to bridging directly using CCTP. To align with our goal of providing a faster and cheaper way to use CCTP, we mitigate costs through two key strategies: <em><strong>transaction bundling</strong></em> and <em><strong>data compression</strong></em>.</p>\n<p>Transactions bundling-</p>\n<p>Datadaemon works periodically to call repayment and rebalancing on the hub pool. This interval is adjustable to make sure a sufficient number of transactions are processed in each batch.</p>\n<p>In this architecture design, gas costs are primarily incurred in rebalancing via CCTP and fund transfers. By processing rebalancing in batches and handling repayments in aggregate sums to the fillers, these costs are distributed across multiple transactions, reducing the costs on any single transaction.</p>\n<p>Data Compression-</p>\n<p>Cross-chain messages are transmitted between spoke pools and the hub pool via Iris, Circle‚Äôs off-chain attestation service. To minimize data size and reduce gas costs, these messages are sent in the form of a hash.</p>\n<p>For a detailed comparison of gas consumption between CCTP and CCTP Express, check out <a href=\"https://medium.com/@cctpexpress/cctp-express-is-cheaper-than-cctp-2c527e0afa62\" rel=\"noopener nofollow ugc\">this article</a>.</p>\n<h1><a name=\"p-49895-faq-7\" class=\"anchor\" href=\"https://ethresear.ch#p-49895-faq-7\"></a>FAQ</h1>\n<p><strong>1. What does it mean to the end user?</strong><br>\nWhen using CCTP Express‚Äôs front end or applications integrated with CCTP Express, users benefit from a significantly faster and cheaper way to bridge USDC across chains. By leveraging CCTP as the underlying asset bridge, the system enhances user experience while maintaining robust security.</p>\n<p><strong>2. What are the possible use cases?</strong><br>\nWe believe CCTP Express is essential to achieve chain abstraction by providing an instant USDC bridging experience. Possible use cases included-</p>\n<p><em>USDC-denominated dApps</em><br>\nUSDC is widely adopted in various dApps, e.g. dYdX and Polymarket. dApps can integrate CCTP Express SDK to offer their users instant transfer in and out from all CCTP supported chains without the usual waiting time.</p>\n<p><em>Payment Network</em><br>\nCCTP Express can offer instant settled transaction experience for users across chains, enabling them to pay their USDC for a coffee from any CCTP supported chain.</p>\n<p><em>Money Lego</em><br>\nArbitragers and Solvers can utilize CCTP Express to be the backbone of their cross chain actions. It‚Äôs highly undesirable for arbitragers or solvers to wait for long in the high speed crypto world, CCTP Express can offer them superior speed without worrying about security as CCTP Express is using CCTP as the underlying bridge.</p>\n<p><strong>3. With a similar idea of providing cross chain bridging powered by off chain agents, how is CCTP Express different from other intent-based bridges, say Across?</strong></p>\n<p>The primary distinction between CCTP Express and Across are: positioning and settlement mechanism.</p>\n<p><em>Positioning -</em></p>\n<p>While both protocols are intent-based bridges powered by fillers/relayers, CCTP Express is positioned to be a booster tool to use CCTP.</p>\n<p>Given this focus, CCTP Express is closely integrated with CCTP and evolves in tandem with it. For instance, if CCTP supports EURC, CCTP Express will promptly support it as well.</p>\n<p>And this alignment also applies to the choice of picking which chain CCTP Express supports. CCTP Express aims to cover all EVM and non-EVM chains CCTP operates. And like<a href=\"https://developers.circle.com/stablecoins/docs/message-format#message-header\" rel=\"noopener nofollow ugc\"> CCTP</a>, CCTP Express adopts the bytes32 address format, instead of the 20 byte address used in EVM, to handle 32 byte addresses in many non-EVM chains.</p>\n<p>In contrast, Across is limited to EVM chains only, as it has a<a href=\"https://docs.across.to/resources/new-chain-requests\" rel=\"noopener nofollow ugc\"> hard requirement</a> to support EVM- chains only.</p>\n<p><em>Settlement mechanism -</em></p>\n<p>In CCTP Express, the Hub Pool smart contract utilizes the Iris attestation service used in CCTP to relay and verify messages. Deposit and Filled messages from various Spoke Pools are sent to Iris for attestation and then collected in the Hub Pool, which processes repayments on-chain.</p>\n<p>In contrast, Across uses canonical bridges to relay messages and utilizes<a href=\"https://docs.across.to/use-cases/settle-cross-chain-intents\" rel=\"noopener nofollow ugc\"> UMA</a> to optimistically verify fill events off-chain. Since UMA works off-chain, an interval is needed as a dispute window.</p>\n<h1><a name=\"p-49895-discuss-with-us-8\" class=\"anchor\" href=\"https://ethresear.ch#p-49895-discuss-with-us-8\"></a>Discuss with Us</h1>\n<p>To shape a better product, we are keen to discuss with fillers and teams who need instant USDC bridging. If anyone is interested in CCTP Express, we have a public telegram group here to discuss about it: <a href=\"https://t.me/cctpexpress\" rel=\"noopener nofollow ugc\">Join Group Chat</a></p>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://ethresear.ch/t/introducing-cctp-express-a-faster-and-cheaper-way-to-use-cctp/20396\">Read full topic</a></p>","link":"https://ethresear.ch/t/introducing-cctp-express-a-faster-and-cheaper-way-to-use-cctp/20396","pubDate":"Tue, 10 Sep 2024 00:14:12 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20396"},"source":{"@url":"https://ethresear.ch/t/introducing-cctp-express-a-faster-and-cheaper-way-to-use-cctp/20396.rss","#text":"Introducing CCTP Express: a faster and cheaper way to use CCTP"}},{"title":"Fake GLV: You don't need an efficient endomorphism to implement GLV-like scalar multiplication in SNARK circuits","dc:creator":"yelhousni","category":"zk-s[nt]arks","description":"<pre><code class=\"lang-auto\"> _____     _           ____ _ __     __\n|  ___|_ _| | _____   / ___| |\\ \\   / /\n| |_ / _` | |/ / _ \\ | |  _| | \\ \\ / /  \n|  _| (_| |   &lt;  __/ | |_| | |__\\ V /   \n|_|  \\__,_|_|\\_\\___|  \\____|_____\\_/   \n</code></pre>\n<h1><a name=\"p-49892-you-dont-need-an-efficient-endomorphism-to-implement-glv-like-scalar-multiplication-in-snark-circuits-1\" class=\"anchor\" href=\"https://ethresear.ch#p-49892-you-dont-need-an-efficient-endomorphism-to-implement-glv-like-scalar-multiplication-in-snark-circuits-1\"></a>You don‚Äôt need an efficient endomorphism to implement GLV-like scalar multiplication in SNARK circuits</h1>\n<ul>\n<li><a href=\"https://ethresear.ch#Introduction\">Introduction</a>\n<ul>\n<li><a href=\"https://ethresear.ch#Other-applications\">Other applications</a></li>\n</ul>\n</li>\n<li><a href=\"https://ethresear.ch#Background\">Background</a></li>\n<li><a href=\"https://ethresear.ch#The-fake-GLV-trick6\">The fake GLV trick</a>\n<ul>\n<li><a href=\"https://ethresear.ch#Implementation7\">Implementation</a>\n<ul>\n<li><a href=\"https://ethresear.ch#Benchmark\">Benchmark</a></li>\n<li><a href=\"https://ethresear.ch#Comparison\">Comparison</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2><a name=\"p-49892-introduction-2\" class=\"anchor\" href=\"https://ethresear.ch#p-49892-introduction-2\"></a>Introduction</h2>\n<p>P-256, also known as secp256r1 and prime256v1, is a 256-bit prime field Weierstrass curve standardized by the NIST. It is widely adopted in internet systems, which explains its myriad use cases in platforms such as TLS, DNSSEC, Apple‚Äôs Secure Enclave, Passkeys, Android Keystore, and Yubikey. The key operation in elliptic curves based cryptography is the scalar multiplication. When the curve is equipped with an efficient endomorphism it is possible to speed up this operation through the well-known <a href=\"https://www.iacr.org/archive/crypto2001/21390189.pdf\" rel=\"noopener nofollow ugc\">GLV</a> algorithm. P-256 does unfortunately not have an efficient endomorphism (see <a href=\"https://neuromancer.sk/std/nist/P-256#\" rel=\"noopener nofollow ugc\">parameters</a>) to enjoy this speedup.</p>\n<p>Verifying ECDSA signatures on Ethereum through precompiled contracts, i.e. smart contracts built into the Ethereum protocol (there are only 9) is only possible with the <em>secp256k1</em> curve and not the P-256.<br>\nVerifying ECDSA signatures on P-256 requires computing scalar multiplications in Solidity and is especially useful for smart-contract wallets, enabling hardware-based signing keys and safer, easier self-custody. Different solutions can bring P-256 signatures on-chain. There are primarily three interesting approaches: (zk)-SNARK based verifiers, smart contract verifiers (e.g. <a href=\"https://eprint.iacr.org/2023/939.pdf\" rel=\"noopener nofollow ugc\">[Dubois23]</a>, <a>Ledger/FCL</a> (deprecated), <a href=\"https://github.com/get-smooth/crypto-lib\" rel=\"noopener nofollow ugc\">smoo.th/SCL</a> and <a href=\"https://daimo.com/blog/p256verifier\" rel=\"noopener nofollow ugc\">daimo/p256verifier</a>), and native protocol precompiles (<a href=\"https://github.com/ethereum/RIPs/blob/196f28d2164f30333b503481e7da954d4bf32ea3/RIPS/rip-7212.md\" rel=\"noopener nofollow ugc\">EIP/RIP 7212</a>).</p>\n<p>Using SNARK (succinctness) properties, provides a great way to reduce gas cost for computation on Ethereum (e.g. ~232k gas for <a href=\"https://eprint.iacr.org/2016/260.pdf\" rel=\"noopener nofollow ugc\">Groth16</a>, ~285k gas for <a href=\"https://eprint.iacr.org/2019/953.pdf\" rel=\"noopener nofollow ugc\">PLONK</a> and ~185k gas for <a href=\"https://eprint.iacr.org/2021/1167\" rel=\"noopener nofollow ugc\">FFLONK</a>). This is very competitive with (and sometimes better that) the currently gas-optimal smart contract verifier. Moreover one can batch many ECDSA verifications in a single proof, amortizing thus the gas cost. However verifying P-256 signatures in a SNARK circuit can be very expensive i.e. long proving time. This is because the field where the points on the P-256 curve lie is different than the field where the SNARK computation is usually expressed. To be able to verify the proof onchain through the procompile the SNARK field needs to be the <a href=\"https://hackmd.io/@jpw/bn254\" rel=\"noopener nofollow ugc\">BN254</a> scalar field. Different teams tried to implement the ECDSA verification on P-256 in a BN254 SNARK circuit efficiently. Among these: <a href=\"https://github.com/zkwebauthn/webauthn-halo2\" rel=\"noopener nofollow ugc\">zkwebauthn/webauthn-halo2</a>, <a href=\"https://github.com/zkwebauthn/webauthn-circom\" rel=\"noopener nofollow ugc\">https://github.com/zkwebauthn/webauthn-circom</a> and <a href=\"https://github.com/privacy-scaling-explorations/circom-ecdsa-p256\" rel=\"noopener nofollow ugc\">PSE/circom-ecdsa-p256</a>.</p>\n<p><em>If P-256 had an efficient endomorphism we could have optimized the proving time a great deal!</em></p>\n<p>In this note we show a way to implement a GLV-like scalar multiplications in-circuit without having an efficient endomorphism.</p>\n<h3><a name=\"p-49892-other-applications-3\" class=\"anchor\" href=\"https://ethresear.ch#p-49892-other-applications-3\"></a>Other applications</h3>\n<ul>\n<li>This technique can be applied to any elliptic curve without an efficient endomorphism (e.g. <a href=\"https://en.wikipedia.org/wiki/Curve25519\" rel=\"noopener nofollow ugc\">Curve25519</a>, <a href=\"https://en.wikipedia.org/wiki/P-384\" rel=\"noopener nofollow ugc\">P-384</a>, MNT-753 (<a href=\"https://coinlist.co/build/coda/pages/MNT4753\" rel=\"noopener nofollow ugc\">k=4</a>, <a href=\"https://coinlist.co/build/coda/pages/MNT6753\" rel=\"noopener nofollow ugc\">k=6</a>), <a href=\"https://docs.starknet.io/architecture-and-concepts/cryptography/stark-curve/\" rel=\"noopener nofollow ugc\">STARK curve</a>, <a href=\"https://eprint.iacr.org/2024/869\" rel=\"noopener nofollow ugc\"><span class=\"math\">\\mathcal{B}</span> of ‚Äúcycle5‚Äù</a>, ‚Ä¶). See this <a href=\"https://neuromancer.sk/std/\" rel=\"noopener nofollow ugc\">database</a> for other curves.</li>\n<li>This would question the choice of <a href=\"https://eprint.iacr.org/2021/1152\" rel=\"noopener nofollow ugc\">Bandersnatch</a> (<em>an embedded endomorphism-equipped curve over BLS12-381</em>) over <a href=\"https://github.com/zkcrypto/jubjub\" rel=\"noopener nofollow ugc\">Jubjub</a> (<em>an embedded curve over BLS12-381 without endomorphism</em>) for <a href=\"https://verkle.info/\" rel=\"noopener nofollow ugc\">Ethereum Verkle trees</a>.</li>\n<li>This can speedup ECDSA verification in <a href=\"https://docs.cairo-lang.org/hello_starknet/signature_verification.html\" rel=\"noopener nofollow ugc\">Starknet</a> and <a href=\"https://www.cairo-lang.org/\" rel=\"noopener nofollow ugc\">Cairo</a> (through the <a href=\"https://docs.starknet.io/architecture-and-concepts/cryptography/stark-curve/\" rel=\"noopener nofollow ugc\">STARK curve</a>).</li>\n<li>This can speedup natively the folding step (√† la Nova) of Ed25519 signatures through the 2-cycles proposed <a href=\"https://moderncrypto.org/mail-archive/curves/2024/001050.html\" rel=\"noopener nofollow ugc\">here</a> by Aurore Guillevic.</li>\n</ul>\n<h2><a name=\"p-49892-background-4\" class=\"anchor\" href=\"https://ethresear.ch#p-49892-background-4\"></a>Background</h2>\n<h3><a name=\"p-49892-standard-scalar-multiplication-5\" class=\"anchor\" href=\"https://ethresear.ch#p-49892-standard-scalar-multiplication-5\"></a>Standard scalar multiplication</h3>\n<p>Let <span class=\"math\">E</span> be an elliptic curve defined over the prime field <span class=\"math\">\\mathbb{F}_p</span> and let <span class=\"math\">r</span> be a prime divisor of the curve order <span class=\"math\">\\#E(\\mathbb{F}_p)</span> (i.e. the number of points).<br>\nLet <span class=\"math\">s \\in \\mathbb{F}_r</span> and <span class=\"math\">P(x,y) \\in E(\\mathbb{F}_p)</span>, we are interested in proving scalar multiplication <span class=\"math\">s\\cdot P</span> over the <span class=\"math\">r</span>-torsion subgroup of <span class=\"math\">E</span>, denoted <span class=\"math\">E[r]</span> (i.e. the subset of points of order <span class=\"math\">r</span>).</p>\n<p>The simplest algorithm is the standard left-to-right <em>double-and-add</em>:</p>\n<pre><code class=\"lang-auto\">INPUT: s = (s_{t‚àí1},..., s_1, s_0), P ‚àà E(Fp).\nOUTPUT: sP.\n1. Q ‚Üê ‚àû.\n2. For i from t‚àí1 downto 0 do\n    2.1 Q ‚Üê 2Q.\n    2.2 If s_i = 1 then Q ‚Üê Q + P.\n3. Return(Q).\n</code></pre>\n<p>If/else branching is not possible in SNARK circuits so this is replaced by constant window table lookups inside the circuit. This can be achieved using polynomials which vanish at the constants that aren‚Äôt being selected, i.e. a 1-bit table lookup <code>Q ‚Üê s_i * Q + (1 - s_i) * (Q+P)</code>. Hence this double-and-add algorithm requires <span class=\"math\">t</span> doublings, <span class=\"math\">t</span> additions and <span class=\"math\">t</span> 1-bit table lookup.<br>\nThis can be extended to <em>windowed</em> double-and-add, i.e. scanning more than a bit per iteration using larger window tables, but the multiplicative depth of the evaluation increases exponentially. We use affine coordinates for doubling/adding points because inverses cost as much as multiplications, i.e. instead of checking that <span class=\"math\">1/x</span> is <span class=\"math\">y</span> we provide <span class=\"math\">y</span> out-circuit and check in-circuit that <span class=\"math\">x\\cdot y = 1</span>. However since we start with <span class=\"math\">Q ‚Üê ‚àû</span> it is infeasible to avoid conditional branching since affine formulas are incomplete. Instead, we scan the bits right-to-left and assume that the first bit <code>s_0</code> is 1 (so that we start at <code>Q ‚Üê P</code>), we double the input point <code>P</code> instead of the accumulator <code>Q</code> in this algorithm and finally conditionally subtract (using the 1-bit lookup) <code>P</code> if <code>s_0</code> was 0.</p>\n<pre><code class=\"lang-auto\">INPUT: s = (s_{t‚àí1},..., s_1, s_0), P ‚àà E(Fp).\nOUTPUT: sP.\n1. Q ‚Üê P.\n2. For i from 1 to t‚àí1 do\n    2.1 If s_i = 1 then Q ‚Üê Q + P.\n    2.2 P ‚Üê 2P.\n3. if s_0 = 0 then Q ‚Üê Q - P\n4. Return(Q).\n</code></pre>\n<h3><a name=\"p-49892-glv-scalar-multiplication-6\" class=\"anchor\" href=\"https://ethresear.ch#p-49892-glv-scalar-multiplication-6\"></a>GLV scalar multiplication</h3>\n<p>However it is well known that if the curve is equipped with an efficient endomorphism then there exists a faster algorithm known as <a href=\"https://www.iacr.org/archive/crypto2001/21390189.pdf\" rel=\"noopener nofollow ugc\">[GLV]</a>.</p>\n<p><strong>Example 1 :</strong> suppose that <span class=\"math\">E</span> has Complex Multiplication (CM) with discrimant <span class=\"math\">-D=-3</span>, i.e. <span class=\"math\">E</span> is of the form <span class=\"math\">y^2=x^3+b</span>, with <span class=\"math\">b \\in \\mathbb{F}_p</span>. This is the case of <code>BN254</code>, <code>BLS12-381</code> and <code>secp256k1</code> elliptic curves used in Ethereum. There is an efficient endomorphism <span class=\"math\">\\phi: E \\rightarrow E</span> defined by <span class=\"math\">(x,y)\\mapsto (\\omega x,y)</span> (and <span class=\"math\">\\mathcal{O} \\mapsto \\mathcal{O}</span>) that acts on <span class=\"math\">P \\in E[r]</span> as <span class=\"math\">\\phi(P)=\\lambda \\cdot P</span>. Both <span class=\"math\">\\omega</span> and <span class=\"math\">\\lambda</span> are cube roots of unity in <span class=\"math\">\\mathbb{F}_p</span> and <span class=\"math\">\\mathbb{F}_r</span> respectively, i.e. <span class=\"math\">\\omega^2+\\omega+1 \\equiv 0 \\pmod p</span> and <span class=\"math\">\\lambda^2+\\lambda+1 \\equiv 0 \\pmod r</span>.</p>\n<p><strong>Example 2 :</strong> suppose that <span class=\"math\">E</span> has Complex Multiplication (CM) with discrimant <span class=\"math\">-D=-8</span>, meaning that the endomorphism ring is <span class=\"math\">\\mathbf{Z}[\\sqrt{‚àí2}]</span>. This is the case of the <code>Bandersnatch</code> elliptic curves specified in Ethereum Verkle trie. There is an efficient endomorphism <span class=\"math\">\\phi: E \\rightarrow E</span> whose kernel is generated by a 2-torsion point. The map can be found by looking at 2-isogeneous curves and applying V√©lu‚Äôs formulas. For Bandersnatch it is defined by <span class=\"math\">(x,y)\\mapsto (u^2\\cdot \\frac{x^2+wx+t}{x+w},u^3\\cdot y\\cdot \\frac{x^2+2wx+v}{(x+w)^2})</span> for some constants <span class=\"math\">u,v,w,t</span> (and <span class=\"math\">\\mathcal{O} \\mapsto \\mathcal{O}</span>) that acts on <span class=\"math\">P \\in E[r]</span> as <span class=\"math\">\\phi(P)=\\lambda \\cdot P</span> where <span class=\"math\">\\lambda^2+2 \\equiv 0 \\pmod r</span>.</p>\n<p>The GLV algorithm starts by decomposing <span class=\"math\">s</span> as <span class=\"math\">s = s_0 + \\lambda s_1</span> and then replacing the scalar multiplication <span class=\"math\">s \\cdot P</span> by <span class=\"math\">s_0 \\cdot P + s_1 \\cdot \\phi(P)</span>. Because <span class=\"math\">s_0</span> and <span class=\"math\">s_1</span> are guaranteed to be <span class=\"math\">\\leq \\sqrt{r}</span> (see Sec.4 of <a href=\"https://www.iacr.org/archive/crypto2001/21390189.pdf\" rel=\"noopener nofollow ugc\">[GLV]</a> and Sec.4 of <a href=\"https://eprint.iacr.org/2015/565.pdf\" rel=\"noopener nofollow ugc\">[FourQ]</a> for an optimization trick), we can halve the size of the for loop in the double-and-add algorithm. We can then scan simultaenously the bits of <span class=\"math\">s_0</span> and <span class=\"math\">s_1</span> and apply the <a href=\"https://crypto.stackexchange.com/questions/99975/strauss-shamir-trick-on-ec-multiplication-by-scalar\" rel=\"noopener nofollow ugc\">Strauss-Shamir trick</a>. This results in a significant speed up but only when an endomorphism is available. For example the left-to-right double-and-add would become:</p>\n<pre><code class=\"lang-auto\">INPUT: s and P ‚àà E(Fp).\nOUTPUT: sP.\n1. Find s1 and s2 s.t. s = s1 + ùúÜ * s2 mod r \n    1.1 let s1 = (s1_{t‚àí1},..., s1_1, s1_0) \n    1.2 and s2 = = (s2_{t‚àí1},..., s2_1, s2_0)\n2. P1 ‚Üê P, P2 ‚Üê ùúô(P) and Q ‚Üê ‚àû.\n3. For i from t‚àí1 downto 0 do\n    3.1 Q ‚Üê 2Q.\n    3.2 If s1_i = 0 and s2_i = 0 then Q ‚Üê Q.\n    3.3 If s1_i = 1 and s2_i = 0 then Q ‚Üê Q + P1.\n    3.4 If s1_i = 0 and s2_i = 1 then Q ‚Üê Q + P2.\n    3.5 If s1_i = 1 and s2_i = 1 then Q ‚Üê Q + P1 + P2.\n4. Return(Q).\n</code></pre>\n<p>Using the efficient endomorphism in-circuit is also possible (see <a href=\"https://eprint.iacr.org/2019/1021.pdf\" rel=\"noopener nofollow ugc\">[Halo, Sec. 6.2 and Appendix C]</a> or <a href=\"https://github.com/Consensys/gnark/blob/ea53f373f45d2f9ad9cc1639c34359a35f771191/std/algebra/emulated/sw_emulated/point.go#L530\" rel=\"noopener nofollow ugc\">[gnark implementation]</a> for short Weierstrass curves and <a href=\"https://github.com/zhenfeizhang/bandersnatch-glv\" rel=\"noopener nofollow ugc\">[arkworks]</a> and <a href=\"https://github.com/Consensys/gnark/blob/dc04a1d3b221dbe7571b5a8394b55d02c2872700/std/algebra/native/twistededwards/scalarmul_glv.go\" rel=\"noopener nofollow ugc\">[gnark]</a> implementations for twisted Edwards). But one should be careful about some extra checks of the decomposition <span class=\"math\">s = s_0 + \\lambda s_1 \\mod r</span> (not the SNARK modulus). The integers <span class=\"math\">s_0, s_1</span> can possibly be negative in which case they will be reduced in-circuit modulo the SNARK field and not <span class=\"math\">r</span>.</p>\n<h2><a name=\"p-49892-the-fake-glv-trick-7\" class=\"anchor\" href=\"https://ethresear.ch#p-49892-the-fake-glv-trick-7\"></a>The fake GLV trick</h2>\n<p>Remember that we are proving that <span class=\"math\">s\\cdot P = Q</span> and not computing it. We can ‚Äúhint‚Äù the result <span class=\"math\">Q</span> and check in-circuit that <span class=\"math\">s\\cdot P - Q = \\mathcal{O}</span>. Now, if we can find <span class=\"math\">u,v \\leq \\sqrt{r}</span> such that <span class=\"math\">v\\cdot s = u \\pmod r</span> then we can check instead that</p>\n<p><span class=\"math\">(v\\cdot s)\\cdot P - v\\cdot Q = \\mathcal{O}</span></p>\n<p>which is equivalent to</p>\n<p><span class=\"math\"> u\\cdot P - v\\cdot Q = \\mathcal{O}</span></p>\n<p>The thing now is that <span class=\"math\">u</span> and <span class=\"math\">v</span> are ‚Äúsmall‚Äù and we can, similarly to the GLV algorithm, halve the size of the double-and-add loop and apply the Strauss-Shamir trick.</p>\n<p><strong>Solution</strong>: running the half-GCD algorithm (i.e. running GCD half-way) is sufficient to find <span class=\"math\">u</span> and <span class=\"math\">v</span>. We can apply the exact same trick for finding the lattice basis as in the GLV paper (Sec. 4). For completeness we recall the algorithm hereafter.<br>\nWe apply the extended Euclidean algorithm to find the greatest common divisor of <span class=\"math\">r</span> and <span class=\"math\">s</span> (This gcd is 1 since <span class=\"math\">r</span> is prime.) The algorithm produces a sequence of equations</p>\n<p><span class=\"math\">w_i \\cdot r + v_i \\cdot s = u_i</span></p>\n<p>for <span class=\"math\">i = 0, 1, 2, \\dots</span>  where <span class=\"math\">w_0 = 1, v_0 = 0, u_0 = r, w_1 = 0, v_1 = 1, u_1 = s</span>, and <span class=\"math\">u_i \\geq 0</span> for all <span class=\"math\">i</span>. We stop at the index <span class=\"math\">m</span> for which <span class=\"math\">u_m \\geq \\sqrt{r}</span> and take <span class=\"math\">u = u_{m+1}</span> and <span class=\"math\">v = -v_{m+1}</span>.<br>\n<em>Note:</em> By construction <span class=\"math\">u</span> is guaranteed to be a positive integer but <span class=\"math\">v</span> can be negative, in which case it would be reduced in-circuit modulo the SNARK modulus and not <span class=\"math\">r</span>. To circumvent this we return in the hint <span class=\"math\">u</span>, <span class=\"math\">v</span> and a <span class=\"math\">\\texttt{b}=1</span> if <span class=\"math\">v</span> is negative and <span class=\"math\">\\texttt{b}=0</span> otherwise. In-circuit we negate <span class=\"math\">Q</span> instead when <span class=\"math\">\\texttt{b}=1</span>.</p>\n<h3><a name=\"p-49892-implementation-8\" class=\"anchor\" href=\"https://ethresear.ch#p-49892-implementation-8\"></a>Implementation</h3>\n<p>A generic implementation in the gnark library is available at <a href=\"https://github.com/Consensys/gnark/feat/fake-GLV\" rel=\"noopener nofollow ugc\">gnark.io (feat/fake-GLV branch)</a>. For Short Weierstrass (e.g. P256) look at the <code>scalarMulFakeGLV</code> <a href=\"https://github.com/Consensys/gnark/blob/62c89cb10cff1413e9d68cce054c7e711d04c726/std/algebra/emulated/sw_emulated/point.go#L1263\" rel=\"noopener nofollow ugc\">method</a> in the emulated package and for twisted Edwards (e.g. Bandersnatch/Jubjub) look at the <code>scalarMulFakeGLV</code> <a href=\"https://github.com/Consensys/gnark/blob/62c89cb10cff1413e9d68cce054c7e711d04c726/std/algebra/native/twistededwards/point.go#L261\" rel=\"noopener nofollow ugc\">method</a> in the native package.</p>\n<h4><a name=\"p-49892-benchmark-9\" class=\"anchor\" href=\"https://ethresear.ch#p-49892-benchmark-9\"></a>Benchmark</h4>\n<p>The best algorithm to implement scalar multiplication in a non-native circuit (i.e. circuit field ‚â† curve field) when an efficient endomorphism is <em>not</em> available is an adaptation of <a href=\"https://www.iacr.org/archive/ches2007/47270135/47270135.pdf\" rel=\"noopener nofollow ugc\">[Joye07]</a> (implemented in <a href=\"https://github.com/Consensys/gnark/blob/fdb2b0de422b1c4fc5c6d08e81e788095ac818a6/std/algebra/emulated/sw_emulated/point.go#L748\" rel=\"noopener nofollow ugc\">gnark here</a>).<br>\nNext we compare this scalar multiplication with our fake GLV in a PLONKish vanilla (i.e. no custom gates) circuit (scs) over the BN254 curve (Ethereum compatible). We also give benchmarks in R1CS.</p>\n<div class=\"md-table\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">P-256</th>\n<th style=\"text-align:center\">Old (Joye07)</th>\n<th style=\"text-align:right\">New (fake GLV)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><span class=\"math\">[s]P</span></td>\n<td style=\"text-align:center\">738,031 scs <br> 186,466 r1cs</td>\n<td style=\"text-align:right\">385,412 scs <br> 100,914 r1cs</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ECDSA verification</td>\n<td style=\"text-align:center\">1,135,876 scs <br> 293,814 r1cs</td>\n<td style=\"text-align:right\">742,541 scs <br> 195,266 r1cs</td>\n</tr>\n</tbody>\n</table>\n</div><blockquote>\n<p>Note here that the old ECDSA verification uses Strauss-Shamir trick for computing <span class=\"math\">[s]P+[t]Q</span> while the new version is merely two fake GLV multiplications and an addition.</p>\n</blockquote>\n<h4><a name=\"p-49892-comparison-10\" class=\"anchor\" href=\"https://ethresear.ch#p-49892-comparison-10\"></a>Comparison</h4>\n<p><a href=\"https://www.p256wallet.org/\" rel=\"noopener nofollow ugc\">p256wallet.org</a> is an ERC-4337 smart contract wallet that leverages zk-SNARKs for WebAuthn and P-256 signature verification. It uses <a href=\"https://github.com/privacy-scaling-explorations/circom-ecdsa-p256\" rel=\"noopener nofollow ugc\">PSE/circom-ecdsa-p256</a> to generate the webAuthn proof, and underneath <a href=\"https://github.com/privacy-scaling-explorations/circom-ecdsa-p256\" rel=\"noopener nofollow ugc\">PSE/circom-ecdsa-p256</a> to generate the ECDSA proof on P-256 curve. The github README reports <code>1,972,905 R1CS</code>. Compiling our circuit in R1CS results in <strong><code>195,266 R1CS</code></strong>. This is more than a <strong>10x</strong> reduction, which is not only due to the fake GLV algorithm but also to optimized non-native field arithmetic in gnark.</p>\n<h4><a name=\"p-49892-other-curves-11\" class=\"anchor\" href=\"https://ethresear.ch#p-49892-other-curves-11\"></a>Other curves</h4>\n<p>Similar results are noticed for other curves in short Weirstrass, e.g. P-384 and STARK curve:</p>\n<div class=\"md-table\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">P-384</th>\n<th style=\"text-align:center\">Old (Joye07)</th>\n<th style=\"text-align:right\">New (fake GLV)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><span class=\"math\">[s]P</span></td>\n<td style=\"text-align:center\">1,438,071 scs</td>\n<td style=\"text-align:right\">782,674 scs</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ECDSA verification</td>\n<td style=\"text-align:center\">2,174,027 scs</td>\n<td style=\"text-align:right\">1,419,929 scs</td>\n</tr>\n</tbody>\n</table>\n</div><div class=\"md-table\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">STARK curve</th>\n<th style=\"text-align:center\">Old (Joye07)</th>\n<th style=\"text-align:right\">New (fake GLV)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><span class=\"math\">[s]P</span></td>\n<td style=\"text-align:center\">727,033 scs</td>\n<td style=\"text-align:right\">380,210 scs</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ECDSA verification</td>\n<td style=\"text-align:center\">1,137,459 scs</td>\n<td style=\"text-align:right\">732,131 scs</td>\n</tr>\n</tbody>\n</table>\n</div><p>and also in twisted Edwards e.g. Jubjub vs. Bandersnatch:</p>\n<div class=\"md-table\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Jubjub</th>\n<th style=\"text-align:center\">Old (2-bit double-and-add)</th>\n<th style=\"text-align:right\">New (fake GLV)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><span class=\"math\">[s]P</span></td>\n<td style=\"text-align:center\">5,863 scs <br> 3,314 r1cs</td>\n<td style=\"text-align:right\">4,549  scs <br> 2,401 r1cs</td>\n</tr>\n</tbody>\n</table>\n</div><div class=\"md-table\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Bandersnatch</th>\n<th style=\"text-align:center\">Old (GLV)</th>\n<th style=\"text-align:right\">New (fake GLV)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><span class=\"math\">[s]P</span></td>\n<td style=\"text-align:center\">4,781 scs <br>  2,455 r1cs</td>\n<td style=\"text-align:right\">4,712 scs <br> 2,420 r1cs</td>\n</tr>\n</tbody>\n</table>\n</div><h2><a name=\"p-49892-acknowledgement-12\" class=\"anchor\" href=\"https://ethresear.ch#p-49892-acknowledgement-12\"></a>Acknowledgement</h2>\n<p>I would like to thank Arnau Cube, Aard Vark, Holden Mui, Olivier B√©gassat and Thomas Piellard for fruitful discussions.</p>\n            <p><small>3 posts - 2 participants</small></p>\n            <p><a href=\"https://ethresear.ch/t/fake-glv-you-dont-need-an-efficient-endomorphism-to-implement-glv-like-scalar-multiplication-in-snark-circuits/20394\">Read full topic</a></p>","link":"https://ethresear.ch/t/fake-glv-you-dont-need-an-efficient-endomorphism-to-implement-glv-like-scalar-multiplication-in-snark-circuits/20394","pubDate":"Mon, 09 Sep 2024 19:48:29 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20394"},"source":{"@url":"https://ethresear.ch/t/fake-glv-you-dont-need-an-efficient-endomorphism-to-implement-glv-like-scalar-multiplication-in-snark-circuits/20394.rss","#text":"Fake GLV: You don't need an efficient endomorphism to implement GLV-like scalar multiplication in SNARK circuits"}},{"title":"Embedded fee markets and ERC-4337 (part 2)","dc:creator":"DavideRezzoli","category":"Economics","description":"<p>by: Davide Rezzoli (<a class=\"mention\" href=\"https://ethresear.ch/u/daviderezzoli\">@DavideRezzoli</a>) and Barnab√© Monnot (<a class=\"mention\" href=\"https://ethresear.ch/u/barnabe\">@barnabe</a>)</p>\n<p>Many thanks to Yoav Weiss (<a class=\"mention\" href=\"https://ethresear.ch/u/yoavw\">@yoavw</a>) for introducing us to the problem, Dror Tirosh (<a class=\"mention\" href=\"https://ethresear.ch/u/drortirosh\">@drortirosh</a>) for helpful comments on the draft, and the 4337 team for their support. Reviews ‚â† endorsements; all errors are the authors‚Äô own.</p>\n<p>This work was done for <a href=\"https://efdn.notion.site/ROP-7-Economic-models-of-signature-aggregation-in-account-abstraction-ec5390efab864ed49a8535e8bdfff182\" rel=\"noopener nofollow ugc\">ROP-7</a>.</p>\n<hr>\n<h3><a name=\"p-49870-introduction-1\" class=\"anchor\" href=\"https://ethresear.ch#p-49870-introduction-1\"></a>Introduction</h3>\n<p>In our previous <a href=\"https://ethresear.ch/t/embedded-fee-markets-and-erc-4337-part-1/19542\">post</a>, we introduced the ERC-4337 model. This model outlines the fee market structure for bundlers and details the cost function related to the on-chain publishing cost and the off-chain (aggregation costs) of a bundle.</p>\n<p>We also introduced the concept of the ‚Äú<em>Bundler Game</em>‚Äù. This game will be the primary focus of the second part. Given a set of transactions, a bundler can choose which transactions to include in their bundle. This creates an asymmetry of information between the bundlers and the user, as the user doesn‚Äôt know how many transactions will be included in the bundle. This leads to a zero-sum game where the user is at a clear disadvantage.</p>\n<p>This research aims to explore methods to improve the UX by ensuring that users do not need to overpay for inclusion in the next bundle. Instead, users should be able to pay a fee based on the actual market demand for inclusion.</p>\n<h2><a name=\"p-49870-current-state-of-erc-4337-2\" class=\"anchor\" href=\"https://ethresear.ch#p-49870-current-state-of-erc-4337-2\"></a>Current state of ERC-4337</h2>\n<p>In today‚Äôs market, the P2P mempool is not live on mainnet and it‚Äôs being tested on the Sepolia testnet. Companies building on ERC-4337 are currently operating in a private mode, the users connect via an RPC to a private bundler which will than work with a buidler to publish onchain your useroperation. <a href=\"https://www.bundlebear.com/overview/all\" rel=\"noopener nofollow ugc\">Bundle Bear app</a>, developed by Kofi, provides some intriguing statistics on the current state of ERC-4337.</p>\n<p>In the <a href=\"https://www.bundlebear.com/bundlers/all\" rel=\"noopener nofollow ugc\">Weekly % Multi-UserOp Bundles</a> metric, we observe the percentage of bundlers creating bundles that include multiple userops. From the beginning of 2024 to June 2024, this percentage has not exceeded 6.6%. This data becomes even more interesting when considering that many bundlers run their own paymasters, entities that sponsor transactions on behalf of users. Notably, the two largest bundlers who also operate as a paymaster, in terms of user operations published, <a href=\"https://www.bundlebear.com/paymasters/all\" rel=\"noopener nofollow ugc\">sponsored 97%</a> of the user operations using their services. The paymaster pays for some parts of the useroperation and the rest is paid by the dapps or other <a href=\"https://www.coinbase.com/en-de/developer-platform/solutions/account-abstraction-kit\" rel=\"noopener nofollow ugc\">entity</a>.</p>\n<p>The question that arises is why paymasters, dApps, etc., are paying for the user operations. Will the user pay them back in the future? We can‚Äôt be sure what will happen, but my personal guess is that currently, dApps are covering the fees to increase usage and adoption of their apps. Once adoption is high, users will likely have to pay for the transactions themselves. It‚Äôs worth mentioning that for the user to pay for a user operation with the current model is not the best option, since a basic ERC-4337 operation costs ~42,000 gas, while a normal transaction costs ~21,000 gas.</p>\n<h2><a name=\"p-49870-variations-on-erc-4337-3\" class=\"anchor\" href=\"https://ethresear.ch#p-49870-variations-on-erc-4337-3\"></a>Variations on ERC-4337</h2>\n<h3><a name=\"p-49870-overview-of-erc-4337-4\" class=\"anchor\" href=\"https://ethresear.ch#p-49870-overview-of-erc-4337-4\"></a>Overview of ERC-4337</h3>\n<p>The mempool is still in a testing phase on Sepolia and is not live on the mainnet. Without the mempool, users have limited options for using account abstraction. Users interact with an RPC, which may be offered by a bundler that bundles UserOps, or with an RPC service that doesn‚Äôt bundle, similar to services like Alchemy or Infura, which receive and propagate transactions to other bundlers.</p>\n<p><img src=\"https://ethresear.ch/uploads/default/original/3X/5/c/5cfa750fc581f313b031ca060a05d21cc3379214.jpeg\" alt=\"High level of a transaction in ERC-4337 without the mempool\" data-base62-sha1=\"dgwwPrr5FpfQXtBASfeKFOe2axu\" width=\"497\" height=\"111\"></p>\n<p>Once the mempool is live, the transaction flow will resemble the diagram below, which is similar to the current transaction flow. A mempool enhances censorship resistance for users because, unlike the RPC model, it reduces the chances of a transaction being excluded. However, even with a mempool, there is still a risk that an RPC provider might not forward the transaction, but the mempool model is particularly beneficial for users who prefer to run their own nodes, as it mitigates this risk.</p>\n<p><img src=\"https://ethresear.ch/uploads/default/original/3X/7/7/779c484a5068fcd2a4df86e24c5ede85cb6af781.png\" alt=\"High level of a normal transaction using an EOA\" data-base62-sha1=\"h47Es0l8Qd2k5fWqkt78p0R1QSl\" width=\"631\" height=\"136\"></p>\n<p><img src=\"https://ethresear.ch/uploads/default/original/3X/f/9/f9ab02c182e4af4e72324eddfc31b93c5555f115.jpeg\" alt=\"High level of an userop type of transaction\" data-base62-sha1=\"zCFhixsTDhXkA8qiud2kSbXHce9\" width=\"621\" height=\"126\"></p>\n<p>While bundlers have the potential to act as builders, we prefer to keep the roles separate due to the competitive landscape. Bundlers would face significant competition from existing, sophisticated builders, making building less attractive and potentially less profitable. As a result, bundlers are more incentivized to collaborate with established builders rather than building independently and risking losses.</p>\n<p>Combining the roles of bundler and builder into a single entity implies significant changes to the current system. Bundlers would need to compete with existing <a href=\"https://etherscan.io/dashboards/block-producers\" rel=\"noopener nofollow ugc\">sophisticated builders</a>, or alternatively, current builders will need to horizontally integrate and assume the bundler role as well. The latter scenario, while more plausible, raises concerns about market concentration and the potential negative impact on censorship resistance.</p>\n<h3><a name=\"p-49870-bundlers-and-builders-as-two-different-entities-5\" class=\"anchor\" href=\"https://ethresear.ch#p-49870-bundlers-and-builders-as-two-different-entities-5\"></a>Bundlers and builders as two different entities</h3>\n<p>With the users connecting directly to an RPC, everything runs in a more private environment, which doesn‚Äôt help with market competition. In the near future the mempool will be on the mainnet increasing competition.</p>\n<p>Using a mempool, in which userops are public to different bundlers increases competition, in the case of non native account abstraction having a separation between bundler and builder is needed, in the case of native account abstraction the separation might not be needed since the builder can interpret the userops as normal transactions.</p>\n<p>For our model we believe that having a separation between the bundler and the builder also offers some advantages, especially in terms of competition and censorship resistance. Imagine a scenario where all the bundlers are offering a cost <span class=\"math\">\\textbf{v}</span> for getting included in their bundle. There will be a bundler who wants to attract more users to achieve higher profits, so they will offer a cost <span class=\"math\">\\textbf{v‚Äô}</span>  where <span class=\"math\">\\textbf{v‚Äô} &lt; \\textbf{v}</span>  with enough competition among bundlers, <span class=\"math\">\\textbf{v'}</span> will get close to <span class=\"math\">\\omega</span>, the aggregation cost for the bundle. In this case, the bundlers who can search more efficiently and have better hardware to include more transactions in a bundle will earn higher fees and in return makes the useroperation for the user cheaper.</p>\n<p>This could lead to the following outcome: In a <strong>competitive environment</strong>, bundlers will lower their prices to be selected by users, who will, in turn, seek the lowest price for the inclusion of their user operation in a bundle. This competition will create a system where the bundler who offers the best price will be selected more often than the bundler who is only trying to maximize their profit by creating smaller bundles. Separating the roles of the bundler and builder can also enhance censorship resistance. A bundler can create a bundle of aggregated user operations and send it to different builders. If the bundle includes operations that could be censored, a non-censoring builder can accept it and proceed with construction. However, it‚Äôs worth noting that from a user‚Äôs perspective, this setup could increase costs, as the introduction of a bundler adds an additional party, leading to higher expenses.</p>\n<h3><a name=\"p-49870-rip-7560-6\" class=\"anchor\" href=\"https://ethresear.ch#p-49870-rip-7560-6\"></a>RIP-7560</h3>\n<p>Native account abstraction isn‚Äôt a novel concept; it‚Äôs been under research for years. While ERC-4337 is gaining traction, its implementation outside the protocol offers distinct advantages alongside trade-offs. Notably, existing EOAs can‚Äôt seamlessly transition to SCWs, and various types of censorship-resistant lists are harder to utilize. As previously mentioned, the gas overhead of a userOp cost escalates significantly compared to a normal transaction. <a href=\"https://github.com/ethereum/RIPs/blob/196f28d2164f30333b503481e7da954d4bf32ea3/RIPS/rip-7560.md\" rel=\"noopener nofollow ugc\">RIP-7560</a> won‚Äôt inherently resolve the ongoing issue concerning off-chain costs, but it substantially reduce transaction expenses. From the initial ~42000 gas, it‚Äôs possible to reduce the cost by <a href=\"https://youtu.be/sZ1UO4VN1GI?si=x7Tu22Oqxr7x-KAb&amp;t=554\" rel=\"noopener nofollow ugc\">~20000 gas</a>.</p>\n<p><img src=\"https://ethresear.ch/uploads/default/original/3X/f/a/fadf929aca9a2378a70f5456501dedf5da00358b.jpeg\" alt=\"High level of a type4 transaction with RIP-7560\" data-base62-sha1=\"zNkmVJxsXQbEGsZrX0lP1xZskI3\" width=\"491\" height=\"136\"></p>\n<h3><a name=\"p-49870-layer2s-account-abstraction-7\" class=\"anchor\" href=\"https://ethresear.ch#p-49870-layer2s-account-abstraction-7\"></a>Layer2s Account Abstraction</h3>\n<p>Account abstraction can be utilized in Layer 2 (L2) solutions. Some L2s already implement it natively, while others follow the L1 approach and are waiting for a new proposal similar to RIP-7560. In L2, the L1 is used for data availability to inherit security, while most of the computation occurs off-chain on the L2, providing cheaper transactions and scalability.</p>\n<p><img src=\"https://ethresear.ch/uploads/default/original/3X/b/2/b2a8d1ebfceef37ab62f0db834e7ee6135441741.jpeg\" alt=\"High level of Account abstraction in Layer 2\" data-base62-sha1=\"puuGsTGTMlLuTCy4cbcIUrqc9hv\" width=\"611\" height=\"136\"></p>\n<p>In scenarios where computation on L2 is significantly cheaper than the cost of calldata for data availability (DA) on the mainchain, the use of signature aggregation proves highly beneficial. For instance, pairing for BLS on the mainnet is facilitated by the <a href=\"https://www.evm.codes/precompiled\" rel=\"noopener nofollow ugc\"><em>0x08</em></a> precompile from the EVM, which costs approximately ~45000k gas. Consequently, using BLS on L1 is more expensive than traditional transactions.</p>\n<p>Compression techniques on L2s are already being used, such as 0-byte compression, which reduces the cost from ~188 bytes to ~154 bytes for an ERC20 transfer. With signature aggregation, the compression efficiency can be further enhanced by using a single signature, reducing the size to ~128 bytes.</p>\n<p>In Layer 2s, signature aggregation is a crucial innovation that enhances both transaction efficiency and cost-effectiveness. By combining multiple signatures into a single one, the overall data payload is significantly reduced, which lowers the costs associated with data availability on Layer 1. This advancement not only improves scalability but also reduces transaction costs for users, making the system more economical and efficient.</p>\n<h2><a name=\"p-49870-signature-aggregation-economics-in-layer2s-8\" class=\"anchor\" href=\"https://ethresear.ch#p-49870-signature-aggregation-economics-in-layer2s-8\"></a>Signature Aggregation economics in Layer2s</h2>\n<p>When using an L2 service, the user incurs several costs, including a fee for the L2 operator, a cost based on network congestion, and the cost of data availability on L1.</p>\n<p>From a previous research on ‚Äù<a href=\"https://barnabe.substack.com/p/understanding-rollup-economics-from#footnote-3-48535841\" rel=\"noopener nofollow ugc\"><strong>Understanding rollup economics from first principles</strong></a>‚Äù, we can outline the costs a user faces when using L2 services as follows:</p>\n<p>When a user interatcs with a layer 2 he has some costs that we can define as follow:</p>\n<ul>\n<li><strong>User fee</strong> = L1 data publication fee + L2 operator fee + L2 congestion fee</li>\n<li><strong>Operator cost</strong> = L2 operator cost + L1 data publication cost</li>\n<li><strong>Operator revenue =</strong> User fees + MEV</li>\n<li><strong>Operator profit = Operator revenue - Operator cost</strong> = L2 congestion fee + MEV</li>\n</ul>\n<p>In the case of non-native account abstraction, an additional entity, the bundler, may introduce a fee for creating bundles of userops.</p>\n<p>Considering the bundler, the costs and profits are extended as follows:</p>\n<ul>\n<li><strong>User fee</strong> = L1 data publication fee + L2 operator fee + L2 congestion fee + Bundler Fee</li>\n<li><strong>Bundler Cost</strong> = Quoted(L1 data publication fee + L2 operator fee + L2 congestion fee)</li>\n<li><strong>Bundler Revenue</strong> = User fee</li>\n<li><strong>Bundler profit</strong> = Bundler Revenue - Bundler cost = Difference between L1 and L2 costs and quoted prices from the bundler + Bundler fee</li>\n<li><strong>Operator Cost</strong> = L1 data publication fee + L2 operator fee</li>\n<li><strong>Operator profit = Operator revenue - Operator cost</strong> = L2 congestion fee + MEV</li>\n</ul>\n<p>The bundler earns its fee from the user for their services, while the remainder of the user‚Äôs payment covers the L2 operator‚Äôs costs. If the user is unaware of the bundle size, estimating the actual cost of sending userops becomes challenging, potentially leading to the bundler charging higher fees than the one necessary to cover the operator cost.</p>\n<h3><a name=\"p-49870-incentive-alignment-in-l2-9\" class=\"anchor\" href=\"https://ethresear.ch#p-49870-incentive-alignment-in-l2-9\"></a>Incentive Alignment in L2</h3>\n<p>The interaction between the bundler and L2 helps address this issue, as L2s are incentivized to keep user costs low due to competition. Overcharging users can drive them to switch to other L2s offering fairer prices.</p>\n<p>Let‚Äôs redefine our model by introducing the operator. The user bids to the bundler for inclusion in the next L2 block by bidding a value <span class=\"math\">V</span>. The user aims to minimize the data publication fee, while the bundler seeks to maximize their fee or gain a surplus from L2 interaction costs and user fees.</p>\n<p>The costs associated with creating a bundle and publishing it on-chain can be divided into two parts:</p>\n<p><strong>On-chain cost function:</strong> A bundler issuing bundle <span class=\"math\">\\mathbf{B}</span> when the base fee is <span class=\"math\">r</span> expends a cost:</p>\n<div class=\"math\">\nC_\\text{on-chain}(\\mathbf{B}, r) = F \\times r + n \\times S \\times r\n</div>\n<p><strong>Aggregated cost function:</strong> The bundler has a cost function for aggregating <span class=\"math\">n</span> transactions in a single bundle <strong><span class=\"math\">\\mathbf{B}</span></strong> with base fee of <span class=\"math\">r</span>:</p>\n<div class=\"math\">\nC_\\text{agg}(\\mathbf{B}, r) = F' \\times r + n \\times S' \\times r + n \\times \\omega\n</div>\n<p>with  <span class=\"math\">S' &lt; S</span> the reduced size of a transaction and the pre-verification gas use <span class=\"math\">F' &gt; F</span>, which contains the publication and verification of the single on-chain aggregated signature.</p>\n<p>If the user can obtain a reliable estimate for <span class=\"math\">n</span>, they can calculate their cost using the <code>estimateGas</code> function, available in most L2 solutions. Having a good estimation can make the user bid accordingly without having to overestimate their bid for inclusion. This function determines the necessary cost to ensure inclusion. Having a good estimate for <span class=\"math\">n</span> and the <code>estimateGas</code> function can avoid the user to pay for a higher <code>preVerificationGas</code>. In the next section, we will explore various mechanisms to ensure a reliable estimation of <span class=\"math\">n</span>.</p>\n<h3><a name=\"p-49870-layer2s-operate-an-oracle-10\" class=\"anchor\" href=\"https://ethresear.ch#p-49870-layer2s-operate-an-oracle-10\"></a>Layer2s operate an oracle</h3>\n<p>The oracle‚Äôs role is to monitor the mempool and estimate the number of transactions present. The process works as follows: the Layer 2 deploys an oracle to check the mempool and then informs the user about the number of transactions in the mempool. This enables the user to estimate their bid for inclusion in a bundle. The Layer 2 can request the bundler to include at least a specified number of transactions (<span class=\"math\">n</span>) in a bundle, or else the bundle will be rejected. Once the bundler gathers enough transactions to form a bundle, it sends the bundle to the Layer 2, which then forwards it to the mainnet as calldata for data availability.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/1/5/155c138c7fac1f1d415836ca20e488c9ad49fa73.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/155c138c7fac1f1d415836ca20e488c9ad49fa73\" title=\"Watcher proposal\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/1/5/155c138c7fac1f1d415836ca20e488c9ad49fa73_2_538x500.jpeg\" alt=\"Watcher proposal\" data-base62-sha1=\"32Xizzsy0ZzVewMufn4YRBDB2ev\" width=\"538\" height=\"500\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/1/5/155c138c7fac1f1d415836ca20e488c9ad49fa73_2_538x500.jpeg, https://ethresear.ch/uploads/default/original/3X/1/5/155c138c7fac1f1d415836ca20e488c9ad49fa73.jpeg 1.5x, https://ethresear.ch/uploads/default/original/3X/1/5/155c138c7fac1f1d415836ca20e488c9ad49fa73.jpeg 2x\" data-dominant-color=\"F8F8F7\"></a></div><p></p>\n<h3><a name=\"p-49870-layer2s-with-shared-sequencer-11\" class=\"anchor\" href=\"https://ethresear.ch#p-49870-layer2s-with-shared-sequencer-11\"></a>Layer2s with shared sequencer</h3>\n<p>An interesting approach is to have multiple Layer 2 (L2) networks running a shared sequencer. This setup can provide a more accurate estimate of the mempool, as the sequencer reaches an agreement through consensus facilitated by the shared sequencer.</p>\n<p>In this configuration, different L2 networks operate independently but share a common sequencer. At regular intervals, these networks check the number of user operations (userops) in the shared mempool. The shared sequencer helps synchronize and aggregate data from these networks. Once they reach an agreement, the information is communicated to the user, allowing them to bid based on the number of userops present.</p>\n<p>This approach offers several advantages. Firstly, it provides a decentralized method to determine the number of userops in the mempool, enhancing resistance to collusion. Secondly, it eliminates the single point of failure that could occur if only one system were managing the communication between the user and the mempool. Thirdly, the shared sequencer ensures consistency and reduces discrepancies between the different L2 solutions.</p>\n<p>By leveraging the shared sequencer, this method ensures a robust and reliable system for estimating and communicating the state of the mempool to users, thus improving the overall efficiency and security of the process.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/d/6/d6c85557ef46c934ff99f11c86e081107333e050.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/d6c85557ef46c934ff99f11c86e081107333e050\" title=\"Shared Sequencer\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/d/6/d6c85557ef46c934ff99f11c86e081107333e050_2_486x500.jpeg\" alt=\"Shared Sequencer\" data-base62-sha1=\"uE3oeNVshrRSnAtr3GyJ0ipu8hO\" width=\"486\" height=\"500\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/d/6/d6c85557ef46c934ff99f11c86e081107333e050_2_486x500.jpeg, https://ethresear.ch/uploads/default/optimized/3X/d/6/d6c85557ef46c934ff99f11c86e081107333e050_2_729x750.jpeg 1.5x, https://ethresear.ch/uploads/default/original/3X/d/6/d6c85557ef46c934ff99f11c86e081107333e050.jpeg 2x\" data-dominant-color=\"F7F7F8\"></a></div><p></p>\n<p>In the two explained approaches by using an oracle, there is a potential attack vector where an adversary could generate multiple user operations in the mempool, knowing that they will revert if aggregated together. As a result, the oracle sees that there are <span class=\"math\">n</span>  transactions and requires a large bundle, but the bundler cannot create the bundle. This issue could stall the network for many blocks.</p>\n<h3><a name=\"p-49870-layer2s-operate-their-own-bundler-12\" class=\"anchor\" href=\"https://ethresear.ch#p-49870-layer2s-operate-their-own-bundler-12\"></a>Layer2s operate their own bundler</h3>\n<p>In this proposal, the Layer 2 itself assumes the role of the bundler, while another entity handles the aggregation of signatures (this could be current bundler services). The process works as follows: the Layer 2 operates its own bundler, and users send their operations (userops) to the mempool. The Layer 2 selects some of these userops from the mempool and sends them ‚Äúraw‚Äù to the aggregator, compensating the aggregator for aggregating the signatures. Once the aggregator produces the bundle, it sends it to the bundler, which then forwards it to the mainnet as calldata for data availability.</p>\n<p>The main idea is that the Layer 2 handles the collection of userops and then outsources the aggregation to another entity. The Layer 2 pays for the aggregation and charges the user a fee for the service.</p>\n<p>There are two different options:</p>\n<ol>\n<li>\n<p><strong>Flat Fee Model:</strong> The bundler (Sequencer) selects some transactions and charges the user a flat fee. This flat fee is calculated similarly to current Layer 2 transactions, predicting the future cost of L1 data publication. Alternatively, the Layer 2 could charge the user a flat fee based on the cost of bundling <span class=\"math\">n</span>  aggregated userops,  the layer 2 still have to predict how many transactions will be present in the bundle he will contruct to correctly quote the user, this can be made in the same way is now where the . As it is now where the l2 charge the best comeptitive price to the user that it is in the Layer 2‚Äôs best interest to keep the prices as competitive as possible for the user.<br>\n</p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/2/a/2ad21c4d7917c11d2c90e9f0f2b4e027466730f7.png\" data-download-href=\"https://ethresear.ch/uploads/default/2ad21c4d7917c11d2c90e9f0f2b4e027466730f7\" title=\"Flat Fee\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/2/a/2ad21c4d7917c11d2c90e9f0f2b4e027466730f7_2_477x500.png\" alt=\"Flat Fee\" data-base62-sha1=\"66OdeThE4zY7h1nzrYachShaaY7\" width=\"477\" height=\"500\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/2/a/2ad21c4d7917c11d2c90e9f0f2b4e027466730f7_2_477x500.png, https://ethresear.ch/uploads/default/original/3X/2/a/2ad21c4d7917c11d2c90e9f0f2b4e027466730f7.png 1.5x, https://ethresear.ch/uploads/default/original/3X/2/a/2ad21c4d7917c11d2c90e9f0f2b4e027466730f7.png 2x\" data-dominant-color=\"F9F8F8\"></a></div><p></p>\n</li>\n<li>\n<p><strong>Requesting Refunds:</strong> If the Layer 2 wants to enhance its credibility, it could enable automatic refunds. This would involve a mechanism that checks how many userops are published in a single block and whether the transactions could have been aggregated. If a userop that could have been aggregated wasn‚Äôt, and no automatic refund was issued, the user can request a refund. In this scenario, the Layer 2 could stake some assets, and if the refund isn‚Äôt provided, the user could enforce the refund, ensuring fairness and accountability.<br>\n</p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/2/8/28b9021118bfcafbcc024f1efe0dcd3c1184c5de.png\" data-download-href=\"https://ethresear.ch/uploads/default/28b9021118bfcafbcc024f1efe0dcd3c1184c5de\" title=\"Request Refund\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/2/8/28b9021118bfcafbcc024f1efe0dcd3c1184c5de_2_477x500.png\" alt=\"Request Refund\" data-base62-sha1=\"5OftyLIgt4MizMREnBOSP1AZs1U\" width=\"477\" height=\"500\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/2/8/28b9021118bfcafbcc024f1efe0dcd3c1184c5de_2_477x500.png, https://ethresear.ch/uploads/default/original/3X/2/8/28b9021118bfcafbcc024f1efe0dcd3c1184c5de.png 1.5x, https://ethresear.ch/uploads/default/original/3X/2/8/28b9021118bfcafbcc024f1efe0dcd3c1184c5de.png 2x\" data-dominant-color=\"F9F8F7\"></a></div><p></p>\n</li>\n</ol>\n<h2><a name=\"p-49870-conclusion-13\" class=\"anchor\" href=\"https://ethresear.ch#p-49870-conclusion-13\"></a>Conclusion</h2>\n<p>In these two different posts, we outline the difficulties users experience when bidding to be included in the next bundle. In the first part, we presented the ERC-4337 model, explaining the costs a bundler incurs when posting a bundle on-chain and the associated off-chain costs. We also outlined the fee markets for bundlers and began discussing the issue of formatting the bundler. Users experience difficulties with bidding due to a lack of knowledge about the number of transactions present in the mempool at the time of bundling.</p>\n<p>In the second part, we explained ERC-4337 and RIP-7560. We then discussed why signature aggregation is more likely to occur on Layer 2 solutions rather than directly on Layer 1. We demonstrated how Layer 2 solutions could address the asymmetric knowledge that users experience in different ways. The first one is to use oracles to signal to the user how many transactions are present in the mempool, with this approach the users knows how much they should bid and can force the bundler to make larger bundles. The third approach which is the simplest is that the L2 acts as a bundler and outsources the aggregation to a third party and lets the users pay a fee for it.</p>\n            <p><small>2 posts - 2 participants</small></p>\n            <p><a href=\"https://ethresear.ch/t/embedded-fee-markets-and-erc-4337-part-2/20384\">Read full topic</a></p>","link":"https://ethresear.ch/t/embedded-fee-markets-and-erc-4337-part-2/20384","pubDate":"Thu, 05 Sep 2024 10:23:10 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20384"},"source":{"@url":"https://ethresear.ch/t/embedded-fee-markets-and-erc-4337-part-2/20384.rss","#text":"Embedded fee markets and ERC-4337 (part 2)"}},{"title":"Timestamp Ordering in MCP for Timing Games","dc:creator":"saguillo2000","category":"Block proposer","description":"<blockquote>\n<p>Thanks to <a class=\"mention\" href=\"https://ethresear.ch/u/julian\">@Julian</a> and <a href=\"https://twitter.com/_ddiaconescu_\" rel=\"noopener nofollow ugc\">@denisa</a> for the corrections, suggestions and discussions!</p>\n</blockquote>\n<p>Multiple Concurrent Proposers (MCP) has recently become a significant topic of discussion within the community, particularly following the introduction of the <a href=\"https://x.com/danrobinson/status/1820506643739615624\" rel=\"noopener nofollow ugc\">BRAID protocol</a> and the rise of DAG consensus. Max‚Äôs argument in favor of MCP for Ethereum centers on the monopoly created by leader-based <a href=\"https://ethresear.ch/t/execution-consensus-separation/19964\">consensus mechanisms</a>, where the leader for a given slot is granted substantial monopolistic power. This concentration of power leads to issues such as short censorship for some transactions.</p>\n<p>In leader-based consensus, the designated leader for each slot has the exclusive authority to propose blocks, which allows them to exploit their position for profit maximization, such as through transaction reordering or frontrunning. MCP aims to mitigate these issues by decentralizing the block proposal process, reducing the influence any single proposer can exert over the network during a given slot.</p>\n<h1><a name=\"p-49846-multiple-concurrent-proposers-economic-order-1\" class=\"anchor\" href=\"https://ethresear.ch#p-49846-multiple-concurrent-proposers-economic-order-1\"></a>Multiple Concurrent Proposers Economic Order</h1>\n<p>Let <span class=\"math\">n</span> represent the number of validators in the network. A subset of validators maintains a local chain, denoted by <span class=\"math\"> k &lt; n</span>. The protocol at some step will need to pick the union of all local blockchains at slot <span class=\"math\">i</span> and an ordering rule must be applied between transactions of each local chain.</p>\n<p><strong>Deterministic Block Ordering</strong>: A deterministic rule is applied to order the blocks and its transactions. In the context of <a href=\"https://www.youtube.com/live/PhsJnEnsLN4?si=_Wd_RzjXLzgdyeaZ\" rel=\"noopener nofollow ugc\">MEV-SBC ‚Äò24</a> event, <a href=\"https://www.youtube.com/watch?v=SBOGdofF4u8\" rel=\"noopener nofollow ugc\">Max proposes</a> two approaches:</p>\n<ol>\n<li><strong>Sorting by Priority Fee</strong>: Blocks are sorted based on the priority fee of transactions. MEV (Maximal Extractable Value) taxes can be applied, where a percentage of the priority fee is extracted and redistributed by the application. This approach is detailed in the proposal <a href=\"https://www.paradigm.xyz/2024/06/priority-is-all-you-need\" rel=\"noopener nofollow ugc\">‚ÄúPriority is All You Need‚Äù</a>.</li>\n<li><strong>Execution Flags</strong>: Transactions can set an ‚Äúexecution flag‚Äù that indicates specific actions, such as interacting with a particular liquidity pool (e.g., trading ETH/USDC in the UNIv5 pool). When the block ordering rule encounters a transaction with such a flag, it pulls all flagged transactions attempting to interact with that pool and executes them as a batch.</li>\n</ol>\n<h1><a name=\"p-49846-timing-games-with-frontrunning-incentive-2\" class=\"anchor\" href=\"https://ethresear.ch#p-49846-timing-games-with-frontrunning-incentive-2\"></a>Timing Games with Frontrunning Incentive</h1>\n<p>Let <span class=\"math\">p</span> be a proposer participating in the MCP protocol, who is responsible for proposing a block in their local chain during slot <span class=\"math\">i</span>. We acknowledge that there exists an inherent delay and processing time required to propose this block. Specifically, the protocol permits a maximum allowable delay of <span class=\"math\">\\Delta</span> time units before <span class=\"math\">p</span> incurs penalties.</p>\n<p><span class=\"math\">p</span> may strategically opt to delay their block proposal until <span class=\"math\">\\Delta - \\epsilon</span> (where <span class=\"math\">\\epsilon &gt; 0 </span>) time units. This delay enables <span class=\"math\">p</span> to potentially exploit a frontrunning opportunity by observing and computing a partial order of transactions submitted by other proposers. By strategically placing their block proposal just before the misslot penalty (no block has been proposed and it‚Äôs no going to be accepted for slot <span class=\"math\">i</span>), <span class=\"math\">p</span> could include transactions with higher gas fees, a situation that provides a clear incentive for engaging in frontrunning behavior and the main incentive for playing timing games in this post.</p>\n<p>Under the current deterministic protocol rules, such a timing strategy is incentivized as it allows proposers to maximize their rewards through manipulation of transaction order. This situation underscores the need for an effective mechanism. However, a more robust solution may involve revisiting the transaction ordering rules to eliminate this concrete incentive for timing games that lead to such exploitative behaviors, thereby ensuring a fairer and more secure protocol.</p>\n<h1><a name=\"p-49846-partially-ordered-dataset-pod-3\" class=\"anchor\" href=\"https://ethresear.ch#p-49846-partially-ordered-dataset-pod-3\"></a>Partially Ordered Dataset (POD)</h1>\n<p>One of the main concerns regarding MCP is the absence of a clearly defined method for determining the order of transactions. It remains uncertain how the sequence and the underlying criteria for ordering will be established, as well as how the influence of clients will be exercised‚Äîwhether through mechanisms such as auctions, latency considerations, or the risk of spam attacks, as highlighted by <a href=\"https://www.youtube.com/watch?v=SBOGdofF4u8\" rel=\"noopener nofollow ugc\">Phil at SBC '24</a>.</p>\n<p>The team of Common Prefix has conducted a thorough <a href=\"https://www.commonprefix.com/static/clients/flashbots/flashbots_report.pdf\" rel=\"noopener nofollow ugc\">analysis of various consensus protocols</a>, including leader-based, inclusion list, and leaderless consensus models, with a focus on their resistance to censorship. As a result of their research, they developed the concept of a Partially Ordered Dataset. In this model, the order of transactions is determined by the timestamps recorded by the clients, which may lead to a lack of strict ordering when two transactions are recorded simultaneously. The implications of relinquishing strict ordering in transaction processing have not been extensively explored in the existing literature, or at least, I am not aware of any comprehensive studies on the matter.</p>\n<p>A POD is a finite sequence of pair <span class=\"math\">\\{(r, T), ‚Ä¶, (r‚Äô, T‚Äô)\\}</span> s.t. <span class=\"math\">r</span> is round (slot) and <span class=\"math\">T</span> a set of transactions.</p>\n<p>A round is perfect <span class=\"math\">r_{perf}</span> if no new transactions can appear with recorded round <span class=\"math\">r_{rec} \\leq r_{perf}</span>, which means there is no conflict in the ordering before <span class=\"math\">r_{perf}</span>.</p>\n<p>A <strong>POD protocol</strong> exposes the following methods.</p>\n<ul>\n<li>input event <code>write(tx)</code> : Clients call <code>write(tx)</code> to write a transaction <code>tx</code> .</li>\n<li>output event <code>write_return(tx, œÄ)</code> : after <code>write(tx)</code> the protocol outputs <code>write_return(tx, œÄ)</code>, where <code>œÄ</code> is a record certificate.</li>\n<li>input event <code>read_perfect()</code>: Clients call <code>read_perfect()</code> to read the transactions in the bulletin.</li>\n<li>output event <code>read_perfect_return(r, D, Œ†)</code> : after <code>read_perfect()</code> protocol outputs <code>read_perfect_return(r, D, Œ†)</code>, where <code>r</code> is a round, called the past perfect round, <code>L</code> is a set of transactions, <code>D</code> is a POD, and <code>Œ†</code> is a past-perfect certificate. For each entry <code>(r', T)</code> in <code>D</code>, we say that transactions in <code>T</code> became finalized at round <code>r'</code>.</li>\n<li>input event <code>read_all()</code> : returns all transactions up to the current round without past-perfection guarantees, hence it can return faster than <code>read_perfect()</code>.</li>\n<li>output event <code>read_all_return(D, Œ†)</code></li>\n<li><code>identify(œÄ, Œ†) ‚Üí P' ‚äÜ P</code> : Clients call <code>identify(œÄ, Œ†) ‚Üí P' ‚äÜ P</code> to identify the set <code>P'</code> of parties who vouched for the finalization of a transaction, where <code>Œ†</code> is a POD and <code>œÄ</code> is the certificate returned by <code>write_return(tx, œÄ)</code>.</li>\n</ul>\n<p>The properties of Liveness and Security are detailed in the original work, and the following will be utilized in subsequent arguments:</p>\n<p>Fair punishment: No honest replica gets punished as a result of malicious operation. If <code>identify(œÄ, Œ†) ‚Üí P'</code>, where <code>œÄ</code> is a record certificate for transaction <code>tx</code> and <code>Œ†</code> is a past-perfect certificate for a POD <code>D</code>, can only be created if all parties in <code>P'</code> sign <code>tx</code> and <code>D</code>.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/7/4/74ea9a2fbbcf46cdb5da2f6898d698da4c404c6a.png\" data-download-href=\"https://ethresear.ch/uploads/default/74ea9a2fbbcf46cdb5da2f6898d698da4c404c6a\" title=\"Construction of Partially Ordered Datasets\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/7/4/74ea9a2fbbcf46cdb5da2f6898d698da4c404c6a_2_690x330.png\" alt=\"Construction of Partially Ordered Datasets\" data-base62-sha1=\"gGi1dA2hMncltonTsgQ9hF3wIoq\" width=\"690\" height=\"330\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/7/4/74ea9a2fbbcf46cdb5da2f6898d698da4c404c6a_2_690x330.png, https://ethresear.ch/uploads/default/optimized/3X/7/4/74ea9a2fbbcf46cdb5da2f6898d698da4c404c6a_2_1035x495.png 1.5x, https://ethresear.ch/uploads/default/original/3X/7/4/74ea9a2fbbcf46cdb5da2f6898d698da4c404c6a.png 2x\" data-dominant-color=\"F2F2F2\"></a></div><p></p>\n<p>The construction of the POD is as follows: The client will send a transaction to all the validators in the network and will have to wait for <span class=\"math\">n - f</span> signatures to confirm his transaction has been received by the network, where <span class=\"math\">f</span> is the amount of allowed byzantine validators. Once the client received the signature he will record the median of all the signatures he has received, as there is going to be some latency and difference between the validators when they received the transaction.</p>\n<p>For the reading set of transactions for some round the client will have two options:</p>\n<ul>\n<li>Believe in synchrony on the txs received: Request all the recorded transactions from the validators for some specific round <span class=\"math\">r</span>. Once obtains the  <span class=\"math\">n- f</span> signatures of all the transactions computes the median of the set of transactions based on their timestamps.</li>\n<li>Past-perfect guarantees, no-synchrony believer: Assume <span class=\"math\">r_{perf}</span> to be the minimum of the received <span class=\"math\">r</span> values, then we will not have any transaction with lower timestamp. Now takes the union of all the upcoming transactions. Now the client will have to wait some <span class=\"math\">\\delta</span> time to ensure through the gossip mechanism there is no lower <span class=\"math\">r_{perf}</span> and no more transaction for the upcoming round.</li>\n</ul>\n<h1><a name=\"p-49846-pods-mitigating-mev-in-mcp-4\" class=\"anchor\" href=\"https://ethresear.ch#p-49846-pods-mitigating-mev-in-mcp-4\"></a>PODs mitigating MEV in MCP</h1>\n<p>Adopting Partially Ordered Datasets (PODs) as the primary data structure for MCP introduces a novel approach that hasn‚Äôt been extensively studied, particularly regarding its potential to mitigate the types of MEV games previously described.</p>\n<p>In PODs, transactions are ordered deterministically based on their timestamps. While this approach necessitates handling cases where multiple transactions share the same timestamp‚Äîor evaluating the likelihood of such occurrences‚Äîit fundamentally alters the dynamics of the fronturunning incentive of timing games previously described against other proposers block transactions.</p>\n<p>Consider a scenario in slot <span class=\"math\">m</span> where a malicious proposer attempts to front-run or sandwich another transaction. Under the previous deterministic ordering, which was based on auctions and priority fees, such attacks were feasible because proposers could manipulate their position in the ordering by outbidding others or exploiting latency. However, with timestamp-based ordering as implemented in PODs, this strategy changes significantly. An open question is still to know which strategies can be applied with PODs or timestamp ordering to extract MEV and if they are worse in wellfare of the network compared with the described game.</p>\n<p>In this new setup, being the last proposer in a slot would actually place that proposer in the final position within the transaction order, limiting their ability to engage in front-running or sandwiching assuming honesty in all nodes. Instead, they would only be able to perform back-running, which is generally considered less harmful than front-running or sandwiching. This shift in ordering strategy could effectively reduce the risk of these more dangerous forms of MEV exploitation.</p>\n<p>If a malicious validator attempts to manipulate the order of transactions by bribing proposers, slashing should be applied to the validator. By imposing such penalties, the protocol discourages malicious behavior and ensures that the integrity of the transaction ordering process is maintained. One of the future next questions it‚Äôs how can we detect a bad behaviour in the transaction record, maybe applying Turkey‚Äôs Method it‚Äôs a posible option and assume that outliers are malicious records.</p>\n<p>However, the situation is more complex than it appears. The shift to a new game for validators, where transaction ordering is influenced by latency, introduces additional challenges. Validators may now engage in latency games, where geographical proximity to other validators or network nodes becomes a crucial factor in gaining an advantage. To mitigate this, it is essential to ensure that validators are well decentralized across different regions.</p>\n<p>Decentralizing validators geographically helps reduce the impact of latency-based advantages. Validators clustered in the same location could lead to centralization risks, where a few validators might dominate the network due to their low-latency connections. This centralization could undermine the fairness of transaction ordering and potentially reintroduce the risk of censorship.</p>\n<p>Moreover, validators are incentivized to avoid sharing the same location because doing so decreases the uniqueness of the transactions they can access for a possible backrunning and taking such opportunities. The more validators operate from the same region, the fewer unique transactions each can capture, leading to lower profits from transaction fees, as these would have to be split among more validators. This dynamic encourages validators to spread out, fostering a more decentralized and resilient network that is better protected against latency-based games and the centralization of power. However, the current incentive is still weak and future work will reside in how to provide better incentives for non-centralization.</p>\n            <p><small>3 posts - 2 participants</small></p>\n            <p><a href=\"https://ethresear.ch/t/timestamp-ordering-in-mcp-for-timing-games/20372\">Read full topic</a></p>","link":"https://ethresear.ch/t/timestamp-ordering-in-mcp-for-timing-games/20372","pubDate":"Tue, 03 Sep 2024 08:17:06 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20372"},"source":{"@url":"https://ethresear.ch/t/timestamp-ordering-in-mcp-for-timing-games/20372.rss","#text":"Timestamp Ordering in MCP for Timing Games"}},{"title":"Interpreting MPT branch node values","dc:creator":"josephjohnston","category":"Data Structure","description":"<p>Consider a branch node for an MPT.<br>\nSuppose the 17‚Äôth item in the branch node list is supposed to be NULL, because the branch node is not a ‚Äúterminator‚Äù node. Ethereum documentation says NULL is encoded as the empty string.<br>\nSuppose the 17‚Äôth item in the list is supposed to be a value because the branch node is a terminator node. Suppose this value happens to be the empty string.<br>\nHow to distinguish these two cases?<br>\nNote this question should be independent of RLP encoding, which only concerns how we encode the list. I‚Äôm asking what‚Äôs in the list itself, before considering how the list is subsequently encoded.</p>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://ethresear.ch/t/interpreting-mpt-branch-node-values/20368\">Read full topic</a></p>","link":"https://ethresear.ch/t/interpreting-mpt-branch-node-values/20368","pubDate":"Sat, 31 Aug 2024 14:57:04 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20368"},"source":{"@url":"https://ethresear.ch/t/interpreting-mpt-branch-node-values/20368.rss","#text":"Interpreting MPT branch node values"}},{"title":"Exploring Verifiable Continuous Sequencing with Delay Functions","dc:creator":"thedevbirb","category":"Layer 2","description":"<p><em>Thanks to Conor, Lin and Swapnil from the Switchboard team, Cecilia and Brecht from the Taiko team, Alex Obadia, Justin Drake, Artem Kotelskiy and the Chainbound team for review.</em></p>\n<h2><a name=\"p-49826-abstract-1\" class=\"anchor\" href=\"https://ethresear.ch#p-49826-abstract-1\"></a>Abstract</h2>\n<p>Agreeing on time in a decentralized setting can be challenging: wall clocks may drift between machines, agents can lie about their local times, and it is generally hard to distinguish between malicious intent and just unsynchronized clocks or network latencies.</p>\n<p>Ethereum can be thought of as a global clock that ticks at a rate of 1 tick per ~12 seconds. This tick rate is soft-enforced by the consensus protocol: blocks and attestations produced too early or too late will not be considered valid. But what should we do in order to achieve a granularity lower than 12 seconds? Do we always require a consensus protocol to keep track of time?</p>\n<p>We want to explore these questions in the context of untrusted L2 sequencers, who don‚Äôt have any incentive to follow the L2 block schedule that is currently maintained by trusted L2 sequencers, and will likely play various forms of timing games in order to maximize their revenue.</p>\n<p>In this article, we introduce mechanisms to enforce the timeliness, safety and non-extractive ordering of sequencers in a decentralized rollup featuring a <strong>rotating leader mechanism</strong>, without relying on additional consensus, honest majority assumptions or altruism. To do so, we use three key primitives:</p>\n<ol>\n<li>Client-side ordering preferences,</li>\n<li>Ethereum as a global 12s-tick clock,</li>\n<li>Verifiable Delay Functions.</li>\n</ol>\n<p>Lastly, we show the case study of MR-MEV-Boost, a modification of MEV-Boost that enables a variation of based preconfirmations, where the same construction explored can be applied to reduce the timing games of the proposer.</p>\n<h2><a name=\"p-49826-rationale-2\" class=\"anchor\" href=\"https://ethresear.ch#p-49826-rationale-2\"></a>Rationale</h2>\n<p>Rollup sequencers are entities responsible for ordering (and in most cases, executing) L2 transactions and occasionally updating the L2 state root on the L1. Currently, centralized sequencers benefit from the reputational collateral of the teams building them to maintain five properties:</p>\n<ul>\n<li><strong>Responsiveness</strong>: responding to user transactions with soft commitments / preconfirmations in a <em>timely</em> manner. We want to highlight that this definition includes the timely broadcast of unsafe heads on the rollup peer-to-peer network.</li>\n<li><strong>Non-equivocation (safety)</strong>: adhering to preconfirmation promises when submitting the ordered batch on the L1, which is what will ultimately determine the total ordering of transactions.</li>\n<li><strong>Non-extractive ordering</strong>: not extracting MEV from users by front-running or sandwiching, or by accepting bribes for front-running privileges.</li>\n<li><strong>Liveness</strong>: posting batches to L1 and updating the canonical rollup state regularly.</li>\n<li><strong>Censorship-resistance:</strong> ensuring that no valid transactions are deliberately excluded by the sequencer regardless of the sender, content, or any external factors.</li>\n</ul>\n<p>In this piece we are concerned with how the first four properties can be maintained in a permissionless, untrusted setting. Note that censorship-resistance is ensured by construction: by introducing multiple organizationally distinct sequencers in different geographies and jurisdictions we have a strong guarantee that any transaction will be accepted eventually.</p>\n<p>Consider a decentralized sequencer set <span class=\"math\">S := \\{S_1,\\dots,S_n\\}</span>  with a predictable leader rotation mechanism and a sequencing window corresponding to a known amount of L1 slots. For simplicity, let‚Äôs assume <span class=\"math\">S_{i}</span> is the current leader and <span class=\"math\">S_{i+1}</span> is the next one. At any point in time, only one sequencer is active and has a lock over the rollup state.</p>\n<p>Here are two strategies that sequencer <span class=\"math\">S_i</span> can explore to maximize its expected value:</p>\n<p><strong>1. Delaying the inclusion of transactions</strong></p>\n<p>Suppose a user sends a transaction to <span class=\"math\">S_i</span> at a certain L2 slot. Then, the sequencer could wait some time before inserting the transaction into a block in order to extract more MEV with sandwich attacks in collaboration with searchers or by directly front-running the user. In particular, <a href=\"https://www.youtube.com/watch?v=01dnINiLhAk&amp;t=287s\" rel=\"noopener nofollow ugc\">since MEV grows superlinearly with time</a>, it‚Äôs not in the sequencer‚Äôs best interest to commit early to a transaction. The worst case scenario would be the sequencer delaying inclusion until the sequencer rotation <span class=\"math\">^1</span>.</p>\n<p><strong>2. Not publishing unsafe heads in the rollup peer-to-peer network</strong></p>\n<p>In this setting the sequencer has low incentives to publish the unsafe heads in the rollup network: since L2 blocks are signed by the sequencer (e.g. in <a href=\"https://docs.optimism.io/builders/node-operators/configuration/consensus-config#p2psequencerkey\" rel=\"noopener nofollow ugc\">Optimism</a>), they act as a binding commitment which can be used by users to slash it in case of equivocations.</p>\n<p>This has a major downstream consequence on the UX of the rollup: both the next sequencer and users need to wait until a batch is included to see the latest transactions. For users it means they won‚Äôt know the status of their transactions in a timely manner, while the next sequencers risks building blocks on invalid state.</p>\n<p>We will now explore mechanisms to mitigate these behaviours and introduce slashing conditions for sequencers.</p>\n<h2><a name=\"p-49826-primitive-1-transaction-deadlines-3\" class=\"anchor\" href=\"https://ethresear.ch#p-49826-primitive-1-transaction-deadlines-3\"></a>Primitive 1: Transaction Deadlines</h2>\n<p>We introduce a new EIP-2718 transaction type with an additional field:</p>\n<ul>\n<li><code>deadline</code> - <code>uint256</code> indicating the last L2 block number for which the transaction is considered valid.</li>\n</ul>\n<p>This idea is not entirely new. For instance, the <a href=\"https://limechain.tech/\" rel=\"noopener nofollow ugc\">LimeChain</a> team has explored this in their <a href=\"https://github.com/LimeChain/based-preconfirmations-research/blob/cfc3830c685965fad5e5843533c5586dcb92e873/docs/preconfirmations-for-vanilla-based-rollups.md#preconfirmation-deadline\" rel=\"noopener nofollow ugc\">Vanilla Based Sequencing</a> article. However, in our variant the <code>deadline</code> field is signed as part of the transaction payload and it is not expressed in L1 slots.</p>\n<p>The reasoning behind it is that the sequencer cannot tamper with either the <code>deadline</code> field or <code>block.number</code> (because it is a monotonically increasing counter), and therefore it is easy to modify the L2 derivation pipeline to attribute a fault in case the sequencer inserts the user transaction in a block where <code>block.number &gt; deadline</code>.</p>\n<p>This approach mitigates problem <span class=\"hashtag-raw\">#1</span>. However, it does not in any way solve the <em>responsiveness</em> issue, since sequencers can still delay proposing the block in order to extract more MEV.</p>\n<h2><a name=\"p-49826-primitive-2-ethereum-as-a-global-clock-4\" class=\"anchor\" href=\"https://ethresear.ch#p-49826-primitive-2-ethereum-as-a-global-clock-4\"></a>Primitive 2: Ethereum as a Global Clock</h2>\n<p>A simple rotating sequencer design would be one where <span class=\"math\">S_i</span> loses the power to settle batches after the end of its sequencing window <span class=\"math\">W_i</span>, which is dictated by an L1 smart contract. However, the sequencer still needs some time to post the batch with the latest L2 blocks. We therefore introduce an <em>inclusion window</em> that is shifted <span class=\"math\">n \\geq 1</span> slots ahead of <span class=\"math\">W_i</span>, where <span class=\"math\">S_i</span> still has time to land rollup batches on L1 with the last L2 blocks, even if the responsibility of sequencing has shifted to <span class=\"math\">S_{i+1}</span>.</p>\n<p>In case of any safety fault, the sequencer should be slashed. If the sequencer has not managed to post all their assigned L2 blocks by the end of its inclusion window, it will forego all associated rewards. Optionally, there could also be penalties for liveness faults. This also helps with the problem of collaboration with the next sequencer, by ensuring that the latest blocks will be known to it within <span class=\"math\">n\\cdot12</span> seconds. Ideally, we‚Äôd like to keep <span class=\"math\">n</span> as small as possible with a value of <span class=\"math\">1</span>.</p>\n<p>There are still some potential issues here: getting a transaction included on Ethereum is probabilistic, meaning that you can‚Äôt be sure that a transaction you send will actually be included in time. In this context it means that the last batch sent by an honest leader may not be included in the L1 by the end of its inclusion window. This can be helped with two approaches:</p>\n<ul>\n<li>A ‚Äúbased‚Äù setup, where the sequencer is also the L1 block proposer and can include any transactions right up to the point they have to propose, or</li>\n<li>Using proposer commitments with a protocol like <a href=\"https://boltprotocol.xyz\" rel=\"noopener nofollow ugc\">Bolt</a>. We expand more on this in the <em>‚ÄùFurther work‚Äù</em> section below.</li>\n</ul>\n<p>Note that we assume there is a registry smart contract that can be consulted for the currently active sequencer, i.e. it implements some leader election mechanism and takes care of sequencer bonds along with rewards and penalties. It is up to the rollup governance to decide whether the registry can be fully permissionless or if it should use an allowlist. In case of any misbehaviour, governance would be used to temporarily or permanently remove the sequencer from the allowlist.</p>\n<h2><a name=\"p-49826-primitive-3-verifiable-delay-functions-5\" class=\"anchor\" href=\"https://ethresear.ch#p-49826-primitive-3-verifiable-delay-functions-5\"></a>Primitive 3: Verifiable Delay Functions</h2>\n<p><a href=\"https://medium.com/iovlabs-innovation-stories/verifiable-delay-functions-8eb6390c5f4\" rel=\"noopener nofollow ugc\">Verifiable Delay Functions</a> (VDFs henceforth) are a cryptographic primitive that allows a prover to show a verifier that a certain amount of time was spent running a function, and do it in a way that the verifier can check the result quickly.</p>\n<p>For instance, consider a cryptographic hash function <span class=\"math\">h</span> and define the application</p>\n<div class=\"math\">\nH(n,s) := (h \\circ \\underset{n\\ times}\\dots \\circ h)(s),\n</div>\n<p>where <span class=\"math\">s</span> is a byte array an <span class=\"math\">n</span> is a natural number.</p>\n<p>Composing (or chaining) hash functions like SHA-256 cannot be trivially sped up using parallel computations, but the solution lacks efficient verification <span class=\"math\">^2</span> as the only way to verify the result is to recompute the composition of functions. This solution appeared as a na√Øve VDF in <a href=\"https://eprint.iacr.org/2018/601.pdf\" rel=\"noopener nofollow ugc\">Boneh‚Äôs paper</a>, and for this reason it is referred to as <em>weak</em>.</p>\n<p>Another example of VDF is <a href=\"https://people.csail.mit.edu/rivest/pubs/RSW96.pdf\" rel=\"noopener nofollow ugc\">iterated squaring over a group of hidden order</a>, with which it is possible to construct time-lock puzzles. We‚Äôll explore the usage of the latter in the next sections.</p>\n<h3><a name=\"p-49826-why-vdfs-tho-6\" class=\"anchor\" href=\"https://ethresear.ch#p-49826-why-vdfs-tho-6\"></a>Why VDFs tho?</h3>\n<p>VDFs are very useful in the context of sequencing because they can act as a <em>proof of elapsed time</em> for the duration of the block (specifically <code>block_time</code> / <code>max_adversary_speedup</code>, see <em>‚ÄúSecurity Considerations‚Äù</em>). Consider the following algorithm for the block production pipeline:</p>\n<ol>\n<li>At the beginning of L2 block <span class=\"math\">N</span>, the sequencer starts computing a VDF that takes an L2 block time (or slightly less) to compute for honest players, using the previous block hash as its input.</li>\n<li>After the end of the L2 slot the sequencer builds a block <span class=\"math\">B_N</span> where the header contains the result of the VDF, denoted <span class=\"math\">V_N</span>. We call this <em>sealing</em> a block. This means the block hash digest contains <span class=\"math\">V_N</span>.</li>\n</ol>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/6/8/6802ae3a20554489b1de7ccb7a9ecda502a79c39.png\" data-download-href=\"https://ethresear.ch/uploads/default/6802ae3a20554489b1de7ccb7a9ecda502a79c39\" title=\"\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/6/8/6802ae3a20554489b1de7ccb7a9ecda502a79c39_2_690x317.png\" alt=\"\" data-base62-sha1=\"eQ7oNIzFfBcY49ZF4Xxt37sIgtP\" width=\"690\" height=\"317\" role=\"presentation\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/6/8/6802ae3a20554489b1de7ccb7a9ecda502a79c39_2_690x317.png, https://ethresear.ch/uploads/default/optimized/3X/6/8/6802ae3a20554489b1de7ccb7a9ecda502a79c39_2_1035x475.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/6/8/6802ae3a20554489b1de7ccb7a9ecda502a79c39_2_1380x634.png 2x\" data-dominant-color=\"EFF2F1\"></a></div><p></p>\n<p>This algorithm has the nice property of creating a chain of VDF computations, in some sense analogous to <a href=\"https://solana.com/news/proof-of-history\" rel=\"noopener nofollow ugc\">Solana‚Äôs Proof of History</a> from which we inherit the security guarantees. What does this give us in the sequencer context? If we remember that a sequencer has a certain deadline by which it has to post batches set by the L1 slot schedule, we can have the L1 enforce that <em>at least</em> some number of L2 blocks need to be settled. This has two downstream results:</p>\n<ul>\n<li>The sequencer <em>must</em> start producing and sealing blocks as soon as their sequencing window starts. Pairing this with the transaction deadline property results in an upper bound of time for when a transaction can be confirmed. If they don‚Äôt follow the block schedule set by the VDF and the L1, they risk not being able to post <em>any</em> batch.</li>\n<li>We mitigate problem <span class=\"hashtag-raw\">#2</span> by taking away the incentive to withhold data (not considering pure griefing attacks): this is because the sequencer cannot tamper with an existing VDF chain, which would require recomputing all the subsequent VDFs and result in an invalid batch.</li>\n</ul>\n<p>In general, for the sake of this post we will consider a generic VDF, provided as a ‚Äúblack box‚Äù while keeping the hash chain example in mind which currently has stronger guarantees against ad-hoc hardware such ASICs. See <em>‚ÄúSecurity Considerations‚Äù</em> below for more insights.</p>\n<h3><a name=\"p-49826-proving-correct-vdfs-7\" class=\"anchor\" href=\"https://ethresear.ch#p-49826-proving-correct-vdfs-7\"></a>Proving correct VDFs</h3>\n<p>If a sequencer provides an invalid VDF in an L2 block header it should be slashed, and ideally we‚Äôd like to ensure this at settlement time. However, recalculating a long hash chain on the EVM is simply unfeasible due to gas costs.</p>\n<p>How to show then that the number of iterations of the VDF is invalid? One way could be to enforce it optimistically (or at settlement, in case of ZK-rollups) by requiring a valid VDF chain output in the derivation pipeline of the rollup. In case of equivocation in an optimistic rollup the sequencer can be challenged using fraud proofs.</p>\n<h3><a name=\"p-49826-hardware-requirements-8\" class=\"anchor\" href=\"https://ethresear.ch#p-49826-hardware-requirements-8\"></a>Hardware requirements</h3>\n<p>Since by definition VDFs cannot be sped up using parallelism, it follows that computing a VDF can be done by only using a single core of a CPU, and so it does in our block production algorithm.</p>\n<p>This makes it different and way more lightweight compared to most Proof-of-Work consensus algorithms such as Bitcoin‚Äôs which requires scanning for a value such that, when hashed with SHA-256, the hash begins with a certain number of zero bits.</p>\n<p>It‚Äôs also worth to note that modern CPUs are optimized to compute the SHA-256 hash function. Since 2016 Intel, starting with the <em>Goldmount</em> family of chips, is offering <a href=\"https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sha-extensions.html\" rel=\"noopener nofollow ugc\">SHA Extensions</a> in the <em>Core</em> and <em>Xeon</em> line-ups on selected models which introduces three new instructions specialized in computing different steps of the hash function algorithm more efficiently.</p>\n<p>Lastly, <a href=\"https://www.man.com/single-core-stagnation-and-the-cloud\" rel=\"noopener nofollow ugc\">single-core performance has stagnated over the years</a> indicating that there is a minor benefit in investing in the latest generation of CPUs, thus lowering down the requirements of the system.</p>\n<h2><a name=\"p-49826-case-study-mr-mev-boost-9\" class=\"anchor\" href=\"https://ethresear.ch#p-49826-case-study-mr-mev-boost-9\"></a>Case Study: MR-MEV-Boost</h2>\n<p><a href=\"https://ethresear.ch/t/based-preconfirmations-with-multi-round-mev-boost/20091\">Multi-Round-MEV-Boost</a>, is a modification of MEV-Boost that enables based preconfirmations by running multiple rounds of MEV-Boost auctions within a single L1 slot. The usage of this primitive is to output after each round a based rollup block built by L2 block builders. As shown in the article, this approach inherits the L1 PBS pipeline and mitigates some of the negative externalities of based preconfirmations as a result.</p>\n<p>Like MEV-Boost, this fork relies on the opted-in proposer to be an auctioneer which ends the sealed auction by calling the <code>getHeader</code> (<a href=\"https://ethereum.github.io/builder-specs/#/Builder/getHeader\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">Builder-API</a>) endpoint of the relays. After having signed the sealed bid, the <code>getPayload</code> (<a href=\"https://ethereum.github.io/builder-specs/#/Builder/submitBlindedBlock\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">Builder-API</a>) is called by the proposer to receive the actual content of the winning bid and to publish the block in the based rollup network.</p>\n<p>In the original protocol, the end of the auction usually coincides with the end of the L1 slot (more precisely, <a href=\"https://mevboost.pics/\" rel=\"noopener nofollow ugc\">near one second after it</a>); delaying it results in a high risk of not being able to broadcast the block in time to gather all the needed attestation and forgo all its associated rewards. As such, a block time is proposed every twelve seconds with consistency, enforced by Ethereum consensus.</p>\n<p>In contrast, given it consists of multiple rounds happening <em>during</em> the slot, in MR-MEV-Boost an <em>untrusted proposer is incentivized to end the auction seconds later or earlier <span class=\"math\">^{3}</span> according to the incoming bids,</em> in order to extract more more MEV. In the worst case, MR-MEV-Boost will reflect L1 block times. Another consequence of this is an inconsistent slot time for the based rollup. This can be seen as a much more serious form of timing games.</p>\n<p>In the article, the discussed possible solutions to this problem are the following:</p>\n<ol>\n<li>Introduce user incentives: if users determine that a proposer is misbehaving, they stop sending transactions to said proposer.</li>\n<li>Introduce a committee (consensus) to attest to timeliness and maintain slot durations.</li>\n</ol>\n<p>We now argue that a trustless solution that strongly limits the proposer without requiring actions from the user does exist, and it leverages the same construction we used for the VDF-powered block production algorithm in the context of decentralized sequencing.</p>\n<p>The construction is fairly simple and consists of computing a VDF that lasts <span class=\"math\">x := 12/r</span> seconds, where <span class=\"math\">r</span> is the number of rounds in an L1 slot (the L2 block time). The proposer must calculate this VDF using the previous based rollup block hash as public input and, at the end of the round, sending it along with the body of a modified <code>getPayload</code> call. The output of the VDF is then stored in the rollup block header and if invalid can result in slashing the proposer after a successful fraud proof.</p>\n<p>With this approach the amount of time a proposer can delay the end of a round is limited: for instance if the first auction ended one second later then during the last round it won‚Äôt be able to provide three seconds of computation for the VDF but two, resulting in an invalid block and consequent slashing <span class=\"math\">^4</span>. This is because in order to start computing a valid VDF, it requires the previous block hash as its input, implying a sealed block.</p>\n<h2><a name=\"p-49826-security-considerations-10\" class=\"anchor\" href=\"https://ethresear.ch#p-49826-security-considerations-10\"></a>Security Considerations</h2>\n<p><strong>Are VDFs really safe for this purpose?</strong><br>\nSuppose an adversary owns hardware which is capable of computing the VDF faster compared to the baseline of honest players <em>without getting noticed</em> (otherwise the number of iterations for the VDF is adjusted by the protocol). Then, the faster the attacker (<code>max_adversary_speedup</code>), the less our construction would constrain the space of its possible actions. In particular, the sequencer would be able to commit a bit later to blocks and be able to re-organize some of them for extracting more value.</p>\n<p>However, given we don‚Äôt need the ‚Äúfast proving‚Äù property, hash-chains have proven to be robust with Solana‚Äôs Proof of History and will continue to be at least in the short-term. Also, our security requirements will not be as strict as something that <a href=\"https://ethresear.ch/t/statement-regarding-the-public-report-on-the-analysis-of-minroot/16670\">needs to be enshrined in Ethereum</a> forever.</p>\n<p>Some solutions and directions to get stronger safety guarantees can be found in the <em>‚ÄùFurther work‚Äù</em> section below.</p>\n<h2><a name=\"p-49826-current-limitations-11\" class=\"anchor\" href=\"https://ethresear.ch#p-49826-current-limitations-11\"></a>Current limitations</h2>\n<p><strong>Sequencer credibility</strong></p>\n<p>As with many new services which leverage (re)staking, the credibility of the sequencer has an upper bound which is the amount it has staked: if a MEV opportunity exceeds that, then a rational untrusted actor would prefer to get slashed and take the MEV reward.</p>\n<p><strong>Leader rotation can be a critical moment</strong></p>\n<p>As discussed in the batcher and registry smart contract section, the inclusion window is shifted of one slot forward at minimum compared to the sequencing window. This is needed because of the time required to settle the last batch before rotating leader, but leaves an additional slot time of at least 12 seconds in which the sequencer has room to re-organize the last L2 blocks before publishing them on the rollup peer-to-peer network. As a consequence, liveness is harmed temporarily because <span class=\"math\">S_{i+1}</span> might be building blocks on invalid state if it starts to sequence immediately.</p>\n<p>Lastly, one additional slot might not be enough to settle a batch according to recent data on <a href=\"https://ethresear.ch/t/slot-inclusion-rates-and-blob-market-combinatorics/19817\">slot inclusion rates for blobs</a>. This can be mitigated by leveraging new inclusion preconfirmation protocols, as explained below.</p>\n<p><strong>Sequencer last-look</strong></p>\n<p>Our construction makes very difficult for a sequencer to reorg a block after it has been committed to, however it doesn‚Äôt solve front-running in its entirety. In particular, the sequencer may extract value from users transactions while building the block with associated <code>deadline</code> field. A possible solution along with its limitations is explored in the section below.</p>\n<h2><a name=\"p-49826-conclusion-12\" class=\"anchor\" href=\"https://ethresear.ch#p-49826-conclusion-12\"></a>Conclusion</h2>\n<p>In this article, we explored mechanisms to enforce the timeliness, safety, and non-extractive ordering of untrusted L2 sequencers in a decentralized rollup environment.<br>\nThe primitives discussed ensure that sequencers can act more predictably and fairly, mitigating issues such as transaction delays and data withholding. Moreover, these techniques can reduce trust assumptions for existing single-sequencer rollups, aligning with the concept of rollups functioning as <a href=\"https://vitalik.eth.limo/general/2024/06/30/epochslot.html#what-should-l2s-do\" rel=\"noopener nofollow ugc\">‚Äúservers with blockchain scaffolding‚Äù</a>. These findings provide a robust framework for the future development of decentralized, secure rollup architectures.</p>\n<h2><a name=\"p-49826-further-work-13\" class=\"anchor\" href=\"https://ethresear.ch#p-49826-further-work-13\"></a>Further work</h2>\n<p><strong>Trusted Execution Environments (TEEs) to ensure the sequencer is not running an ASIC</strong></p>\n<p>A <a href=\"https://en.wikipedia.org/wiki/Trusted_execution_environment\" rel=\"noopener nofollow ugc\">Trusted Execution Environment</a> is a secure area of a CPU, often called <em>enclave</em>, that helps the code and data loaded inside it be protected with respect to confidentiality and integrity.<br>\nIts usage in blockchain protocols is an active area of research, with the main concerns being trusting the hardware manufacturer and the <a href=\"https://en.wikipedia.org/wiki/Software_Guard_Extensions\" rel=\"noopener nofollow ugc\">various vulnerabilities found in the past</a> of some implementations (here‚Äôs the <a href=\"https://x.com/_markel___/status/1828112469010596347\" rel=\"noopener nofollow ugc\">latest</a>).<br>\nDepending on the use case these trust assumptions and vulnerabilities might be a deal-breaker. However, in our setting we just need a guarantee that the sequencer is not using specialized hardware for computing the VDF, without caring about possible leakage of confidential data from the enclave or manipulation of the wall clock / monotonic clock.</p>\n<p><strong>Adapt existing anti-ASICs Proof-of-Work algorithms</strong></p>\n<p>The <a href=\"https://www.getmonero.org/resources/about/\" rel=\"noopener nofollow ugc\">Monero</a> blockchain, launched in 2014 as a privacy and untraceable-focused alternative to Bitcoin, uses an ASIC-resistant Proof-of-Work algorithm called <a href=\"https://github.com/tevador/RandomX\" rel=\"noopener nofollow ugc\">RandomX</a>. Quoting their <code>README</code>:</p>\n<blockquote>\n<p>RandomX is a proof-of-work (PoW) algorithm that is optimized for general-purpose CPUs. RandomX uses random code execution (hence the name) together with several memory-hard techniques to minimize the efficiency advantage of specialized hardware.</p>\n</blockquote>\n<p>The algorithm however leverages <a href=\"https://github.com/tevador/RandomX/blob/102f8acf90a7649ada410de5499a7ec62e49e1da/README.md#cpu-performance\" rel=\"noopener nofollow ugc\">some degree of parallelism</a>; it is an interesting research direction whether it can adapted into a single-core version, leading to a new weak-VDF.<br>\nThis approach, while orthogonal to using a TEE, can potentially achieve the same result which is having a guarantee that the sequencer is not using sophisticated hardware.</p>\n<p><strong>Time-lock puzzles to prevent front-running</strong></p>\n<p>As mentioned in the <em>‚ÄúCurrent limitations‚Äù</em> section, our construction doesn‚Äôt limit the problem of sequencer front-running the users. Luckily, this can be solved by requiring users to encrypt sensitive transactions using <a href=\"https://people.csail.mit.edu/rivest/pubs/RSW96.pdf\" rel=\"noopener nofollow ugc\">time-lock puzzles</a>, as we will show in more detail in a separate piece. However, this solution doesn‚Äôt come free: encrypted transactions or encrypted mempools can incentive spamming and statistical arbitrage, <a href=\"https://collective.flashbots.net/t/it-s-time-to-talk-about-l2-mev/3593\" rel=\"noopener nofollow ugc\">especially when the protocol fees are not very high</a>.</p>\n<p><strong>Inclusion Preconfirmations and Data Availability layers</strong></p>\n<p>Batch submissions to an L1 contract could be made more efficient by leveraging some of the new preconfirmations protocol like <a href=\"https://boltprotocol.xyz\" rel=\"noopener nofollow ugc\">Bolt</a> by Chainbound or <a href=\"https://docs.primev.xyz/concepts/what-is-mev-commit\" rel=\"noopener nofollow ugc\">MEV-Commit</a> by Primev to have guaranteed inclusion in the same slot. In particular, sequencing windows should end precisely in the slot before one where the proposer is running the aforementioned protocols in order to leverage inclusion commitments.</p>\n<p>Additionally, the batch could be posted into an efficient and lightweight Data Availability layer run by proposers to enforce a deadline of a configurable amount of seconds in the beginning of the slot, otherwise the sequencer would be slashed.</p>\n<p><img src=\"https://ethresear.ch/uploads/default/original/3X/b/e/bed5956f14947f6e30a081e3064cd2a196897c95.png\" alt=\"\" data-base62-sha1=\"recjREgksTDOyP0hRd7Jx5a9rUx\" width=\"328\" height=\"190\" role=\"presentation\"></p>\n<hr>\n<h2><a name=\"p-49826-footnotes-14\" class=\"anchor\" href=\"https://ethresear.ch#p-49826-footnotes-14\"></a>Footnotes</h2>\n<ol>\n<li>More precisely, if an operator controls multiple subsequent sequencers it could delay inclusion until the last sequencer rotation.</li>\n<li>In Solana, the verification of a SHA-256 chain is actually parallelised but requires dividing a block associated to a ~400ms computation into 32 shreds which are forwarded to the rest of the validators as soon as they‚Äôre computed. As such, verification is sped up by computing the intermediate steps of the hash chain in parallel.</li>\n<li>In general, the proposer will end some rounds earlier as a side effect of delaying other rounds. For example, it could force a longer last round to leverage possible L1 &lt;&gt; L2 arbitrage opportunities.</li>\n<li>There is an edge case where the proposer might not be able to compute all the VDFs even if honest, and it is due to the rotation mechanism: since the public input of the VDF must be the previous rollup block hash, during rotation the next leader will need some time before hearing the block from the rollup network, potentially more than 1s. This could lead the next proposer to be late in computing the VDFs.<br>\nTo reduce this risk, the next proposer could rely on various parties to receive this information such as streaming services and/or trusted relays.</li>\n</ol>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://ethresear.ch/t/exploring-verifiable-continuous-sequencing-with-delay-functions/20362\">Read full topic</a></p>","link":"https://ethresear.ch/t/exploring-verifiable-continuous-sequencing-with-delay-functions/20362","pubDate":"Fri, 30 Aug 2024 14:29:49 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20362"},"source":{"@url":"https://ethresear.ch/t/exploring-verifiable-continuous-sequencing-with-delay-functions/20362.rss","#text":"Exploring Verifiable Continuous Sequencing with Delay Functions"}},{"title":"PeerDas Documentation","dc:creator":"arantxazapico","category":"Sharding","description":"<p>Joint work with <a class=\"mention\" href=\"https://ethresear.ch/u/b-wagn\">@b-wagn</a>, <a href=\"https://eprint.iacr.org/2024/1362.pdf\" rel=\"noopener nofollow ugc\">A Documentation of Ethereum‚Äôs PeerDAS</a></p>\n<p>The long-term vision of the Ethereum community includes a comprehensive data availability protocol using polynomial commitments and tensor codes. As the next step towards this vision, an intermediate solution called PeerDAS is about to integrated, to bridge the way to the full protocol. With PeerDAS soon becoming an integral part of Ethereum‚Äôs consensus layer, understanding its security guarantees is essential.</p>\n<p>The linked document aims to describe the cryptography used in PeerDAS in a manner accessible to the cryptographic community, encouraging innovation and improvements, and to explicitly state the security guarantees of PeerDAS. We focus on PeerDAS as described in Ethereum‚Äôs consensus specifications [<a href=\"https://github.com/ethereum/consensus-specs/commit/54093964c95fbd2e48be5de672e3baae8531a964\" rel=\"noopener nofollow ugc\">Eth24a</a>, <a href=\"https://github.com/ethereum/consensus-specs/tree/dev/specs/_features/eip7594\" rel=\"noopener nofollow ugc\">Eth24b</a>].</p>\n<p>Our intention is two-fold: first, we aim to provide a description of the cryptography used in PeerDAS that is accessible to the cryptographic community, potentially leading to new ideas and<br>\nimprovements that can be incorporated in the future. Second, we want to explicitly state the security and efficiency guarantees of PeerDAS. In terms of security, this document justifies the following claim:<br>\n<strong>Theorem 1</strong> (Main Theorem, Informal): <em>Assuming plausible cryptographic hardness assumptions, PeerDAS is a secure data availability sampling scheme in the algebraic group model, according to the definition in [<a href=\"https://eprint.iacr.org/2023/1079\" rel=\"noopener nofollow ugc\">HASW23</a>].</em></p>\n<p>We hope to receive feedback from the community to make further improvements to this document</p>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://ethresear.ch/t/peerdas-documentation/20361\">Read full topic</a></p>","link":"https://ethresear.ch/t/peerdas-documentation/20361","pubDate":"Fri, 30 Aug 2024 12:56:35 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20361"},"source":{"@url":"https://ethresear.ch/t/peerdas-documentation/20361.rss","#text":"PeerDas Documentation"}},{"title":"Accessible Encryption for Ethereum Rollups with Fairomon","dc:creator":"shakeshack","category":"Layer 2","description":"<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/5/f/5fa5f78d2b4b44708e03133cf29d1de097113e36.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/5fa5f78d2b4b44708e03133cf29d1de097113e36\" title=\"690x435\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/5/f/5fa5f78d2b4b44708e03133cf29d1de097113e36_2_690x435.jpeg\" alt=\"690x435\" data-base62-sha1=\"dE8WqnkBYhOZifIQKA4YkTkYm1w\" width=\"690\" height=\"435\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/5/f/5fa5f78d2b4b44708e03133cf29d1de097113e36_2_690x435.jpeg, https://ethresear.ch/uploads/default/optimized/3X/5/f/5fa5f78d2b4b44708e03133cf29d1de097113e36_2_1035x652.jpeg 1.5x, https://ethresear.ch/uploads/default/original/3X/5/f/5fa5f78d2b4b44708e03133cf29d1de097113e36.jpeg 2x\" data-dominant-color=\"B5B5B8\"></a></div><p></p>\n<p>Co-authored by <a class=\"mention\" href=\"https://ethresear.ch/u/pememoni\">@pememoni</a> and <a class=\"mention\" href=\"https://ethresear.ch/u/shakeshack\">@shakeshack</a>. With special thanks to the rest of the Fairblock team!</p>\n<p>Fairomon is a special fairy type pokemon that combines the work of Fairblock and Monomer - a framework that enables builders to create Ethereum rollups with built-in encryption with minimal lift.</p>\n<h1><a name=\"p-49798-background-1\" class=\"anchor\" href=\"https://ethresear.ch#p-49798-background-1\"></a>Background</h1>\n<p>Monomer is a rollup framework that enables Cosmos SDK app chains to be deployed as rollups on Ethereum. Internally, Monomer is built on top of the OP stack relying on it for chain derivation and settlement while supporting an ABCI interface for a Cosmos SDK app chain to be deployed on top. Fairblock provides threshold MPC encryption that can be utilized in Monomer rollups through a module built for Cosmos SDK chains.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/2/3/2311821ac2a3b134e2df081bbf12f2d71f2c31cc.png\" data-download-href=\"https://ethresear.ch/uploads/default/2311821ac2a3b134e2df081bbf12f2d71f2c31cc\" title=\"451x500\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/2/3/2311821ac2a3b134e2df081bbf12f2d71f2c31cc_2_451x500.png\" alt=\"451x500\" data-base62-sha1=\"50edNT7A2IU2M9DMxkY6SJ1Swxe\" width=\"451\" height=\"500\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/2/3/2311821ac2a3b134e2df081bbf12f2d71f2c31cc_2_451x500.png, https://ethresear.ch/uploads/default/optimized/3X/2/3/2311821ac2a3b134e2df081bbf12f2d71f2c31cc_2_676x750.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/2/3/2311821ac2a3b134e2df081bbf12f2d71f2c31cc_2_902x1000.png 2x\" data-dominant-color=\"F8F8F8\"></a></div><p></p>\n<p>Fairblock enables blockchain developers to integrate pre-execution encryption. This pre-execution encryption is made possible through their threshold MPC network that delivers identity-based encryption (IBE), and soon custom encryption schemes, to partner chains. Fairblock‚Äôs MPC network, called Fairyring, generates threshold encryption and decryption keys for each supported Monomer rollup, while the rollups themselves receive and process encrypted transactions natively.</p>\n<h1><a name=\"p-49798-how-it-works-2\" class=\"anchor\" href=\"https://ethresear.ch#p-49798-how-it-works-2\"></a>How it Works</h1>\n<p>FairyRing uses decentralized key generation to issue a master secret key (MSK) for each epoch (every 100 blocks). From each MSK, a master public key (MPK) can be derived. Once the MPK is derived, it is relayed to a Monomer chain where it will be used to encrypt each requested transaction. In parallel, the MSK is split into equal shares for the amount of FairyRing validators participating in the network. For each request for decryption, FairyRing validators use their share of the MSK to collectively derive the associated private keys.</p>\n<p>In threshold IBE, users or developers can program the decryption conditions for transactions. Onchain conditions that could trigger decryption could be a block height, the price of an asset, a smart contract call, verification of a ZK proof, or the end of a governance poll, for example. Identity-based encryption allows for the programmability of decryption and allows for decryption to be triggered by ‚ÄúIDs,‚Äù which can be either onchain conditions or on/offchain identifiers or attributes that certain wallets prove ownership of.</p>\n<h1><a name=\"p-49798-whats-possible-with-fairomon-3\" class=\"anchor\" href=\"https://ethresear.ch#p-49798-whats-possible-with-fairomon-3\"></a>What‚Äôs Possible with Fairomon</h1>\n<p>MPC encryption can make a number of previously inaccessible applications possible within rollups, most notably encrypted mempools, censorship-resistant sequencing, and DeFi and gaming apps such as encrypted orders, leaderless NFT auctions, ID-gated content, and highest-hand-wins card games like blackjack.</p>\n<p>The transaction flow for an application is as follows:</p>\n<ul>\n<li>User submits an encrypted tx and decryption condition (e.g. target height) to an app</li>\n<li>Chain receives encrypted txs in mempool</li>\n<li>Encrypted txs are sorted by target heights and ordering within a block is committed to inside of the integrated x/pep module</li>\n<li>When target height or decryption condition is reached, the app chain receives decryption key from the Fairyring chain</li>\n<li>Encrypted txs are decrypted and executed inside the BeginBlock method of the x/pep module</li>\n</ul>\n<p>See the architecture diagram below for a detailed description of how Fairyring integrates with a Monomer appchain.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/7/2/723cc342b05947059263449d26d5e63a0010c14a.png\" data-download-href=\"https://ethresear.ch/uploads/default/723cc342b05947059263449d26d5e63a0010c14a\" title=\"690x147\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/7/2/723cc342b05947059263449d26d5e63a0010c14a_2_690x147.png\" alt=\"690x147\" data-base62-sha1=\"giAC8NOqAwl6za4KBt4x9f9JiJk\" width=\"690\" height=\"147\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/7/2/723cc342b05947059263449d26d5e63a0010c14a_2_690x147.png, https://ethresear.ch/uploads/default/optimized/3X/7/2/723cc342b05947059263449d26d5e63a0010c14a_2_1035x220.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/7/2/723cc342b05947059263449d26d5e63a0010c14a_2_1380x294.png 2x\" data-dominant-color=\"F3F2EF\"></a></div><p></p>\n<p>Monomer links:</p>\n<ul>\n<li><a href=\"https://github.com/polymerdao/monomer\" rel=\"noopener nofollow ugc\">Github</a></li>\n<li><a href=\"https://github.com/polymerdao/monomer/tree/main/doc\" rel=\"noopener nofollow ugc\">Docs</a></li>\n</ul>\n<p>Fairblock links:</p>\n<ul>\n<li>\n<p><a href=\"https://www.fairblock.network/\" rel=\"noopener nofollow ugc\">Website</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/Fairblock\" rel=\"noopener nofollow ugc\">Github</a></p>\n</li>\n<li>\n<p><a href=\"https://docs.fairblock.network/docs/basics/overview\" rel=\"noopener nofollow ugc\">Docs</a></p>\n</li>\n</ul>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://ethresear.ch/t/accessible-encryption-for-ethereum-rollups-with-fairomon/20349\">Read full topic</a></p>","link":"https://ethresear.ch/t/accessible-encryption-for-ethereum-rollups-with-fairomon/20349","pubDate":"Wed, 28 Aug 2024 15:45:36 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20349"},"source":{"@url":"https://ethresear.ch/t/accessible-encryption-for-ethereum-rollups-with-fairomon/20349.rss","#text":"Accessible Encryption for Ethereum Rollups with Fairomon"}},{"title":"Outdated encryption stored on blockchain","dc:creator":"knev","category":"Security","description":"<p>Please pardon my ignorance. I‚Äôve read several publications related to blockchain being used in healthcare, construction and the like. Many of these publications state that blockchain allows the storage of secured data.</p>\n<p>My question is this: If data is ‚Äúsecurely‚Äù stored on blockchain (I assume encrypted) and the encryption algorithm LATER (after long-term usage) is proven to be ‚Äúcryptographically broken‚Äù (e.g., SHA-1) ‚Ä¶</p>\n<ul>\n<li>does this not mean all ‚Äúsecured‚Äù data on the blockchain using that algorithm is suddenly public?</li>\n<li>are there steps that can be taken to re-encrypt the data to avoid the massive leak of data?</li>\n</ul>\n<p>Kind regards.</p>\n            <p><small>7 posts - 4 participants</small></p>\n            <p><a href=\"https://ethresear.ch/t/outdated-encryption-stored-on-blockchain/20346\">Read full topic</a></p>","link":"https://ethresear.ch/t/outdated-encryption-stored-on-blockchain/20346","pubDate":"Wed, 28 Aug 2024 12:21:08 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20346"},"source":{"@url":"https://ethresear.ch/t/outdated-encryption-stored-on-blockchain/20346.rss","#text":"Outdated encryption stored on blockchain"}},{"title":"Does multi-block MEV exist? Analysis of 2 years of MEV Data","dc:creator":"pascalst","category":"Economics","description":"<h1><a name=\"p-49786-does-multi-block-mev-exist-analysis-of-2-years-of-mev-data-1\" class=\"anchor\" href=\"https://ethresear.ch#p-49786-does-multi-block-mev-exist-analysis-of-2-years-of-mev-data-1\"></a>Does multi-block MEV exist? Analysis of 2 years of MEV Data</h1>\n<p><em>by <a href=\"https://x.com/pascalstichler\" rel=\"noopener nofollow ugc\">Pascal Stichler</a> (<a href=\"https://www.ephema.io/\" rel=\"noopener nofollow ugc\">ephema labs</a>)</em></p>\n<p><em>Many thanks to <a href=\"https://x.com/nero_eth\" rel=\"noopener nofollow ugc\">Toni</a>, <a href=\"https://x.com/_julianma\" rel=\"noopener nofollow ugc\">Julian</a>, <a href=\"https://x.com/sui414\" rel=\"noopener nofollow ugc\">Danning</a>, <a href=\"https://x.com/cshg0x\" rel=\"noopener nofollow ugc\">Chris</a> and <a href=\"https://x.com/marc_nitzsche\" rel=\"noopener nofollow ugc\">Marc</a> for feedback and especially to <a href=\"https://x.com/barnabemonnot\" rel=\"noopener nofollow ugc\">Barnab√©</a> for nudging the research in the first place and continuous feedback.</em></p>\n<h2><a name=\"p-49786-tldr-2\" class=\"anchor\" href=\"https://ethresear.ch#p-49786-tldr-2\"></a><em>TL;DR</em></h2>\n<ul>\n<li>We looked at proposer-builder data and MEV-Boost payment data since the merge (September 2022) to identify patterns of multi-block MEV.</li>\n<li>We observe fewer multi-slot sequences of builders than a random Monte Carlo simulation would predict. The longest observed multi-slot sequence is 25 slots.</li>\n<li>Average MEV-Boost payments increase for longer consecutive sequences by the same builder from ~0.05 ETH for single slots to ~0.08 ETH for nine consecutive slots.</li>\n<li>In longer sequences, the payment per slot increases slightly with later slots. This indicates that builders bid higher to get longer sequences or the first slot after a longer sequence.</li>\n<li>There is a weak positive autocorrelation between subsequent MEV-Boost payments. This contradicts the hypothesis that there are generally periods of low and high MEV.</li>\n<li>Comparing builders with periods of low and high base fee volatility shows a low correlation. This indicates that no builder specialization based on base fee volatility has developed yet.</li>\n</ul>\n<p><em>The detailed results can be found in the Jupyter notebook on <a href=\"https://github.com/ephema/MEVBoost-Analysis/blob/762b7626c57cc6a1c350059b41e272a70cda49cf/%5Bephema%5D_MEV_Boost_Multi_Slot_MEV_Analysis.ipynb\" rel=\"noopener nofollow ugc\">Github </a>or <a href=\"https://colab.research.google.com/drive/1kKM-da6xP7St8puzPuyn1Ndag6a6wsg3?usp=sharing\" rel=\"noopener nofollow ugc\">Google Colab</a>.</em></p>\n<h2><a name=\"p-49786-background-3\" class=\"anchor\" href=\"https://ethresear.ch#p-49786-background-3\"></a>Background</h2>\n<p>Multi-block Maximal Extractable Value (MMEV) occurs when one party controls more than one consecutive block. It was first introduced in 2021 by [<a href=\"https://arxiv.org/pdf/2109.04347\" rel=\"noopener nofollow ugc\">1</a>] as k-MEV and further elaborated by [<a href=\"https://eprint.iacr.org/2022/445.pdf\" rel=\"noopener nofollow ugc\">2</a>]. It is commonly assumed that controlling multiple slots in a sequence allows to capture significantly more MEV than controlling them individually. This derives from MEV accruing superlinearly over time. The <a href=\"https://collective.flashbots.net/t/multi-block-mev/457\" rel=\"noopener nofollow ugc\">most discussed</a> multi-block MEV strategies include <a href=\"https://eprint.iacr.org/2022/445.pdf\" rel=\"noopener nofollow ugc\">TWAP oracle manipulation attacks</a> on DEXes and producing forced liquidations by price manipulation.</p>\n<p>After the merge, [<a href=\"https://arxiv.org/pdf/2303.04430\" rel=\"noopener nofollow ugc\">3</a>] have looked into the first four months of data on multi-block MEV and summarized it as <em>‚Äúpreliminary and non-conclusive results, indicating [that] builders employ super-linear bidding strategies to secure consecutive block space\"</em>.</p>\n<p>With the recent Attester-Proposer-Separation (APS) and pre-confirmation discussions, multi-block MEV has become more of a pressing issue again as it might be prohibitive for some of the proposed designs (For a more in-depth overview, we‚Äôve created a <a href=\"https://miro.com/app/board/uXjVK07aBCU=/?share_link_id=220296247588\" rel=\"noopener nofollow ugc\">diagram of recently proposed mechanism designs</a> and also <a href=\"https://x.com/mikeneuder\" rel=\"noopener nofollow ugc\">Mike Neuder</a> lately gave a <a href=\"https://www.youtube.com/watch?v=ToVi-zsiE4M\" rel=\"noopener nofollow ugc\">comprehensive overview</a>).</p>\n<h2><a name=\"p-49786-methodology-4\" class=\"anchor\" href=\"https://ethresear.ch#p-49786-methodology-4\"></a>Methodology</h2>\n<p>In order to get a better understanding of the historical prevalence of multi-block MEV, we decided to look at all slots from the Merge in September ‚Äò22 until May ‚Äò24 (totalling roughly 4.3 million slots) and analyze the corresponding data on validators and builders and on MEV-boost payments (if applicable). The scope was to identify patterns of unusual consecutive slot sequences and accompanying MEV values. <a href=\"https://mevboost.pics/data.html\" rel=\"noopener nofollow ugc\">The data</a> has been kindly provided by Toni Wahrst√§tter and contains information per slot on relay, builder pubkey, proposer pubkey and MEV-Boost value as well as a builder pubkey and validator pubkey mapping. In the labeling of validators for our purposes staking pool providers such as Lido or Rocket Pool are treated as one entity.</p>\n<p>MEV-Boost payments are used as a proxy for the MEV per block. We acknowledge that this is only a non-perfect approximation. The ascending MEV-Boost first-price auction by its nature of being public essentially functions like a second price + 1 wei auction (thanks to Julian for pointing this out!). Hence, we strictly speaking only get an estimate of the intrinsic value of the second highest bidder. However, as [<a href=\"https://arxiv.org/pdf/2405.01329\" rel=\"noopener nofollow ugc\">4</a>] have observed more than 88% of MEV-Boost auctions were competitive and [<a href=\"https://arxiv.org/pdf/2407.13931\" rel=\"noopener nofollow ugc\">5</a>] concluded that the average profit margin per top three builder is between 1% and 5.4%, further indicating a competitive market between the top builders. Based on this, despite the limitations we deem it feasible to use the MEV-Boost payments as an approximation for the generated MEV per block.</p>\n<p>To establish a baseline of expected multi-slot sequences, a Monte Carlo simulation was conducted. In this simulation, builders were randomly assigned to each slot within the specified time period, based on their observed daily market share during that period. The frequency of consecutive slots, ranging in length from 1 to 25 (the longest observed sequence in the empirical data), was recorded. This procedure was repeated 100 times, and the average was taken. We decided to use daily market shares for the main analysis as in the investigated time period market shares have strongly shifted [4]. For comparison we also ran the analysis on monthly and overall market shares.</p>\n<p>Further, base fee volatility data has been included to cross-check effects of low and high-volatility periods. Previous research (e.g. [<a href=\"https://arxiv.org/pdf/2305.19150\" rel=\"noopener nofollow ugc\">6</a>] &amp; [<a href=\"https://arxiv.org/pdf/2401.01622\" rel=\"noopener nofollow ugc\">7</a>]) has focused on token price volatility effects based on CEX-prices. As we are interested in low- and high-MEV environments, we deem base fee volatility for our use case more fitting, as it is driven by empty or full blocks which are at least partially a result of the prevalence of MEV opportunities.</p>\n<h2><a name=\"p-49786-empirical-findings-5\" class=\"anchor\" href=\"https://ethresear.ch#p-49786-empirical-findings-5\"></a>Empirical Findings</h2>\n<h3><a name=\"p-49786-finding-1-fewer-multi-slot-sequences-exist-than-assumed-by-random-distribution-6\" class=\"anchor\" href=\"https://ethresear.ch#p-49786-finding-1-fewer-multi-slot-sequences-exist-than-assumed-by-random-distribution-6\"></a>Finding 1: Fewer multi-slot sequences exist than assumed by random distribution</h3>\n<p><strong></strong></p><div class=\"lightbox-wrapper\"><strong><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/b/6/b6ab4921507e70c619d5121b5abf611e67e2138f.png\" data-download-href=\"https://ethresear.ch/uploads/default/b6ab4921507e70c619d5121b5abf611e67e2138f\" title=\"\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/b/6/b6ab4921507e70c619d5121b5abf611e67e2138f_2_533x426.png\" alt=\"\" data-base62-sha1=\"q3XSoYCSA2iCGImNM9PoiLu7vfF\" width=\"533\" height=\"426\" role=\"presentation\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/b/6/b6ab4921507e70c619d5121b5abf611e67e2138f_2_533x426.png, https://ethresear.ch/uploads/default/optimized/3X/b/6/b6ab4921507e70c619d5121b5abf611e67e2138f_2_799x639.png 1.5x, https://ethresear.ch/uploads/default/original/3X/b/6/b6ab4921507e70c619d5121b5abf611e67e2138f.png 2x\" data-dominant-color=\"EFEEED\"></a></strong></div><br>\n<em>Figure 1: Comparison of statistically expected vs. observed multi-slot sequences (note that slots &gt; 25 have been summarized in slot 25 for brevity)</em><p></p>\n<p>Firstly, the prevalence of multi-slot sequences with the same builder proposing the block was investigated to determine if they are more common than would be expected by chance.</p>\n<p>Comparing the results of the Monte Carlo simulation as a baseline in expected distribution (blue) with the observed distribution (orange), it can be seen that significantly fewer multi-slot sequences occur than expected (Figure 1). The longest observed sequence was 25 slots and the longest sequence with the same validator (Lido) and builder (BeaverBuild) was 11 consecutive slots on March 4th, 2024 (more details with descriptive statistics in the <a href=\"https://colab.research.google.com/drive/1kKM-da6xP7St8puzPuyn1Ndag6a6wsg3#scrollTo=5bje4mIWzELq\" rel=\"noopener nofollow ugc\">notebook</a>). Running the same simulation on monthly or total market shares in the time period, the observation shifts to having more longer sequences than expected, however we attribute this to the statistical effect of changing market shares. A detailed analysis can be run in the <a href=\"https://colab.research.google.com/drive/1kKM-da6xP7St8puzPuyn1Ndag6a6wsg3#scrollTo=mz4CTqCQInTv\" rel=\"noopener nofollow ugc\">notebook</a> or be provided upon request.</p>\n<p>In the next step, to understand this in a more-fine-grained manner, the values are compared for each of the top 10 builders based on market shares. Therefore, for each builder, the difference between expected and observed occurrences of multi-slot sequences are plotted with the size of the bubble indicating the delta in Figure 2. The expected occurrences are based on the results of the Monte Carlo simulation. Red bubbles indicate a positive deviation (more observed slots than expected), while blue indicates a negative deviation. Green dots indicate values in line with the expectation. In Figure 2 it is shown in absolute numbers, in the <a href=\"https://colab.research.google.com/drive/1kKM-da6xP7St8puzPuyn1Ndag6a6wsg3#scrollTo=cd07f078-f646-450c-b610-9e91012111f2&amp;line=3&amp;uniqifier=1\" rel=\"noopener nofollow ugc\">notebook</a> it can also be seen on a relative scale.</p>\n<p><strong></strong></p><div class=\"lightbox-wrapper\"><strong><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/e/9/e94454973c4bf844c96e0a1735409a130a0983dd.png\" data-download-href=\"https://ethresear.ch/uploads/default/e94454973c4bf844c96e0a1735409a130a0983dd\" title=\"\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/e/9/e94454973c4bf844c96e0a1735409a130a0983dd_2_628x419.png\" alt=\"\" data-base62-sha1=\"xhzEauFL5pYwNguH7QOHbym4ba5\" width=\"628\" height=\"419\" role=\"presentation\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/e/9/e94454973c4bf844c96e0a1735409a130a0983dd_2_628x419.png, https://ethresear.ch/uploads/default/optimized/3X/e/9/e94454973c4bf844c96e0a1735409a130a0983dd_2_942x628.png 1.5x, https://ethresear.ch/uploads/default/original/3X/e/9/e94454973c4bf844c96e0a1735409a130a0983dd.png 2x\" data-dominant-color=\"F0F2F1\"></a></strong></div><br>\n<em>Image 2: Deviations between expected (Monte Carlo simulation) and observed multi-slot frequencies per builder</em><p></p>\n<p>It can be observed in the relative as well as in the absolute deviation that for the top builders there are more single slot sequences than expected with the exception of ETH-Builder, f1b and Blocknative. For multi-slot sequences with two or more slots, almost all top 10 builders have less than expected. This shows that the trend is not limited to singular entities but derives more from the general market structure.</p>\n<h3><a name=\"p-49786-finding-2-payments-for-multi-slot-sequences-are-higher-on-average-than-for-single-slots-7\" class=\"anchor\" href=\"https://ethresear.ch#p-49786-finding-2-payments-for-multi-slot-sequences-are-higher-on-average-than-for-single-slots-7\"></a>Finding 2: Payments for multi-slot sequences are higher on average than for single slots</h3>\n<p>To understand if multi-slot sequences are valuable, we looked into MEV-Boost payments and compared single-slot to multi-slot sequences (Figure 3).</p>\n<p><strong><img src=\"https://ethresear.ch/uploads/default/original/3X/b/5/b570ac276a9b9dc76883e6e89489c8792b0186e3.png\" alt=\"\" data-base62-sha1=\"pT5OX4pSyEtnUEhV9xaSdpAtBo7\" width=\"467\" height=\"342\" role=\"presentation\"></strong><br>\n<em>Figure 3: Average MEV-Boost payments per Sequence Length</em></p>\n<p>It can be observed that in accordance with previous work of [3], we observe higher average MEV payouts for longer consecutive sequences (from about 0.05 ETH for single slot sequences to around 0.08 ETH for sequences with nine consecutive slots). Note that the gray numbers in Figure 3 provide the sample size for each slot length. So it can be observed that the longer the sequence, almost linearly the average MEV-boost payment per slot in the sequence rises. At this stage of the research we can only speculate why this is the case. It could be driven by a higher value in longer consecutive sequences, but also by alternative effects. For example, Julian rightfully pointed out it could also be driven by an increasing intrinsic value for the second highest-bidder due to accumulating MEV in private order flow and the intrinsic valuation of the winning bidder remains constant. Or as Danning suggested, it might be driven by certain types of proprietary order flow (e.g. CEX-DEX arbitrage) being more valuable in certain time periods (e.g. volatile periods) leading to more consecutive sequences as well as higher MEV-Boost payments on average. For a more comprehensive answer and a more in-depth understanding, an analysis on the true block value (builder profits plus proposer payments) and potentially on individual tx level is necessary. We leave this open for future research.</p>\n<p>This trend also holds when plotting the average payments for each individual builder. The results on this are shown in the <a href=\"https://colab.research.google.com/drive/1kKM-da6xP7St8puzPuyn1Ndag6a6wsg3#scrollTo=e673f535-1bad-41aa-b617-fcdeee234f01&amp;line=3&amp;uniqifier=1\" rel=\"noopener nofollow ugc\">notebook</a>.</p>\n<h3><a name=\"p-49786-finding-3-per-slot-payments-also-increase-with-longer-sequences-8\" class=\"anchor\" href=\"https://ethresear.ch#p-49786-finding-3-per-slot-payments-also-increase-with-longer-sequences-8\"></a>Finding 3: Per Slot Payments also increase with longer sequences</h3>\n<p>Supplementary to the absolute average payment, we also looked into the payment per slot position in longer sequences (Figure 4). E.g. how much was on average paid for the third position in a longer sequence.</p>\n<p><strong><img src=\"https://ethresear.ch/uploads/default/original/3X/3/9/3910c4ca760a17b0ae0a9ec76bb90d27155b5e42.png\" alt=\"\" data-base62-sha1=\"88P8QepGXY3Oj7cs6LD3seQ38SC\" width=\"428\" height=\"333\" role=\"presentation\"></strong><br>\n<em>Figure 4: Average MEV-Boost payments per Sequence Position</em></p>\n<p>Also in the payment per slot analysis a similar trend can be observed, however less prevalent. This suggests that there is slight value in longer sequences, however builders are not willing to bid significantly more for longer consecutive sequences or the first slot after a longer sequence.</p>\n<p>This indicates for us that, at least so far, multi-slot strategies are not applied systematically. In this case, we expect builders would need to pay significantly higher values for later slots to ensure to capture the MEV opportunity prepared earlier.</p>\n<h3><a name=\"p-49786-finding-4-low-auto-correlation-between-consecutive-mev-boost-payments-9\" class=\"anchor\" href=\"https://ethresear.ch#p-49786-finding-4-low-auto-correlation-between-consecutive-mev-boost-payments-9\"></a>Finding 4: Low auto-correlation between consecutive MEV-Boost payments</h3>\n<p><strong></strong></p><div class=\"lightbox-wrapper\"><strong><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/9/d/9db050ae9f5aa540ea6f3c5b6270dee27e111380.png\" data-download-href=\"https://ethresear.ch/uploads/default/9db050ae9f5aa540ea6f3c5b6270dee27e111380\" title=\"\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/9/d/9db050ae9f5aa540ea6f3c5b6270dee27e111380_2_533x321.png\" alt=\"\" data-base62-sha1=\"muYIpGffs7YaMIKuLvKX3WKE9bi\" width=\"533\" height=\"321\" role=\"presentation\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/9/d/9db050ae9f5aa540ea6f3c5b6270dee27e111380_2_533x321.png, https://ethresear.ch/uploads/default/optimized/3X/9/d/9db050ae9f5aa540ea6f3c5b6270dee27e111380_2_799x481.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/9/d/9db050ae9f5aa540ea6f3c5b6270dee27e111380_2_1066x642.png 2x\" data-dominant-color=\"F7F6F5\"></a></strong></div><br>\n<em>Figure 5: Auto-correlation of MEV-Boost Payments</em><p></p>\n<p>We examined auto-correlation in the MEV boost payments to understand if historical MEV data allows us to forecast future MEV and to see if there are low- and high-MEV periods (Figure 5).</p>\n<p>Overall, it can be observed that within the first few slots the correlation strongly decreases until an offset of 2 to 3 slots (we tested for Pearson Correlation Coefficient, Spearman‚Äôs Rank Correlation Coefficient and Kendall‚Äôs Rank Correlation Coefficient). Based on this we can conclude that not more than one to three slots in advance the MEV value can be moderately predicted based on historical data.</p>\n<p>Further interesting observations can be made. As expected, the Spearman and Kendall correlation coefficients are significantly higher than the Pearson correlation coefficient, underlining that the data is not following a normal distribution but being skewed and having large outliers. Additionally, it is interesting to note that for the Pearson correlation coefficient, the complete data set and the top 50% quantile dataset behave similarly, which is not the case for the Spearman and Kendall coefficients. This might be an indicator that the rank ordering for the lower 50% quantile can be more reliably predicted, further underlying that high MEV values are volatile and spiky, hence difficult to predict.</p>\n<h3><a name=\"p-49786-finding-5-no-indication-of-builder-specialization-on-low-or-high-base-fee-volatility-environment-10\" class=\"anchor\" href=\"https://ethresear.ch#p-49786-finding-5-no-indication-of-builder-specialization-on-low-or-high-base-fee-volatility-environment-10\"></a>Finding 5: No indication of builder specialization on low- or high base fee volatility environment</h3>\n<p>Previous research (e.g. [6] &amp; [7]) has found that certain builders specialize in low- or high token price volatility environments, with volatility being measured on CEX-price changes. Further, [5] observe that different builders have different strategies with some focusing on high-value blocks while others on gaining market share in low-MEV blocks.</p>\n<p>Complementary, to determine whether low or high base fee volatility impacts (multi-block) MEV, we analyzed changes in base fee data to identify periods of high volatility. The base fee fluctuations are driven by whether the gas usage in the previous block was below or above the gas target, as defined by <a href=\"https://eips.ethereum.org/EIPS/eip-1559\" rel=\"noopener nofollow ugc\">EIP-1559</a>. To identify high volatility environments, we employed two methods: (i) a more naive approach that calculated price changes per slot, classifying the highest and lowest (negative) 10% of these changes as high volatility periods, with the remaining 80 % of slots being categorized as low volatility. Consequently, high volatility blocks occur following a block with either minimal or significant MEV and/or priority tips. (ii) Secondly, the Garman-Klass volatility [<a href=\"https://arxiv.org/pdf/0807.3492\" rel=\"noopener nofollow ugc\">8</a>] was calculated on an epoch basis, with slots in the top 20% of GK values designated as high volatility. This approach allows us to examine longer periods characterized by minimal or significant MEV and/or priority tips.</p>\n<p>Initial correlation analysis shows only a low correlation between low and high volatile periods and the respective builders (<a href=\"https://en.wikipedia.org/wiki/Cram%C3%A9r%27s_V\" rel=\"noopener nofollow ugc\">Cram√©r‚Äôs V</a> for the naive approach 0.0664 and for the Garman-Klass 0.0772). This indicates that there seems to be no builder specialization based on the volatility environment of the base fee. So, it can be observed that in contrast to token price volatility for base price volatility there seems to not have a specialization of builders developed (yet). Further research is needed to elaborate on this first finding.</p>\n<h2><a name=\"p-49786-limitations-11\" class=\"anchor\" href=\"https://ethresear.ch#p-49786-limitations-11\"></a>Limitations</h2>\n<p>The research presented here is intended as an initial exploratory analysis of the data rather than a comprehensive study. It is important to note several limitations that affect the scope and conclusions of this analysis. Firstly, it is limited by the considered data set being publicly available MEV-Boost payments data. This leaves out roughly 10 % of non-MEV-Boost facilitated blocks and it does not reflect potential private off-chain agreements. Additionally, the data was partially incomplete and in other parts contained duplicate information (see the <a href=\"https://colab.research.google.com/drive/1kKM-da6xP7St8puzPuyn1Ndag6a6wsg3#scrollTo=0d986969-2492-49ac-ad92-8ff78e2a7fe1&amp;line=2&amp;uniqifier=1\" rel=\"noopener nofollow ugc\">notebook</a> for details). Further, missed slots have been excluded so far, a more detailed analysis in the future might focus on the particular effects missed slots have on the subsequent MEV. Lastly, as outlined in the methodology section, using MEV-Boost payments is only a proxy for captured MEV and the competitive metric used in [4] is only partially applicable for our use case.</p>\n<p>As outlined in section Finding 2 it currently can only be speculated about the causation of the increasing average MEV-Boost payouts. Furthermore, running the analysis on the true block value (proposer payment plus builder profits) might generate further insights and solidify the research findings.</p>\n<p>On the frequency analysis, the approach contains somewhat a chicken and egg-problem. The Monte Carlo simulation is run on market shares, while the market shares potentially derive from multi-slot sequences. We see a daily time window as an appropriate balance between precision and the need to filter out isolated effects, although this can be critically challenged.</p>\n<h2><a name=\"p-49786-conclusions-12\" class=\"anchor\" href=\"https://ethresear.ch#p-49786-conclusions-12\"></a>Conclusions</h2>\n<p>Analyzing block meta-data since the merge, we observe that multi-slot sequences occur less frequently than statistically expected. Further, we observe that the average payments for longer multi-slot sequences increase with the sequence length. Similarly, the payments per slot position in longer sequences also slightly rise. This might indicate that there is generally value in longer consecutive sequences. However, considering the only slight increase in value and the fewer observed multi-slot sequences than expected we so far see no indication of deliberate multi-slot MEV strategies being deployed. Also on individual builder level we currently don‚Äôt observe strong deviations from expected distributions. This may also stem from the fact that in the current PBS mechanism, with MEV-Boost operating as a just-in-time (JIT) block auction, creating multi-block MEV opportunities carries inherent risk. This risk arises as creating these opportunities typically requires an upfront investment, and the opportunity might be captured by a competing builder in the next slot, assuming no off-chain collusion between the proposer and builder. This element of risk is a critical factor that could be eliminated by some of the proposed changes to the mechanism (e.g. some APS designs), making it an essential consideration when defining future mechanisms.</p>\n<h2><a name=\"p-49786-references-13\" class=\"anchor\" href=\"https://ethresear.ch#p-49786-references-13\"></a>References</h2>\n<p>[1] Babel K, Daian P, Kelkar M, Juels A. Clockwork finance: Automated analysis of economic security in smart contracts. <em>In 2023 IEEE Symposium on Security and Privacy (SP)</em> 2023 May 21 (pp. 2499-2516). IEEE.</p>\n<p>[2] Mackinga T, Nadahalli T, Wattenhofer R. Twap oracle attacks: Easier done than said?. <em>In 2022 IEEE International Conference on Blockchain and Cryptocurrency (ICBC)</em> 2022 May 2 (pp. 1-8). IEEE.</p>\n<p>[3] Jensen JR, von Wachter V, Ross O. Multi-block MEV. arXiv preprint arXiv:2303.04430. 2023 Mar 8.</p>\n<p>[4] Yang S, Nayak K, Zhang F. Decentralization of Ethereum‚Äôs Builder Market. arXiv preprint arXiv:2405.01329. 2024 May 2.</p>\n<p>[5] √ñz B, Sui D, Thiery T, Matthes F. Who Wins Ethereum Block Building Auctions and Why?. arXiv preprint arXiv:2407.13931. 2024 Jul 18.</p>\n<p>[6] Gupta T, Pai MM, Resnick M. The centralizing effects of private order flow on proposer-builder separation. arXiv preprint arXiv:2305.19150. 2023 May 30.</p>\n<p>[7] Heimbach L, Pahari V, Schertenleib E. Non-atomic arbitrage in decentralized finance. arXiv preprint arXiv:2401.01622. 2024 Jan 3.</p>\n<p>[8] Meilijson I. The Garman-Klass volatility estimator revisited. arXiv preprint arXiv:0807.3492. 2008 Jul 22.</p>\n            <p><small>4 posts - 2 participants</small></p>\n            <p><a href=\"https://ethresear.ch/t/does-multi-block-mev-exist-analysis-of-2-years-of-mev-data/20345\">Read full topic</a></p>","link":"https://ethresear.ch/t/does-multi-block-mev-exist-analysis-of-2-years-of-mev-data/20345","pubDate":"Wed, 28 Aug 2024 10:31:36 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20345"},"source":{"@url":"https://ethresear.ch/t/does-multi-block-mev-exist-analysis-of-2-years-of-mev-data/20345.rss","#text":"Does multi-block MEV exist? Analysis of 2 years of MEV Data"}},{"title":"A Note on Equivocation in Slot Auction ePBS","dc:creator":"Julian","category":"Proof-of-Stake","description":"<p><em>Thanks to Francesco D‚ÄôAmato, Barnab√© Monnot, Mike Neuder, and Thomas Thiery for feedback and review. Thanks again to Francesco for coming up with the second proposal.</em></p>\n<p>Whether we want to implement slot auctions into ePBS is an <a href=\"https://www.notion.so/Arguments-in-Favor-and-Against-Slot-Auctions-in-ePBS-c7acde3ff21b4a22a3d41ac4cf4c75d6?pvs=21\" rel=\"noopener nofollow ugc\">active discussion area</a>, and support for slot auctions was signaled in the <a href=\"https://youtu.be/fQx_UbaPX-E?si=C8ALtI4zOSmFjRpN\" rel=\"noopener nofollow ugc\">seventh ePBS breakout call</a>. Currently, the ecosystem lacks knowledge about the fork choice safety of slot auctions in the <a href=\"https://ethereum-magicians.org/t/eip-7732-enshrined-proposer-builder-separation-epbs/19634\" rel=\"noopener nofollow ugc\">current ePBS proposal</a>. This note presents two strawman proposals to start discussing the forkchoice safety of slot auction ePBS.</p>\n<p>This note presupposes the reader is familiar with the ePBS proposal (<a href=\"https://ethereum-magicians.org/t/eip-7732-enshrined-proposer-builder-separation-epbs/19634\" rel=\"noopener nofollow ugc\">EIP-7732</a>).  An essential part of this EIP is that a <em>payload boost</em> is applied to a beacon block if the <a href=\"https://ethresear.ch/t/payload-timeliness-committee-ptc-an-epbs-design/16054#proposer-initiated-splitting-18\">Payload-timeliness committee (PTC)</a> reaches a quorum. If an execution payload is seen on time by a majority of the PTC, the beacon block that corresponds to the execution payload receives additional fork-choice weight (Reveal Boost). If the PTC observes a timely message from the builder stating that it withholds its payload, the additional fork-choice weight is given to the parent block of the beacon block corresponding with the withhold message (Withholding Boost).</p>\n<p>In <a href=\"https://mirror.xyz/0x03c29504CEcCa30B93FF5774183a1358D41fbeB1/CPYI91s98cp9zKFkanKs_qotYzw09kWvouaAa9GXBrQ\" rel=\"noopener nofollow ugc\">slot auction</a> ePBS, the beacon proposer does not commit to an execution payload hash, unlike in block auction ePBS. Instead, it commits to a specific builder that can submit an execution payload when it is time to reveal. The first problem is that a builder could submit multiple execution payloads. In this note, we will refer to this as a builder equivocation.</p>\n<p>In block auction ePBS, something similar to equivocation is possible. The builder could wait for at least one PTC member to vote <code>PAYLOAD_ABSENT</code> and then release a withhold message and an execution payload to split the PTC‚Äôs view such that none of the three vote options (<code>PAYLOAD_ABSENT</code>, <code>PAYLOAD_WITHHELD</code>, <code>PAYLOAD_PRESENT</code>) reaches the <a href=\"https://discord.com/channels/595666850260713488/874767108809031740/1272916231250382939\" rel=\"noopener nofollow ugc\">quorum of 50%</a> of the votes.</p>\n<p>In block auction ePBS, this equivocation does not benefit the builder much. If the PTC does not reach a quorum, no payload boost is applied, and the honest next-slot validator will take the payload as head. If the builder equivocates, the protocol does not need to guarantee Builder Reveal Safety since the builder does not act as the protocol expects. Still, the builder does not have the flexibility to submit a different execution payload since the beacon block commits to the execution payload hash.</p>\n<p>It could be that the builder is incentivized to play a <a href=\"https://arxiv.org/abs/2305.09032\" rel=\"noopener nofollow ugc\">timing game</a> and eventually decides that it is best if the block were withheld. The builder could submit a withhold message and see if the PTC will reach a quorum on <code>PAYLOAD_WITHHELD</code>. If the PTC does not seem to do so, and the PTC also has not yet reached a quorum on <code>PAYLOAD_ABSENT</code>, the builder reveals its payload after all. This attack seems difficult to pull off, but it allows the builder to check whether it can renege on its promised payment to the proposer while still landing its payload on-chain if it has to pay (assuming an honest next-slot proposer).</p>\n<p>In slot auction ePBS, a builder may be more incentivized to equivocate because it can change the contents of its execution payload. For example, the builder could broadcast a particular execution payload, but a short time later, a significant MEV opportunity appears, and the builder now wants to broadcast a new execution payload.</p>\n<p>Preventing equivocations in slot auction ePBS would be desirable because equivocations would cause insecurity in fork choice. Specifically, we want to obtain the following properties with minimal changes.</p>\n<blockquote>\n<p><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/bulb.png?v=12\" title=\":bulb:\" class=\"emoji only-emoji\" alt=\":bulb:\" loading=\"lazy\" width=\"20\" height=\"20\"><strong>Desiderata</strong></p>\n<ol>\n<li>If the builder reveals precisely one timely execution payload, it should retain the same Builder Reveal Safety guarantees as in block auction ePBS</li>\n<li>If the builder reveals multiple timely and equivocating execution payloads,<br>\na. no execution payload should go on-chain,<br>\nb. but the Unconditional Payment should be as strong as in block auction ePBS</li>\n</ol>\n</blockquote>\n<p>Should slashing or a penalty be applied to equivocating execution payload messages? This question is relevant to block and slot auction ePBS, although the potential benefits of equivocation are likely to be higher in slot auction ePBS. Since ePBS still allows local block construction, it seems unwise to apply harsh slashing or penalties if there is equivocation because this may disincentivize local block construction. Moreover, since it is not clear that there are significant gains to be made from equivocating execution payloads, and if gains are to be made, slashing or penalties do not qualitatively change this, so slashing or penalties are not immediately necessary.</p>\n<h2><a name=\"p-49750-proposal-1-vote-for-execution-payload-hash-1\" class=\"anchor\" href=\"https://ethresear.ch#p-49750-proposal-1-vote-for-execution-payload-hash-1\"></a>Proposal 1: Vote for Execution Payload Hash</h2>\n<p>The first strawman proposal to obtain these properties involves changing the block auction ePBS fork-choice specification as follows.</p>\n<blockquote>\n<p><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/bulb.png?v=12\" title=\":bulb:\" class=\"emoji\" alt=\":bulb:\" loading=\"lazy\" width=\"20\" height=\"20\"> <strong>Proposal 1: Vote for Execution Payload Hash</strong></p>\n<ol>\n<li>Replace <code>PAYLOAD_PRESENT</code> with <code>execution_payload_hash</code></li>\n<li>If no PTC quorum is reached, let the honest next-slot validator use an empty block as its head instead of a full block.</li>\n</ol>\n</blockquote>\n<p>A PTC member would now vote for the <code>execution_payload_hash</code> it has observed instead of simply voting whether a payload is present. Reveal boost is applied if a quorum is reached on <code>execution_payload_hash</code>. Intuitively, this is necessary for slot auctions since the PTC now indicates which execution payload should be used if the block is full and not just that the block is full.</p>\n<p>It seems like desideratum 1‚Äîthe same Builder Reveal Safety as in block auction ePBS‚Äîis immediately satisfied since an honest builder does not release equivocating execution payloads. A PTC member‚Äôs <code>execution_payload_hash</code> vote functions the same as a <code>PAYLOAD_PRESENT</code> vote.</p>\n<p>If the builder equivocates but the PTC still reaches a quorum on <code>execution_payload_hash</code>, then the execution payload will make it on-chain in the same way a payload would have made it on-chain if the builder did not equivocate. I believe this is fine because the builder released an equivocating payload that did not split the view of the PTC (sufficiently). This indicates that this equivocating payload is a minor threat to the fork-choice security. Although this outcome contradicts desideratum 2a, the timely requirement in desideratum 2 should be read as the execution payload intends to split the view of the PTC sufficiently.</p>\n<p>If the builder equivocates and the PTC does not reach a quorum, then the next-slot honest proposer should see an empty block as its head. The builder loses some of its Builder Reveal Safety because it could be that the builder reveals only one payload (does not equivocate), yet the PTC does not reach a quorum. However, Builder Reveal Safety is not very strong in block auction ePBS either because a next-slot rational proposer would prefer to build on an empty block than a full block since these are more valuable (the ex-post reorg safety is low if reveal boost is not applied). Changing the default next-slot honest proposer behavior from seeing a full block to an empty block as its head does not change much in Builder Reveal Safety, and the system then satisfies desideratum 2.</p>\n<p>What if the next-slot proposer is dishonest? The builder could collude with the next-slot proposer and broadcast messages such that the PTC does not reach a quorum and include an execution payload late. This is similar to the attack in block auction ePBS, where a builder tries to get Withhold Boost to apply but releases an execution payload if it does not succeed. The builder and next-slot proposer collusion allows the builder to play aggressive timing games while ensuring Builder Reveal Safety. These timing games come at the expense of the execution validation time of the attesting committee. It is not immediately apparent what this attack would gain for the builder and next-slot proposer collusion since the builder timing game gain comes almost entirely from the next-slot proposer‚Äôs revenues.</p>\n<p>The downside of this proposal is the problem of free data availability. The PTC could now reach a quorum on an <code>execution_payload_hash</code>. These PTC votes would end up on-chain, and an adversary could use them to show that a piece of data was available to the PTC. Yet the adversary would not have to pay the base fee needed to provide the data on-chain; it only has to pay the proposer to commit to the adversary as the builder.</p>\n<h2><a name=\"p-49750-proposal-2-pretend-payload-absent-2\" class=\"anchor\" href=\"https://ethresear.ch#p-49750-proposal-2-pretend-payload-absent-2\"></a>Proposal 2: Pretend Payload Absent</h2>\n<p>The second strawman proposal does not suffer from the free data availability problem and achieves the desiderata as follows.</p>\n<blockquote>\n<p><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/bulb.png?v=12\" title=\":bulb:\" class=\"emoji\" alt=\":bulb:\" loading=\"lazy\" width=\"20\" height=\"20\"> <strong>Proposal 2: Pretend Payload Absent</strong><br>\nIf the next-slot proposer/attesters observe(s) at least two equivocating payloads, it/they assign(s) no additional fork-choice weight to any empty or full block</p>\n</blockquote>\n<p>The behavior of a PTC member does not change from the block auction ePBS specification. However, suppose a proposer sees that the block producer in the previous slot released equivocating execution payloads. In that case, it ignores the fork-choice weight the PTC may have given to any fork.</p>\n<p>If the builder is honest, this does not change its Builder Reveal Safety since the system works exactly as it does in block auction ePBS. Desideratum 1 is thus immediately satisfied.</p>\n<p>If the builder equivocates, an honest-but-rational proposer will choose to build on an empty block since it allows the proposer to extract the MEV from two slots of time instead of one. The attesters will not object to this since they observed the equivocating payloads and assigned no additional fork-choice weight to any forks. Therefore, if the next-slot proposer and attesters are honest, desideratum 2 is also satisfied.</p>\n<p>The next-slot proposer could collude with the builder. The builder could equivocate, and the next-slot proposer could choose to build on a full block. Similarly to the collusion situation described in the first proposal, though, the gain that a builder gets from this equivocation seems to primarily come from the profits the next-slot proposer could make. It is not clear that the joint utility of the collusion increases by enough to justify the collusion.</p>\n<p>A builder and a next-slot proposer could collude to ensure an execution payload does not become canonical. Consider a builder that submits an execution payload, and the PTC reaches a quorum on whether this payload is timely. Later, the builder regrets the contents of its execution payload and aims to remove it from the canonical chain. It could then release an equivocation payload so the next-slot proposer will not build on the undesirable execution payload. This is similar to a builder not revealing its block in block auction ePBS.</p>\n<p>In conclusion, these strawman proposals seem to achieve the same fork-choice safety under slot auctions as under block auctions with minimal changes. While the first proposal has a problem with free data availability, the second proposal may be more susceptible to builder games, such as reorging its execution payload. The lack of free data availability and being less susceptible to builder games are advantages of slot auctions in ePBS. Further research on a design that simultaneously solves both problems would be very valuable. If you are interested in working on (slot auctions in) ePBS, please see this <a href=\"https://www.notion.so/ePBS-EIP-7732-tracker-9f85f7b086994bd79192bc72bae703a1?pvs=21\" rel=\"noopener nofollow ugc\">page</a>!</p>\n            <p><small>6 posts - 3 participants</small></p>\n            <p><a href=\"https://ethresear.ch/t/a-note-on-equivocation-in-slot-auction-epbs/20331\">Read full topic</a></p>","link":"https://ethresear.ch/t/a-note-on-equivocation-in-slot-auction-epbs/20331","pubDate":"Fri, 23 Aug 2024 16:52:02 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20331"},"source":{"@url":"https://ethresear.ch/t/a-note-on-equivocation-in-slot-auction-epbs/20331.rss","#text":"A Note on Equivocation in Slot Auction ePBS"}},{"title":"The Role of the P2P Market in ePBS","dc:creator":"Julian","category":"Economics","description":"<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/d/1/d178209b1bebdec57cfa0665bfacea6970512e8c.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/d178209b1bebdec57cfa0665bfacea6970512e8c\" title=\"role_of_p2p\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/d/1/d178209b1bebdec57cfa0665bfacea6970512e8c_2_690x389.jpeg\" alt=\"role_of_p2p\" data-base62-sha1=\"tT3a6Eh20ESatNn7IqboSefeEQk\" width=\"690\" height=\"389\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/d/1/d178209b1bebdec57cfa0665bfacea6970512e8c_2_690x389.jpeg, https://ethresear.ch/uploads/default/optimized/3X/d/1/d178209b1bebdec57cfa0665bfacea6970512e8c_2_1035x583.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/d/1/d178209b1bebdec57cfa0665bfacea6970512e8c_2_1380x778.jpeg 2x\" data-dominant-color=\"504F56\"></a></div><br>\n<em>A two-tier auction market: the right resembles the less sophisticated publicly observable P2P market, and the left resembles the more sophisticated private RPC market.</em><p></p>\n<p><em>Thanks to Potuz, Barnab√© Monnot, Terence Tsao, and Thomas Thiery for comments and discussion.</em></p>\n<p>The current ePBS proposal, <a href=\"https://eips.ethereum.org/EIPS/eip-7732\" rel=\"noopener nofollow ugc\">EIP-7732</a>, suggests operating a two-tier market where builders can bid to obtain the execution payload construction rights. Large block builders are expected to use the pull-based direct connection market. This market allows for lower latency and more flexibility for the builder, as the builder only needs to commit to its bid once the proposer asks for it. This market, however, requires the proposer to connect to the builder‚Äôs RPC and actively pull bid(s) from it. Smaller builders who lack this connectivity with the validator set can use the push-based P2P market. This market has stricter rules for what bidders can do but does not need the proposer to pull bid(s) from it since bids are pushed to the proposer.</p>\n<p>This note explores the role of the P2P market in ePBS. Although there has been some <a href=\"https://ethresear.ch/t/builder-bidding-behaviors-in-epbs/20129\">initial</a> <a href=\"https://hackmd.io/@potuz/HyhN0Nt9A\" rel=\"noopener nofollow ugc\">exploration</a> on the topic, this note presents a clear counterfactual of a world where the P2P market were not included in EIP-7732. This note also emphasizes <a href=\"https://collective.flashbots.net/t/tee-boost/3741/5\" rel=\"noopener nofollow ugc\">multiplexing</a>‚Äîthe ability of proposers to discover builders‚Äîas the most important aspect of the P2P market.</p>\n<p>The three arguments in favor of the P2P market that the author has seen in previous work are: 1) it allows anyone to set a floor price for the auction, 2) it can be used for MEV-Burn in future protocol upgrades, and 3) it lowers entry barriers for new entrants or long-tail builders.</p>\n<p>The first argument is that allowing anyone to bid via the publicly observable P2P market gives all validators the ability to set a floor price for the auction. Validators can bid based on the block that they could locally build. Builders must then bid at least above the bid of these validators to obtain the execution payload construction rights. It has been argued that this is valuable if a cartel of builders intends to keep bids low. The floor price, however, would not break up a cartel. Although proposers would make slightly more revenue in this case, it is unclear what the value of such a floor price is to the protocol.</p>\n<p>The beacon proposer selling the rights may be the ideal party to set a reserve price. As I argue in <a href=\"https://mirror.xyz/0x03c29504CEcCa30B93FF5774183a1358D41fbeB1/8aCbi_a-Gh5DWnkJWstm8zA5fvtoQB-QR5we7C8XC90\" rel=\"noopener nofollow ugc\">this post</a>, a proposer may want to put a higher reserve price than its valuation for the execution payload construction rights to attract higher bids from builders. The P2P market allows the proposer to signal its reserve price to the market. In this sense, the P2P market allows the validator and other participants to express their preferences.</p>\n<p>The second argument states that the P2P market may facilitate <a href=\"https://ethresear.ch/t/mev-burn-a-simple-design/15590\">MEV-Burn</a> in future protocol upgrades. MEV-Burn aims to decouple the rewards from selling execution payload construction rights from being a validator. This has numerous benefits; for example, it decreases the value of using a staking service provider (SSP) since MEV-Burn decreases the variance of validator payoffs. MEV-Burn requires that builder bids be legible to the protocol. Most designs achieve this by having a committee that observes the best available bids. If ePBS would only have the direct connection market, the MEV-Burn designs need to be revisited since a proposer selling the execution rights is incentivized to understate the amount that will be burnt. Still, the P2P market is expected to only reflect a small portion of the value of the execution payload construction rights, hence even ePBS with the P2P market may not be satisfactory for an effective MEV-Burn solution.</p>\n<p>The last reason for the P2P market is that it would allow builders from which proposers are unlikely to pull bids to still compete in the market. Proposers may be unlikely to pull bids from builders that infrequently participate in the auction because they are very specialized or from new builders unknown to the proposer. This could be because proposers have an outdated whitelist of builders from which to pull bids. Allowing these proposers to participate in the push-based P2P market will result in more builder diversity in block construction, which may benefit the protocol.</p>\n<p>This last reason is what we will explore in this post. Specifically, what does the Ethereum ecosystem gain by enshrining the push-based P2P market aside from an out-of-protocol solution that facilitates small builders‚Äô participation in the market?</p>\n<p>Shea Ketsdever recently released a post on <a href=\"https://collective.flashbots.net/t/tee-boost/3741\" rel=\"noopener nofollow ugc\">TEE-Boost</a>, an adaptation of MEV-Boost that uses Trusted Execution Environments. In this post, she highlights the different roles a relay plays. One of the roles is multiplexing, allowing proposers to discover builders who may want to participate in the auction.</p>\n<p>The ePBS P2P market aims to achieve multiplexing. In the context of ePBS, multiplexing has at least two facets: trustlessness and value reflection. Trustlessness is important because ePBS removes the trust that proposers and builders must place in a relay to facilitate the fair exchange. Value reflection is essential because a multiplexing tool that poorly reflects the value bidders assign to the auctioned item will not efficiently match an auctioneer with the correct bidder.</p>\n<p>The ePBS P2P market scores very well on the trustlessness front. Neither a proposer nor a builder must trust anyone since bids are broadcast via the P2P network, and the winning bid is committed to on-chain. The P2P market, however, scores poorly on the value reflection front. Since the P2P network must be DOS resistant, it cannot handle too many bids, so bidders will likely not be allowed to bid as often as they could in MEV-Boost, meaning they have to be strategic about when they bid. Moreover, early bids will not be able to be canceled, which could lead to strategic builders only winning via the P2P market if the valuation of other builders that operate via the direct connection market has decreased (<a href=\"https://www.youtube.com/watch?v=-PXGPFFneMI\" rel=\"noopener nofollow ugc\">adverse selection</a>). Finally, the value reflection of the P2P market relative to the RPC market will worsen as the RPC market becomes more sophisticated while the P2P market becomes stale.</p>\n<p>How would an out-of-protocol actor facilitate multiplexing if ePBS were deployed? In MEV-Boost, relays facilitate multiplexing because submitting blocks to relays is (largely) permissionless, and relays are well-connected to validators. In ePBS, a relay - from no one referred to as a bid curation relay - would look different. A bid curation relay could open an RPC endpoint that proposers connect to and host an auction where builders submit bids, like in MEV-Boost. Bids, however, do not need to contain transaction data since the bid curation relay would not be responsible for the fair exchange problem that is solved via ePBS. Bids in ePBS are a bid value and the hash of the execution payload. A proposer then pulls the highest bid from the bid curation relay and, if it so desires, commits to the highest bid via the in-protocol ePBS system. A winning builder then sees this in-protocol commitment and publishes the block via ePBS.</p>\n<p>It becomes clear that the trust assumptions that proposers and builders must place in a bid curation relay are vastly lower than in MEV-Boost. Essentially, the proposer and builders must trust the bid curation relay to forward the highest-paying bid when the proposer asks for it. The bid curation relay is not trusted with the block contents (<a href=\"https://collective.flashbots.net/t/tee-boost/3741\" rel=\"noopener nofollow ugc\">builder privacy</a> is preserved) and is not responsible for unconditional payment (<a href=\"https://collective.flashbots.net/t/tee-boost/3741\" rel=\"noopener nofollow ugc\">data availability and validation</a> are enforced via the protocol).</p>\n<p>The ePBS relay scores worse on the trustlessness front than the P2P market since the proposer and builders must trust the relay not to censor its bids. On the other hand, the value reflection of such a bid curation relay could be far better. The relay could offer bid cancellations and high-frequency bidding to builders. Moreover, relays could invest in latency reductions and charge for this, as some do in MEV-boost. If a relay successfully reduces latency, more prominent builders may connect to it. This means the value reflection of relays relative to directly connected builders may remain stable or improve over time.</p>\n<p><a href=\"https://collective.flashbots.net/t/tee-boost/3741/5?u=julian\" rel=\"noopener nofollow ugc\">Shea also highlights</a> another option that has been discussed widely before: next to the P2P market; there could be an on-chain registry of builders. There could be a smart contract that any builder could write its RPC endpoint to. Any validator could then see the available RPC endpoints and pull bids from it during its slot. This alternative scores well on the trustlessness front since no trust is required, and it scores well on the value reflection point since it allows all builders to compete on a similar level. The proposer could pull from this registry every time it is supposed to propose a block.</p>\n<p>Why do we care about multiplexing? Multiplexing contributes to the credible neutrality of the network. In the context of ePBS, credible neutrality may mean something like this: the builder with the highest valuation for the execution payload construction rights is allocated these rights. If proposers were to rely solely on directly connected builders, some long-tail builders who happened to have an exceptionally high value for a specific block might be excluded. If proposers rely on bid curation relays, they may not forward the highest-paying bid because they prefer to forward another bid for whatever reason. If proposers rely on an on-chain registry of builders, it may not connect to the newer or smaller builders.</p>\n<p>Allowing multiplexing to contribute to credible neutrality is a trade-off between trustlessness and value reflection. If a completely trustless market is so poor at value reflection that it never surfaces a winning bid, it does not contribute much to credible neutrality. If a perfectly value-reflecting market puts a lot of trust in one party, the benefit of credible neutrality is also nonexistent.</p>\n<p>To conclude, the P2P market is easy to implement, and its maintenance does not require a hard fork so clients can iterate freely. Although the P2P market only contributes a little to the core functionality of ePBS, there are virtually no downsides to implementing it, and it is a nice feature that may benefit some users and could be beneficial for proposers as it increases their revenues and may be helpful for MEV-Burn in the future. Further work could specify the P2P market rules and how an on-chain registry of builder RPC endpoints could work.</p>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://ethresear.ch/t/the-role-of-the-p2p-market-in-epbs/20330\">Read full topic</a></p>","link":"https://ethresear.ch/t/the-role-of-the-p2p-market-in-epbs/20330","pubDate":"Fri, 23 Aug 2024 16:01:14 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20330"},"source":{"@url":"https://ethresear.ch/t/the-role-of-the-p2p-market-in-epbs/20330.rss","#text":"The Role of the P2P Market in ePBS"}},{"title":"An Automatic Technique to Detect Storage Collisions and Vulnerabilities within Solidity Smart Contract","dc:creator":"WaizKhan7","category":"Security","description":"<p>Storage collisions and vulnerabilities within Ethereum smart contracts can lead to unexpected issues like freezing funds, escalating privileges, and financial asset theft. A storage collision occurs when two different storage structs unintentionally use same storage slot(s), or the slot layout is changed during the upgrade of implementation contract. These collision vulnerabilities have been detected in large numbers (worth millions of dollars) in a <a href=\"https://www.ndss-symposium.org/ndss-paper/not-your-type-detecting-storage-collision-vulnerabilities-in-ethereum-smart-contracts/\" rel=\"noopener nofollow ugc\">recent study</a> within smart contracts deployed on the Ethereum network.</p>\n<p>In this topic, we propose a more accurate and complete technique to detect storage vulnerabilities and collisions in Solidity smart contracts. And encourage the Ethereum community to <strong>provide feedback on the proposed technique</strong>.</p>\n<h3><a name=\"p-49742-introduction-1\" class=\"anchor\" href=\"https://ethresear.ch#p-49742-introduction-1\"></a>Introduction</h3>\n<p>We are working on a solution based on advanced static analysis techniques that can identify vulnerabilities within the deep storage of Ethereum Solidity smart contracts. We aim to detect storage collisions in proxy contracts deployed on the Ethereum network like ERC-2535 (Diamond/Multi-Facet Proxy), ERC-1822, upgrade proxy pattern, etc., as complex proxy contracts are more likely to experience a storage collision, like during the upgrade of implementation or facet contracts.</p>\n<p><a href=\"https://www.ndss-symposium.org/ndss-paper/not-your-type-detecting-storage-collision-vulnerabilities-in-ethereum-smart-contracts/\" rel=\"noopener nofollow ugc\">N. Ruaro et al.</a> analyzed Ethereum contracts using contract bytecode to detect storage collisions and reported 14,891 vulnerable contracts. Their technique was able to identify storage slot types correctly with an accuracy of 87.3%. Whereas, we aim to build a solution that will use source code to accurately analyze the storage layout and slot types of the contract. Furthermore, we will also analyze dynamic arrays, mapping variables, and complex nested structs in our analysis.</p>\n<p>Suppose a collision occurs on the state variables‚Äô base slots, our approach will allow us to identify the impact of the collision on dynamic arrays and mapping variables declared consecutively, and arrays data type or mappings key types are same which is a common practice in large contracts like gaming contracts.</p>\n<p>As shown in the below example code, the slot layout was changed during the contract upgrade, and since <code>token_uris</code> and <code>token_version</code> have same key types and data types, both variables will return each other‚Äôs data after the upgrade due to collision.</p>\n<pre><code class=\"lang-auto\">library ImplementationStorage1 {\n    struct AddressSlot {\n        address owner; // slot n+0\n        mapping(uint256 =&gt; string) token_uris; // slot n+1\n        mapping(uint256 =&gt; string) token_versions; // slot n+2\n    }\n\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n\n// updated code\nlibrary ImplementationStorage2 {\n    struct AddressSlot {\n        address owner; //slot n+0\n        mapping(uint256 =&gt; string) token_versions; // slot n+1 (shld be token_uris)\n        mapping(uint256 =&gt; string) token_uris; // slot n+2 (shld be token_versions)\n    }\n\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n</code></pre>\n<p><code>token_uris</code> accessing <code>token_versions</code> and vice-versa after the upgrade.</p>\n<pre><code class=\"lang-auto\">       (before upgrade)                        (after upgrade)   \n      _________________                      _________________\n     |     Proxy       |                     |     Proxy       |\n     |_________________|                     |_________________|\n     | * IMPLEMENT_SLOT| --&gt; NFTManager1     | * IMPLEMENT_SLOT| --&gt; NFTManager2\n     | * ADMIN_SLOT    |                     | * ADMIN_SLOT    |\n     |_________________|                     |_________________|\n     | + upgradeTo()   |                     | + upgradeTo()   |\n     | + changeAdmin() |                     | + changeAdmin() |\n     |_________________|                     |_________________|\n              |                                       |\n              v                                       v\n      _________________                       _________________\n     |   NFTManager1   |                     |   NFTManager2   |\n     |_________________|                     |_________________|\n     | - owner         |                     | - owner         |\n     | - token_uris    | **** collision **** | - token_versions|\n     | - token_versions| **** collision **** | - token_uris    |\n     |_________________|                     |_________________|\n\n</code></pre>\n<p>We plan to build a technology that will automatically detect all storage collisions within a Solidity smart contract.</p>\n<h4><a name=\"p-49742-methodology-2\" class=\"anchor\" href=\"https://ethresear.ch#p-49742-methodology-2\"></a>Methodology</h4>\n<p>We have structured our development plan into three distinct phases, outlined as follows:</p>\n<ul>\n<li><strong><strong>Automatic State Variable Detector and Slot Layout Calculator</strong></strong></li>\n</ul>\n<p>In this phase, we focus on developing an automatic state variable detector and slot layout calculator. This component will facilitate the identification of state variables within smart contracts and determine their corresponding slot layout. By automating this process, we aim to streamline the initial analysis procedures.</p>\n<p>Sample output of Slot Calculator</p>\n<pre><code class=\"lang-auto\">slot 0 - mapping ds.selectorToFacetAndPosition[bytes4] = FacetAddressAndPosition;\nslot 1 - mapping ds.facetFunctionSelectors[address] = FacetFunctionSelectors;\nslot 2 - address [] ds.facetAddresses;\nslot 3 - mapping ds.supportedInterfaces[bytes4] = bool;\nslot 4 - address ds.contractOwner;\nslot 5 - mapping ds.tempSelectorsNested[uint256] = FacetAddressAndPosition;\nslot 6 - FacetAddressAndPosition [] ds.FacetAddressAndPositionArray;\nslot 7 - mapping ds.tempMapping[uint256] = uint256;\nslot 8 - mapping ds.tempMapping2[address] = uint256;\n</code></pre>\n<ul>\n<li><strong><strong>Mapping Keys Analyzer and Slot Calculator of Complex Variables</strong></strong></li>\n</ul>\n<p>Building upon the foundation established in phase 1, in this phase we will first extend the slot calculator capability to calculate the slots of complex variables and their entries (for all data types) i.e. slots of mapping keys, dynamic array, complex struct, mappings with complex struct as value.</p>\n<p>This component will also include the approximation of all keys used in mapping variables for saving data using advanced static analysis techniques. By accurately approximating keys and calculating entries, we seek to enhance the precision and breadth of storage slot calculation methodology, which will help detect storage collision within deep storage data of a smart contract.</p>\n<ul>\n<li><strong><strong>Collision Detector for State Variables and Complex Variables All Entries Slots</strong></strong></li>\n</ul>\n<p>The final phase of our methodology focuses on implementing a collision detector for both state variables and complex variable slots. This critical component will identify any potential collisions or conflicts within any type of state variables and their associated variable(s)/value(s) slots. By detecting and addressing collisions, we aim to ensure the integrity and reliability of smart contracts.</p>\n<p>We aim to develop a robust and comprehensive methodology for smart contract storage collision detectors, by systematically progressing through above discussed three development phases.</p>\n<h4><a name=\"p-49742-conclusion-3\" class=\"anchor\" href=\"https://ethresear.ch#p-49742-conclusion-3\"></a>Conclusion</h4>\n<p>The development of our solution will allow developers to ensure that their contract has no potential storage collisions before deployment. It will also be able to detect storage collisions within deep storage of deployed smart contracts and can help in securing contracts worth millions of dollars.</p>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://ethresear.ch/t/an-automatic-technique-to-detect-storage-collisions-and-vulnerabilities-within-solidity-smart-contract/20328\">Read full topic</a></p>","link":"https://ethresear.ch/t/an-automatic-technique-to-detect-storage-collisions-and-vulnerabilities-within-solidity-smart-contract/20328","pubDate":"Fri, 23 Aug 2024 09:35:11 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20328"},"source":{"@url":"https://ethresear.ch/t/an-automatic-technique-to-detect-storage-collisions-and-vulnerabilities-within-solidity-smart-contract/20328.rss","#text":"An Automatic Technique to Detect Storage Collisions and Vulnerabilities within Solidity Smart Contract"}},{"title":"Mechan-stein (alt. Franken-ism)","dc:creator":"mikeneuder","category":"Block proposer","description":"<h1><a name=\"p-49714-mechan-stein-alt-franken-ismbrp-classsmallsmall-choose-your-own-adventurehttpsxcomvitalikbuterinstatus1788489148183019929-either-way-just-trying-to-portmanteau-frankenstein-and-mechanismsmallp-1\" class=\"anchor\" href=\"https://ethresear.ch#p-49714-mechan-stein-alt-franken-ismbrp-classsmallsmall-choose-your-own-adventurehttpsxcomvitalikbuterinstatus1788489148183019929-either-way-just-trying-to-portmanteau-frankenstein-and-mechanismsmallp-1\"></a>Mechan-stein (alt. Franken-ism)<br><p><small><em>^ <a href=\"https://x.com/VitalikButerin/status/1788489148183019929\" rel=\"noopener nofollow ugc\">choose your own adventure</a> ‚Äì either way, just trying to portmanteau ‚ÄòFrankenstein‚Äô and ‚ÄòMechanism.‚Äô</em></small></p></h1>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/3/d/3d13edb2750f779fb39f38e943038de48a692422.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/3d13edb2750f779fb39f38e943038de48a692422\" title=\"upload_2936c4a8e65027883c0cacec063f9ea2\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/3/d/3d13edb2750f779fb39f38e943038de48a692422_2_498x500.jpeg\" alt=\"upload_2936c4a8e65027883c0cacec063f9ea2\" data-base62-sha1=\"8IjOZ06fIgkHslXWliL0RLOHwXM\" width=\"498\" height=\"500\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/3/d/3d13edb2750f779fb39f38e943038de48a692422_2_498x500.jpeg, https://ethresear.ch/uploads/default/optimized/3X/3/d/3d13edb2750f779fb39f38e943038de48a692422_2_747x750.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/3/d/3d13edb2750f779fb39f38e943038de48a692422_2_996x1000.jpeg 2x\" data-dominant-color=\"8B9D84\"></a></div><br>\n<sub><em><strong>^‚Äúdon‚Äôt worry bro, just one more auction, i swear. check it out.‚Äù h/t Mallesh for the relevant <a href=\"https://x.com/malleshpai/status/1748026472923623619\" rel=\"noopener nofollow ugc\">tweet</a>.</strong></em><br>\n</sub><p></p>\n<p><span class=\"math\">\\cdot</span><br>\n<em>by <a href=\"https://twitter.com/mikeneuder\" rel=\"noopener nofollow ugc\">mike</a> ‚Äì wednesday; august 21, 2024.</em><br>\n<sub><em>^hbd <a href=\"https://en.wikipedia.org/wiki/Bo_Burnham\" rel=\"noopener nofollow ugc\">Bo</a>. if you, dear reader, haven‚Äôt seen <a href=\"https://en.wikipedia.org/wiki/Bo_Burnham:_Inside\" rel=\"noopener nofollow ugc\">‚ÄúInside‚Äù</a> or <a href=\"https://www.youtube.com/watch?v=5XWEVoI40sE\" rel=\"noopener nofollow ugc\">‚ÄúInside Outtakes,‚Äù</a> watching them is your homework assignment.</em></sub><br>\n<span class=\"math\">\\cdot</span><br>\n<em>Many thanks to <a href=\"https://x.com/barnabemonnot\" rel=\"noopener nofollow ugc\">Barnab√©</a>, <a href=\"https://x.com/_julianma\" rel=\"noopener nofollow ugc\">Julian</a>, <a href=\"https://x.com/soispoke\" rel=\"noopener nofollow ugc\">Thomas</a>, <a href=\"https://x.com/jacobykaufmann\" rel=\"noopener nofollow ugc\">Jacob</a>, <a href=\"https://x.com/mteamisloading\" rel=\"noopener nofollow ugc\">mteam</a>, <a href=\"https://x.com/nero_eth\" rel=\"noopener nofollow ugc\">Toni</a>, <a href=\"https://x.com/drakefjustin\" rel=\"noopener nofollow ugc\">Justin</a>, <a href=\"https://x.com/vitalikbuterin\" rel=\"noopener nofollow ugc\">Vitalik</a>, <a href=\"https://x.com/MaxResnick1\" rel=\"noopener nofollow ugc\">Max</a>, and <a href=\"https://x.com/malleshpai\" rel=\"noopener nofollow ugc\">Mallesh</a> for discussions around these topics and comments on the draft!</em><br>\n<span class=\"math\">\\cdot</span><br>\n<em>The idea for the combined mechanism explored in <a href=\"https://ethresear.ch#p-49714-h-2-mechan-stein-9\">Part 2</a> of this post came from a Baranb√©-led whiteboarding session and accompanying <a href=\"https://x.com/barnabemonnot/status/1808444733305258047\" rel=\"noopener nofollow ugc\">tweet thread</a>. These ideas are also explored in the <a href=\"https://efdn.notion.site/Block-construction-session-bd611621250f45948eff05fcf6a34067?pvs=4\" rel=\"noopener nofollow ugc\">this doc</a>, which inspired <a href=\"https://github.com/michaelneuder/talks/blob/268e273b55cf2c753b2479c3ebbb826d41811754/misc2024/sbc.pdf\" rel=\"noopener nofollow ugc\">this talk</a>.</em><br>\n<span class=\"math\">\\cdot</span><br>\n<strong>tl;dr;</strong> <em>We sketch a high-level framing for Ethereum block construction centered around the design goals of encouraging builder competition, limiting the value of validator sophistication, and preserving the neutrality of block space. We then highlight three proposed mechanisms and how they interface with the established desiderata. We conclude by exploring the potential synergies of combining these designs into a single flow, called <code>Mechan-stein</code>.</em><br>\n<span class=\"math\">\\cdot</span><br>\n<strong>Contents</strong><br>\n(1) <a href=\"https://ethresear.ch#p-49714-h-1-the-building-blocks-pun-intended-of-block-space-market-design-2\">The building blocks of block-space market design</a><br>\n&nbsp;&nbsp;  <a href=\"https://ethresear.ch#p-49714-enshrined-pbs-mev-burn-via-ptc-3\">Enshrined PBS &amp; MEV-burn via PTC</a><br>\n&nbsp;&nbsp;  <a href=\"https://ethresear.ch#p-49714-execution-auctions-an-attester-proposer-separation-instatiation-5\">Execution Auctions (an Attester-Proposer Separation instantiation)</a><br>\n&nbsp;&nbsp;  <a href=\"https://ethresear.ch#p-49714-focil-7\">FOCIL</a><br>\n(2) <a href=\"https://ethresear.ch#p-49714-h-2-mechan-stein-9\">Mechan-stein</a><br>\n&nbsp;&nbsp;  <a href=\"https://ethresear.ch#p-49714-potential-issues-with-mechan-stein-10\">Potenital Issues with Mechan-stein</a><br>\n<span class=\"math\">\\cdot</span></p>\n<p><strong>Related work</strong></p>\n<div class=\"md-table\">\n<table>\n<thead>\n<tr>\n<th>Article</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://mirror.xyz/barnabe.eth/QJ6W0mmyOwjec-2zuH6lZb0iEI2aYFB9gE-LHWIMzjQ\" rel=\"noopener nofollow ugc\"><em>More words on Proposer-Builder Separation</em></a></td>\n</tr>\n<tr>\n<td><a href=\"https://efdn.notion.site/Block-construction-session-bd611621250f45948eff05fcf6a34067?pvs=4\" rel=\"noopener nofollow ugc\"><em>Notes from block construction session</em></a></td>\n</tr>\n<tr>\n<td><a href=\"https://ethresear.ch/t/burning-mev-through-block-proposer-auctions/14029\"><em>MEV-burn</em></a></td>\n</tr>\n<tr>\n<td><a href=\"https://ethresear.ch/t/payload-timeliness-committee-ptc-an-epbs-design/16054\"><em>PTC</em></a></td>\n</tr>\n<tr>\n<td><a href=\"https://ethresear.ch/t/fork-choice-enforced-inclusion-lists-focil-a-simple-committee-based-inclusion-list-proposal/19870\"><em>FOCIL</em></a></td>\n</tr>\n</tbody>\n</table>\n</div><hr>\n<h1><a name=\"p-49714-h-1-the-building-blocks-pun-intended-of-block-space-market-design-2\" class=\"anchor\" href=\"https://ethresear.ch#p-49714-h-1-the-building-blocks-pun-intended-of-block-space-market-design-2\"></a>[1] The building blocks (pun intended) of block-space market design</h1>\n<p>Since before the Merge, <a href=\"https://github.com/michaelneuder/mev-bibliography\" rel=\"noopener nofollow ugc\">much</a> has been (and continues to be) written about Ethereum‚Äôs transaction supply chain and block-space market design. I still think Vitalik‚Äôs <a href=\"https://vitalik.eth.limo/general/2021/12/06/endgame.html\" rel=\"noopener nofollow ugc\"><em>Endgame</em></a> summarizes the best-case outcome most succinctly with,</p>\n<blockquote>\n<p><em>‚ÄúBlock production is centralized, block validation is trustless and highly decentralized, and censorship is still prevented.‚Äù</em></p>\n</blockquote>\n<p>We can operationalize each of these statements into a design goal for our system:</p>\n<ol>\n<li><em>‚ÄúBlock production is centralized.‚Äù</em> <span class=\"math\">\\rightarrow</span> MEV is a fact of life in financial systems, and some actors will inevitably specialize in its extraction. We can‚Äôt expect solo-stakers to run profitable builders, but we can encourage competition and transparency in the MEV markets. When discussing <code>MEV-boost</code>, we usually describe it as aiming to democratize access to MEV for all proposers (which it does extremely well), but one under-discussed element of the existing system is that it <em>encourages builder competition</em> by creating a transparent market for buying block space. There are (and always will be) advantages and economies of scale for being a big builder (e.g., colocation with relays, acquiring exclusive order flow deals, and holding large inventory on various trading venues ‚Äì for more, see this <a href=\"https://arxiv.org/pdf/2407.13931\" rel=\"noopener nofollow ugc\">recent paper</a> from Burak, Danning, Thomas, and Florian), but anyone can send blocks and compete in the auction. Another important element of <code>MEV-boost</code> is that the auction happens Just-In-Time (JIT) for the block proposal, making <a href=\"https://ethresear.ch/t/on-attestations-block-propagation-and-timing-games/20272\">timing games</a> around the block proposal deadline valuable to the proposer who serves as the auctioneer. Still, the real-time nature of the auction ensures that the builder with the highest value <em>for this specific slot</em> wins the auction (rather than, e.g., the builder with the highest average value for any slot ‚Äì see <a href=\"https://arxiv.org/pdf/2408.03116\" rel=\"noopener nofollow ugc\">Max &amp; Mallesh‚Äôs argument</a> for why ahead-of-time auctions are more centralized). This leads to <strong>design goal <span class=\"hashtag-raw\">#1:</span> encourage builder competition.</strong><a href=\"https://ethresear.ch#fn1dst\"><span class=\"math\">^{[1]}</span></a><a name=\"fn1\"></a></li>\n<li><em>‚ÄúBlock validation is trustless and highly decentralized‚Äù</em><a href=\"https://ethresear.ch#fn2dst\"><span class=\"math\">^{[2]}</span></a><a name=\"fn2\"></a> <span class=\"math\">\\rightarrow</span> Ethereum‚Äôs primary focus has been preserving the validator set‚Äôs decentralization (why this is important in item <span class=\"hashtag-raw\">#3</span> below). This fundamental tenet instantiates itself in both the engineering/technical design and the economic/incentive design. On the engineering front, the <a href=\"https://github.com/ethereum/consensus-specs/tree/dev\" rel=\"noopener nofollow ugc\">spec</a> is written with the <a href=\"https://docs.ethstaker.cc/ethstaker-knowledge-base/hardware/hardware-requirements\" rel=\"noopener nofollow ugc\">minimum hardware requirements</a> in mind. This constraint ensures that participation in Ethereum‚Äôs consensus is <em>feasible</em> given (relatively) modest resources. On the economic level, the goal is to minimize the disparity in financial outcomes between at-home stakers and professional operators. Beyond feasibility, this aims to make at-home staking <em>not too irrational.</em> This double negative is tongue-in-cheek but hopefully conveys the message of trying to ensure there is some economic viability to at-home staking rather than staking through a centralized provider. Another lens for interpreting this is keeping the marginal value of sophistication low. We can‚Äôt expect at-home operators to have the exact same rewards as Coinbase and Lido (e.g., because they may have higher network latency), but the centralized staking providers shouldn‚Äôt benefit greatly from sophistication. This leads to <strong>design goal <span class=\"hashtag-raw\">#2:</span> limit the value of validator sophistication.</strong></li>\n<li><em>‚ÄúCensorship is prevented.‚Äù</em> <span class=\"math\">\\rightarrow</span> Credible neutrality is what differentiates crypto-economic systems from FinTech. If centralized entities determine which transactions land on chain and which do not, it‚Äôs over. To ensure the anti-fragility and neutrality of Ethereum, we must rely on a <a href=\"https://collective.flashbots.net/t/decentralized-crypto-needs-you-to-be-a-geographical-decentralization-maxi/1385\" rel=\"noopener nofollow ugc\">geographically distributed</a> validators; the validator set is the most decentralized part of the block production pipeline. In my opinion, (i) the main point of having a decentralized validator set is to allow those validators to express different preferences over the transactions that land on chain (‚Äúhigh preference entropy‚Äù ‚Äì <a href=\"https://ethresear.ch/t/unbundling-staking-towards-rainbow-staking/18683\">h/t Dr. Monnot</a>), and (ii) relying on this decentralization is the only way to preserve neutrality of the chain (c.f., <a href=\"https://ethresear.ch/t/uncrowdable-inclusion-lists-the-tension-between-chain-neutrality-preconfirmations-and-proposer-commitments/19372\"><em>Uncrowdable Inclusion Lists</em></a> for more discussion on chain neutrality). This leads to <strong>design goal <span class=\"hashtag-raw\">#3:</span> preserve the neutrality of Ethereum block space.</strong></li>\n</ol>\n<p>Right. To summarize:</p>\n<ol>\n<li><em>‚ÄúBlock production is centralized.‚Äù</em> <span class=\"math\">\\rightarrow</span> <strong>design goal <span class=\"hashtag-raw\">#1:</span> encourage builder competition.</strong></li>\n<li><em>‚ÄúBlock validation is trustless and highly decentralized‚Äù</em> <span class=\"math\">\\rightarrow</span> <strong>design goal <span class=\"hashtag-raw\">#2:</span> limit the value of validator sophistication.</strong></li>\n<li><em>‚ÄúCensorship is prevented.‚Äù</em> <span class=\"math\">\\rightarrow</span> <strong>design goal <span class=\"hashtag-raw\">#3:</span> preserve the neutrality of Ethereum block space.</strong></li>\n</ol>\n<p>Ok. This is all great, but let‚Äôs talk specifics. Many proposals aim to accomplish some of the design goals above. I am going to focus on three:</p>\n<ol>\n<li><strong>Enshrined <a href=\"https://barnabe.substack.com/p/pbs\" rel=\"noopener nofollow ugc\">Proposer-Builder Separation</a> &amp; <a href=\"https://ethresear.ch/t/burning-mev-through-block-proposer-auctions/14029\"><code>MEV-burn</code></a> via <a href=\"https://ethresear.ch/t/payload-timeliness-committee-ptc-an-epbs-design/16054\">Payload-Timeliness Committee</a></strong> (abbr. <code>PTC</code> onwards).</li>\n<li><strong><a href=\"https://mirror.xyz/barnabe.eth/QJ6W0mmyOwjec-2zuH6lZb0iEI2aYFB9gE-LHWIMzjQ\" rel=\"noopener nofollow ugc\">Execution Auctions</a>/Attester-Proposer Separation</strong>.</li>\n<li><strong><a href=\"https://ethresear.ch/t/fork-choice-enforced-inclusion-lists-focil-a-simple-committee-based-inclusion-list-proposal/19870/5\">Fork-Choice Enforced Inclusion Lists</a></strong> (abbr. <code>FOCIL</code> onwards).</li>\n</ol>\n<p>This may seem jargon-laden, and I apologize; please check out the links for the canonical article on each topic; for even more legibility, I will present a high-level view of each proposal below.</p>\n<h3><a name=\"p-49714-enshrined-pbs-mev-burn-via-ptc-3\" class=\"anchor\" href=\"https://ethresear.ch#p-49714-enshrined-pbs-mev-burn-via-ptc-3\"></a>Enshrined PBS &amp; <code>MEV-burn</code> via <code>PTC</code></h3>\n<p>This design enshrines a JIT block auction into the Ethereum consensus layer. The diagram below summarizes the block production pipeline <em>during the slot</em>.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/2/2/22560b81c3e436b0a3524b9c52a1b6b5aa277003.png\" data-download-href=\"https://ethresear.ch/uploads/default/22560b81c3e436b0a3524b9c52a1b6b5aa277003\" title=\"upload_a40f44ea2cb5821c889733125eb53260\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/2/2/22560b81c3e436b0a3524b9c52a1b6b5aa277003_2_423x500.png\" alt=\"upload_a40f44ea2cb5821c889733125eb53260\" data-base62-sha1=\"4TKAeCidlD1n8QgF0Kg8skLBQVt\" width=\"423\" height=\"500\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/2/2/22560b81c3e436b0a3524b9c52a1b6b5aa277003_2_423x500.png, https://ethresear.ch/uploads/default/optimized/3X/2/2/22560b81c3e436b0a3524b9c52a1b6b5aa277003_2_634x750.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/2/2/22560b81c3e436b0a3524b9c52a1b6b5aa277003_2_846x1000.png 2x\" data-dominant-color=\"F2F1F1\"></a></div><p></p>\n<ol>\n<li><strong>The builder bids</strong> in the auction by sending <code>(block header, bid value)</code> pairs to the proposer and the committee members.</li>\n<li><strong>The proposer commits</strong> to the highest bid value by signing and publishing the winning bid.</li>\n<li><strong>The committee enforces</strong> that the proposer selected a sufficiently high bid according to their view.</li>\n<li><strong>The builder publishes</strong> the block.</li>\n<li><strong>The committee enforces</strong> the timeliness of the builder‚Äôs publication.</li>\n</ol>\n<h4><a name=\"p-49714-analysis-4\" class=\"anchor\" href=\"https://ethresear.ch#p-49714-analysis-4\"></a>Analysis</h4>\n<ul>\n<li><code>PTC</code> allows the protocol (through the enforcement of the committee) to serve as the trusted third-party in the <a href=\"https://citeseerx.ist.psu.edu/document?repid=rep1&amp;type=pdf&amp;doi=208b22c7a094ada20736593afcc8c759c7d1b79c\" rel=\"noopener nofollow ugc\">fair-exchange</a> of the sale of the block building rights. <code>MEV-burn</code> (maybe more aptly denoted as ‚Äúblock maximization‚Äù because burning isn‚Äôt strictly necessary for the bids) asks the attesters to enforce a threshold for the bid selected as the winner by the proposer.</li>\n<li><span><code>PTC</code> primarily implements <strong>design goal <span class=\"hashtag-raw\">#1:</span> encourage builder competition.</strong></span> <code>PTC</code> enshrines <code>MEV-boost</code>, fully leaning into creating a competitive marketplace for block building. As in <code>MEV-boost</code>, the real-time block auction allows any builder to submit bids and encourages competition during each slot. Additionally, the JIT auction and bid-threshold enforcement of <code>MEV-burn</code> reduces the risk of multi-slot MEV by forcing each auction to take place during the slot. Lastly, <code>PTC</code> and other ePBS designs historically were aimed at <a href=\"https://ethresear.ch/t/why-enshrine-proposer-builder-separation-a-viable-path-to-epbs/15710#reasons-to-enshrine-4\">removing relays</a>. With bid thresholds from <code>MEV-burn</code>, the <a href=\"https://ethresear.ch/t/relays-in-a-post-epbs-world/16278\">bypassability of the protocol</a> becomes less feasible (even if the best builder bypasses, the second best can go through the protocol and ensure their bid wins).</li>\n<li><span><code>PTC</code> marginally addresses <strong>design goal <span class=\"hashtag-raw\">#2:</span> limit the value of validator sophistication.</strong></span> By creating an explicit market for MEV-aware blocks, <code>PTC</code> ensures that all validators can access a large portion of the MEV available in their slot. <code>MEV-burn</code> also smooths out the variance in the validator rewards. However, one of the major limitations of this auction design is the ‚Äúvalue-in-flight‚Äù (h/t Barnab√© for <a href=\"https://www.youtube.com/watch?v=KHw7gdJ14uQ\" rel=\"noopener nofollow ugc\">coining</a> the <a href=\"https://mirror.xyz/barnabe.eth/QJ6W0mmyOwjec-2zuH6lZb0iEI2aYFB9gE-LHWIMzjQ\" rel=\"noopener nofollow ugc\">term</a>) problem of the auction taking place during the slot. Because the value of the sold item changes dramatically throughout a slot, the auctioneer‚Äôs role benefits from sophistication. Beyond simple <a href=\"https://dataalways.mirror.xyz/-m0-bp3aZpcqa15_QbMX3MD1v9xg7VCcfGtZBR7I9Bg\" rel=\"noopener nofollow ugc\">timing games</a>, more exotic strategies around the fork-choice rule (e.g., using extra fork-choice weight to <a href=\"https://ethresear.ch/t/on-attestations-block-propagation-and-timing-games/20272\">further delay block publication</a>, h/t Toni) are possible, and we are just starting to see these play out.</li>\n<li><span> <code>PTC</code> does not address <strong>design goal <span class=\"hashtag-raw\">#3:</span> Preserve the neutrality of Ethereum block space.</strong></span> Neither <code>PTC</code> nor PBS generally are designed to encourage censorship resistance. The fact that a few builders account for most of Ethereum‚Äôs blocks is not surprising, and we should not count on those builders to uphold the credible neutrality of the chain (even if they are right now). While it is true that <code>PTC</code> aims to maintain a decentralized validator set, the fact that the full block is sold counter-acts that effect by still giving discretionary power of the excluded transactions to the builder (e.g., consider the hypothetical where 100% of validators are at-home stakers (maximally decentralized), but they all outsource to the same builder <span class=\"math\">\\implies</span> the builder fully determines the transactions that land onchain).</li>\n</ul>\n<h3><a name=\"p-49714-execution-auctions-an-attester-proposer-separation-instatiation-5\" class=\"anchor\" href=\"https://ethresear.ch#p-49714-execution-auctions-an-attester-proposer-separation-instatiation-5\"></a>Execution Auctions (an Attester-Proposer Separation Instatiation)</h3>\n<p>In contrast to the JIT block auction enabled by <code>PTC</code>, this design enshrines an ahead-of-time slot auction into the Ethereum consensus layer. A <a href=\"https://mirror.xyz/0x03c29504CEcCa30B93FF5774183a1358D41fbeB1/CPYI91s98cp9zKFkanKs_qotYzw09kWvouaAa9GXBrQ\" rel=\"noopener nofollow ugc\">slot auction</a> still allocates the entire block to the winner of the auction, but they no longer need to commit to the specific contents of the block when bidding (e.g., they are buying future block space) ‚Äì this allows the auction to take place well in advance of the slot itself. The diagram below summarizes the block production pipeline <em>32 slots ahead of time</em> (the 32 is just an arbitrary number; you could run the auction any time in advance or even during the slot itself; the key distinction is the fact that the bids don‚Äôt contain commitments to the contents of the block).</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/3/6/36fa041386a05b37b3dad9e959dad6c329d506ba.png\" data-download-href=\"https://ethresear.ch/uploads/default/36fa041386a05b37b3dad9e959dad6c329d506ba\" title=\"upload_ba33d4610c47000f0ac60a5273f91f61\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/3/6/36fa041386a05b37b3dad9e959dad6c329d506ba_2_505x500.png\" alt=\"upload_ba33d4610c47000f0ac60a5273f91f61\" data-base62-sha1=\"7QlrhxVS6jHruAgABd4NJWnGO1k\" width=\"505\" height=\"500\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/3/6/36fa041386a05b37b3dad9e959dad6c329d506ba_2_505x500.png, https://ethresear.ch/uploads/default/optimized/3X/3/6/36fa041386a05b37b3dad9e959dad6c329d506ba_2_757x750.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/3/6/36fa041386a05b37b3dad9e959dad6c329d506ba_2_1010x1000.png 2x\" data-dominant-color=\"F6F6F5\"></a></div><p></p>\n<p>N.B., the first three steps are nearly identical to the <code>PTC</code> process. The only differences are (a) the auction for the <code>Slot N+32</code> block production rights takes place during <code>Slot N</code> and (b) the bid object is a single <code>bid value</code> rather than the <code>(block header, bid value)</code> tuples. The actual building and publication of the block happen during <code>Slot N+32</code>, and <code>Execution Auctions</code> are agnostic to that process.</p>\n<ol>\n<li><strong>The builder bids</strong> in the auction by sending <code>bid value</code> to the proposer and the committee members.</li>\n<li><strong>The proposer commits</strong> to the highest bid value by signing and publishing the winning bid.</li>\n<li><strong>The committee enforces</strong> that the proposer selected a sufficiently high bid according to their view.</li>\n</ol>\n<h4><a name=\"p-49714-analysis-6\" class=\"anchor\" href=\"https://ethresear.ch#p-49714-analysis-6\"></a>Analysis</h4>\n<ul>\n<li><code>Execution Auctions</code> allow the protocol (through the enforcement of the committee) to serve as the trusted third party in the <a href=\"https://citeseerx.ist.psu.edu/document?repid=rep1&amp;type=pdf&amp;doi=208b22c7a094ada20736593afcc8c759c7d1b79c\" rel=\"noopener nofollow ugc\">fair-exchange</a> of the sale of the block building rights for a future slot.</li>\n<li><span><code>Execution Auctions</code> primarily support <strong>design goal <span class=\"hashtag-raw\">#2:</span> limit the value of validator sophistication.</strong></span> With the real-time auction of <code>PTC</code>, we described how the value-in-flight problem results in value from the sophistication of the validators who conduct the auction. In <code>Execution Auctions</code>, the auction occurs apriori, making the value of the object sold less volatile. The validator conducting the auction has a much simpler role that doesn‚Äôt benefit from timing games in the way they do in the JIT auction, thereby reducing their value from sophistication.</li>\n<li><span><code>Execution Auctions</code> do not address <strong>design goal <span class=\"hashtag-raw\">#1:</span> encourage builder competition.</strong></span> By running the auction ahead of time, the highest value bidder will always be the builder who is best at producing blocks (h/t Max and Mallesh for <a href=\"https://arxiv.org/pdf/2408.03116\" rel=\"noopener nofollow ugc\">formalizing this</a>). The builder may still choose to sell the block production rights on the secondary market, but only at a premium over the amount they can extract.<a href=\"https://ethresear.ch#fn3dst\"><span class=\"math\">^{[3]}</span></a><a name=\"fn3\"></a></li>\n<li><span><code>Execution Auctions</code> do not address <strong>design goal <span class=\"hashtag-raw\">#3:</span> Preserve the neutrality of Ethereum block space.</strong></span> <code>Execution Auctions</code> are <em>not designed to encourage censorship resistance</em>. We fully expect the future block space and builder markets to remain centralized. Another major concern with <code>Execution Auctions</code> is the risk of multi-slot MEV. Because the auction is not real-time, it is possible to acquire multiple consecutive future slots and launch multi-slot MEV strategies without competing in any auction during the slot itself. (We could try to mitigate this by making the look-ahead only a single slot ‚Äì e.g., <code>Slot N+1</code> auction during <code>Slot N</code>, but this may open up the same value-in-flight issues around JIT block auctions. More research is needed (and actively being done h/t Julian) here.)</li>\n</ul>\n<h3><a name=\"p-49714-focil-7\" class=\"anchor\" href=\"https://ethresear.ch#p-49714-focil-7\"></a>FOCIL</h3>\n<p>This design allows multiple consensus participants to construct lists of transactions that must be included in a given slot. In contrast to the previous designs, this <em>is not</em> an auction and <em>does not</em> aim to enshrine a MEV marketplace into the protocol. Instead, the focus here is improving the system‚Äôs neutrality by allowing multiple parties to co-create a template (in the form of a set of constraints) for the produced block. The diagram below describes the block production process <em>during the slot itself.</em></p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/b/c/bc6cae7b07f724344d704a6bd035e33e82f7500f.png\" data-download-href=\"https://ethresear.ch/uploads/default/bc6cae7b07f724344d704a6bd035e33e82f7500f\" title=\"upload_badb6db529bdfb2640abe1ce4d767dd2\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/b/c/bc6cae7b07f724344d704a6bd035e33e82f7500f_2_455x500.png\" alt=\"upload_badb6db529bdfb2640abe1ce4d767dd2\" data-base62-sha1=\"qSSC2LzxrDmdrY79j3qf78r0d7V\" width=\"455\" height=\"500\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/b/c/bc6cae7b07f724344d704a6bd035e33e82f7500f_2_455x500.png, https://ethresear.ch/uploads/default/optimized/3X/b/c/bc6cae7b07f724344d704a6bd035e33e82f7500f_2_682x750.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/b/c/bc6cae7b07f724344d704a6bd035e33e82f7500f_2_910x1000.png 2x\" data-dominant-color=\"F6F7F7\"></a></div><p></p>\n<ol>\n<li><strong>The IL committee publishes</strong> their inclusion lists to the builder (clumping this together with the proposer for this diagram because the builder must follow the block template) and the attesters.</li>\n<li><strong>The builder publishes</strong> a block that includes an aggregate view of the ILs they received and conforms to the constraints therein.</li>\n<li><strong>The attesters enforce</strong> the block validity conditions, which now check that the builder included a sufficient threshold of observed inclusion lists.</li>\n</ol>\n<h4><a name=\"p-49714-analysis-8\" class=\"anchor\" href=\"https://ethresear.ch#p-49714-analysis-8\"></a>Analysis</h4>\n<ul>\n<li><code>FOCIL</code> increases the protocol‚Äôs neutrality by allowing multiple validators to express their preferences in the block co-creation.</li>\n<li><span><code>FOCIL</code> primarily contributes to <strong>design goal <span class=\"hashtag-raw\">#3:</span> preserve the neutrality of Ethereum blockspace.</strong></span> This is the direct goal; more inputs to the block construction seems like a no-brainer (very much in line with the latest thread of <a href=\"https://www.youtube.com/watch?v=mJLERWmQ2uw\" rel=\"noopener nofollow ugc\">concurrent proposer research</a>). Critically, <code>FOCIL</code> intentionally does not give any MEV power to the inclusion list constructors (see <a href=\"https://ethresear.ch/t/uncrowdable-inclusion-lists-the-tension-between-chain-neutrality-preconfirmations-and-proposer-commitments/19372\"><em>Uncrowdability</em></a> for more) to avoid the economic capture of that role. In particular, <code>FOCIL</code> <em>does not</em> aim to constrain the builder‚Äôs ability to extract MEV generally; the builder can still reorder and insert transactions at will in their block production process. Instead, it‚Äôs their ability to <em>arbitrarily exclude</em> transactions, which <code>FOCIL</code> reduces.</li>\n<li><span><code>FOCIL</code> does not address <strong>design goal <span class=\"hashtag-raw\">#1:</span> encourage builder competition.</strong></span> <code>FOCIL</code> is agnostic to the exact block production process beyond enforcing a block template for transactions that cannot be excluded arbitrarily.</li>\n<li><span><code>FOCIL</code> does not address <strong>design goal <span class=\"hashtag-raw\">#2:</span> limit the value of validator sophistication.</strong></span> <code>FOCIL</code> is agnostic to the exact block production process beyond enforcing a block template for transactions that cannot be excluded arbitrarily.</li>\n</ul>\n<p>Right. That was the ‚Äúvegetable eating‚Äù portion of this article. The critical takeaway is <strong>each of the above proposals primarily addresses one of the cited design goals, but none address all three simultaneously.</strong> This makes it easy to point out flaws in any specific design.<br>\n‚Ä¶<br>\nYou probably see where we are going with this. Let‚Äôs not bury the lede. What if we combine them? Each serves a specific role and operates on a different portion of the slot duration; why not play it out?</p>\n<h1><a name=\"p-49714-h-2-mechan-stein-9\" class=\"anchor\" href=\"https://ethresear.ch#p-49714-h-2-mechan-stein-9\"></a>[2] Mechan-stein</h1>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/5/0/508d35ee9a4052135205628aa738a64cbcdd4c51.png\" data-download-href=\"https://ethresear.ch/uploads/default/508d35ee9a4052135205628aa738a64cbcdd4c51\" title=\"upload_bc314953eed471a97f9afd50b068bb14\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/5/0/508d35ee9a4052135205628aa738a64cbcdd4c51_2_440x500.png\" alt=\"upload_bc314953eed471a97f9afd50b068bb14\" data-base62-sha1=\"buAJSXQO5HfSBYYswmTEgmwSzOp\" width=\"440\" height=\"500\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/5/0/508d35ee9a4052135205628aa738a64cbcdd4c51_2_440x500.png, https://ethresear.ch/uploads/default/optimized/3X/5/0/508d35ee9a4052135205628aa738a64cbcdd4c51_2_660x750.png 1.5x, https://ethresear.ch/uploads/default/original/3X/5/0/508d35ee9a4052135205628aa738a64cbcdd4c51.png 2x\" data-dominant-color=\"ADAB9A\"></a></div><p></p>\n<p>With the groundwork laid, we can ~nearly~ combine the three mechanisms directly. There is one issue, however, which arises from both auctions selling the same object ‚Äì the proposing rights for <code>Slot N+32</code>. The resulting bids in the first auction (the slot auction sale of <code>Slot N+32</code> during <code>Slot N</code>) would thus not carry any economic meaning because bidders would be competing for the slot but would then be forced sellers by the time the slot arrived. To resolve this, the second auction (which happens JIT during the slot) could instead be a Top-of-Block auction (e.g., the first 5mm gas consumed in the block). There are many articles exploring the Top-of-Block/Rest-of-Block split (sometimes called block prefix/suffixes) (see, e.g., <a href=\"https://ethresear.ch/t/how-much-can-we-constrain-builders-without-bringing-back-heavy-burdens-to-proposers/13808\">here</a>, <a href=\"https://github.com/bharath-123/pepc-boost-relay\" rel=\"noopener nofollow ugc\">here</a>, <a href=\"https://ethresear.ch/t/state-lock-auctions-towards-collaborative-block-building/18558\">here</a>), so we won‚Äôt go into the details of the consensus changes required to facilitate this exchange. Taking its feasibility for granted, the double-auction design of Mechan-stein makes more sense.<br>\n- <strong>Auction 1 during <code>Slot N</code></strong> sells the block proposing rights for <code>Slot N+32</code> and is conducted by the proposer of <code>Slot N</code>.<br>\n- <strong>Auction 2 during <code>Slot N+32</code></strong> sells the Top-of-Block to a (potentially different) builder who specifies the specific set of transactions to be executed first in the block. This auction is conducted just in time by the builder/winner of Auction 1.</p>\n<p>With this framing, the winner of Auction 1 effectively bought the option to build (or sell) the Rest-of-Block for <code>Slot  N+32</code> ‚Äì thus the expected value of the bids in that auction would be the average amount of MEV extractable in the block suffix (aside: this might play nicely with <a href=\"https://x.com/barnabemonnot/status/1808444762376020121\" rel=\"noopener nofollow ugc\">preconfs</a>). The diagram below shows the flow at a high level (leaving off many back-and-forths for legibility).</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/8/d/8dd0b952112b0f09ac63c9b1a5fba3e4c718dc60.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/8dd0b952112b0f09ac63c9b1a5fba3e4c718dc60\" title=\"upload_95efb121f762fdc00a15aecb64fe6e54-1\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/8/d/8dd0b952112b0f09ac63c9b1a5fba3e4c718dc60_2_690x373.jpeg\" alt=\"upload_95efb121f762fdc00a15aecb64fe6e54-1\" data-base62-sha1=\"keyvL4i2Ho9QV3E9PximOsHCRcA\" width=\"690\" height=\"373\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/8/d/8dd0b952112b0f09ac63c9b1a5fba3e4c718dc60_2_690x373.jpeg, https://ethresear.ch/uploads/default/optimized/3X/8/d/8dd0b952112b0f09ac63c9b1a5fba3e4c718dc60_2_1035x559.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/8/d/8dd0b952112b0f09ac63c9b1a5fba3e4c718dc60_2_1380x746.jpeg 2x\" data-dominant-color=\"F5F5F5\"></a></div><p></p>\n<ol>\n<li><strong>The <code>Slot N</code> proposer auctions off</strong> the <code>Slot N+32</code> proposing rights.</li>\n<li><strong>The <code>Slot N</code> attesters enforce</strong> the bid threshold of the slot auction.</li>\n<li><em>[32 slots later]</em> <strong>The <code>Slot N+32</code> IL committee publishes</strong> their ILs.</li>\n<li><strong>The <code>Slot N+32</code> builder auctions off</strong> the Top-of-Block for <code>Slot N+32</code>.</li>\n<li><strong>The <code>Slot N+32</code> <code>PTC</code> enforces</strong> the bid threshold of the Top-of-Block auction.</li>\n<li><strong>The <code>Slot N+32</code> <code>PTC</code> enforces</strong> the timeliness of the block publication from the winning builder.</li>\n<li><strong>The <code>Slot N+32</code> attesters enforce</strong> the IL threshold of the final block.</li>\n</ol>\n<p>Yeah, yeah ‚Äì it‚Äôs a lot of steps, but the pitch is pretty compelling.</p>\n<ul>\n<li><span>Mechan-stein addresses <strong>design goal <span class=\"hashtag-raw\">#1:</span> encourage builder competition.</strong></span> The permissionless, JIT Top-of-Block auction helps mitigate the risk of multi-slot MEV in <code>Execution Auctions</code> by <em>forcing</em> the slot auction winner to sell a portion of the block or at least pay a threshold to build the full block themselves.</li>\n<li><span>Mechan-stein addresses <strong>design goal <span class=\"hashtag-raw\">#2:</span> limit the value of validator sophistication.</strong></span> The role of an average validator in block production is now the simple combination of (1) conducting the ahead-of-time slot auction and (2) publishing their inclusion list when part of an IL committee. This greatly reduces the power bestowed on the validator because (1) they are now conducting an auction apriori (thus, latency and timing games play a smaller role) and (2) the inclusion list intentionally does not generate much value for MEV-carrying transactions (because it only guarantees inclusion rather than ordering).</li>\n<li><span>Mechan-stein addresses <strong>design goal <span class=\"hashtag-raw\">#3:</span> preserve the neutrality of Ethereum block space.</strong></span> By allowing many participants to co-create the set of constraints enforced on the builder of each block, high preference entropy is achieved without unduly benefiting the transactions that land in an inclusion list, as block builders can still reorder and insert at their leisure. However, the builder‚Äôs ability to exclude is limited, removing some of their monopolist power over the transactions in the block.</li>\n</ul>\n<p>The combined mechanism creates a set of checks and balances where the weaknesses of one design in isolation are the strengths of another. Everything is perfect, right?</p>\n<h3><a name=\"p-49714-potential-issues-with-mechan-stein-10\" class=\"anchor\" href=\"https://ethresear.ch#p-49714-potential-issues-with-mechan-stein-10\"></a>Potential issues with Mechan-stein</h3>\n<p>It might not be only rainbows and butterflies. Without being comprehensive (neither in the list of potential issues nor the responses to said issues), let‚Äôs run down a few of the most obvious questions with Mechan-stein and some initial counter-points.</p>\n<ul>\n<li><span><strong>Point <span class=\"hashtag-raw\">#1</span></strong> ‚Äì complexity, complexity, complexity.</span> This could (and maybe should) count for multiple points (h/t Mallesh for the relevant <a href=\"https://x.com/malleshpai/status/1748026472923623619\" rel=\"noopener nofollow ugc\">tweet</a>). Each of these proposals involves massive changes to the consensus layer of Ethereum with wide-ranging impact (particularly on the fork-choice rule). The devil is truly in the details, and getting something like this spec‚Äôed out and implemented would be an immense research and engineering lift ‚Äì let‚Äôs just say <a href=\"https://en.wikipedia.org/wiki/Occam%27s_razor\" rel=\"noopener nofollow ugc\">William of Ockham</a> would not be impressed.\n<ul>\n<li><span><strong>Counter-point <span class=\"hashtag-raw\">#1</span></strong> ‚Äì building the future of finance in a permissionless and hyper-financialized world wasn‚Äôt going to be simple (‚ÄúRome wasn‚Äôt built in a day‚Äù).</span> It shouldn‚Äôt be shocking that there doesn‚Äôt seem to be a silver bullet for building an MEV-aware, decentralized, credibly neutral blockchain. Maybe eating the complexity now can leave the chain in a more stable equilibrium. Also, there may be significant synergies in combining designs (e.g., using the same committee for <code>FOCIL</code> and <code>PTC</code>). You could probably do a subset of Mechan-stein and still get some benefits (e.g., <code>FOCIL</code> + <code>PTC</code>).</li>\n</ul>\n</li>\n<li><span><strong>Point <span class=\"hashtag-raw\">#2</span></strong> ‚Äì how may the ahead-of-time slot auction distort the MEV market?</span> Mostly just reciting <a href=\"https://arxiv.org/pdf/2408.03116\" rel=\"noopener nofollow ugc\">Max and Mallesh‚Äôs</a> argument (3rd time referencing that paper in this article lol). By removing the real-time nature of the initial auction, you bias it towards a winner-take-all for the best builder (or the ‚ÄúBest Block Space Future Value Estimator‚Ñ¢‚Äù). I‚Äôd say this is similar in spirit to the Phil Daian view of making the competition as deterministic as possible (e.g., <a href=\"https://youtu.be/SBOGdofF4u8?t=620\" rel=\"noopener nofollow ugc\">‚Äúdeterministic vs statistical opportunities‚Äù</a>).\n<ul>\n<li><span><strong>Counter-point <span class=\"hashtag-raw\">#2</span></strong> ‚Äì that is the point of still having the <code>PTC</code> conduct a JIT Top-of-Block auction.</span> I think this feels reasonable. However, there is still a slight edge that the auctioneer (who may be a builder themselves) has in the JIT auction, which is they can benefit from the sophistication and latency investments as they are the auctioneer and a participant. As mentioned above, you could consider skipping the <code>Execution Auctions</code> part of Mechan-stein and just going with <code>FOCIL</code> + <code>PTC</code> (or even leave <code>MEV-boost</code> alone as the primary PBS market and just do <code>FOCIL</code>). (h/t Justin for pointing out that you could try to do <code>Execution Auctions</code> where multiple proposers (more than one auction winner) are selected ‚Äì another combined mechanism that tries to mitigate the multi-slot MEV risk.)</li>\n</ul>\n</li>\n<li><span><strong>Point <span class=\"hashtag-raw\">#3</span></strong> ‚Äì there is still power in being the block producer.</span> As pointed out in this <a href=\"https://ethresear.ch/t/fork-choice-enforced-inclusion-lists-focil-a-simple-committee-based-inclusion-list-proposal/19870/3\">comment</a> and <a href=\"https://ethresear.ch/t/fork-choice-enforced-inclusion-lists-focil-a-simple-committee-based-inclusion-list-proposal/19870/4\">its response</a> on the <code>FOCIL</code> post, there is still some discretionary power in being the block builder. Namely, they can choose which ILs they exclude from their aggregate up to some protocol-enforced tolerance. This notion of having an IL ‚Äúaggregator‚Äù is the main difference between <code>FOCIL</code> and a leaderless approach like <a href=\"https://www.youtube.com/watch?v=mJLERWmQ2uw\" rel=\"noopener nofollow ugc\">Braid</a>.\n<ul>\n<li><span><strong>Counter-point <span class=\"hashtag-raw\">#3</span></strong> ‚Äì this seems like a fundamental feature.</span> Again, I find myself leaning on Phil‚Äôs comment and mental model for ‚Äúhow economic power expresses itself in the protocol.‚Äù In a distributed system with network latency and geographic decentralization, some parties will have advantages over others. Suppose the protocol doesn‚Äôt explicitly imbue some participants with power during some period (e.g., by electing a leader). In that case, that power will still manifest somewhere else, likely in a more implicit (thus more sophisticated) way. This is more of a meta point, and I am happy to be convinced otherwise.</li>\n</ul>\n</li>\n</ul>\n<p>All right, going to cut it here; hope you found it interesting. Lot‚Äôs to think on still.</p>\n<p><em>thank for reading <img src=\"https://ethresear.ch/images/emoji/facebook_messenger/heart.png?v=12\" title=\":heart:\" class=\"emoji\" alt=\":heart:\" loading=\"lazy\" width=\"20\" height=\"20\"> -mike</em></p>\n<hr>\n<h3><a name=\"p-49714-footnotes-11\" class=\"anchor\" href=\"https://ethresear.ch#p-49714-footnotes-11\"></a>footnotes</h3>\n<p><span class=\"math\">^{[1]}</span><a name=\"fn1dst\"></a>: It is worth noting that, conditioned on having strong censorship resistance properties, the difference between a monopolist builder and a competitive marketplace of builders isn‚Äôt so vital. As discussed with Barnab√© and Julian, perhaps a more important property is the ‚Äúreplace-ability‚Äù of a monopolist builder if they begin abusing their power. All else being equal, I still prefer the outcome where we have multiple builders, even if just for the memetic reality of having a single block builder looks highly centralized, even if the other consensus participants heavily constrain them. Hence, builder competition still feels like a fair desiderata.<a href=\"https://ethresear.ch#fn1\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/leftwards_arrow_with_hook.png?v=12\" title=\":leftwards_arrow_with_hook:\" class=\"emoji\" alt=\":leftwards_arrow_with_hook:\" loading=\"lazy\" width=\"20\" height=\"20\">Ô∏é</a></p>\n<p><span class=\"math\">^{[2]}</span><a name=\"fn2dst\"></a>: Vitalik pointed out that when he originally wrote this, he was referring more to the act of validating the blocks (e.g., by verifying a ZK proof) rather than explicitly participating in consensus. The name ‚Äúvalidator‚Äù denotes someone who engages in consensus, which has been a nomenclatural pain point since the launch of the beacon chain. Despite this, I still like the framing of keeping some form of consensus participation decentralized (mainly as a means to better chain neutrality), so I will slightly abuse the naming confusion. xD <a href=\"https://ethresear.ch#fn2\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/leftwards_arrow_with_hook.png?v=12\" title=\":leftwards_arrow_with_hook:\" class=\"emoji\" alt=\":leftwards_arrow_with_hook:\" loading=\"lazy\" width=\"20\" height=\"20\">Ô∏é</a></p>\n<p><span class=\"math\">^{[3]}</span><a name=\"fn3dst\"></a>: It is worth noting that validators could also choose to only sell their block at a premium in the more general case through the use of the <a href=\"https://writings.flashbots.net/the-cost-of-resilience\" rel=\"noopener nofollow ugc\"><code>min-bid</code></a> feature of <code>MEV-boost</code>. See more on <code>min-bid</code> from <a href=\"https://mirror.xyz/0x03c29504CEcCa30B93FF5774183a1358D41fbeB1/8aCbi_a-Gh5DWnkJWstm8zA5fvtoQB-QR5we7C8XC90\" rel=\"noopener nofollow ugc\">Julian</a> and <a href=\"https://hackmd.io/@dataalways/resilience\" rel=\"noopener nofollow ugc\">Data Always</a>. <a href=\"https://ethresear.ch#fn3\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/leftwards_arrow_with_hook.png?v=12\" title=\":leftwards_arrow_with_hook:\" class=\"emoji\" alt=\":leftwards_arrow_with_hook:\" loading=\"lazy\" width=\"20\" height=\"20\">Ô∏é</a></p>\n            <p><small>7 posts - 5 participants</small></p>\n            <p><a href=\"https://ethresear.ch/t/mechan-stein-alt-franken-ism/20321\">Read full topic</a></p>","link":"https://ethresear.ch/t/mechan-stein-alt-franken-ism/20321","pubDate":"Wed, 21 Aug 2024 13:23:40 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20321"},"source":{"@url":"https://ethresear.ch/t/mechan-stein-alt-franken-ism/20321.rss","#text":"Mechan-stein (alt. Franken-ism)"}},{"title":"L2 sequencer proving on weak hardware; parallelization and decentralization","dc:creator":"rezahsnz","category":"ZK Rollup","description":"<p><a href=\"https://ethresear.ch/t/vortex-building-a-prover-for-the-zk-evm/14427\">Linea‚Äôs sequencer</a> proves a 30m gassed block of transactions in 5 minutes. Here‚Äôs its setup:</p>\n<blockquote>\n<ul>\n<li>On a 96 cores machine with 384 GB of RAM (hpc6a.48xlarge on AWS)</li>\n<li>In 5 minutes (only including the inner-proof)</li>\n</ul>\n</blockquote>\n<p>So is it possible to reduce the proving time and, at the same time, obtain decentralization guarantees? We have an idea.</p>\n<h3><a name=\"p-49694-overview-1\" class=\"anchor\" href=\"https://ethresear.ch#p-49694-overview-1\"></a>Overview</h3>\n<p>Almost all of the L2 sequencers are closed-source, intellectual property, and thus protected behind centralized setups. To cram that much power into an entity requires a great deal of justification today. To decentralize the flow, on the other hand, one has to accept certain amounts of delay and noise usually found in decentralized compute networks.</p>\n<h4><a name=\"p-49694-zkvms-recursion-and-risc0s-approach-2\" class=\"anchor\" href=\"https://ethresear.ch#p-49694-zkvms-recursion-and-risc0s-approach-2\"></a>zkVMs, recursion, and Risc0‚Äôs approach</h4>\n<p>Any zkVM toolset puts a certain upper bound on the maximum number of cycles(roughly speaking 1 cycle equals 1 operation) it can prove in one go. This is usually done for efficiency reasons. For <a href=\"https://github.com/risc0\" rel=\"noopener nofollow ugc\">Risc0</a>, a RISC-V general zkVM, it is 2^24 ~ 16.78m cycles. With recursion, proving infinitely sized programs are made possible. So the solution is to divide a large program into individual sub-programs(called segment in Risc0 jargon) and have them proved one by one and aggregate the proofs into a final proof as if the whole program was proved in one go. For example, consider proving a 1b cycles program. With 16.78M maximum segment size limit, one ends up proving 60 segments. The upper bound for segment size limit is not the end of story however and one can customize it into a well-known range of [2^13 - 2^24]. Each segment limit size needs specific memory requirements shown on Table 1:<br>\n</p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/b/7/b790b7f5fb18cec94d0e621383844425862ba9fb.png\" data-download-href=\"https://ethresear.ch/uploads/default/b790b7f5fb18cec94d0e621383844425862ba9fb\" title=\"Screenshot from 2024-07-18 14-37-34\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/b/7/b790b7f5fb18cec94d0e621383844425862ba9fb_2_690x387.png\" alt=\"Screenshot from 2024-07-18 14-37-34\" data-base62-sha1=\"qbTqZ7OMhRtwxJFVg1x6kuxiXub\" width=\"690\" height=\"387\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/b/7/b790b7f5fb18cec94d0e621383844425862ba9fb_2_690x387.png, https://ethresear.ch/uploads/default/optimized/3X/b/7/b790b7f5fb18cec94d0e621383844425862ba9fb_2_1035x580.png 1.5x, https://ethresear.ch/uploads/default/original/3X/b/7/b790b7f5fb18cec94d0e621383844425862ba9fb.png 2x\" data-dominant-color=\"FAFAFA\"></a></div><br>\nExtrapolating Table 1‚Äôs values, we get 50m cycles for a program that needs 384gb of memory, in order to be proved in Risc0. Recall that Linea‚Äôs prover uses 384gb of memory to generate proofs. This is a naive 1-1 translation, but we can treat it as baseline for further testing. So, with this assumption, should one write Linea‚Äôs sequencer logic in Risc0, she would end up with a program that is 50m cycles long. Doubling cycles to ~90m, to account for aggregation won‚Äôt hurt here.<p></p>\n<h4><a name=\"p-49694-segmentation-parallel-proving-and-decentralization-3\" class=\"anchor\" href=\"https://ethresear.ch#p-49694-segmentation-parallel-proving-and-decentralization-3\"></a>Segmentation, parallel proving, and decentralization</h4>\n<p>Recursion is a powerful idea in zkVM proving. With recursion once can get to prove seemingly large programs very quickly assuming she has a prove-ready network of machines. Table 2 shows a segmented prove session for a 90m cycles program on a pretty weak machine(8+ years old, Intel core i7 5500U(2C 4T), 16gb memory):<br>\n</p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/0/9/091af39f1eb4b3465f1de18222eed6c4d1051edb.png\" data-download-href=\"https://ethresear.ch/uploads/default/091af39f1eb4b3465f1de18222eed6c4d1051edb\" title=\"Screenshot from 2024-07-18 14-47-06\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/0/9/091af39f1eb4b3465f1de18222eed6c4d1051edb_2_690x235.png\" alt=\"Screenshot from 2024-07-18 14-47-06\" data-base62-sha1=\"1iy2x6FkIBx6qV5pfSRvPJE0oKT\" width=\"690\" height=\"235\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/0/9/091af39f1eb4b3465f1de18222eed6c4d1051edb_2_690x235.png, https://ethresear.ch/uploads/default/optimized/3X/0/9/091af39f1eb4b3465f1de18222eed6c4d1051edb_2_1035x352.png 1.5x, https://ethresear.ch/uploads/default/original/3X/0/9/091af39f1eb4b3465f1de18222eed6c4d1051edb.png 2x\" data-dominant-color=\"F0F4EF\"></a></div><p></p>\n<p>As you can see, different segment size limits result in varied proving regimes. In Table 2, two columns are colored in green, 2^18 and 2^19. Consulting Table 1, we would get 2gb and 4gb of required memory to prove them respectively. These columns are sweet spots for any zkVM proving network whose nodes are presumably weak. Focusing on the 2^19 segment size limit, to prove a 90m cycles program, one would need at least 168 nodes in order to prove the program in 4 minutes and 9 seconds. But 168 nodes is a faulty assumption. In reality, if a p2p network is to undertake the proving job, it needs to have redundancy values of 1:4 and above. The redundancy accounts for noise that is a feature of any p2p network. With 1:4 redundant nodes, 1 in every 5 nodes is assumed to be honest and the rest are time wasters. So, a 1:4 redundant p2p network needs at least of 840 nodes to get the job done.<br>\nAssuming that the proving network is p2p, one can expect to obtain decentralized guarantees en route.</p>\n<h3><a name=\"p-49694-conclusion-4\" class=\"anchor\" href=\"https://ethresear.ch#p-49694-conclusion-4\"></a>Conclusion</h3>\n<p>Here we introduced an imaginary setup to decentralize and improve L2 sequencer proving times. If the claim turns out to be legit, we would expect to improve the overall proving time for any zkVM application area. In addition, the setup provides decentralization guarantees as a side effect. While everything looks nice, we, at <a href=\"https://github.com/WholesumNet\" rel=\"noopener nofollow ugc\">Wholesum network</a> would like to put this setup to test and see if it works in action. If successful, a p2p verifiable compute network of 10,000 weak nodes can handle up to 10 Linea like L2s.</p>\n<p>A somewhat more expanded version of this post is also available <a href=\"https://github.com/WholesumNet/docs/blob/779942cf6f650d24fcedf2d8da5a6dd2033a9fee/parallelization/parallelized-proving/report.pdf\" rel=\"noopener nofollow ugc\">here</a>.</p>\n<p>We appreciate your feedback.</p>\n            <p><small>2 posts - 1 participant</small></p>\n            <p><a href=\"https://ethresear.ch/t/l2-sequencer-proving-on-weak-hardware-parallelization-and-decentralization/20313\">Read full topic</a></p>","link":"https://ethresear.ch/t/l2-sequencer-proving-on-weak-hardware-parallelization-and-decentralization/20313","pubDate":"Tue, 20 Aug 2024 15:18:35 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20313"},"source":{"@url":"https://ethresear.ch/t/l2-sequencer-proving-on-weak-hardware-parallelization-and-decentralization/20313.rss","#text":"L2 sequencer proving on weak hardware; parallelization and decentralization"}},{"title":"On Proposer Timing Games and Economies of Scale","dc:creator":"Nero_eth","category":"Economics","description":"<h1><a name=\"p-49689-on-proposer-timing-games-and-economies-of-scale-1\" class=\"anchor\" href=\"https://ethresear.ch#p-49689-on-proposer-timing-games-and-economies-of-scale-1\"></a>On Proposer Timing Games and Economies of Scale</h1>\n<p><a href=\"https://timing.pics\">Timing games</a> are a known phenomenon (<a href=\"https://eprint.iacr.org/2023/760\">[1]</a>, <a href=\"https://arxiv.org/abs/2305.09032\">[2]</a> and <a href=\"https://ethresear.ch/t/deep-diving-attestations-a-quantitative-analysis/20020\">[3]</a>). The concern is that proposer timing games come with a negative impact on the network.</p>\n<p>In the following, I want to show how the success of playing proposer timing games is also a function of economies of scale.</p>\n<p><strong>The main finding is:</strong><br>\n<em><strong> ‚Üí An entity with 30% market share can delay 0.8s longer than a 5% entity.</strong></em><br>\n<em><strong> ‚Üí For every 1% increase in validator market share, the delay in block proposals can increase by 0.03 seconds without facing additional reorg risk.</strong></em></p>\n<p><img src=\"https://ethresear.ch/uploads/default/original/3X/c/5/c58fec82d848d1fb7ae0352e8c50c4e8071253c5.png\" alt=\"tgeos\" data-base62-sha1=\"sbIpRwMTj4kkAqp5n8VjmOUp793\" width=\"456\" height=\"318\"></p>\n<p><em>Special thanks to <a href=\"https://x.com/weboftrees\">Anders</a>, <a href=\"https://x.com/mikeneuder\">Mike</a> and <a href=\"https://x.com/casparschwa\">Caspar</a> for feedback!</em></p>\n<h2><a name=\"p-49689-introduction-2\" class=\"anchor\" href=\"https://ethresear.ch#p-49689-introduction-2\"></a>Introduction</h2>\n<p>A proposer must gather at least 40% of these votes to ensure their block is accepted and not reorged by the following proposer. It‚Äôs 40% because that‚Äôs the proposer boost threshold. Blocks with less than 40% attestations can be reorged by the next proposer leveraging proposer boost. The challenge for a timing-gamer lies in determining the optimal time to propose (or call getHeader). An economically rational validator would want to wait as long as possible (providing the builder with the longest possible time window) without risking a reorg.</p>\n<p>First, let‚Äôs revisit the following chart from <a href=\"https://ethresear.ch/t/deep-diving-attestations-a-quantitative-analysis/20020\">this analysis</a>:<br>\n</p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/4/2/42fe46361f7b2a22bd61c0195f719a57df04d64d.png\" data-download-href=\"https://ethresear.ch/uploads/default/42fe46361f7b2a22bd61c0195f719a57df04d64d\" title=\"42fe46361f7b2a22bd61c0195f719a57df04d64d\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/4/2/42fe46361f7b2a22bd61c0195f719a57df04d64d_2_690x304.png\" alt=\"42fe46361f7b2a22bd61c0195f719a57df04d64d\" width=\"690\" height=\"304\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/4/2/42fe46361f7b2a22bd61c0195f719a57df04d64d_2_690x304.png, https://ethresear.ch/uploads/default/optimized/3X/4/2/42fe46361f7b2a22bd61c0195f719a57df04d64d_2_1035x456.png 1.5x, https://ethresear.ch/uploads/default/original/3X/4/2/42fe46361f7b2a22bd61c0195f719a57df04d64d.png 2x\" data-dominant-color=\"FBFBFC\"></a></div><p></p>\n<p><strong>~80% of all attestations are seen until second 5 in the slot</strong>. The <strong>40% threshold is reached somewhere around second 3.8</strong>. Thus, assuming zero latency, a block published at second 3.8 should still be able to receive 60% of attestations.</p>\n<p><strong>In the following, we refer to this curve as <span class=\"math\">C(t)</span>.</strong></p>\n<h2><a name=\"p-49689-initial-setup-3\" class=\"anchor\" href=\"https://ethresear.ch#p-49689-initial-setup-3\"></a>Initial Setup</h2>\n<p>The core idea is to determine how the cumulative votes cast by validators evolve over a slot and how a proposer‚Äôs control over a portion of these validators may influence the optimal timing of their block proposal.</p>\n<p>Given that <span class=\"math\">C(t)</span> represents the cumulative percentage of votes cast by time <span class=\"math\">t</span>, the proposer controls <span class=\"math\">x\\%</span> of validators, and needs to ensure that they can still reach at least 40% by the time they propose, we start with the following condition:</p>\n<div class=\"math\">\nx + (1 - C(t)) \\times (1 - x) \\geq 0.4\n</div>\n<p>In this equation:</p>\n<ul>\n<li><strong><span class=\"math\">(1 - C(t)) \\times (1 - x)</span>:</strong> The remaining uncast votes from validators not controlled by the proposer, which could support the proposer‚Äôs block.</li>\n</ul>\n<blockquote>\n<p>Note that <strong><span class=\"math\">x \\times C(t)</span></strong> would be the portion of votes from the proposer‚Äôs validators already included in <span class=\"math\">C(t).</span></p>\n</blockquote>\n<p>Two assumptions are important to stress:</p>\n<ul>\n<li><strong>Coordination</strong>: It is assumed that validators coordinate when attesting, e.g. using a central oracle that provides the commands.</li>\n<li><strong>Honest Validators</strong>: All validators who have not yet voted at the time of the block proposal will vote for the proposed block (and not the parent block). See <a href=\"https://github.com/ethereum/consensus-specs/blob/b2f2102dad0cd8b28a657244e645e0df1c0d246a/specs/phase0/validator.md#phase-0----honest-validator\">honest validator specs</a>.</li>\n</ul>\n<h3><a name=\"p-49689-simplifying-the-equation-4\" class=\"anchor\" href=\"https://ethresear.ch#p-49689-simplifying-the-equation-4\"></a>Simplifying the Equation</h3>\n<p>We rearrange the initial equation to find the threshold for <span class=\"math\">C(t)</span>, the cumulative percentage of votes that can be cast before the proposer must act:</p>\n<div class=\"math\">\nx + (1 - C(t)) \\times (1 - x) \\geq 0.4\n</div>\n<p>Expanding and simplifying:</p>\n<div class=\"math\">\n(1‚àíC(t))√ó(1‚àíx) = 1 - x - C(t) + C(t) \\times x \n</div>\n<div class=\"math\">\n1 - C(t) + C(t) \\times x \\geq 0.4\n</div>\n<p>Finally, solving for <span class=\"math\">C(t)</span>:</p>\n<div class=\"math\">\nC(t) \\leq \\frac{0.6}{1 - x}\n</div>\n<p>Find the complete derivation <a href=\"https://hackmd.io/L0A6zeBZSzGew2Ni0AzFVQ\">here</a>.</p>\n<h3><a name=\"p-49689-interpretation-5\" class=\"anchor\" href=\"https://ethresear.ch#p-49689-interpretation-5\"></a>Interpretation</h3>\n<p>This simplified equation <span class=\"math\">C(t) \\leq \\frac{0.6}{1 - x}</span> means that the proposer can safely propose as long as the cumulative attestations <span class=\"math\">C(t)</span> remain below the threshold defined by <span class=\"math\">\\frac{0.6}{1 - x}</span>.</p>\n<ul>\n<li><strong><span class=\"math\">C(t)</span>:</strong> The cumulative percentage of votes cast by time <span class=\"math\">t</span>.</li>\n<li><strong><span class=\"math\">x \\%</span>:</strong> The percentage of total validators controlled by the proposer.</li>\n<li><strong><span class=\"math\">0.4</span>:</strong> The 40% threshold needed to secure a majority (<span class=\"math\">1-0.4=0.6)</span>.</li>\n</ul>\n<p>The equation ensures that the proposer, with their share of validators, can still influence the outcome favorably by proposing before the cumulative attestations exceed this threshold.</p>\n<p>A node operator with many validators can risk a few seconds more than a small-size operator, knowing that their own validators will never vote against them.</p>\n<p><strong>The following chart shows the effects of economies of scale and answers the question of <em>how long a node operator with <em>x%</em> market share can maximally wait until the point it won‚Äôt be able to receive at least 40% of all attestations anymore</em>.</strong></p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/e/2/e24d2c92d6d6e9a6965edcac0b21f454c6404795.png\" data-download-href=\"https://ethresear.ch/uploads/default/e24d2c92d6d6e9a6965edcac0b21f454c6404795\" title=\"timing_games_proposer_share\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/e/2/e24d2c92d6d6e9a6965edcac0b21f454c6404795_2_690x383.png\" alt=\"timing_games_proposer_share\" data-base62-sha1=\"whXfGVbSxvX8hcoDUyfDKp6p04B\" width=\"690\" height=\"383\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/e/2/e24d2c92d6d6e9a6965edcac0b21f454c6404795_2_690x383.png, https://ethresear.ch/uploads/default/original/3X/e/2/e24d2c92d6d6e9a6965edcac0b21f454c6404795.png 1.5x, https://ethresear.ch/uploads/default/original/3X/e/2/e24d2c92d6d6e9a6965edcac0b21f454c6404795.png 2x\" data-dominant-color=\"FAF9F9\"></a></div><p></p>\n<p>The ‚Äú<em>seconds in slot</em>‚Äù values on the y-axis are <code>attestation_seen</code> timestamps that are not corrected by the time required for block propagation and verification. Since those numbers are just constants impacting the absolute values on the y-axis, this doesn‚Äôt matter in making the relative impact of market share on the limits of timing games visible.</p>\n<p><strong>We can see that a node operator with 30% of the market share can potentially wait 0.8 seconds longer than a node operator with 5% market share while risking the same.</strong></p>\n<h2><a name=\"p-49689-in-python-6\" class=\"anchor\" href=\"https://ethresear.ch#p-49689-in-python-6\"></a>In Python</h2>\n<p>Using Python, we can calculate the latest ‚Äúsafe‚Äù proposal time for different percentages of validator control. Here‚Äôs the key part of the implementation:</p>\n<pre data-code-wrap=\"python\"><code class=\"lang-python\">import numpy as np\nfrom scipy.interpolate import interp1d\n\n# Provided cumulative attestation data (seconds, % of casted attestations)\ndata = [\n     (0.791, 0.0005390835579514825),\n     # (additional data points omitted for brevity)\n     (2.228, 0.05444743935309973),\n     (2.464, 0.10835579514824797),\n     (2.639, 0.16226415094339622),\n     (2.777, 0.21617250673854446),\n     (2.932, 0.27008086253369273),\n     (3.104, 0.323989218328841),\n     (3.308, 0.3778975741239892),\n     (3.627, 0.43180592991913747),\n     (4.069, 0.4857142857142857),\n     (4.25, 0.539622641509434),\n     (4.407, 0.5935309973045823),\n     (4.576, 0.6474393530997304),\n     (4.723, 0.7013477088948787),\n     (4.898, 0.7552560646900269),\n     (5.039, 0.8091644204851752),\n     (5.245, 0.8630727762803234),\n     (5.521, 0.9169811320754717),\n     (6.187, 0.9708894878706199)\n]\n\n# Extracting the times and cumulative attestation percentages\ntimes = np.array([point[0] for point in data])\ncumulative_attestations = np.array([point[1] for point in data])\n\n# Interpolating the cumulative attestation function\ncumulative_attestation_func = interp1d(times, cumulative_attestations, kind='linear', fill_value=\"extrapolate\")\n\n# Function to calculate the latest time a proposer with x% control can safely propose a block\ndef calculate_latest_proposal_time(x):\n    threshold = 0.5 / (1 - x)\n    \n    for t in np.linspace(times[0], times[-1], 1000):\n        if cumulative_attestation_func(t) &gt; threshold:\n            return t\n    return None\n\n</code></pre>\n<h1><a name=\"p-49689-conclusion-7\" class=\"anchor\" href=\"https://ethresear.ch#p-49689-conclusion-7\"></a>Conclusion</h1>\n<p>By understanding and calculating the relationship between validator market share and cumulative attestations, proposers can optimize their proposal timing to minimize the likelihood of reorgs while maximizing profits.</p>\n<p>Such strategies could be improved by checking which CL client the subsequent validator runs, or, even simpler, the slot index in an epoch. Based on that information one can better estimate the chances of getting reorged (e.g. if it‚Äôs Teku, Nimbus, Lodestar, or the last slot in an epoch, then the reorg probability is significantly lower because no honest reorg strategy is implemented).</p>\n<p>Pushing proposer timing games to their limits has a <a href=\"https://ethresear.ch/t/on-attestations-block-propagation-and-timing-games/20272\">negative impact on attesters</a> and can have cascading effects: If validators realize they miss out on profits because they vote for the wrong block too often, they might start delaying their attestation.</p>\n<p><strong>Ultimately, pushing timing games to their limits can have a detrimental impact on the network. Furthermore, validator coordination that goes beyond running multiple validators from a single node shouldn‚Äôt be tolerated/supported. Now, it is important to follow/contribute to block construction research and find ways to <a href=\"https://eips.ethereum.org/EIPS/eip-7716\">reduce the profitability of timing games</a> or prevent them entirely.</strong></p>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://ethresear.ch/t/on-proposer-timing-games-and-economies-of-scale/20309\">Read full topic</a></p>","link":"https://ethresear.ch/t/on-proposer-timing-games-and-economies-of-scale/20309","pubDate":"Tue, 20 Aug 2024 05:48:59 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20309"},"source":{"@url":"https://ethresear.ch/t/on-proposer-timing-games-and-economies-of-scale/20309.rss","#text":"On Proposer Timing Games and Economies of Scale"}},{"title":"Decentralized and Verifiable Cloud Service on Ethereum","dc:creator":"0x1cc","category":"Applications","description":"<p><em>by <a href=\"https://x.com/0x_1cc\" rel=\"noopener nofollow ugc\">KD.Conway</a></em></p>\n<h2><a name=\"p-49659-tldr-1\" class=\"anchor\" href=\"https://ethresear.ch#p-49659-tldr-1\"></a>TL;DR</h2>\n<ul>\n<li>\n<p>We propose a decentralized and verifiable cloud service protocol on Ethereum, which can provide computationally intensive service to all web2 or web3 applications, making decentralized ChatGPT, decentralized blockchain explorer reality. By migrating the full stack, including frontend and backend components, to the decentralized cloud, we move toward fully decentralized and verifiable end-to-end Web3 applications.</p>\n</li>\n<li>\n<p>The protocol operates under a minority trust assumption, requiring only one honest node to guarantee service quality. Additionally, the correctness of the cloud service is verifiable on Ethereum.</p>\n</li>\n<li>\n<p>With near-zero on-chain costs, our decentralized cloud service platform can be even more affordable than traditional centralized options.</p>\n</li>\n</ul>\n<h2><a name=\"p-49659-protocol-overview-2\" class=\"anchor\" href=\"https://ethresear.ch#p-49659-protocol-overview-2\"></a>Protocol Overview</h2>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/d/8/d816db0bb6bbc127b1a5f2fa1f320e7c923dbb77.png\" data-download-href=\"https://ethresear.ch/uploads/default/d816db0bb6bbc127b1a5f2fa1f320e7c923dbb77\" title=\"ecs\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/d/8/d816db0bb6bbc127b1a5f2fa1f320e7c923dbb77_2_690x331.png\" alt=\"ecs\" data-base62-sha1=\"uPC6iBUHxlToWnG59kzCXWtSGtF\" width=\"690\" height=\"331\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/d/8/d816db0bb6bbc127b1a5f2fa1f320e7c923dbb77_2_690x331.png, https://ethresear.ch/uploads/default/optimized/3X/d/8/d816db0bb6bbc127b1a5f2fa1f320e7c923dbb77_2_1035x496.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/d/8/d816db0bb6bbc127b1a5f2fa1f320e7c923dbb77_2_1380x662.png 2x\" data-dominant-color=\"F1F2F3\"></a></div><p></p>\n<p>A service contract exists on Ethereum, functioning similarly to a gRPC protobuf. This contract defines the service, and the functions within it specify the methods that can be invoked.</p>\n<p>Each service provider must register and stake on the service contract. For each service, multiple providers will be available to offer the service.</p>\n<p>When a user initiates a service request, such as requesting an AI inference from an LLM model:</p>\n<ul>\n<li>\n<p>The user first utilizes a verifiable Ethereum light client, such as Helios, to retrieve the list of available service providers from the on-chain service contract.</p>\n</li>\n<li>\n<p>The user randomly selects several providers from this list.</p>\n</li>\n<li>\n<p>The user then sends off-chain transactions to these selected providers in parallel. These off-chain transactions are essentially the same as calling the corresponding service function in the smart contract, but they use a different chain ID. This specific chain ID indicates that the transaction is intended to call a cloud service rather than perform an on-chain transaction on Ethereum.</p>\n</li>\n<li>\n<p>The service providers execute the required computations in their local environments according to the program defined in the corresponding function in the service contract. They then return the responses to the user. Each response is signed by the service provider and includes the user‚Äôs transaction hash and the results.</p>\n</li>\n<li>\n<p>Upon receiving the responses from the selected providers, the user first verifies the signatures and checks the consistency of the results.</p>\n<ul>\n<li>\n<p>If the results are consistent, the service is considered to have functioned correctly, and no further action is required.</p>\n</li>\n<li>\n<p>If there is a discrepancy in the results, this indicates the presence of at least one malicious service provider. In this case, the user submits the providers‚Äô responses to the on-chain arbitration contract. This triggers a process where the service providers must defend the accuracy of their results. The on-chain arbitration process is detailed in the following section.</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2><a name=\"p-49659-service-contract-3\" class=\"anchor\" href=\"https://ethresear.ch#p-49659-service-contract-3\"></a>Service Contract</h2>\n<p>The design of the service contract is akin to the design of gRPC. A new service contract corresponds to a new service in gRPC, and the functions defined in the service contract specify the methods that can be invoked. Due to the constraints of smart contracts, we cannot implement complex computations, such as AI computations, directly within the smart contract. Instead, we define a standard for writing a program, which is then uploaded to decentralized DA services, with the program‚Äôs hash stored in the on-chain smart contract.</p>\n<p>Following the design principle of ‚ÄúSeparate Execution from Proving,‚Äù there are two implementations for the service program. One is compiled for native execution, optimized for speed, and can leverage multithreaded CPUs and GPUs to accelerate execution. The other implementation is for proving; the service program is compiled into machine-independent code, allowing us to use zkVM (zero-knowledge virtual machine) or fpVM (fraud-proof virtual machine) to generate proofs. This dual-target approach ensures fast execution, while proving is based on the machine-independent code.</p>\n<p>For example, consider matrix multiplication. Native execution utilizes GPU computation (e.g., CUDA) for acceleration. During the proving phase, the service program is compiled into machine-independent instructions, which can be executed in zkVM or fpVM. Both implementations ensure consistent execution results.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/b/1/b1ccfdf9e6f994151293a835a4619dca5e974865.png\" data-download-href=\"https://ethresear.ch/uploads/default/b1ccfdf9e6f994151293a835a4619dca5e974865\" title=\"output\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/b/1/b1ccfdf9e6f994151293a835a4619dca5e974865_2_690x151.png\" alt=\"output\" data-base62-sha1=\"pmTHL7pfXZqNQUG3qbGzDdecvfD\" width=\"690\" height=\"151\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/b/1/b1ccfdf9e6f994151293a835a4619dca5e974865_2_690x151.png, https://ethresear.ch/uploads/default/optimized/3X/b/1/b1ccfdf9e6f994151293a835a4619dca5e974865_2_1035x226.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/b/1/b1ccfdf9e6f994151293a835a4619dca5e974865_2_1380x302.png 2x\" data-dominant-color=\"F8F8F9\"></a></div><p></p>\n<p>When processing user requests, service providers will run the program in the native execution environment and return the results to the users. Only when on-chain arbitration is required will the service providers run the program for proving. This approach allows service providers to handle requests as quickly as possible in most cases.</p>\n<p>Additionally, the service program can be configured to read data from trustworthy sources, such as Ethereum or other blockchains, as well as from decentralized, trustworthy data storage providers. This flexibility allows the service program to function as a blockchain explorer, an AI service, or a decentralized search engine.</p>\n<p>A demo version of the service contract is shown below.</p>\n<pre data-code-wrap=\"solidity\"><code class=\"lang-solidity\">contract Service {\n\n    // address =&gt; web2 domain\n    mapping(address =&gt; string) serviceProviderHost;\n\n    address[] serviceProviders;\n\n    // function selector =&gt; programHash\n    mapping(bytes4 =&gt; bytes32) programHashs;\n\n    event Request(\n        address account,\n        bytes4 functionSelector,\n        bytes32 programHash,\n        bytes input\n    );\n\n    function func1(bytes calldata input) public {\n        emit Request(msg.sender, this.func1.selector, programHashs[this.func1.selector], input);\n    }\n}\n</code></pre>\n<p>Note that <code>func1</code> specifies the method that can be called. When a user wants to call <code>func1</code>, instead of sending an on-chain transaction on Ethereum, the user needs to send an off-chain transaction directly to the service providers. Besides, the user can obtain the list of service provider addresses, along with their corresponding Web2 domains using Ethereum verifiable light client.</p>\n<h2><a name=\"p-49659-onchain-arbitration-4\" class=\"anchor\" href=\"https://ethresear.ch#p-49659-onchain-arbitration-4\"></a>Onchain Arbitration</h2>\n<p>We support multiple proving systems for on-chain arbitration, including zero-knowledge proofs, Trusted Execution Environments (TEE), and fraud-proof systems. For demonstration purposes, we focus on the fraud-proof system, as it offers lower generation costs compared to zero-knowledge proofs and does not require specific hardware. In previous work, we demonstrated the ability to generate fraud proofs for extremely large AI models. For more details, please refer to opML (<a href=\"https://arxiv.org/abs/2401.17555\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">[2401.17555] opML: Optimistic Machine Learning on Blockchain</a>).</p>\n<p>The on-chain arbitration process using the fraud-proof system proceeds as follows:</p>\n<ul>\n<li>\n<p>If a user receives inconsistent results from the service providers, they submit the providers‚Äô responses to the on-chain arbitration contract, initiating an interactive dispute game with all the involved providers.</p>\n</li>\n<li>\n<p>At this point, the service providers must run the proving-version of the service program in their local fraud-proof VMs to generate the fraud proof, which they then submit to the on-chain arbitration contract to defend their results. For more details on the interactive dispute game, refer to the fraud-proof system design.</p>\n</li>\n<li>\n<p>Service providers who supplied incorrect results will lose the dispute game, resulting in their staked amount being slashed. The slashed stake will be distributed to the winners of the dispute game, as well as to the user, as compensation.</p>\n</li>\n</ul>\n<p>This on-chain arbitration mechanism ensures that only one honest node is required to guarantee the correctness of the provided service. As a result, the protocol relies on a minority trust assumption and inherits security from Ethereum. Assuming at least one honest node and the safety of Ethereum, the protocol can guarantee the correctness of the service.</p>\n<p>It‚Äôs important to note that on-chain arbitration only occurs when some service providers produce incorrect results. In typical cases, no on-chain interaction is needed, which allows the service to operate as quickly as current centralized cloud service providers.</p>\n<h2><a name=\"p-49659-charging-mechanism-5\" class=\"anchor\" href=\"https://ethresear.ch#p-49659-charging-mechanism-5\"></a>Charging Mechanism</h2>\n<p>There are several possible charging mechanisms:</p>\n<ul>\n<li>\n<p><strong>Subscription Model:</strong> This is similar to the Web2 approach, where the charging mechanism can be conducted off-chain. For example, to use ChatGPT via an API for commercial purposes, you would pay OpenAI a monthly fee to access their services. Multiple service providers can offer the service, allowing for competition and choice.</p>\n</li>\n<li>\n<p><strong>On-Chain Payment Mechanism:</strong> Paying for each request on-chain can be costly due to transaction fees. Batching and rolling up these requests and payments can significantly reduce on-chain transaction costs. One possible approach is to use payment channels to pay for requests. Alternatively, service providers could generate service proofs and claim fees as follows:</p>\n<ul>\n<li>\n<p>A service agreement contract specifies the price for each service request.</p>\n</li>\n<li>\n<p>Users first stake funds into the service agreement contract.</p>\n</li>\n<li>\n<p>Service providers can claim their fees by submitting service proofs to the on-chain service agreement contract. To minimize transaction costs, providers can batch and roll up user requests.</p>\n</li>\n<li>\n<p>The on-chain service proof is a zk-proof, which verifies that the service provider has delivered a certain number of responses to users. The provider can then claim the corresponding service fees according to the agreement contract. This proof ensures the correctness of the user‚Äôs request transaction signature, the service provider‚Äôs response signature, and the transaction nonce.</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Free Service Model:</strong> Another approach is for companies to cover the service fees by the themselves (currently, the web2 companies pay the cloud service fee by themselves), offering free services to users while generating revenue through other means, such as advertising or VIP services.</p>\n</li>\n</ul>\n<h2><a name=\"p-49659-advantages-6\" class=\"anchor\" href=\"https://ethresear.ch#p-49659-advantages-6\"></a>Advantages</h2>\n<ul>\n<li>\n<p>This decentralized cloud service can be cheaper than centralized cloud services while maintaining similar speed.</p>\n<ul>\n<li>\n<p><strong>Cost-Effectiveness:</strong> Decentralized servers can be significantly cheaper than centralized cloud servers. For example, <a href=\"http://io.net\" rel=\"noopener nofollow ugc\">io.net</a> has shown that the cost of decentralized GPUs can be as low as one-third of the cost of AWS. For services with lower security requirements, such as using LLMs for personal queries, using just two nodes is often sufficient. Additionally, a random check mechanism can be adopted, querying one node most of the time and occasionally checking another to verify correctness. This setup can be more cost-effective than centralized platform.</p>\n</li>\n<li>\n<p><strong>Scalability and Speed:</strong> This platform can outperform centralized systems, especially for computationally intensive tasks. A decentralized cloud service platform operates on an N-to-M model (N users with M servers, where the number of servers can be infinite), whereas centralized platforms use an N-to-1 model (N users with a single super server). This allows a decentralized cloud service platform to scale more effectively. For instance, a centralized AI platform like ChatGPT may slow down during peak times because it can‚Äôt scale its computing power quickly enough. In contrast, decentralized platform can dynamically distribute the load across many servers, ensuring faster response times even during heavy usage.</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Trustless and Verifiable:</strong> The protocol operates under a minority trust assumption, requiring only one honest node to guarantee service quality. Additionally, the correctness of the cloud service is verifiable on Ethereum.</p>\n</li>\n<li>\n<p><strong>Censorship-Resilient:</strong> This platform contributes to a more robustly decentralized Web3, enhancing censorship resistance.</p>\n</li>\n</ul>\n<h2><a name=\"p-49659-toward-fully-decentralized-and-verifiable-web3-application-7\" class=\"anchor\" href=\"https://ethresear.ch#p-49659-toward-fully-decentralized-and-verifiable-web3-application-7\"></a>Toward Fully Decentralized and Verifiable Web3 Application</h2>\n<p>With this protocol, we can move toward fully decentralized and verifiable Web3 applications.</p>\n<p><strong>Decentralized and Verifiable Blockchain Explorer:</strong> Currently, blockchain explorers like Etherscan are hosted by centralized entities, and the results they present are not verifiable. If such an explorer were hacked, it could display malicious and misleading information, such as fake transactions or contracts, potentially leading to phishing scams. By migrating the entire blockchain explorer‚Äîincluding both the frontend and backend services‚Äîto our platform, we can ensure full verifiability and robust security for the blockchain explorer.</p>\n<p><strong>Decentralized, Verifiable, Faster, and Cheaper AI Platform:</strong> This protocol enables the creation of a fully decentralized, verifiable, and cost-effective AI platform. By moving the entire stack, including both frontend and backend services as well as AI computation, to a decentralized cloud, we can build an AI platform that is not only more affordable but also potentially faster than centralized alternatives.</p>\n<p><strong>Decentralized Cloud Gaming:</strong> Some games require high-end hardware, such as powerful GPUs and CPUs, leading game companies to move their games to cloud services, reducing the hardware requirements for customers. We can similarly bring Web3 games to our platform. Since our platform is verifiable on Ethereum, game reward settlements can be easily managed through smart contracts.</p>\n<h2><a name=\"p-49659-further-discussion-8\" class=\"anchor\" href=\"https://ethresear.ch#p-49659-further-discussion-8\"></a>Further Discussion</h2>\n<h3><a name=\"p-49659-updating-the-state-9\" class=\"anchor\" href=\"https://ethresear.ch#p-49659-updating-the-state-9\"></a>Updating the State</h3>\n<p>In the previous discussion, the service program operates under a stateless design, meaning it does not modify its internal state. However, the data source used by the service program is upgradable. For instance, if a service program uses Ethereum as its data source, users can interact with smart contracts on Ethereum to update the state. The service program can then utilize the latest Ethereum state as its data source, enabling the implementation of a decentralized explorer.</p>\n<p>If updating the internal state of the service program is required, a state machine replication network must be established among the service providers. In this case, each service program would correspond to a layer 2 or layer 3 blockchain on Ethereum. When users invoke a method that updates the internal state, they would send the transaction to the corresponding layer 2 or layer 3 blockchain. The service providers would then reach a consensus on the execution results of that transaction and update the internal state accordingly. Periodically, the layer 2 blockchain would roll up the transactions and its latest state back to Ethereum.</p>\n<h3><a name=\"p-49659-verifiable-fhe-10\" class=\"anchor\" href=\"https://ethresear.ch#p-49659-verifiable-fhe-10\"></a>Verifiable FHE</h3>\n<p>To ensure user privacy, Fully Homomorphic Encryption (FHE) can be integrated into our protocol. In this case, the FHE computation would be incorporated into the service program. Instead of sending plaintext data to the service providers, users would encrypt their input and send only the ciphertext, thereby preserving their privacy. Additionally, if on-chain arbitration is triggered, the FHE service program would be compiled into machine-independent instructions, and a fraud proof or zk-proof would be generated to make the FHE computation fully verifiable.</p>\n<h2><a name=\"p-49659-related-work-and-comparison-11\" class=\"anchor\" href=\"https://ethresear.ch#p-49659-related-work-and-comparison-11\"></a>Related Work and Comparison</h2>\n<p><strong>Comparison with Web3URL</strong></p>\n<p>Web3URL (<a href=\"https://w3url.w3eth.io/\" rel=\"noopener nofollow ugc\">https://w3url.w3eth.io/</a>) is an interesting project that transforms Ethereum into an unstoppable decentralized web server. Our protocol can be seen as a significant extension of Web3URL. In Web3URL, service functions must be written within smart contracts, which naturally limits large-scale applications. In contrast, our protocol supports complex service programs, such as AI computations, and provides flexible access to large-scale data, making decentralized ChatGPT and decentralized explorers a reality.</p>\n<p><strong>Comparison with ICP</strong></p>\n<p>The Internet Computer (ICP: <a href=\"https://internetcomputer.org/\" rel=\"noopener nofollow ugc\">https://internetcomputer.org/</a>) hosts decentralized serverless compute, similar to our goal of creating a decentralized cloud service platform. However, we differ from ICP in several key aspects:</p>\n<ul>\n<li>\n<p><strong>Ethereum Integration:</strong> We are building on Ethereum, allowing us to inherit its security features.</p>\n</li>\n<li>\n<p><strong>Higher Security:</strong> We achieve a higher level of security compared to ICP. While ICP operates in a Byzantine Fault Tolerance (BFT) network under a majority trust assumption‚Äîrequiring that most nodes in the subnet are honest‚Äîwe adopt an approach similar to rollups, with on-chain arbitration ultimately reverting to Ethereum. This allows us to guarantee correctness under a minority trust assumption, where just one honest node can ensure the integrity of our protocol.</p>\n</li>\n<li>\n<p><strong>Complex Computation:</strong> Following the design principle of ‚ÄúSeparate Execution from Proving,‚Äù we can handle complex computations natively, such as LLM inference or even fine-tuning. In contrast, service programs in ICP always run within canisters, which significantly limits their applicability for large-scale computations.</p>\n</li>\n</ul>\n<p>If you are interested in this project or have suggestions for improvements, please feel free to reach out to me.</p>\n            <p><small>4 posts - 3 participants</small></p>\n            <p><a href=\"https://ethresear.ch/t/decentralized-and-verifiable-cloud-service-on-ethereum/20292\">Read full topic</a></p>","link":"https://ethresear.ch/t/decentralized-and-verifiable-cloud-service-on-ethereum/20292","pubDate":"Sat, 17 Aug 2024 11:48:03 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20292"},"source":{"@url":"https://ethresear.ch/t/decentralized-and-verifiable-cloud-service-on-ethereum/20292.rss","#text":"Decentralized and Verifiable Cloud Service on Ethereum"}},{"title":"Censorship Insurance Markets for BRAID","dc:creator":"jonahb27","category":"Block proposer","description":"<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/b/f/bf7665c93b36acdfa0cb7c8ed757aa3ef87f101f.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/bf7665c93b36acdfa0cb7c8ed757aa3ef87f101f\" title=\"BRAID\"><img src=\"https://ethresear.ch/uploads/default/original/3X/b/f/bf7665c93b36acdfa0cb7c8ed757aa3ef87f101f.jpeg\" alt=\"BRAID\" data-base62-sha1=\"rjKRtDgYAP4vmSSayhZ1b1A8Fm7\" width=\"500\" height=\"500\" data-dominant-color=\"495C57\"></a></div><p></p>\n<p>By: <a href=\"https://x.com/_jonahb_\">Jonah Burian</a> and <a href=\"https://x.com/BenLevy0\">Ben Levy</a></p>\n<p><em>Tl;dr: We point out that BRAID‚Äôs liquidity requirements lead to poor user UX and suggest censorship insurance markets as a potential solution.</em></p>\n<p><em>Thanks to <a href=\"https://x.com/maxresnick1\">Max Resnick</a> and <a href=\"https://x.com/davidecrapis\">Davide Crapis</a> for the feedback.</em></p>\n<h2><a name=\"p-49651-intro-1\" class=\"anchor\" href=\"https://ethresear.ch#p-49651-intro-1\"></a>Intro</h2>\n<blockquote>\n<p>‚ÄúThe greatness of <s>America</s> <em>Ethereum</em> lies not in being more enlightened than any other <s>nation</s> <em>blockchain</em>, but rather in her ability to repair her faults.‚Äù <em>- Alexis de Tocqueville</em></p>\n</blockquote>\n<p>Censorship resistance (CR) is one of the core security properties of a blockchain.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/c/7/c7e58a93fe9b45a91ecf29a6aefa91567c310262.png\" data-download-href=\"https://ethresear.ch/uploads/default/c7e58a93fe9b45a91ecf29a6aefa91567c310262\" title=\"CR\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/c/7/c7e58a93fe9b45a91ecf29a6aefa91567c310262_2_690x180.png\" alt=\"CR\" data-base62-sha1=\"swmO0GJ1QBKqG3t56pVSs0ZWPDA\" width=\"690\" height=\"180\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/c/7/c7e58a93fe9b45a91ecf29a6aefa91567c310262_2_690x180.png, https://ethresear.ch/uploads/default/optimized/3X/c/7/c7e58a93fe9b45a91ecf29a6aefa91567c310262_2_1035x270.png 1.5x, https://ethresear.ch/uploads/default/original/3X/c/7/c7e58a93fe9b45a91ecf29a6aefa91567c310262.png 2x\" data-dominant-color=\"151515\"></a></div><p></p>\n<p>Ethereum gifts proposers with one-slot monopolies on transaction inclusion, creating a principal-agent problem and a single point of failure. A censoring party can bribe the current proposer to censor a transaction.</p>\n<p>There has been considerable work to mitigate this problem. A key insight is that the weak link problem of a single proposer results in weak CR. Multi-proposer schemes like <a href=\"https://www.youtube.com/watch?v=mJLERWmQ2uw\">BRAID</a> and <a href=\"https://ethresear.ch/t/fork-choice-enforced-inclusion-lists-focil-a-simple-committee-based-inclusion-list-proposal/19870/1\">FOCIL</a> can correct this principal-agent problem.</p>\n<p>In this piece, we focus on BRAID, a multi-proposer mechanism that has garnered significant recent attention. It aims to increase CR in a capital-efficient way via a conditional tipping mechanism (explained below).</p>\n<p>One challenge in this approach, the need for a deterministic ordering rule, is already well understood. <em><strong>In this piece we identify another challenge‚Äîliquidity requirements that adversely affect UX‚Äîand propose a few potential solutions.</strong></em></p>\n<h2><a name=\"p-49651-braid-at-a-high-level-2\" class=\"anchor\" href=\"https://ethresear.ch#p-49651-braid-at-a-high-level-2\"></a>BRAID at a High Level:</h2>\n<p>BRAID runs <span class=\"math\">k</span> subchains in parallel, each with a unique proposer. Block <span class=\"math\">n</span> of Ethereum is the union of transactions from block <span class=\"math\">n</span> of the <span class=\"math\">k</span> subchains, with a special ordering rule applied to order this unordered set.</p>\n<h3><a name=\"p-49651-tipping-in-braid-3\" class=\"anchor\" href=\"https://ethresear.ch#p-49651-tipping-in-braid-3\"></a>Tipping in BRAID</h3>\n<p>Bidders submit a conditional twin tip <span class=\"math\">(t,T)</span> which depends on the number of proposers who include the transaction. If only a single proposer includes a transaction, they receive <span class=\"math\">T</span>; if multiple proposers include the transaction, they split <span class=\"math\">t</span>.</p>\n<h3><a name=\"p-49651-tipping-properties-4\" class=\"anchor\" href=\"https://ethresear.ch#p-49651-tipping-properties-4\"></a>Tipping Properties</h3>\n<p>Let <span class=\"math\">œï(t,T)</span> be the minimum cost to censor a BRAID transaction. It has been <a href=\"https://arxiv.org/abs/2301.13321\">shown</a> that <span class=\"math\">œï(t,T)=kT</span>.</p>\n<p>The goal of BRAID is that users will most likely never actually have to pay <span class=\"math\">T</span>; instead, they pay <span class=\"math\">t</span>, which can be much lower than <span class=\"math\">T</span>.</p>\n<p>This multi-dimensional tip disentangles the cost of inclusion (for the transacting party) from the cost of censoring such that <span class=\"math\">t&lt;&lt;T</span>.</p>\n<p>Simply put, a user get‚Äôs <span class=\"math\">kT</span> worth of CR while (usually) only paying <span class=\"math\">t</span>.</p>\n<p><strong>How Users Will Tip:</strong></p>\n<ul>\n<li><span class=\"math\">T</span>: From a user‚Äôs perspective, they set <span class=\"math\">T=\\frac{V}{k}</span> where <span class=\"math\">V</span> is the value the user places in their transaction not being censored.</li>\n<li><span class=\"math\">t</span>: In current BRAID specs, the ordering of transactions depends on <span class=\"math\">t</span>, with more favorable ordering (i.e., coming first) given to those with the highest <span class=\"math\">t</span>. Therefore, a user will choose their <span class=\"math\">t</span> based on where they want to be in the ordering.</li>\n</ul>\n<p><em>Note that if a user does not care about CR, they can set <span class=\"math\">T=t</span> and send their transaction to just one proposer.</em></p>\n<h2><a name=\"p-49651-the-ux-challenge-5\" class=\"anchor\" href=\"https://ethresear.ch#p-49651-the-ux-challenge-5\"></a>The UX Challenge:</h2>\n<p>While a user will only pay <span class=\"math\">t</span> for their transaction, they need to have <span class=\"math\">T</span> available to make a credible promise to the protocol that they can pay <span class=\"math\">T</span>. Hence a user needs to have <span class=\"math\">T</span> of additional available liquidity to make a transaction. We saw before that <span class=\"math\">T \\propto V</span>: <span class=\"math\">T</span> tends to scale with the value of the transaction. This burdens users with a liquidity requirement.</p>\n<p>For example, say a user wants to sell $5M of ETH due to impending interest rate fears and values censorship resistance at $1M. Let‚Äôs say there are 4 shards, i.e., <span class=\"math\">k=4</span>. The user needs to have $250k of additional unpledged liquidity available just to exit their position. This hampers the UX of on-chain finance by placing additional and obscure liquidity requirements on participants that scale with the value of their positions.</p>\n<h2><a name=\"p-49651-fixes-6\" class=\"anchor\" href=\"https://ethresear.ch#p-49651-fixes-6\"></a>Fixes:</h2>\n<h3><a name=\"p-49651-proof-of-post-state-liquidity-7\" class=\"anchor\" href=\"https://ethresear.ch#p-49651-proof-of-post-state-liquidity-7\"></a><strong>Proof of Post-State Liquidity</strong></h3>\n<p><strong>Idea:</strong> A user submits a transaction with a proof that they will have enough liquidity to pay <span class=\"math\">T</span> if necessary after their transaction. In the case before, the proof will show that the transaction will give the user $1M of liquidity so they could afford the <span class=\"math\">T=</span> $250k if necessary.</p>\n<p><strong>Problem:</strong> This assumes that a proposer has a good understanding of the post-state of a transaction. Most financial transactions interact with shared state, and as a result, transaction ordering is needed to know the post-state. This knowledge relies on the final ordering so we can‚Äôt include it as an input to the transaction. Even when there is a reasonable lower bound on post-state available liquidity, establishing it would (unrealistically) require bespoke proofs for each transaction type.</p>\n<h3><a name=\"p-49651-censorship-insurance-ci-8\" class=\"anchor\" href=\"https://ethresear.ch#p-49651-censorship-insurance-ci-8\"></a>Censorship Insurance (CI)</h3>\n<p><strong>Idea:</strong> A third party‚Äìthe CI provider‚Äìcan sponsor the escrow of <span class=\"math\">T</span> for the transaction. Users will have to pay an insurance premium of <span class=\"math\">rT</span> to the CI provider, where <span class=\"math\">r</span> represents the rate (mostly) based on the likelihood of censorship. CI providers are thus assessing the rewards of censoring the transaction in real time to ensure it is below <span class=\"math\">kT</span>.</p>\n<p>To prevent an attack where a user purchases insurance and then only sends their tx to one proposer whom they are colluding with, the CI should be (one of) the relayer(s) for the tx. This mirrors how gas sponsorship works and indeed CI insurance should likely just be included in a gas sponsorship service.</p>\n<p>Effectively a user pays a total of <span class=\"math\">t + rT</span> for their transaction and only needs to have <span class=\"math\">t + rT</span> on hand as opposed to <span class=\"math\">T</span>, which is frequently more than <span class=\"math\">t + rT</span>.</p>\n<p>An additional benefit of this scheme is that a marketplace of at least two CI providers will conveniently alert users when their <span class=\"math\">T</span> is too low and there is a high risk of censorship because they‚Äôll refuse to censorship-insure the transaction at a reasonable rate.</p>\n<p><strong>Problem:</strong> It will be difficult to bootstrap a two-sided marketplace for this from scratch.</p>\n<h3><a name=\"p-49651-ci-market-structure-9\" class=\"anchor\" href=\"https://ethresear.ch#p-49651-ci-market-structure-9\"></a>CI Market Structure</h3>\n<p>In practice applications or wallets will likely claim jurisdiction over this issue. One possible solution to the bootstrapping problem, therefore, is for applications and/or wallets to sign wholesale agreements with CI providers √† la PFOF.</p>\n<p>While the above solution likely works fine, another option is to create a proper on-chain market with e.g. an RFQ for each transaction whose sender wishes to purchase censorship resistance for.</p>\n<p><img src=\"https://ethresear.ch/uploads/default/original/3X/0/4/049237e341dc88cd24cde968c71e70ce689c3444.png\" alt=\"snake\" data-base62-sha1=\"ErbepHjP783sZdbfKfWocF9KUQ\" width=\"240\" height=\"240\"></p>\n<p>This market, fittingly, would benefit from the CR properties of BRAID.</p>\n<h2><a name=\"p-49651-conclusion-10\" class=\"anchor\" href=\"https://ethresear.ch#p-49651-conclusion-10\"></a>Conclusion</h2>\n<p>BRAID is still in its early days as a proposal. The UX issue of liquidity requirements has not been sufficiently explored, though there are promising signs that we can reasonably punt the issue to the application layer. For next steps, we suggest further exploration of the feasibility of CI markets.</p>\n<h2><a name=\"p-49651-previous-work-11\" class=\"anchor\" href=\"https://ethresear.ch#p-49651-previous-work-11\"></a>Previous work:</h2>\n<ul>\n<li><a href=\"https://arxiv.org/abs/2301.13321\">Censorship Resistance in On-Chain Auctions</a>: Elijah, Max, Mallesh</li>\n<li><a href=\"https://ethresear.ch/t/concurrent-block-proposers-in-ethereum/18777\">Concurrent Block Proposers in Ethereum</a>: Mike, Max</li>\n<li><a href=\"https://blog.duality.xyz/introducing-multiplicity/\">Introducing Multiplicity</a>: Duality blog</li>\n<li><a href=\"https://efdn.notion.site/ROP-9-Multiplicity-gadgets-for-censorship-resistance-7def9d354f8a4ed5a0722f4eb04ca73b\">ROP-9: Multiplicity gadgets for censorship-resistance</a> RIG</li>\n<li><a href=\"https://www.youtube.com/watch?v=mJLERWmQ2uw\">BRAID: Implementing Multiple Concurrent Block Proposers</a>: Max</li>\n<li><a href=\"https://ethresear.ch/t/fork-choice-enforced-inclusion-lists-focil-a-simple-committee-based-inclusion-list-proposal/19870/1\">Fork-Choice enforced Inclusion Lists (FOCIL): A simple committee-based inclusion list proposal</a>: Thomas, Barnab√©, Francesco and Julian</li>\n</ul>\n            <p><small>4 posts - 3 participants</small></p>\n            <p><a href=\"https://ethresear.ch/t/censorship-insurance-markets-for-braid/20288\">Read full topic</a></p>","link":"https://ethresear.ch/t/censorship-insurance-markets-for-braid/20288","pubDate":"Fri, 16 Aug 2024 15:36:38 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20288"},"source":{"@url":"https://ethresear.ch/t/censorship-insurance-markets-for-braid/20288.rss","#text":"Censorship Insurance Markets for BRAID"}},{"title":"Ethereum discv5 DHT Network Health Weekly Reports","dc:creator":"yiannisbot","category":"Networking","description":"<blockquote>\n<p><em>Work presented here has been carried out by the <a href=\"https://probelab.network\" rel=\"noopener nofollow ugc\">ProbeLab</a> team and in particular <a class=\"mention\" href=\"https://ethresear.ch/u/guillaumemichel\">@guillaumemichel</a> <a class=\"mention\" href=\"https://ethresear.ch/u/cortze\">@cortze</a> <a class=\"mention\" href=\"https://ethresear.ch/u/dennis-tra\">@dennis-tra</a> and Steph.</em></p>\n</blockquote>\n<h2><a name=\"p-49640-high-level-description-1\" class=\"anchor\" href=\"https://ethresear.ch#p-49640-high-level-description-1\"></a>High Level Description</h2>\n<p>The ProbeLab team has developed and deployed infrastructure to monitor several critical metrics for Ethereum‚Äôs CL discv5 DHT network. In particular, we have adapted the Nebula crawler (<a href=\"https://github.com/dennis-tra/nebula/\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">GitHub - dennis-tra/nebula: üåå A network agnostic DHT crawler, monitor, and measurement tool that exposes timely information about DHT networks.</a>) to be compatible with discv5-based networks and are gathering results that reflect the health of the P2P network at the DHT level.</p>\n<p>In this post we‚Äôre presenting a summary of what is included in the reports, but for a more complete picture of what‚Äôs there, head to: <a href=\"https://probelab.io/ethereum/discv5/2024-29/\" rel=\"noopener nofollow ugc\">https://probelab.io/ethereum/discv5/2024-29/</a> for the latest report.</p>\n<ul>\n<li>\n<p>Reports are produced every Monday for the preceding week.</p>\n</li>\n<li>\n<p>The methodology we follow for DHT Crawling, Data Filtering, Node Classification as well as the differences of our tool to alternatives in the space is given in the Methodology section: <a href=\"https://probelab.io/ethereum/discv5/methodology/\" rel=\"noopener nofollow ugc\">https://probelab.io/ethereum/discv5/methodology/</a>.</p>\n</li>\n<li>\n<p>The crawler used to produce the reports can be found (and can be reused) here: <a href=\"https://github.com/dennis-tra/nebula/\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">GitHub - dennis-tra/nebula: üåå A network agnostic DHT crawler, monitor, and measurement tool that exposes timely information about DHT networks.</a>.</p>\n</li>\n</ul>\n<h2><a name=\"p-49640-why-you-should-care-2\" class=\"anchor\" href=\"https://ethresear.ch#p-49640-why-you-should-care-2\"></a>Why you should care</h2>\n<p>The metrics included in the reports:</p>\n<ul>\n<li>\n<p>give an overview of the network structure, size and client adoption breakdown. This helps in understanding the robustness and diversity of the network,</p>\n</li>\n<li>\n<p>provide accurate geographic distribution of nodes in the network per client implementation over time, which can highlight regional trends and potential vulnerabilities or strengths in specific areas,</p>\n</li>\n<li>\n<p>make it easy to spot drastic changes in the structure and setup of the network,</p>\n</li>\n<li>\n<p>allow for monitoring of new protocol version uptake/adoption, and provide insights on whether there are adoption barriers,</p>\n</li>\n<li>\n<p>reveal the infrastructure setup (e.g., data center-hosted vs non-data center-hosted) and cloud provider distribution per client implementation,</p>\n</li>\n<li>\n<p>show the breakdown of nodes supporting particular network-layer protocols,</p>\n</li>\n<li>\n<p>depict the percentage of reachable vs unreachable node records in the DHT network.</p>\n</li>\n</ul>\n<h2><a name=\"p-49640-overview-of-results-3\" class=\"anchor\" href=\"https://ethresear.ch#p-49640-overview-of-results-3\"></a>Overview of Results</h2>\n<p>We‚Äôre presenting a small fraction of the results given at <a href=\"https://probelab.io\" rel=\"noopener nofollow ugc\">https://probelab.io</a> to give an idea of the metrics listed. Please head there for the complete reports from Week 11 (mid-March), 2024.</p>\n<p><strong>Client Diversity</strong></p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/4/3/433c4aecd269c5dfd9291dc03bbf58624414061c.png\" data-download-href=\"https://ethresear.ch/uploads/default/433c4aecd269c5dfd9291dc03bbf58624414061c\" title=\"discv5-agents-overall\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/4/3/433c4aecd269c5dfd9291dc03bbf58624414061c_2_489x375.png\" alt=\"discv5-agents-overall\" data-base62-sha1=\"9ANalSHzx5WpILh8Cssu8iqaYS8\" width=\"489\" height=\"375\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/4/3/433c4aecd269c5dfd9291dc03bbf58624414061c_2_489x375.png, https://ethresear.ch/uploads/default/optimized/3X/4/3/433c4aecd269c5dfd9291dc03bbf58624414061c_2_733x562.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/4/3/433c4aecd269c5dfd9291dc03bbf58624414061c_2_978x750.png 2x\" data-dominant-color=\"E7E6E4\"></a></div><p></p>\n<p><strong>Client Diversity Over Time</strong></p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/2/6/2664514f07b9b5aa0f4dea5319bc82fe047fa27b.png\" data-download-href=\"https://ethresear.ch/uploads/default/2664514f07b9b5aa0f4dea5319bc82fe047fa27b\" title=\"discv5-agents-overall-stacked\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/2/6/2664514f07b9b5aa0f4dea5319bc82fe047fa27b_2_489x375.png\" alt=\"discv5-agents-overall-stacked\" data-base62-sha1=\"5tD4y25IZZpEDWS94p6mWrD1iYz\" width=\"489\" height=\"375\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/2/6/2664514f07b9b5aa0f4dea5319bc82fe047fa27b_2_489x375.png, https://ethresear.ch/uploads/default/optimized/3X/2/6/2664514f07b9b5aa0f4dea5319bc82fe047fa27b_2_733x562.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/2/6/2664514f07b9b5aa0f4dea5319bc82fe047fa27b_2_978x750.png 2x\" data-dominant-color=\"DCDAD9\"></a></div><p></p>\n<p><strong>Agent version adoption over time - Example: Lighthouse</strong></p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/a/0/a081c5b9376d2f17792caaa6b6d91b9f2e4353a0.png\" data-download-href=\"https://ethresear.ch/uploads/default/a081c5b9376d2f17792caaa6b6d91b9f2e4353a0\" title=\"discv5-versions-distribution\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/a/0/a081c5b9376d2f17792caaa6b6d91b9f2e4353a0_2_489x375.png\" alt=\"discv5-versions-distribution\" data-base62-sha1=\"mTUqJMBLpLOCgHUELpWOsKX6M4E\" width=\"489\" height=\"375\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/a/0/a081c5b9376d2f17792caaa6b6d91b9f2e4353a0_2_489x375.png, https://ethresear.ch/uploads/default/optimized/3X/a/0/a081c5b9376d2f17792caaa6b6d91b9f2e4353a0_2_733x562.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/a/0/a081c5b9376d2f17792caaa6b6d91b9f2e4353a0_2_978x750.png 2x\" data-dominant-color=\"E6D9D2\"></a></div><p></p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/6/1/61739999c2d736e11817cf8f417008e2c88869dc.png\" data-download-href=\"https://ethresear.ch/uploads/default/61739999c2d736e11817cf8f417008e2c88869dc\" title=\"discv5-agents-versions\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/6/1/61739999c2d736e11817cf8f417008e2c88869dc_2_489x375.png\" alt=\"discv5-agents-versions\" data-base62-sha1=\"dU5Za5KQnDcJp7ETG1KU8ywLkGo\" width=\"489\" height=\"375\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/6/1/61739999c2d736e11817cf8f417008e2c88869dc_2_489x375.png, https://ethresear.ch/uploads/default/optimized/3X/6/1/61739999c2d736e11817cf8f417008e2c88869dc_2_733x562.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/6/1/61739999c2d736e11817cf8f417008e2c88869dc_2_978x750.png 2x\" data-dominant-color=\"DCE3EF\"></a></div><p></p>\n<p><strong>Country distribution of all nodes</strong></p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/3/4/34aa9fb69b64bdf785073d62f018a4c78cbad033.png\" data-download-href=\"https://ethresear.ch/uploads/default/34aa9fb69b64bdf785073d62f018a4c78cbad033\" title=\"discv5-geo-agent-all-bars\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/3/4/34aa9fb69b64bdf785073d62f018a4c78cbad033_2_489x375.png\" alt=\"discv5-geo-agent-all-bars\" data-base62-sha1=\"7vUo5ag1dENh1y4BMFybIb38X99\" width=\"489\" height=\"375\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/3/4/34aa9fb69b64bdf785073d62f018a4c78cbad033_2_489x375.png, https://ethresear.ch/uploads/default/optimized/3X/3/4/34aa9fb69b64bdf785073d62f018a4c78cbad033_2_733x562.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/3/4/34aa9fb69b64bdf785073d62f018a4c78cbad033_2_978x750.png 2x\" data-dominant-color=\"EAF1F6\"></a></div><p></p>\n<p><strong>Client-specific country distribution - Example: Prysm</strong></p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/c/9/c92579370dcf03c6358536d0a358da2d79aeaa51.png\" data-download-href=\"https://ethresear.ch/uploads/default/c92579370dcf03c6358536d0a358da2d79aeaa51\" title=\"discv5-geo-agents-lines-prysm\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/c/9/c92579370dcf03c6358536d0a358da2d79aeaa51_2_489x375.png\" alt=\"discv5-geo-agents-lines-prysm\" data-base62-sha1=\"sHqg0lL70SbHABxWoMx221HSD5v\" width=\"489\" height=\"375\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/c/9/c92579370dcf03c6358536d0a358da2d79aeaa51_2_489x375.png, https://ethresear.ch/uploads/default/optimized/3X/c/9/c92579370dcf03c6358536d0a358da2d79aeaa51_2_733x562.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/c/9/c92579370dcf03c6358536d0a358da2d79aeaa51_2_978x750.png 2x\" data-dominant-color=\"FAF8F8\"></a></div><p></p>\n<p><strong>Cloud provider distribution of all nodes</strong></p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/5/5/55ffef8626b07b1f21845591817184f663c7c88f.png\" data-download-href=\"https://ethresear.ch/uploads/default/55ffef8626b07b1f21845591817184f663c7c88f\" title=\"discv5-cloud-agent-all-bars\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/5/5/55ffef8626b07b1f21845591817184f663c7c88f_2_489x375.png\" alt=\"discv5-cloud-agent-all-bars\" data-base62-sha1=\"cgMVk2NYPDPJDrB20Xy5m9BXqs7\" width=\"489\" height=\"375\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/5/5/55ffef8626b07b1f21845591817184f663c7c88f_2_489x375.png, https://ethresear.ch/uploads/default/optimized/3X/5/5/55ffef8626b07b1f21845591817184f663c7c88f_2_733x562.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/5/5/55ffef8626b07b1f21845591817184f663c7c88f_2_978x750.png 2x\" data-dominant-color=\"EEF3F7\"></a></div><p></p>\n<p><strong>Cloud vs non-cloud distribution of nodes over time</strong></p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/4/7/47638e6a177376cd847949f006ddd6ad91a73368.png\" data-download-href=\"https://ethresear.ch/uploads/default/47638e6a177376cd847949f006ddd6ad91a73368\" title=\"discv5-cloud-rate-agent-all-lines\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/4/7/47638e6a177376cd847949f006ddd6ad91a73368_2_489x375.png\" alt=\"discv5-cloud-rate-agent-all-lines\" data-base62-sha1=\"abxckcFFQ7ZwNhKGcPYplROghmg\" width=\"489\" height=\"375\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/4/7/47638e6a177376cd847949f006ddd6ad91a73368_2_489x375.png, https://ethresear.ch/uploads/default/optimized/3X/4/7/47638e6a177376cd847949f006ddd6ad91a73368_2_733x562.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/4/7/47638e6a177376cd847949f006ddd6ad91a73368_2_978x750.png 2x\" data-dominant-color=\"FCFCFC\"></a></div><p></p>\n<p><strong>Stale Peer Records over time</strong></p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/d/9/d941c8d07f12784b4d26214ce100dcfbb8f1e99e.png\" data-download-href=\"https://ethresear.ch/uploads/default/d941c8d07f12784b4d26214ce100dcfbb8f1e99e\" title=\"discv5-stale-records-mainnet-stacked\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/d/9/d941c8d07f12784b4d26214ce100dcfbb8f1e99e_2_489x375.png\" alt=\"discv5-stale-records-mainnet-stacked\" data-base62-sha1=\"uZWyjY1g91W85mbEt7UXr7lJftk\" width=\"489\" height=\"375\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/d/9/d941c8d07f12784b4d26214ce100dcfbb8f1e99e_2_489x375.png, https://ethresear.ch/uploads/default/optimized/3X/d/9/d941c8d07f12784b4d26214ce100dcfbb8f1e99e_2_733x562.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/d/9/d941c8d07f12784b4d26214ce100dcfbb8f1e99e_2_978x750.png 2x\" data-dominant-color=\"EED8C4\"></a></div><p></p>\n<h2><a name=\"p-49640-how-to-contribute-4\" class=\"anchor\" href=\"https://ethresear.ch#p-49640-how-to-contribute-4\"></a>How to contribute</h2>\n<p>Overall, we believe this set of results give an accurate view of the structure and health of the discv5 DHT network. We hope you‚Äôll find the reports useful.</p>\n<p>If there are important metrics that you believe should be part of these weekly reports, comment below, or get in touch with the team: <a href=\"https://www.probelab.network/contact\" rel=\"noopener nofollow ugc\">probelab.network/contact</a>.</p>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://ethresear.ch/t/ethereum-discv5-dht-network-health-weekly-reports/20282\">Read full topic</a></p>","link":"https://ethresear.ch/t/ethereum-discv5-dht-network-health-weekly-reports/20282","pubDate":"Thu, 15 Aug 2024 16:10:39 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20282"},"source":{"@url":"https://ethresear.ch/t/ethereum-discv5-dht-network-health-weekly-reports/20282.rss","#text":"Ethereum discv5 DHT Network Health Weekly Reports"}},{"title":"Autonomous Competence Identification Protocol","dc:creator":"peersky","category":"Meta-innovation","description":"<p>I‚Äôm excited to share my ongoing research on a protocol designed to streamline communication and decision-making around subjective matters, particularly within DAOs and R&amp;D processes. This protocol establishes a ranking system that counters common governance issues, fostering a more collaborative and effective environment.</p>\n<p>I‚Äôm posting this in the meta-innovation category because it has implications both for DAO/Consensus research and for potential collaboration tools within the Ethereum community.</p>\n<p><em>Link to paper in progress: <a href=\"https://github.com/peersky/papers/blob/main/acid/whitepaper.pdf\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">papers/acid/whitepaper.pdf at main ¬∑ peersky/papers ¬∑ GitHub</a></em></p>\n<h2><a name=\"p-49639-tldr-1\" class=\"anchor\" href=\"https://ethresear.ch#p-49639-tldr-1\"></a>TL‚ÄôDR</h2>\n<p>The protocol enables subjective decision-making and quantifies proposer ratings. Participants define a context and engage in rounds of discussion, providing and receiving feedback without revealing identities until the round concludes. This mitigates biases like the <a href=\"https://en.wikipedia.org/wiki/Halo_effect\" rel=\"noopener nofollow ugc\">Halo effect</a>, and collusion (sybil attack) risks.</p>\n<p>Protocol streamlines discussions and enables autonomously assign competent decision makers as well as create pre-arranged agenda for any follow up voting systems (hence addresses <a href=\"https://www.sciencedirect.com/science/article/abs/pii/0022053176900405\" rel=\"noopener nofollow ugc\">Agenda Manipulation</a>,  ( casually explained in <a href=\"https://www.youtube.com/watch?v=goQ4ii-zBMw\" rel=\"noopener nofollow ugc\">this youtube video</a> ) problem</p>\n<h2><a name=\"p-49639-motivation-2\" class=\"anchor\" href=\"https://ethresear.ch#p-49639-motivation-2\"></a>Motivation</h2>\n<h3><a name=\"p-49639-communication-complexities-hinder-decision-making-3\" class=\"anchor\" href=\"https://ethresear.ch#p-49639-communication-complexities-hinder-decision-making-3\"></a>Communication Complexities Hinder Decision-Making</h3>\n<p>Effective decision-making is hindered by communication complexities.</p>\n<ul>\n<li>Traditional methods (meetings, chats): don‚Äôt scale, leading to information overload and delays.</li>\n<li>More stakeholders exponentially increase communication complexity, leaving less time for effective decisions.</li>\n<li>Individual contributions can get lost, leading to under-appreciation and high turnover.</li>\n</ul>\n<h3><a name=\"p-49639-traditional-organizations-are-sub-optimally-managed-4\" class=\"anchor\" href=\"https://ethresear.ch#p-49639-traditional-organizations-are-sub-optimally-managed-4\"></a>Traditional Organizations are Sub-optimally Managed</h3>\n<p>Despite modern networking and project management technologies, the primary, basis of hierarchical communication hasn‚Äôt changed much over centuries. Decisions still require large centralization force, which will step in and cut opinions to shape performance capable decision.</p>\n<ul>\n<li>Centralized decision-making prioritizes efficiency over diverse input, fostering internal politics and biased decisions.</li>\n<li>This breeds internal politics, leading to biased decisions that may harm the organization.</li>\n<li>Current methods lack objective ways to measure and reward valuable contributions, limiting organizational potential.</li>\n<li>Does not let organizations reach their full potential</li>\n</ul>\n<p>This touches every organization, including Ethereum R&amp;D.</p>\n<h3><a name=\"p-49639-icos-do-not-work-well-for-daos-5\" class=\"anchor\" href=\"https://ethresear.ch#p-49639-icos-do-not-work-well-for-daos-5\"></a>ICOs do not work well for DAOs</h3>\n<p>Research shows that many DAOs are highly centralized, with low participation rates and vulnerability to governance attacks. The incentive structures in Proof of Stake (PoS) and Proof of Work (PoW) systems can lead to centralization.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/1/e/1edd6c487afe9524d47e660bb04cf7872abb6008.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/1edd6c487afe9524d47e660bb04cf7872abb6008\" title=\"img\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/1/e/1edd6c487afe9524d47e660bb04cf7872abb6008_2_690x274.jpeg\" alt=\"img\" data-base62-sha1=\"4p2IGe0bCv68xvWg0MwBMFLBkaA\" width=\"690\" height=\"274\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/1/e/1edd6c487afe9524d47e660bb04cf7872abb6008_2_690x274.jpeg, https://ethresear.ch/uploads/default/optimized/3X/1/e/1edd6c487afe9524d47e660bb04cf7872abb6008_2_1035x411.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/1/e/1edd6c487afe9524d47e660bb04cf7872abb6008_2_1380x548.jpeg 2x\" data-dominant-color=\"E1E0DF\"></a></div><br>\n<div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/4/e/4e7ea5b4ee785ee33c7f3664e698a915d71867f8.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/4e7ea5b4ee785ee33c7f3664e698a915d71867f8\" title=\"img2\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/4/e/4e7ea5b4ee785ee33c7f3664e698a915d71867f8_2_690x374.jpeg\" alt=\"img2\" data-base62-sha1=\"bcoAa4OAtZdSFAPJpZhmXLrtm40\" width=\"690\" height=\"374\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/4/e/4e7ea5b4ee785ee33c7f3664e698a915d71867f8_2_690x374.jpeg, https://ethresear.ch/uploads/default/optimized/3X/4/e/4e7ea5b4ee785ee33c7f3664e698a915d71867f8_2_1035x561.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/4/e/4e7ea5b4ee785ee33c7f3664e698a915d71867f8_2_1380x748.jpeg 2x\" data-dominant-color=\"F6F5F5\"></a></div><p></p>\n<h3><a name=\"p-49639-cyber-physical-social-systems-6\" class=\"anchor\" href=\"https://ethresear.ch#p-49639-cyber-physical-social-systems-6\"></a>Cyber-Physical-Social-Systems</h3>\n<p>There‚Äôs a growing need for DAOs to bridge traditional management with AI agents and automated infrastructure, as highlighted by research in Cyber-Physical-Social Systems (CPSS).</p>\n<h2><a name=\"p-49639-approach-7\" class=\"anchor\" href=\"https://ethresear.ch#p-49639-approach-7\"></a>Approach</h2>\n<p>The protocol aims to incentivize participation without enabling influence compounding. It builds on a real-world game where participants propose and vote on ideas (like music tracks) without revealing identities until the round ends.</p>\n<h3><a name=\"p-49639-key-requirements-for-the-protocol-8\" class=\"anchor\" href=\"https://ethresear.ch#p-49639-key-requirements-for-the-protocol-8\"></a>Key requirements for the protocol:</h3>\n<ul>\n<li><strong>Mission aligned:</strong> Participant activity directly impacts organizational goals.</li>\n<li><strong>Highly performant</strong>: Organizations using the protocol should outperform traditional structures.</li>\n<li><strong>Centralization resilient</strong>: Financial contributions shouldn‚Äôt lead to disproportionate influence.</li>\n<li><strong>Multidimensional</strong>: Support diverse participant interests.</li>\n<li><strong>Rational</strong>: Function even when agents act in their self-interest.</li>\n</ul>\n<h3><a name=\"p-49639-key-features-9\" class=\"anchor\" href=\"https://ethresear.ch#p-49639-key-features-9\"></a>Key features:</h3>\n<ul>\n<li><strong>Competence-based participation</strong>: Participants earn governance rights through demonstrated competence, not just financial contributions.</li>\n<li><strong>Sybil attack resistance</strong>: A tournament ladder structure imposes costs and time requirements, making manipulation difficult.</li>\n<li><strong>Progressive decentralization</strong>: Organizations can evolve by adding governance layers, increasing overall governance surface area.</li>\n</ul>\n<h2><a name=\"p-49639-current-state-10\" class=\"anchor\" href=\"https://ethresear.ch#p-49639-current-state-10\"></a>Current State</h2>\n<ul>\n<li><strong>Research paper in progress</strong>: Seeking feedback and potential co-authors.</li>\n<li><strong>Basic prototype and testing</strong>: Exploring use cases beyond music, such as manage-less code writing.</li>\n<li><strong>Website with Telegram group</strong>: <a href=\"https://rankify.it\" rel=\"noopener nofollow ugc\">https://rankify.it</a></li>\n</ul>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://ethresear.ch/t/autonomous-competence-identification-protocol/20281\">Read full topic</a></p>","link":"https://ethresear.ch/t/autonomous-competence-identification-protocol/20281","pubDate":"Thu, 15 Aug 2024 12:41:30 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20281"},"source":{"@url":"https://ethresear.ch/t/autonomous-competence-identification-protocol/20281.rss","#text":"Autonomous Competence Identification Protocol"}},{"title":"A Threshold Network for ‚ÄúHuman Keys‚Äù to solve privacy and custody issues","dc:creator":"nanaknihal","category":"Cryptography","description":"<h1><a name=\"p-49627-introduction-1\" class=\"anchor\" href=\"https://ethresear.ch#p-49627-introduction-1\"></a>Introduction</h1>\n<p>In blockchain and PKI more generally, people are represented by keys. A somewhat strange question to ask might be ‚Äúwhy don‚Äôt keys represent people?‚Äù I will argue this is actually an important question and the crux of major privacy and onboarding challenges. We present a a threshold network design dubbed Mishti Network to derive keys from people rather than arbitrary randomness. This network solves a number of problems in ZK identity, compliance, and onboarding.</p>\n<p>What does it mean for a key to be a representation of a person? There are two conditions that should be met:</p>\n<ul>\n<li>A person‚Äôs knowledge and/or attributes can always map to the private key</li>\n<li>This person is the sole controller of the key</li>\n</ul>\n<p>In other words, it is a collision-resistant map of personal data and attributes to a high-entropy pseudorandom number. Without collision resistance, multiple people could have the same key. Without high entropy, the key is not secure. Keys can be both standard private keys or also a nullifier that‚Äôs useful for secure ZK credentials.</p>\n<p>Human keys are not solely biometrics. They could be from human-friendly data such as security questions, passwords, or any unique knowledge belonging to an individual rather than arbitrary randomness.</p>\n<h1><a name=\"p-49627-solution-oblivious-pseudorandom-function-2\" class=\"anchor\" href=\"https://ethresear.ch#p-49627-solution-oblivious-pseudorandom-function-2\"></a>Solution: Oblivious Pseudorandom Function</h1>\n<p>This solution is based on a threshold verifiable oblivious pseudorandom function (tVOPRF) on private data. An oblivious pseudorandom function (OPRF) takes a private input and computes a pseudorandom function (PRF). PRFs take low-entropy input and create high-entropy output. Adding verifiability via a ZKP makes it into a VOPRF. Verifying individual node contributions is important to decentralizing the network.</p>\n<h1><a name=\"p-49627-why-it-is-helpful-to-ethereum-pki-3\" class=\"anchor\" href=\"https://ethresear.ch#p-49627-why-it-is-helpful-to-ethereum-pki-3\"></a>Why it is helpful to Ethereum + PKI</h1>\n<p>Some of the outstanding issues in Ethereum are onboarding and privacy. Onboarding requires not just simplicity but also self-custody, and recovery. Current onboarding solutions such as social logins and passkeys do not have self-custody (as they can be recovered by web2 accounts), while self-custodial solutions can‚Äôt have recovery without extra onboarding step like electing gaurdians.</p>\n<p>A similar need is for ZK identity applications that need to derive nullifiers from their users‚Äô identities, in a way nobody can trace back to the user. This is a common need in proof-of-personhood solutions to ensure that each person only has one corresponding nullifier without a central database or key that links users to their nullifiers.</p>\n<p>Furthermore, the underlying cryptography and network can be repurposed to tackle another pressing challenge: that of satisfying compliance rules with ZK identity. The same underlying elliptic curve multiplication primitive that underlies this design can be used to construct threshold ElGamal decryption over ZK-friendly curves, which can allow ZK proofs to contain encrypted data with flexible access control.</p>\n<h1><a name=\"p-49627-oblivious-pseudorandom-function-4\" class=\"anchor\" href=\"https://ethresear.ch#p-49627-oblivious-pseudorandom-function-4\"></a>Oblivious Pseudorandom Function</h1>\n<p>To generate keys from identities, an oblivious pseudorandom function (OPRF) can be constructed with distributed EC scalar multiplication. This allows private user data such as security questions, biometrics, passwords, or social security numbers, etc. to deterministically generate secret keys. The resulting pseudorandom value is computationally impractical to reverse despite it being from low-entropy input. One can thereby create wallet or nullifier from any (or a combination) of these low-entropy ‚Äúhuman‚Äù factors. In the 2HashDH OPRF [1], a server or network‚Äôs secret is used to give randomness to the client‚Äôs input. The oblivious property prevents any server or set of nodes from seeing see this input.</p>\n<p>2HashDH is the following algorithm between a user with a private input <span class=\"math\">x</span> and a server (or network) with a private key <span class=\"math\">s</span>. For a subgroup <span class=\"math\">G</span> of an elliptic curve there are two hash functions:</p>\n<p><span class=\"math\">hashToCurve: \\{0,1\\}^* \\rightarrow G</span><br>\n<span class=\"math\">hashToScalar: G \\rightarrow F_q</span>.</p>\n<p>The 2HashDH OPRF proceeds as follows</p>\n<ol>\n<li>User samples a random mask <span class=\"math\">r</span> and sends <span class=\"math\">M = r * hashToCurve(x)</span></li>\n<li>Server multiplies by its secret, returning <span class=\"math\">s * M</span></li>\n<li>User computes the output by unmasking the server‚Äôs response and hashing it: <span class=\"math\">o = HashToScalar(r^{-1} * s * M)</span></li>\n</ol>\n<p><span class=\"math\">o</span> is uniformly pseudorandom in <span class=\"math\">F_q</span>, and the server is information-theoretically blinded from the user‚Äôs input.</p>\n<h2><a name=\"p-49627-decentralizing-the-server-5\" class=\"anchor\" href=\"https://ethresear.ch#p-49627-decentralizing-the-server-5\"></a>Decentralizing the server</h2>\n<p>To decentralize the OPRF server, only the step with a server must be decentralized:</p>\n<blockquote>\n<ol start=\"2\">\n<li>Server multiplies by its secret, returning <span class=\"math\">s * M</span></li>\n</ol>\n</blockquote>\n<p>For threshold elliptic curve multiplication, first a linear secret sharing, such as Shamir‚Äôs scheme, must be used. The secret key is generated through distributed key generation (DKG) such that each node with index <span class=\"math\">i</span> receives share <span class=\"math\">f(i)</span> for some secret polynomial <span class=\"math\">f</span> known to nobody. There is no node at the <span class=\"math\">0</span> index and <span class=\"math\">f(0)</span> is the secret key of the network. The secret key <span class=\"math\">f(0)</span> can be computed by a set <span class=\"math\">Q</span> of <span class=\"math\">t</span> nodes where <span class=\"math\">t</span> is one more than the degree of <span class=\"math\">f</span>.</p>\n<p><span class=\"math\">f(0) = \\sum_{i \\in Q}{L_{0, Q}(i)*f(i)}</span></p>\n<p>where <span class=\"math\">L_{0,Q}(i)</span> is the Lagrange basis for index <span class=\"math\">i</span> in set <span class=\"math\">Q</span> evaluated at zero.</p>\n<p>Instead of reconstructing <span class=\"math\">f(0)</span>, the nodes can collaborate to construct <span class=\"math\">f(0) * M</span></p>\n<p><span class=\"math\">f(0) * M = \\sum_{i \\in Q}{L_{0, Q}(i)*f(i) * M}</span></p>\n<p>This is sufficient for step</p>\n<blockquote>\n<ol start=\"2\">\n<li>Server multiplies by its secret, returning <span class=\"math\">s * M</span></li>\n</ol>\n</blockquote>\n<p>if the nodes are honest. But if one lies, the result will be wrong and there will be no way of knowing who lied. Thus, each node should prove their individual multiplication using a lightweight zero-knowledge DLEQ proof.</p>\n<h1><a name=\"p-49627-other-interesting-use-case-provable-encryption-with-programmable-privacy-6\" class=\"anchor\" href=\"https://ethresear.ch#p-49627-other-interesting-use-case-provable-encryption-with-programmable-privacy-6\"></a>Other interesting use case: Provable encryption with programmable privacy</h1>\n<p>The same decentralized EC scalar primitive can be used not just for VOPRF but also for ElGamal decryption over ZK-friendly curves. This is helpful when identities must be revealed in certain conditions.</p>\n<p>For example, many private DeFi protocols are interested in ensuring that bad actors do not get the benefits of anonymity, while the average user typically does. Governments are not satisfied with solely ZK because they need access to user data, but currently the only alternative is honeypots where all user data is stored to be turned over to authorities if needed.</p>\n<p>Another use of revealing provably encrypted identities under certain conditions is undercollateralized lending ‚Äì what if you want an identity or private key to be revealed if a DeFi loan is defaulted on? In this case, you need to prove the proper data is encrypted correctly, then have a smart contract control decryption rights.</p>\n<p>To modify this threshold EC point multiplication to such use cases, little is needed.</p>\n<h3><a name=\"p-49627-encryption-7\" class=\"anchor\" href=\"https://ethresear.ch#p-49627-encryption-7\"></a>Encryption</h3>\n<p>ElGamal encryption is client-side:</p>\n<ol>\n<li>Create an ephemeral keypair <span class=\"math\">(a, A = aG)</span></li>\n<li>Encode the message as an EC point <span class=\"math\">P</span></li>\n<li>Compute Diffie-Hellman shared secret with network public key: <span class=\"math\">aB</span></li>\n<li>Compute the ciphertext <span class=\"math\">(A, aB+P)</span></li>\n</ol>\n<h3><a name=\"p-49627-decryption-8\" class=\"anchor\" href=\"https://ethresear.ch#p-49627-decryption-8\"></a>Decryption</h3>\n<p>Unlike encryption, decryption requires a server or decentralized network.</p>\n<ol>\n<li>Server/network multiply ephemeral public key <span class=\"math\">A</span> by its secret key <span class=\"math\">b</span> to get <span class=\"math\">bA</span> = <span class=\"math\">aB</span></li>\n<li>Decryptor subtracts this value from <span class=\"math\">aB+P</span> to get <span class=\"math\">P</span></li>\n</ol>\n<p>The server/network‚Äôs step can be handled by the same threshold multiplication protocol as before!</p>\n<h1><a name=\"p-49627-network-setup-and-collusion-protection-9\" class=\"anchor\" href=\"https://ethresear.ch#p-49627-network-setup-and-collusion-protection-9\"></a>Network Setup and Collusion Protection</h1>\n<p>The team at Holonym has implemented this as as an AVS on Eigenlayer called Mishti Network. High reputation is common among Eigenlayer operators despite the permissionless nature, so it is ideal for threshold networks where collusion is a concern. To further mitigate collusion risk, there is the idea of parallel networks:</p>\n<p>The asynchronous and homomorphic nature of the computations means users can permissionlessly add nodes outside of Mishti Network that they trust to not collude with Mishti Network. E.g. instead of splitting a secret between Mishti Network, half of the secret is between the Mishti Network and the other half in a semi-trusted node elected by the user. Since the whole network just does an EC multiplication, exactly what its individual does do, nodes and networks can be treated the same. A 2/2 scheme could be done between a semi-trusted node and Mishti network, simply by</p>\n<ul>\n<li>Adding their public keys to get the joint public key</li>\n<li>Adding their responses to get a joint response to the computation</li>\n</ul>\n<p>Note this requires no consent from the network and is not limited to 2/2 schemes; it can be done with any combination of semi-trusted nodes and/or independent networks via threshold schemes.</p>\n<h1><a name=\"p-49627-references-10\" class=\"anchor\" href=\"https://ethresear.ch#p-49627-references-10\"></a>References</h1>\n<p>[1] S. Jarecki, A. Kiayias, and H. Krawczyk, ‚ÄúRound-optimal<br>\npassword-protected secret sharing and T-PAKE in the password only model,‚Äù in International Conference on the Theory and Application of Cryptology and Information Security. Springer, 2014 pp. 233‚Äì253</p>\n<h1><a name=\"p-49627-concluding-notes-11\" class=\"anchor\" href=\"https://ethresear.ch#p-49627-concluding-notes-11\"></a>Concluding Notes</h1>\n<p>If you have any ideas on how to improve or elaborate on this network design for either ZK identity, self-custody, or any other relevant use cases, please reply or reach out.</p>\n            <p><small>3 posts - 2 participants</small></p>\n            <p><a href=\"https://ethresear.ch/t/a-threshold-network-for-human-keys-to-solve-privacy-and-custody-issues/20276\">Read full topic</a></p>","link":"https://ethresear.ch/t/a-threshold-network-for-human-keys-to-solve-privacy-and-custody-issues/20276","pubDate":"Wed, 14 Aug 2024 23:38:38 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20276"},"source":{"@url":"https://ethresear.ch/t/a-threshold-network-for-human-keys-to-solve-privacy-and-custody-issues/20276.rss","#text":"A Threshold Network for ‚ÄúHuman Keys‚Äù to solve privacy and custody issues"}},{"title":"On Attestations, Block Propagation, and Timing Games","dc:creator":"Nero_eth","category":"Proof-of-Stake","description":"<h1><a name=\"p-49615-on-attestations-block-propagation-and-timing-games-1\" class=\"anchor\" href=\"https://ethresear.ch#p-49615-on-attestations-block-propagation-and-timing-games-1\"></a>On Attestations, Block Propagation, and Timing Games</h1>\n<p>By now, <a href=\"https://timing.pics/\">proposer timing games</a> are no longer a new phenomenon and have been analyzed, <a href=\"https://eprint.iacr.org/2023/760\">here</a>, <a href=\"https://arxiv.org/abs/2305.09032\">here</a> and <a href=\"https://ethresear.ch/t/deep-diving-attestations-a-quantitative-analysis/20020\">here</a>.</p>\n<p>In the following research piece, I want to show the <strong>evolution of <a href=\"https://timing.pics/\">proposer timing games</a></strong> and analyze their impact on attesters. Through a case study of the node operators of Lido, Coinbase, and Kiln, we dive deep into block proposal timing and its impact on Ethereum‚Äôs consensus.</p>\n<p><img src=\"https://ethresear.ch/uploads/default/original/3X/1/5/152baa9c8da23d4524a4e75101c4a1c0967ebf83.png\" alt=\"kilnmeme\" data-base62-sha1=\"31hA4vYiC0HXYzLulsE2jgQccYH\" width=\"456\" height=\"413\"></p>\n<p>As of August 2024, the <strong>block building market is largely outsourced</strong>, with <a href=\"https://mevboost.pics/\">~90%</a> handled by <a href=\"https://github.com/flashbots/mev-boost\">mevboost</a> block builders. In practice, two builders, <a href=\"https://www.titanbuilder.xyz/\">Titan Builder</a> and <a href=\"https://beaverbuild.org/\">Beaverbuild</a>, produce approximately <a href=\"https://mevboost.pics/\">80%</a> of all blocks that make it on-chain.</p>\n<p><strong>Kiln is among the entities pushing timing games the furthest</strong>, delaying block proposals to the <strong>3-3.5 second</strong> mark within the slot.</p>\n<blockquote>\n<p>In today‚Äôs environment with mevboost, <strong>block propagation is primarily handled by relays.</strong> Although proposers still propagate the block after receiving it from the relay, relays typically have better network connectivity and can therefore do it faster. <strong>However, the timing remains under the control of proposers</strong>, who can delay their <code>getHeader</code> calls to engage in timing games.</p>\n</blockquote>\n<p>This chart shows the <strong>evolution of timing games</strong>. We can see that blocks from Kiln validators appear later and later over time.</p>\n<p><img src=\"https://ethresear.ch/uploads/default/original/3X/8/2/82cad8533f90505055f8eced73ae89d774a96111.gif\" alt=\"proposer_timing_games\" data-base62-sha1=\"iF2FcLalibUbfwkXjgSw3JZDhBv\" width=\"690\" height=\"383\" class=\"animated\"></p>\n<p><strong>This comes with an impact on the network: for blocks proposed by Kiln proposers, the missed/wrong head vote rate is significantly higher:</strong><br>\n</p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/8/d/8d3a31d4dd9d8856d2baaf1b7ad1528312b72923.png\" data-download-href=\"https://ethresear.ch/uploads/default/8d3a31d4dd9d8856d2baaf1b7ad1528312b72923\" title=\"missed_head_votes_over_proposers\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/8/d/8d3a31d4dd9d8856d2baaf1b7ad1528312b72923_2_690x316.png\" alt=\"missed_head_votes_over_proposers\" data-base62-sha1=\"k9m0itcVa1uOzFoLrnC7UEx2Nwv\" width=\"690\" height=\"316\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/8/d/8d3a31d4dd9d8856d2baaf1b7ad1528312b72923_2_690x316.png, https://ethresear.ch/uploads/default/optimized/3X/8/d/8d3a31d4dd9d8856d2baaf1b7ad1528312b72923_2_1035x474.png 1.5x, https://ethresear.ch/uploads/default/original/3X/8/d/8d3a31d4dd9d8856d2baaf1b7ad1528312b72923.png 2x\" data-dominant-color=\"FCFBFB\"></a></div><p></p>\n<p><a href=\"https://ethresear.ch/t/deep-diving-attestations-a-quantitative-analysis/20020\">Previous analysis</a> showed that <strong>the longer one waits, the higher the expected number of missed head votes</strong> (<em>‚Äú80% of attestations seen by the second 5 in the slot‚Äù</em>). Kiln proposes blocks very late, causing some attesters to miss them and instead vote for the parent block. <strong>Given that there are approximately 32,000 validators assigned to each slot, this results in about 10% of them voting for the wrong block.</strong></p>\n<p>Let‚Äôs examine the attesting behavior of three large node operators and compare how they respond to <strong>blocks proposed at different times within a slot.</strong> The chart below illustrates the distribution of correct and timely head votes across the seconds within a slot.<br>\n<img src=\"https://ethresear.ch/uploads/default/original/3X/5/e/5eb241fefdf5cecb08a41d95fbf6d0263dbb573d.gif\" alt=\"attestations_seen_late\" data-base62-sha1=\"dvINsHYiu6PRjUS95UhcOYcA3aB\" width=\"690\" height=\"383\" class=\"animated\"><br>\nFor early blocks, we observe that both <strong>Lido and Coinbase display a characteristic ‚ÄúU‚Äù-shape</strong> in their voting patterns that might be caused by different geo locations or client software. In contrast, <strong>Kiln shows a single prominent peak</strong> that slightly lags behind the first peaks of Coinbase and Lido. <strong>However, for late blocks, Kiln attesters also show the ‚ÄúU‚Äù-shape pattern.</strong></p>\n<p><strong>When blocks are first seen at the 4-second mark in the p2p network during a slot, most Lido attesters attest up to 2 seconds earlier than most of the Kiln or Coinbase attesters.</strong> This pattern doesn‚Äôt necessarily suggest that Kiln is executing ‚Äúindividual strategies.‚Äù Instead, it could be attributed to running different clients or using different geographical locations.</p>\n<h3><a name=\"p-49615-but-who-affects-whom-2\" class=\"anchor\" href=\"https://ethresear.ch#p-49615-but-who-affects-whom-2\"></a><em><strong>But who affects whom?</strong></em></h3>\n<p>In the following chart, we compare a node operator‚Äôs performance over different proposers. A bar above y=1, for example, the green bar at Lido, indicates that Lido attesters miss more head votes for blocks from Kiln proposers. At the same time, Lido attesters do better for Lido blocks. The dashed line at 1 indicates the average share in missed head votes over all entities as proposers. A bar below 1 means the specific entity misses fewer head votes in conjunction with the respective proposer compared to the average.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/7/8/786e634d534692c6bcef1859d4baf99b6490a363.png\" data-download-href=\"https://ethresear.ch/uploads/default/786e634d534692c6bcef1859d4baf99b6490a363\" title=\"missed_head_votes_over_proposers_percentage\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/7/8/786e634d534692c6bcef1859d4baf99b6490a363_2_690x316.png\" alt=\"missed_head_votes_over_proposers_percentage\" data-base62-sha1=\"hbnNGIDeAWz1uDryDd1jJOu4tMf\" width=\"690\" height=\"316\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/7/8/786e634d534692c6bcef1859d4baf99b6490a363_2_690x316.png, https://ethresear.ch/uploads/default/optimized/3X/7/8/786e634d534692c6bcef1859d4baf99b6490a363_2_1035x474.png 1.5x, https://ethresear.ch/uploads/default/original/3X/7/8/786e634d534692c6bcef1859d4baf99b6490a363.png 2x\" data-dominant-color=\"D5D5CD\"></a></div><p></p>\n<blockquote>\n<p>Importantly, it is expected that each node operator does best with its local blocks. This is expected even without a coordination oracle, simply by co-locating nodes.</p>\n</blockquote>\n<p>To quickly summarize what we see:</p>\n<ul>\n<li>Most node operators are rather stable across different proposers.</li>\n<li><strong>Figment performs significantly worse for Kiln proposers.</strong> The same applies to Lido, Kraken, and EtherFi attesters.</li>\n<li><strong>Kiln and Binance are the only entities performing better for Kiln blocks</strong> (which are, as a reminder, very late).</li>\n</ul>\n<p><strong>Kiln attesters generally do well.</strong> <a href=\"https://ethresear.ch/t/deep-diving-attestations-a-quantitative-analysis/20020\">Earlier analysis</a> showes that Kiln does a more than good job when it comes to running high-performing validators. Refer to <a href=\"https://ethresear.ch/t/deep-diving-attestations-a-quantitative-analysis/20020\">this analysis</a> for further details of Kiln‚Äôs attestation performance.</p>\n<p><strong>Kiln causes stress.</strong> Now, we know that Kiln blocks cause stress to other attesters but not necessarily to Kiln‚Äôs attesters.</p>\n<p><strong>Explaining how.</strong> The ‚Äú<em>how</em>?‚Äù is difficult to respond to at this point. A possible explanation might be that Kiln‚Äôs validators are heavily co-located, with many validators running on the same machine, or have very dense peering. Another reason might be coordinated behavior across multiple nodes, either through custom peering/private mesh networks or through another additional communication layer connecting their validators. The latter is regarded as more centralizing as it leverages economies of scale even more.</p>\n<p>A similar pattern can be observed when examining the (correct &amp; timely) attestation timing of Lido and Coinbase for the blocks proposed by each respective entity (26.07.2024-03.08.2024).<br>\n<img src=\"https://ethresear.ch/uploads/default/original/3X/5/a/5acb3eda53b7f342972637ae3d881d9e7cb44983.gif\" alt=\"attestations_seen_late_by_proposer_misses\" data-base62-sha1=\"cXcqhiQr0Nq9qOt287CRN2Nanon\" width=\"690\" height=\"383\" class=\"animated\"></p>\n<p>Interestingly, Kiln develops a ‚ÄúU‚Äù-shape distribution ranging from <span class=\"math\">3.8 \\Rightarrow\n 6.1</span> for their own late blocks, Lido a peak at 4.2s, and Coinbase a plateau starting at second 4 with a small peak at second 6 in the slot.</p>\n<h2><a name=\"p-49615-prevent-reorgs-of-my-own-proposed-blocks-3\" class=\"anchor\" href=\"https://ethresear.ch#p-49615-prevent-reorgs-of-my-own-proposed-blocks-3\"></a>‚ÄúPrevent reorgs of my own proposed blocks‚Äù</h2>\n<p>Let‚Äôs shift our focus to reorged blocks. One strategy from the perspective of a node operator might be to <strong>never</strong> vote for reorging out one‚Äôs own block. Simply speaking, ‚Äú<em>never vote for the parent block as the head if the proposer is me</em>‚Äù.</p>\n<p>Instead of calling it <em>an entity‚Äôs own block</em>, I will use <em>local block</em> in the following.</p>\n<p>The following chart shows the percentage of attesters voting for the reorged block vs voting for the parent block. The red part displays the % of all attesters from that entity that voted for a reorged block built by that entity.<br>\n</p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/f/5/f580dddb61ad6a3e4f577516f312475182d980d7.png\" data-download-href=\"https://ethresear.ch/uploads/default/f580dddb61ad6a3e4f577516f312475182d980d7\" title=\"votes_for_local_reorged_block\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/f/5/f580dddb61ad6a3e4f577516f312475182d980d7_2_690x316.png\" alt=\"votes_for_local_reorged_block\" data-base62-sha1=\"z1P4H8Fvgb5jMRwigHosZfOjwuH\" width=\"690\" height=\"316\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/f/5/f580dddb61ad6a3e4f577516f312475182d980d7_2_690x316.png, https://ethresear.ch/uploads/default/optimized/3X/f/5/f580dddb61ad6a3e4f577516f312475182d980d7_2_1035x474.png 1.5x, https://ethresear.ch/uploads/default/original/3X/f/5/f580dddb61ad6a3e4f577516f312475182d980d7.png 2x\" data-dominant-color=\"A7C3DD\"></a></div><p></p>\n<p>Kiln shows outlier behavior. While most node operators‚Äô attesters correctly vote for the parent block rather than the local block, Kiln‚Äôs attesters appear to disregard this norm. <strong>Over 10% of Kiln attesters attempt to keep the local block on-chain by voting for it.</strong> If such strategies are adopted, they might justify the losses from incorrect head votes if they prevent the local block from being reorged. However, these tactics are generally frowned upon within the Ethereum community: ‚Äú<em>don‚Äôt play with consensus</em>‚Äù.</p>\n<blockquote>\n<p>The chart uses 365 days of data. Thus, if some sophisticated strategy was implemented during the last year, the red portion would be proportionately smaller.</p>\n</blockquote>\n<h2><a name=\"p-49615-but-how-do-we-feel-about-any-additional-level-of-coordination-4\" class=\"anchor\" href=\"https://ethresear.ch#p-49615-but-how-do-we-feel-about-any-additional-level-of-coordination-4\"></a>But how do we feel about any additional level of coordination?</h2>\n<p>Regarding coordinated attesting, we, as community, seem to accept that validators run on the same node vote for the same checkpoints.</p>\n<p>We probably don‚Äôt want any additional efforts that cross the boundaries of physical machines to improve coordination across validators. It‚Äôs something that everyone can build that goes beyond <a href=\"https://github.com/ethereum/consensus-specs/blob/b2f2102dad0cd8b28a657244e645e0df1c0d246a/specs/phase0/validator.md#attesting\">what the specs describe</a>. Such coordination could have different forms:</p>\n<ul>\n<li><strong>Level 1 - Fall-backs &amp; Static Peering</strong>: Have a central fall-back/back-up node for multiple physical machines. This can also be a circuit breaker, some particularly fault-tolerant machine acting as a private relayer for information. Setups with improved peering, private mesh networks, or similar might also fall into this category.</li>\n<li><strong>Level 2 - If-else rules</strong>: Have hard-coded rules waiting longer in certain slots. Those would be installed on multiple physical machines, allowing them to ‚Äúcoordinate‚Äù based on predefined rules.</li>\n<li><strong>Level 3 - Botnet</strong>: Have a centralized oracle that communicates with all validators and delivers the checkpoints to vote for and the timestamp when they should be published.</li>\n</ul>\n<p>In my opinion, crossing the line into the latter form of coordination (<em>level 2 and 3</em>) is problematic, and node operators should be held accountable. Finally, there may be a <strong>gray area</strong> for strategies involving <strong>static peering</strong> and <strong>private mesh networks</strong>.</p>\n<p><strong>Such setups could be used to run (malicious) strategies such as:</strong></p>\n<ul>\n<li>ensuring to never vote for different checkpoints across multiple physical machines.</li>\n<li>ensuring to never vote for reorging out a block from one‚Äôs own proposer.</li>\n<li>coordinating based on the consecutive proposer (<a href=\"https://github.com/ethereum/consensus-specs/pull/3034\">honest reorg client</a> (y/n)).</li>\n<li>censoring attestations of a certain party.</li>\n<li>not voting for the blocks of a certain party.</li>\n<li>etc.</li>\n</ul>\n<p><strong>When discussing <em>coordination</em>, it‚Äôs important to distinguish between two types:</strong></p>\n<ol>\n<li>Coordinated behavior that occurs when validators are <strong>run from the same physical machine</strong>.</li>\n<li>Coordinated behavior that arises from running the same <strong>modified client software</strong> or relying on the same <strong>centralized oracle</strong>.</li>\n</ol>\n<p>A potential solution to counter sophisticated coordinated validator behavior is <a href=\"https://ethereum-magicians.org/t/eip-7716-anti-correlation-attestation-penalties/20137\">EIP-7716: Anti-Correlation Penalties\"</a>, which proposes to scale penalties with the correlation among validators.</p>\n<p><em><strong>Find the code for this analysis <a href=\"https://github.com/nerolation/timing-games-and-economies-of-scale\">here</a>.</strong></em></p>\n<h1><a name=\"p-49615-more-on-that-topics-5\" class=\"anchor\" href=\"https://ethresear.ch#p-49615-more-on-that-topics-5\"></a>More on that topics</h1>\n<div class=\"md-table\">\n<table>\n<thead>\n<tr>\n<th>Title</th>\n<th>Author</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://timing.pics\">Timing.pics</a></td>\n<td>DotPics Website</td>\n</tr>\n<tr>\n<td><a href=\"https://ethresear.ch/t/timing-games-implications-and-possible-mitigations/17612\">Timing Games: Implications and Possible Mitigations</a></td>\n<td>Caspar &amp; Mike</td>\n</tr>\n<tr>\n<td><a href=\"https://ethresear.ch/t/deep-diving-attestations-a-quantitative-analysis/20020\">Deep Diving Attestations - A quantitative analysis</a></td>\n<td>Toni</td>\n</tr>\n<tr>\n<td><a href=\"https://www.paradigm.xyz/2023/04/mev-boost-ethereum-consensus\">Time, slots, and the ordering of events in Ethereum Proof-of-Stake</a></td>\n<td>Georgios &amp; Mike</td>\n</tr>\n<tr>\n<td><a href=\"https://arxiv.org/abs/2305.09032\">Time is Money: Strategic Timing Games in Proof-of-Stake Protocols</a></td>\n<td>Caspar et al.</td>\n</tr>\n<tr>\n<td><a href=\"https://eprint.iacr.org/2023/760\">Time to Bribe: Measuring Block Construction Market</a></td>\n<td>Toni et al.</td>\n</tr>\n<tr>\n<td><a href=\"https://ethresear.ch/t/the-cost-of-artificial-latency-in-the-pbs-context/17847\">The cost of artificial latency in the PBS context</a></td>\n<td>Chorus One</td>\n</tr>\n<tr>\n<td><a href=\"https://ethresear.ch/t/empirical-analysis-of-the-impact-of-block-delays-on-the-consensus-layer/17888\">Empirical analysis of the impact of block delays on the consensus layer</a></td>\n<td>Kiln</td>\n</tr>\n<tr>\n<td><a href=\"https://youtu.be/J_N13erDWKw?t=1061\">P2P Presentation on Timing Games (Youtube)</a></td>\n<td>P2P_org</td>\n</tr>\n<tr>\n<td><a href=\"https://www.youtube.com/watch?v=gsFU-inKRQ8\">Time is Money (Youtube)</a></td>\n<td>Caspar</td>\n</tr>\n</tbody>\n</table>\n</div>\n            <p><small>6 posts - 3 participants</small></p>\n            <p><a href=\"https://ethresear.ch/t/on-attestations-block-propagation-and-timing-games/20272\">Read full topic</a></p>","link":"https://ethresear.ch/t/on-attestations-block-propagation-and-timing-games/20272","pubDate":"Wed, 14 Aug 2024 13:04:48 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20272"},"source":{"@url":"https://ethresear.ch/t/on-attestations-block-propagation-and-timing-games/20272.rss","#text":"On Attestations, Block Propagation, and Timing Games"}},{"title":"A Node-Based Solution to Execution Sharding: The KRNL Protocol","dc:creator":"tahir-krnl","category":"Sharded Execution","description":"<p>By <a href=\"https://x.com/asim_eth\" rel=\"noopener nofollow ugc\">Asim Ahmad</a> and <a href=\"https://x.com/Tahir_Mahmood\" rel=\"noopener nofollow ugc\">Tahir Mahmood</a> on behalf of <a href=\"https://krnl.xyz\" rel=\"noopener nofollow ugc\">KRNL</a>.</p>\n<p><strong>1. Abstract</strong></p>\n<p>The evolution of the Web3 ecosystem confronts pivotal challenges such as network fragmentation, scalability constraints, cross-chain integration complexities, and security vulnerabilities. To address these issues, we introduce the KRNL Protocol‚Äîan orchestration and verification engine that seamlessly integrates permissionless and composable functions across multiple blockchain networks within the Ethereum transaction lifecycle. By transforming both on-chain and off-chain functions into execution shards called ‚Äúkernels,‚Äù KRNL offers a distributed runtime environment that optimizes resource utilization, enhances modularity, and accelerates deployment. This approach not only improves the responsiveness of decentralized applications (dApps) but also reduces their time-to-market. Our proposal positions KRNL as part of the fabric of the Web3 framework.</p>\n<p><strong>2. Motivation</strong></p>\n<p>The Web3 ecosystem faces several significant challenges, including fragmentation, scalability limitations, cross-chain friction, and security concerns.</p>\n<p><strong>Fragmentation</strong>: The emergence of numerous Layer 1 and Layer 2 solutions has led to the creation of isolated silos. This fragmentation impedes seamless interaction between applications and smart contracts across different environments, undermining the foundational principle of composability in decentralized systems.</p>\n<p><strong>Scalability Constraints</strong>: Ethereum grapples with network congestion and high gas fees. These scalability issues deter the widespread adoption of dApps and erode user experience.</p>\n<p><strong>Cross-Chain Friction</strong>: Facilitating interoperability between Ethereum and other blockchains often demands intricate integrations. The absence of standardized cross-chain communication protocols exacerbates development complexities, stifling innovation and efficiency.</p>\n<p><strong>Security Vulnerabilities</strong>: Ensuring transaction integrity, provenance, and security in a decentralized manner remains a challenge. The proliferation of bridges and interoperability solutions introduces novel attack vectors, heightening security risks.</p>\n<p>To address these challenges, we reimagine the execution paradigm by introducing the concept of kernels - community-built, permissionless, monetizable, and composable execution shards across Web3. We also introduce the KRNL protocol, an orchestration and verification engine that enables smart contracts to integrate execution shards, enriching the logic and state of traditional smart contract operations without the creation of custom infrastructure. With this proposal, we aim to become an essential tool for the development of cross-chain applications.</p>\n<p><strong>3. TL;DR</strong></p>\n<p>Execution Sharding refers to the approach of dividing and distributing the execution of smart contracts across multiple blockchain networks, or ‚Äúshards‚Äù, to enhance scalability and efficiency in blockchain systems. Instead of executing every transaction on a single chain, execution sharding allows transactions and smart contract states to be distributed across multiple chains, each handling a portion of the overall workload.</p>\n<p>Execution sharding is critical for Ethereum‚Äôs scalability. The KRNL Protocol integrates permissionless and composable kernels (execution shards) across multiple networks, seamlessly into the native Ethereum transaction lifecycle.</p>\n<p>KRNL manages resources to provide a secure and optimal execution environment for smart contracts. This enables a distributed runtime environment that determines transaction outcome based on selected kernels, operating across different environments. KRNL‚Äôs open framework enhances modularity, optimizes resources, ensures stable operations, and accelerates deployment, ultimately improving responsiveness and reducing time to market for applications.</p>\n<p><strong>4. Introducing Kernels</strong></p>\n<p>Within the KRNL Protocol framework, kernels represent execution shards. These kernels transform both on-chain and off-chain functions into modular units characterized by the following attributes:</p>\n<ul>\n<li><strong>Statelessness</strong>: Kernels maintain no intrinsic state, ensuring flexibility and facilitating seamless migration across environments.</li>\n<li><strong>Lightweight Design</strong>: To minimize computational overhead, kernels promote efficient execution.</li>\n<li><strong>Resilience</strong>: Engineered to withstand operational failures, ensuring reliable performance.</li>\n<li><strong>Independent Deployability</strong>: Allowing for deployment across various environments.</li>\n</ul>\n<p>The defining features of kernels include:</p>\n<ul>\n<li><strong>Infrastructure Agnosticism</strong>: Kernels are not tethered to specific infrastructures; they possess the agility to migrate across environments as necessitated.</li>\n<li><strong>Enhanced Modularity and Composability</strong>: By deconstructing applications into discrete kernels, modularity is enhanced, enabling permissionless sharing across multiple applications.</li>\n<li><strong>Accelerated Deployment</strong>: Simplifying the deployment process improves responsiveness and reduces time-to-market for applications.</li>\n</ul>\n<p><strong>5. Vision</strong></p>\n<p><strong>The Pre-Cloud Paradigm</strong></p>\n<p>Before cloud computing, developers bore the burden of constructing, operating, and maintaining all requisite programs and services. This paradigm engendered prohibitive costs, scalability constraints, accessibility challenges, and resource limitations. Cloud computing revolutionized this landscape, introducing managed services where back-end infrastructures are handled by cloud providers.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/5/f/5fe5cbe3446592ada1eea874797faf006e20d182.png\" data-download-href=\"https://ethresear.ch/uploads/default/5fe5cbe3446592ada1eea874797faf006e20d182\" title=\"Before and After Cloud Computing\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/5/f/5fe5cbe3446592ada1eea874797faf006e20d182_2_690x315.png\" alt=\"Before and After Cloud Computing\" data-base62-sha1=\"dGlHawMkk3iJMiae9lxr2f1xP6q\" width=\"690\" height=\"315\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/5/f/5fe5cbe3446592ada1eea874797faf006e20d182_2_690x315.png, https://ethresear.ch/uploads/default/optimized/3X/5/f/5fe5cbe3446592ada1eea874797faf006e20d182_2_1035x472.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/5/f/5fe5cbe3446592ada1eea874797faf006e20d182_2_1380x630.png 2x\" data-dominant-color=\"8791DD\"></a></div><p></p>\n<p><strong>KRNL‚Äôs Transformative Potential</strong></p>\n<p>KRNL seeks to catalyze a comparable paradigm shift within the Web3 domain‚Äîa permissionless Web3 cloud environment built by the community through contributions of monetizable kernels. This vision aligns with the Function as a Service (FaaS) model, reimagined to suit the decentralized and heterogeneous fabric of blockchain ecosystems.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/0/3/03a9e2f49a0d71e30f39b7ce9368173d25a7b5a6.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/03a9e2f49a0d71e30f39b7ce9368173d25a7b5a6\" title=\"Before and After KRNL\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/0/3/03a9e2f49a0d71e30f39b7ce9368173d25a7b5a6_2_690x301.jpeg\" alt=\"Before and After KRNL\" data-base62-sha1=\"wppAfeD9zl6FmqCPbHVRu57ihE\" width=\"690\" height=\"301\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/0/3/03a9e2f49a0d71e30f39b7ce9368173d25a7b5a6_2_690x301.jpeg, https://ethresear.ch/uploads/default/optimized/3X/0/3/03a9e2f49a0d71e30f39b7ce9368173d25a7b5a6_2_1035x451.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/0/3/03a9e2f49a0d71e30f39b7ce9368173d25a7b5a6_2_1380x602.jpeg 2x\" data-dominant-color=\"97A0E4\"></a></div><p></p>\n<p><strong>Functions as a Service (FaaS) in the Web3 Context</strong></p>\n<p>FaaS is a category of cloud computing services that provide a platform enabling customers to develop, run and manage applications without the complexity of building and maintaining the infrastructure associated with developing and launching an app. Examples of a traditional FaaS include AWS Lambda, Google Cloud Functions, Microsoft Azure Functions, etc.</p>\n<p>The conventional FaaS model does not fit well in distributed and heterogeneous blockchain environments, where each blockchain is a silo and not efficient in the context of the whole Web3 ecosystem. To adapt this concept to Web3, it is essential to ensure decentralized registry, management, and execution of kernels.</p>\n<p><strong>6. Core Concepts</strong></p>\n<p><strong>The Computing Engine</strong></p>\n<p>KRNL enhances an Ethereum Remote Procedure Call (RPC) node with a verification and orchestration-enabled computing engine. This engine abstracts the intricacies associated with integrating smart contract interdependencies.</p>\n<p>The computing engine creates an application and technology agnostic framework that offers a runtime environment to user applications in a distributed manner. It sits between a transaction initiated on any chain and its propagation into a block, determining a transaction‚Äôs outcome based on the kernels selected. This approach allows for flexible, efficient scaling and optimization of distributed applications.</p>\n<p><strong>Proof of Provenance (PoP)</strong></p>\n<p>PoP validates that prescribed kernels have run successfully before a transaction is executed, ensuring reliability and security of the KRNL Protocol.</p>\n<p>The KRNL Protocol achieves this by utilizing various schemes including a decentralized token authority that issues a signature token, ERC-1271, cryptography and proof systems. The implementation requires the application developer to implement a Software Development Kit (SDK) as well as the token authority. PoP works with existing standards within the Ethereum ecosystem, combining multiple schemes to ensure an anti-fragile system.</p>\n<p><strong>Decentralized Registry</strong></p>\n<p>An Ethereum based registry for activating and monetizing community built kernels. This registry serves as the definitive repository, maintaining critical information about registered kernels, including their pathways, monetization schemes, and other customizable parameters. Core to the design of KRNL is the concept of a two-sided marketplace where kernels are built and monetized, while being utilized by applications across Web3.</p>\n<p><strong>7. Architecture</strong></p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/d/2/d2b12fc5edd69ae351e74dda8a31b3f6e57a5311.png\" data-download-href=\"https://ethresear.ch/uploads/default/d2b12fc5edd69ae351e74dda8a31b3f6e57a5311\" title=\"Architecture Overview of the KRNL Protocol\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/d/2/d2b12fc5edd69ae351e74dda8a31b3f6e57a5311_2_690x388.png\" alt=\"Architecture Overview of the KRNL Protocol\" data-base62-sha1=\"u3RT8Iirh25DrxmRYUa9aPYd8Jj\" width=\"690\" height=\"388\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/d/2/d2b12fc5edd69ae351e74dda8a31b3f6e57a5311_2_690x388.png, https://ethresear.ch/uploads/default/optimized/3X/d/2/d2b12fc5edd69ae351e74dda8a31b3f6e57a5311_2_1035x582.png 1.5x, https://ethresear.ch/uploads/default/original/3X/d/2/d2b12fc5edd69ae351e74dda8a31b3f6e57a5311.png 2x\" data-dominant-color=\"E5F1ED\"></a></div><p></p>\n<p><strong>Use Case Scenario</strong></p>\n<p>In a hypothetical scenario, a DeFi protocol on Ethereum would like to allow users to trade RWA assets if they are an approved user on Company 1‚Äôs RWA platform (and if not, to reject the transaction from this wallet). Say Company 1 has built an RWA platform on Blockchain 2, with dynamic off-chain metadata corresponding to approved users. Additionally, these users need to have an identity score of X as determined by a on-chain DID smart contract on Blockchain 3. In the past, implementing these solutions across various chains would have required multiple complex integrations and in many cases require direct communication with vendors. However, with KRNL, builders now only need to perform a single, one-time permissionless integration.</p>\n<p>There is not currently any application layer that facilitates the conditional logic before state changes are executed, and this is generally built ground-up by builders. Ideally, this would be done in a plug-and-play, permissionless manner that would be reproducible by protocols that want to utilize the RWA platform and identifiers from the DID system.<br>\n</p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/8/6/869c6dc2fe0c134bfb17f32f1b481fadcd6e2704.png\" data-download-href=\"https://ethresear.ch/uploads/default/869c6dc2fe0c134bfb17f32f1b481fadcd6e2704\" title=\"Limitations of Existing Solutions\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/8/6/869c6dc2fe0c134bfb17f32f1b481fadcd6e2704_2_690x323.png\" alt=\"Limitations of Existing Solutions\" data-base62-sha1=\"jcP7Wr7VRTXtKvM9oX2dZTNgfCA\" width=\"690\" height=\"323\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/8/6/869c6dc2fe0c134bfb17f32f1b481fadcd6e2704_2_690x323.png, https://ethresear.ch/uploads/default/optimized/3X/8/6/869c6dc2fe0c134bfb17f32f1b481fadcd6e2704_2_1035x484.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/8/6/869c6dc2fe0c134bfb17f32f1b481fadcd6e2704_2_1380x646.png 2x\" data-dominant-color=\"F6F6F7\"></a></div><p></p>\n<p><strong>8. Decentralization and Security Considerations</strong></p>\n<p><strong>Upholding Decentralization</strong></p>\n<p>KRNL leverages the intrinsic decentralization of existing native blockchains. By integrating with a standard Ethereum RPC node, any Ethereum RPC node can function as a KRNL node without interfering with consensus mechanisms of the underlying network. Node operators are incentivized through the accrual of a proportion of fees generated from kernels, fostering a decentralized and participatory ecosystem.</p>\n<p><strong>Mitigating Malicious Activities</strong></p>\n<p>To preempt and mitigate potential malicious activities, such as replicating KRNL node code to fabricate counterfeit signatures, KRNL employs multiple cryptographic schemes that ensure security by design. The security architecture is flexible, customizable, and predominantly under the control of the dApp developer. This approach ensures that the KRNL Protocol remains permissionless, resilient, and secure.</p>\n<p><strong>Explore more in our <a href=\"https://github.com/KRNL-Labs/krnl-node-sandbox-public\" rel=\"noopener nofollow ugc\">KRNL Developer Sandbox</a></strong></p>\n<p><strong>Learn more about <a href=\"https://docs.krnl.xyz/\" rel=\"noopener nofollow ugc\">KRNL</a></strong></p>\n<p><strong>Supporting Research Papers</strong></p>\n<p><a href=\"https://arxiv.org/html/2404.08151v1\" rel=\"noopener nofollow ugc\">Decentralized FaaS over Multi-Clouds with Blockchain based Management for Supporting Emerging Applications</a></p>\n<p>DeFaaS is a novel decentralized Function-as-a-Service (FaaS) system proposed to address the limitations of centralized FaaS solutions. This system leverages blockchain technology and decentralized API management to create a distributed FaaS platform that offers improved scalability, flexibility, security, and reliability. DeFaaS is designed to support various distributed computing scenarios beyond FaaS, including decentralized applications (dApps), volunteer computing, and multi-cloud service mesh. The proposed system aims to mitigate issues associated with centralized FaaS, such as vendor lock-in and single points of failure.</p>\n<p><a href=\"https://www.sciencedirect.com/science/article/pii/S0306457321000340?ref=pdf_download&amp;fr=RR-2&amp;rr=89e00464f80d773d\" rel=\"noopener nofollow ugc\">Multi-Service Model for Blockchain Networks</a></p>\n<p>Multi-service networks aim to efficiently supply distinct goods within the same infrastructure by relying on a (typically centralized) authority to manage and coordinate their differential delivery at specific prices. In turn, final customers constantly seek to lower costs whilst maximizing quality and reliability. This paper proposes a decentralized business model for multi-service networks using Ethereum blockchain features ‚Äì gas, transactions, and smart contracts ‚Äì to execute multiple services at different prices. By employing Ether, to quantify the quality of service and reliability of distinct private Ethereum networks, their model concurrently processes streams of services at different gas prices while differentially delivering reliability and service quality.</p>\n<p><a href=\"https://www.researchgate.net/publication/372662346_Orchestrating_Digital_Wallets_for_On-_and_Off-chain_Decentralized_Identity_Management\" rel=\"noopener nofollow ugc\">Qualified Digital Certificates within Blockchain Networks</a></p>\n<p>This paper examines decentralized digital identities, which use asymmetric cryptography without centralized oversight, focusing on both on-chain (blockchain) and off-chain (self-sovereign) types. Currently, no single wallet manages both types of decentralized identities. To address this, the paper proposes an orchestration solution for a universal wallet that combines both types and validates it using a real-life use case.</p>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://ethresear.ch/t/a-node-based-solution-to-execution-sharding-the-krnl-protocol/20268\">Read full topic</a></p>","link":"https://ethresear.ch/t/a-node-based-solution-to-execution-sharding-the-krnl-protocol/20268","pubDate":"Wed, 14 Aug 2024 11:56:25 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20268"},"source":{"@url":"https://ethresear.ch/t/a-node-based-solution-to-execution-sharding-the-krnl-protocol/20268.rss","#text":"A Node-Based Solution to Execution Sharding: The KRNL Protocol"}},{"title":"DoS on block proposers in PoS and block builders in PBS","dc:creator":"ivan-homoliak","category":"Block proposer","description":"<ol>\n<li>\n<p>In Ethereum 2.0 PoS, the block proposer of the next block is known a certain time (~12s) before she creates the block. It might create an opportunity for attackers to DoS the next proposer who will therefore not create the new block and lose the reward. This might be systematically repeated again. We know that something similar was of concern for Algorand PoS and its VRF-based leader election that avoided this kind of attack.</p>\n</li>\n<li>\n<p>In PBS, the builder reveals the sealed block bid (commitment), and then later reveals the block contents. If the contents are not revealed, the builder will be penalized. So, the attacker already knowing the network address of victim can DoS her and cause severe penalties for not revealing the block on time. This might be systematically repeated again.</p>\n</li>\n</ol>\n<p>My question or point to discuss is how Ethereum protects against this kind of attack?</p>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://ethresear.ch/t/dos-on-block-proposers-in-pos-and-block-builders-in-pbs/20262\">Read full topic</a></p>","link":"https://ethresear.ch/t/dos-on-block-proposers-in-pos-and-block-builders-in-pbs/20262","pubDate":"Tue, 13 Aug 2024 10:28:43 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20262"},"source":{"@url":"https://ethresear.ch/t/dos-on-block-proposers-in-pos-and-block-builders-in-pbs/20262.rss","#text":"DoS on block proposers in PoS and block builders in PBS"}},{"title":"A trustless on-chain anti-MEV solution for Layer2/3","dc:creator":"Lawliet-Chan","category":"Layer 2","description":"<p>We have a solution to resolve the Layer2 MEV onchain trustlessly.<br>\nHere is the arch:<br>\n</p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/a/e/aeec6e16bbf3b6864d66ae84ecf5b663f9c55ce5.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/aeec6e16bbf3b6864d66ae84ecf5b663f9c55ce5\" title=\"image\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/a/e/aeec6e16bbf3b6864d66ae84ecf5b663f9c55ce5_2_336x500.jpeg\" alt=\"image\" data-base62-sha1=\"oXrCZnu1z4Kc3Q9BtlzOm5buc8B\" width=\"336\" height=\"500\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/a/e/aeec6e16bbf3b6864d66ae84ecf5b663f9c55ce5_2_336x500.jpeg, https://ethresear.ch/uploads/default/optimized/3X/a/e/aeec6e16bbf3b6864d66ae84ecf5b663f9c55ce5_2_504x750.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/a/e/aeec6e16bbf3b6864d66ae84ecf5b663f9c55ce5_2_672x1000.jpeg 2x\" data-dominant-color=\"FBFBFB\"></a></div><p></p>\n<ol>\n<li>Users only send their txHash to the L2 chain with some advance charge (to prevent DOS attack)</li>\n<li>The chain accepts these txHashes, sort them based on the amount of tips, and then make a Tx-Order-commitment and broadcast it to the other chain nodes.  Also, user can subscribe this commitment.</li>\n<li>When users see the order-commitments, they will send their tx-content to the L2 chain and the DA-layers.</li>\n<li>Chain accepts the tx-content from users, and also fetch txs from DA-layers ,  pack them according to the previously promised order. If the tx-content does not match the previously tx-hash, chain will put them behind the txs which made order-commitment.<br>\n<strong>All promised txs will be sorted before the unpromised txs.</strong><br>\nNOTICE: In this way, the chain may deduct tx-content and pretend not to receive it.  To prevent this situation. We have to:<br>\ni. Decentralise chain node.<br>\nii. Use DA to complete the txs if one node does not accept the txs.</li>\n</ol>\n<p>In this case, we call it MEVless protocol,   it means you don‚Äôt have to trust any group and institution.  You do not have to depend on a privacy node, not through MEVA, to protect your transactions from MEV attack.  Because all the attackers(besides miners themselves) cannot see your tx-content when it orders.   Once the tx-content is packed and executed, it must be packed by the previously commitment, attackers cannot front-run and sandwich attack you.</p>\n<p>We have developed some of it and you can see the running effect:</p><aside class=\"onebox githubfolder\" data-onebox-src=\"https://github.com/yu-org/nine-tripods/tree/main/MEVless\">\n  <header class=\"source\">\n      <img src=\"https://ethresear.ch/uploads/default/original/2X/b/bad3e5f9ad67c1ddf145107ce7032ac1d7b22563.svg\" class=\"site-icon\" data-dominant-color=\"\" width=\"32\" height=\"32\">\n\n      <a href=\"https://github.com/yu-org/nine-tripods/tree/main/MEVless\" target=\"_blank\" rel=\"noopener nofollow ugc\">github.com</a>\n  </header>\n\n  <article class=\"onebox-body\">\n    <h3><a href=\"https://github.com/yu-org/nine-tripods/tree/main/MEVless\" target=\"_blank\" rel=\"noopener nofollow ugc\">nine-tripods/MEVless at main ¬∑ yu-org/nine-tripods</a></h3>\n\n\n  <p><span class=\"label1\">Contribute to yu-org/nine-tripods development by creating an account on GitHub.</span></p>\n\n  </article>\n\n  <div class=\"onebox-metadata\">\n    \n    \n  </div>\n\n  <div style=\"clear: both\"></div>\n</aside>\n<aside class=\"onebox githubfolder\" data-onebox-src=\"https://github.com/VersechainLabs/versechain/tree/mevless\">\n  <header class=\"source\">\n      <img src=\"https://ethresear.ch/uploads/default/original/2X/b/bad3e5f9ad67c1ddf145107ce7032ac1d7b22563.svg\" class=\"site-icon\" data-dominant-color=\"\" width=\"32\" height=\"32\">\n\n      <a href=\"https://github.com/VersechainLabs/versechain/tree/mevless\" target=\"_blank\" rel=\"noopener nofollow ugc\">github.com</a>\n  </header>\n\n  <article class=\"onebox-body\">\n    <h3><a href=\"https://github.com/VersechainLabs/versechain/tree/mevless\" target=\"_blank\" rel=\"noopener nofollow ugc\">GitHub - VersechainLabs/versechain at mevless</a></h3>\n\n  <p><a href=\"https://github.com/VersechainLabs/versechain/tree/mevless\" target=\"_blank\" rel=\"noopener nofollow ugc\">mevless</a></p>\n\n  <p><span class=\"label1\">A high performance decentralized modular sequencer for Starknet</span></p>\n\n  </article>\n\n  <div class=\"onebox-metadata\">\n    \n    \n  </div>\n\n  <div style=\"clear: both\"></div>\n</aside>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/b/f/bfa58e407bea18228ba10bbc90f904aca2c776aa.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/bfa58e407bea18228ba10bbc90f904aca2c776aa\" title=\"image\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/b/f/bfa58e407bea18228ba10bbc90f904aca2c776aa_2_607x500.jpeg\" alt=\"image\" data-base62-sha1=\"rlnTGRarj8uDU4goSBfHnKuxlx0\" width=\"607\" height=\"500\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/b/f/bfa58e407bea18228ba10bbc90f904aca2c776aa_2_607x500.jpeg, https://ethresear.ch/uploads/default/optimized/3X/b/f/bfa58e407bea18228ba10bbc90f904aca2c776aa_2_910x750.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/b/f/bfa58e407bea18228ba10bbc90f904aca2c776aa_2_1214x1000.jpeg 2x\" data-dominant-color=\"071307\"></a></div><p></p>\n<p>You can see the txHash order-commitment in the above red box and you can try MEV-attacking these txs when they are completed by tx-contents later, then you will find you cannot insert your tx into their order at all.</p>\n            <p><small>8 posts - 4 participants</small></p>\n            <p><a href=\"https://ethresear.ch/t/a-trustless-on-chain-anti-mev-solution-for-layer2-3/20260\">Read full topic</a></p>","link":"https://ethresear.ch/t/a-trustless-on-chain-anti-mev-solution-for-layer2-3/20260","pubDate":"Tue, 13 Aug 2024 04:02:59 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20260"},"source":{"@url":"https://ethresear.ch/t/a-trustless-on-chain-anti-mev-solution-for-layer2-3/20260.rss","#text":"A trustless on-chain anti-MEV solution for Layer2/3"}},{"title":"Proof of Service Integrity (PoSI): Trustless measurement of service integrity","dc:creator":"peshwar9","category":"Security","description":"<h1><a name=\"p-49574-proof-of-service-integrity-posi-trustless-measurement-of-service-integrity-1\" class=\"anchor\" href=\"https://ethresear.ch#p-49574-proof-of-service-integrity-posi-trustless-measurement-of-service-integrity-1\"></a>Proof of Service integrity (PoSI) : Trustless measurement of service integrity</h1>\n<h2><a name=\"p-49574-tldr-2\" class=\"anchor\" href=\"https://ethresear.ch#p-49574-tldr-2\"></a>TL;Dr</h2>\n<p><strong>Proof of Service Integrity (PoSI)</strong> is a byzantine fault tolerant verification protocol for offchain activities.</p>\n<p>It performs three main tasks in a decentralised fashion - <em>deployment</em> of approved service images, <em>measurements</em> of deployed services, and <em>attestation</em> of the integrity of these services in production.</p>\n<p>The problem PoSI solves is that offchain services are growing in volume, size and complexity in modern chain architectures, but they are largely centralised and run in trusted environments while handling millions of dollars of transaction flows. This is incompatible with the goals of crypto systems. Permissionless verification of offchain services using PoSI protocol provides a real-time integrated security view for emerging hybrid crypto protocols that have a mix of on-chain and off-chain activities.</p>\n<p>Offchain services that are verified by PoSI protocol are called <strong>Integrity Verified services</strong> (IVS).</p>\n<h2><a name=\"p-49574-preface-3\" class=\"anchor\" href=\"https://ethresear.ch#p-49574-preface-3\"></a>Preface</h2>\n<p>This post builds on the earlier proposal on integrity proofs (<a href=\"https://ethresear.ch/t/integrity-proofs-to-improve-rollup-security/19437\" class=\"inline-onebox\">Integrity proofs to improve rollup security</a>) with the following main differences:</p>\n<ol>\n<li>Focus on measuring integrity of any off-chain service, rather than just rollup services</li>\n<li>Earlier design was TEE-based, current protocol is primarily BFT-based but uses TEEs as a <em>defense-in-depth</em> mechanism.</li>\n<li>Changes to the architecture</li>\n</ol>\n<h2><a name=\"p-49574-prelude-4\" class=\"anchor\" href=\"https://ethresear.ch#p-49574-prelude-4\"></a>Prelude</h2>\n<p>Traditional distributed systems monitoring/observability involves collecting and analyzing data in order to gain insights into the functioning, performance, security and health of software systems and applications. It involves systematically observing and tracking various metrics, events, logs and distributed traces to construct a visual representation of a system‚Äôs hardware and software performance and health. While there are multiple types of distributed systems monitoring data, one  dimension in particular that is not measured in traditional web2 distributed systems is service integrity.</p>\n<p>For this post, let‚Äôs define <em>service integrity</em> as the following:</p>\n<ol>\n<li>The correct (authorised and verified) software version has been deployed</li>\n<li>No unauthorised changes have been made to the deployed software in production.</li>\n<li>Anyone can permissionlessly verify proof of <span class=\"hashtag-raw\">#1</span> and <span class=\"hashtag-raw\">#2</span> for any given service either through data provided over a user interface or API, or through verification of a zero-knowledge proof.</li>\n</ol>\n<p>In internet/online systems (web2), <em>services integrity</em> (particularly <span class=\"hashtag-raw\">#1</span> and <span class=\"hashtag-raw\">#2</span>) is the responsibility of the organisation or entity that centrally owns and manages the distributed service, <em>aka trusted deployments</em>. As a consequence, <span class=\"hashtag-raw\">#3</span> is simply not possible.</p>\n<p>When we talk about web3 systems, <em>service integrity</em> becomes paramount. Services are deployed in <em>untrusted environments</em> managed by operators that we do not know or have legal contracts with.</p>\n<p>The way this problem has been solved in blockchain-based systems (Proof-of-stake in particular) is through a carefully designed set of incentives to encourage external operators to run the distributed software with desired behaviours, coupled with a clever mechanism for the distributed network to reach a consensus such that if an operator that is part of the consensus set is detected to perform any malicious action, they can be financially penalised (through onchain mechanisms or social governance).</p>\n<p>This worked reasonably in the early days of evolution of onchain systems where all the logic for onchain protocols were on smart contracts on a single chain, which was invoked from offchain clients. Censorship resistance was largely handled by allowing anyone to run the Json-RPC nodes (which are the user transaction entry points) that communicate with the other distributed network nodes over P2P protocols. This ensured eventual censorship-resistance.</p>\n<h2><a name=\"p-49574-evolution-of-crypto-protocol-architectures-5\" class=\"anchor\" href=\"https://ethresear.ch#p-49574-evolution-of-crypto-protocol-architectures-5\"></a>Evolution of crypto protocol architectures</h2>\n<p>Recent developments in blockchain systems have seen an explosion in the number of layer-1 and layer-2 chains, and the rise of modular architectures with innovations in application protocols, core infrastructure, scaling and interop solutions, developer &amp; user tools. These innovations are aimed at solving problems with scaling throughput, reducing latency, lowering transaction costs, offering greater sovereignty to builders over design choices, solving for both synchronous and async interoperability, unifying liquidity, mev optimisation, and improving user experience in crypto.</p>\n<p>These developments have resulted in increased complexity and sophistication of onchain protocols involving a mix of smart-contract logic and offchain logic. Emerging use cases such as cross-chain swaps involve a mix of smart contract and offchain logic on both the source and destination chains.</p>\n<p>Let‚Äôs look at a few of the hybrid onchain-offchain architectures in popular crypto protocols.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/4/9/491a30b1c361107e65615618ea2b29c226245e4d.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/491a30b1c361107e65615618ea2b29c226245e4d\" title=\"Fig 1: Hybrid onchain-offchain design in crypto protocols\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/4/9/491a30b1c361107e65615618ea2b29c226245e4d_2_690x474.jpeg\" alt=\"Fig 1: Hybrid onchain-offchain design in crypto protocols\" data-base62-sha1=\"aqGXZvy6h9CXGrhmEhpaFsnhhGR\" width=\"690\" height=\"474\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/4/9/491a30b1c361107e65615618ea2b29c226245e4d_2_690x474.jpeg, https://ethresear.ch/uploads/default/optimized/3X/4/9/491a30b1c361107e65615618ea2b29c226245e4d_2_1035x711.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/4/9/491a30b1c361107e65615618ea2b29c226245e4d_2_1380x948.jpeg 2x\" data-dominant-color=\"F1EFEF\"></a></div><p></p>\n<p>Fig A shows onchain logic on a single chain encoded as smart contracts. The onchain logic is accessed from a regular web or mobile client application through RPC calls.</p>\n<p>Fig B shows an example of crypto protocol containing a mix of onchain smart contract logic on a single chain and offchain component attached to it. The offchain component typically either supplies data from an online system (eg price feeds through oracle) or performs compute-heavy operations on behalf of the smart contract (eg co-processor). The offchain component can also be a regular web backend of the dapp, if the app developer chooses to keep a portion of the business logic offchain (which is not uncommon in most modern dapps).</p>\n<p>Fig C shows an example of a cross-chain transaction that involves two chains - source and destination chain (e.g., cross-chain swaps or bridging). Here, smart contract logic is present on both the chains, and there are corresponding offchain components.</p>\n<blockquote>\n<p>The main challenge that is being addressed in this post is that a big proportion of the off-chain components that are part of these hybrid onchain-offchain crypto protocols are run in trusted environments. This is incompatible with the main goals of crypto protocols which are trustlessness, censorship resistance and permission-less participation and verifiability.</p>\n</blockquote>\n<p>While the onchain components (aka smart contracts) are secured by consensus, economic incentives and permissionless verification, the same cannot be said about offchain services whose actions cannot be attributed onchain.  These services are, in most cases, centralised,  owned and run by trusted entities, but play critical role in the overall transaction workflows. They are vulnerable to censorship, tampering and other kinds of attacks. Note that only the on-chain logic of the crypto protocols is secured by the blockchain consensus, not the supporting off-chain infrastructure and services which have varying levels of trust assumptions. In some cases, it is not even possible to detect malicious actions performed by such offchain components <em>(non-attributable faults)</em>.</p>\n<p>Figure 2 shows a non-exhaustive list of popular categories of offchain services that are an integral part of many crypto protocols.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/4/b/4b764f4c7ce39d7b0d4769c441ff37392c08d505.png\" data-download-href=\"https://ethresear.ch/uploads/default/4b764f4c7ce39d7b0d4769c441ff37392c08d505\" title=\"Fig 2: Common categories of off-chain services\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/4/b/4b764f4c7ce39d7b0d4769c441ff37392c08d505_2_690x350.png\" alt=\"Fig 2: Common categories of off-chain services\" data-base62-sha1=\"aLzhQdo4QHrT82cTTXJfkN1bRFH\" width=\"690\" height=\"350\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/4/b/4b764f4c7ce39d7b0d4769c441ff37392c08d505_2_690x350.png, https://ethresear.ch/uploads/default/optimized/3X/4/b/4b764f4c7ce39d7b0d4769c441ff37392c08d505_2_1035x525.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/4/b/4b764f4c7ce39d7b0d4769c441ff37392c08d505_2_1380x700.png 2x\" data-dominant-color=\"D4E4EB\"></a></div><p></p>\n<p>What are the types of risks to crypto protocols with such centralised offchain services?</p>\n<p><em>Insider Threats</em>: Employees or contractors within the service development team or the cloud platform provider may misuse their privileged access.<br>\n<em>Unauthorized Modifications</em>: Malicious actors might attempt to alter the service code logic or configuration without detection, leading to unintended consequences inconsistent with the protocol goals.<br>\n<em>Censorship Risks</em>: In case of offchain services, bad actors might attempt to censor certain transactions or user interactions.<br>\n<em>Data and Fund Security</em>: There‚Äôs a risk of unauthorized access to sensitive data or funds managed by the service. e.g. a dapp backend managing an embedded wallet may view/steal user wallet keys.</p>\n<h2><a name=\"p-49574-we-need-a-decentralised-verification-protocol-6\" class=\"anchor\" href=\"https://ethresear.ch#p-49574-we-need-a-decentralised-verification-protocol-6\"></a>We need a decentralised verification protocol</h2>\n<p>Hence, a critical requirement for the success of these modular hybrid onchain-offchain architectures is the ability to prove offchain service integrity at scale in a decentralised trustless manner, i.e. a <em>Byzantine fault tolerant service integrity verification system</em>.</p>\n<p>In this post, we present <em>Proof of Service Integrity</em> (<strong>PoSI</strong>), a verification protocol that performs three main tasks - <em>deployment of publicly-identifiable code images</em>, <em>measurement of the correctness  of code deployed periodically</em>, and  <em>attestation of service integrity</em> in the production environment. These correspond respectively to the properties of <em>correctness</em>, <em>integrity</em> and <em>verifiability</em> for the monitored services. Figure 3 shows the key desired properties and relationships between the PoSI nodes that are part of the verification network, and the monitored services.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/1/3/135c0d620ec8bd53705bf83f07fd11c3aff47d42.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/135c0d620ec8bd53705bf83f07fd11c3aff47d42\" title=\"Fig 3: Verification layer for off-chain services\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/1/3/135c0d620ec8bd53705bf83f07fd11c3aff47d42_2_690x163.jpeg\" alt=\"Fig 3: Verification layer for off-chain services\" data-base62-sha1=\"2Lgiaq5fePnbgbxjkz4qhuYRcqK\" width=\"690\" height=\"163\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/1/3/135c0d620ec8bd53705bf83f07fd11c3aff47d42_2_690x163.jpeg, https://ethresear.ch/uploads/default/optimized/3X/1/3/135c0d620ec8bd53705bf83f07fd11c3aff47d42_2_1035x244.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/1/3/135c0d620ec8bd53705bf83f07fd11c3aff47d42_2_1380x326.jpeg 2x\" data-dominant-color=\"EDEFF4\"></a></div><p></p>\n<p>The PoSI nodes that implement the verification protocol itself satisfy the following  properties: 1) <em>Trustless:</em> Service integrity measurements are secure against byzantine attacks by collaborations among the monitoring services and the monitored services. 2) <em>Tamper-proof</em>: The service monitoring service while verifying the tamper-resistance of the monitored services, is itself tamper-resistant  3) <em>Open</em>: The protocol allows anyone to register and provide measurement data , by using cryptographic primitives to ensure that a subset of actors cannot maliciously modify results in their favour.</p>\n<p>A formal security model allows us to establish guarantees of accurate service measurements in the presence of malicious actors. The security guarantees of the PoSI protocol are composable with the onchain state commitments on blockchain ledgers to provide a comprehensive view of protocol security which is not possible by just focusing on smart-contract &amp; consensus-based security.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/f/2/f2a8e22a3c90dfb18ded2bfa3c371ef147452247.png\" data-download-href=\"https://ethresear.ch/uploads/default/f2a8e22a3c90dfb18ded2bfa3c371ef147452247\" title=\"Fig 4: Integrated view of security of crypto protocols with PoSI\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/f/2/f2a8e22a3c90dfb18ded2bfa3c371ef147452247_2_690x201.png\" alt=\"Fig 4: Integrated view of security of crypto protocols with PoSI\" data-base62-sha1=\"yCFnuP5SKhSOn82afjyOjY7e8N9\" width=\"690\" height=\"201\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/f/2/f2a8e22a3c90dfb18ded2bfa3c371ef147452247_2_690x201.png, https://ethresear.ch/uploads/default/optimized/3X/f/2/f2a8e22a3c90dfb18ded2bfa3c371ef147452247_2_1035x301.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/f/2/f2a8e22a3c90dfb18ded2bfa3c371ef147452247_2_1380x402.png 2x\" data-dominant-color=\"E2E8E4\"></a></div><p></p>\n<h2><a name=\"p-49574-proof-of-service-integrity-posi-protocol-overview-7\" class=\"anchor\" href=\"https://ethresear.ch#p-49574-proof-of-service-integrity-posi-protocol-overview-7\"></a>Proof of Service Integrity (PoSI) protocol overview</h2>\n<p>PoSI enables verifiable service integrity through the following:</p>\n<p><em>Authenticated Deployment</em>: PoSI ensures that only authorized and verified code is deployed to the production environment. This prevents the introduction of malicious or unauthorized code during the deployment process.</p>\n<p><em>Continuous Integrity Monitoring</em>: Once deployed, PoSI nodes continuously monitor the service to detect any unauthorized modifications or tampering. Any discrepancies between the running service and its expected state are immediately detected and reported.</p>\n<p><em>Integrity Attestation</em>: Users or dApps can request integrity proofs for any PoSI-enabled service through a permissionless, public interface. Two types of integrity checks can be done on a given service - <em>measurements-based</em> and <em>proof-based</em>. <em>Measurements-based</em> checks involve deriving service integrity from the onchain measurements for the service. <em>Proof-based</em> checks can be done by requesting a SNARK proof of integrity  for the service, which can then be verified either on-chain (SNARK verification) or off-chain (in a web or mobile app).</p>\n<p>Services that are verified by PoSI protocol are called <em>Integrity-verified services</em> (IVS).</p>\n<h2><a name=\"p-49574-architecture-workflows-8\" class=\"anchor\" href=\"https://ethresear.ch#p-49574-architecture-workflows-8\"></a>Architecture workflows</h2>\n<p>PoSI protocol involves the following three workflows:</p>\n<ol>\n<li>Service developer workflow</li>\n<li>Operator workflow</li>\n<li>Verification workflow</li>\n</ol>\n<p>Figure 5 shows an overview of the key actors and actions in the protocol.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/9/2/929487f88493ab7c774f428b5bed736328ff9f72.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/929487f88493ab7c774f428b5bed736328ff9f72\" title=\"Fig 5: Overview of PoSI protocol\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/9/2/929487f88493ab7c774f428b5bed736328ff9f72_2_690x268.jpeg\" alt=\"Fig 5: Overview of PoSI protocol\" data-base62-sha1=\"kUHW6vnV2ngtBuqWAQBGqbXnfl8\" width=\"690\" height=\"268\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/9/2/929487f88493ab7c774f428b5bed736328ff9f72_2_690x268.jpeg, https://ethresear.ch/uploads/default/optimized/3X/9/2/929487f88493ab7c774f428b5bed736328ff9f72_2_1035x402.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/9/2/929487f88493ab7c774f428b5bed736328ff9f72_2_1380x536.jpeg 2x\" data-dominant-color=\"E9F0F5\"></a></div><p></p>\n<p>The architecture of PoSI involves the following components and actors:</p>\n<p><strong>1. Human/Organisational actors:</strong></p>\n<p><em>Service developer</em>: This refers to the developer and owner of the distributed software service. The service developer is the main ‚Äòcustomer‚Äô for the integrity-verified service, and is the person or entity that is ready to pay a fee to have their service integrity-verified.</p>\n<p><em>Operator:</em> This refers to the provider of the computational infrastructure. The service developer can themselves choose to be the operator by deploying the IVS on a cloud account controlled by them or they can choose to deploy their service on an external operator‚Äôs VM through a DePIN service.</p>\n<p><strong>2. PoSI Platform:</strong></p>\n<p><em>PoSI platform onchain:</em> This contains the core smart contracts of the  protocol.</p>\n<p><em>PoSI Offchain</em>: This comprises core offchain services that are part of the protocol.</p>\n<p><strong>3. Applications/ Other chains:</strong></p>\n<p><em>Application</em>:  A web or mobile application that verifies the proof for an IVS.</p>\n<p><em>Other chain:</em> Any other chain can verify the zk proofs generated by the PoSI protocol.</p>\n<h3><a name=\"p-49574-service-developer-workflow-9\" class=\"anchor\" href=\"https://ethresear.ch#p-49574-service-developer-workflow-9\"></a>Service developer workflow</h3>\n<ol>\n<li>Service developer builds the service and registers the service image in a public repository.</li>\n<li>Service developer registers the service image along with other service metadata with the PoSI onchain smart contracts. They also deposit rewards amount, along with service level expectations (e.g. frequency of measurements).</li>\n<li>Service developer can trigger the PoSI smart contract to trigger the service deployment either on their self-hosted VM, their cloud VM or on a DePIN VM.</li>\n<li>The PoSI protocol pays out the rewards to the operators based on the tasks performed by them, from the service developer‚Äôs account.</li>\n</ol>\n<h3><a name=\"p-49574-operator-workflow-10\" class=\"anchor\" href=\"https://ethresear.ch#p-49574-operator-workflow-10\"></a>Operator workflow</h3>\n<ol>\n<li>Operator registers their VM with the PoSI registration service. The operator can choose to perform two kinds of tasks - host <em>service images</em>, or host the <em>PoSI host program</em> that performs measurements on other services. For the former, any regular VM of the configuration required by service developers would be accepted. For the latter, TEE-based VMs will be required.</li>\n<li>Note that service developer can choose to deploy their service on their own VM, in which case they need to register it like other external operators. For TEE-based VMs, the quote has to be generated by the operator and submitted to the registration service along with in-enclave generated public key.</li>\n<li>Operator stakes the minimum specified tokens as part of registration. If the service developer hosts the service on their own VM, this step is not required.</li>\n<li>The PoSI registration service verifies the registered VM and registers it with the PoSI onchain contract. The PoSi registration service itself runs within a TEE enclave.</li>\n<li>When the service developer triggers deployment of a service, the PoSI host program retrieves the registered service image from public repository and deploys the service on the service developer (or external operator‚Äôs VM based on the configuration).</li>\n<li>If an operator has registered to host the PoSI protocol, the PoSI master  deploys the PoSI host program on the operator‚Äôs VM. This enables the operator to then perform service measurements on other services.</li>\n<li>Based on the specification of the service developer, the operator set is established for verifying that service, which runs the consensus mechanism to determine the final service measurements. The votes of all  operators in the operator set are aggregated and recorded onchain, along with the measurements.</li>\n<li>At periodic intervals, measurements of the performance of the verious operators are taken by the PoSI measurement service, and rewards are computed for the operators. Any incorrect measurements attributable to any of the operators in operator set is penalized through slashing of their stake, in a manner defined in the PoSI protocol.</li>\n</ol>\n<h3><a name=\"p-49574-verification-workflow-11\" class=\"anchor\" href=\"https://ethresear.ch#p-49574-verification-workflow-11\"></a>Verification workflow</h3>\n<ol>\n<li>Any web or mobile application can ask the PoSI protocol servers for attestation of any particular service. The PoSI protocol returns the proof to the web/mobile application.</li>\n<li>Two kinds of proofs can be requested from the PoSI protocol for a service: <em>state proofs</em> and <em>SNARK-proofs</em>. <em>State proofs</em> simple return the onchain state of a service computed from the measurements submitted by operators. SNARK proofs that are returned by the PoSI protocol can be verified either off-chain within the web/mobile application, or submitted to another on-chain smart contract for verification.</li>\n</ol>\n<p>An integrated view of the various workflows for the PoSI protocol is shown in figure.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/3/2/32045a0a10edcc50ab33324a649080621d79a8ac.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/32045a0a10edcc50ab33324a649080621d79a8ac\" title=\"Fig 6: Integrated view of PoSI workflows\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/3/2/32045a0a10edcc50ab33324a649080621d79a8ac_2_690x309.jpeg\" alt=\"Fig 6: Integrated view of PoSI workflows\" data-base62-sha1=\"78tcdo34Msy6Rrfp7XfBKSRiAgY\" width=\"690\" height=\"309\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/3/2/32045a0a10edcc50ab33324a649080621d79a8ac_2_690x309.jpeg, https://ethresear.ch/uploads/default/optimized/3X/3/2/32045a0a10edcc50ab33324a649080621d79a8ac_2_1035x463.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/3/2/32045a0a10edcc50ab33324a649080621d79a8ac_2_1380x618.jpeg 2x\" data-dominant-color=\"EFF3EF\"></a></div><p></p>\n<p>Note: Figure 6 shows only a single host program taking the service measurements (for reducing clutter in diagram), but it can be visualised as a set of nodes that participate and arrive at a consensus before posting the measurements on-chain.</p>\n<h2><a name=\"p-49574-conclusion-12\" class=\"anchor\" href=\"https://ethresear.ch#p-49574-conclusion-12\"></a>Conclusion</h2>\n<p>Trustfree measurement of offchain service integrity is an unsolved problem in decentralised networks. <strong>Proof of Service Integrity (PoSI)</strong> addresses this core requirement by providing a secure, byzantine resistant verification layer for offchain services while allowing open participation for operators and service developers to benefit from the protocol. All components of the protocol can be operated by community-run protocol nodes controlled by the onchain protocol smart contracts. PoSI incorporates a layered security model that includes <em>consensus-based</em>, <em>hardware-based</em> and <em>crypto-economic security</em>. PoSI requires the participating offchain services to have open source code, a publicly verifiable service image, reproducible build process and dockerized deployment.</p>\n<h2><a name=\"p-49574-faq-13\" class=\"anchor\" href=\"https://ethresear.ch#p-49574-faq-13\"></a>FAQ</h2>\n<h3><a name=\"p-49574-what-kind-of-services-can-benefit-from-the-posi-protocol-14\" class=\"anchor\" href=\"https://ethresear.ch#p-49574-what-kind-of-services-can-benefit-from-the-posi-protocol-14\"></a>What kind of services can benefit from the PoSI protocol?</h3>\n<p>Any in-protocol or out-of-protocol offchain service can benefit from PoSI protocol. A non-exhaustive list of offchain services was mentioned earlier in the post, and is reproduced here:</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/4/b/4b764f4c7ce39d7b0d4769c441ff37392c08d505.png\" data-download-href=\"https://ethresear.ch/uploads/default/4b764f4c7ce39d7b0d4769c441ff37392c08d505\" title=\"Fig 7: Popular categories of off-chain services\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/4/b/4b764f4c7ce39d7b0d4769c441ff37392c08d505_2_690x350.png\" alt=\"Fig 7: Popular categories of off-chain services\" data-base62-sha1=\"aLzhQdo4QHrT82cTTXJfkN1bRFH\" width=\"690\" height=\"350\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/4/b/4b764f4c7ce39d7b0d4769c441ff37392c08d505_2_690x350.png, https://ethresear.ch/uploads/default/optimized/3X/4/b/4b764f4c7ce39d7b0d4769c441ff37392c08d505_2_1035x525.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/4/b/4b764f4c7ce39d7b0d4769c441ff37392c08d505_2_1380x700.png 2x\" data-dominant-color=\"D4E4EB\"></a></div><p></p>\n<h3><a name=\"p-49574-what-are-the-alternative-architectures-available-to-secure-offchain-services-15\" class=\"anchor\" href=\"https://ethresear.ch#p-49574-what-are-the-alternative-architectures-available-to-secure-offchain-services-15\"></a>What are the alternative architectures available to secure offchain services?</h3>\n<p>For offchain services to transition from <em>trusted</em> to <em>trust-minimised</em> / <em>trustless</em> architectures, here is a comparison of the various design approaches.</p>\n<div class=\"md-table\">\n<table>\n<thead>\n<tr>\n<th>Design approach</th>\n<th>Description</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Security model</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Consensus-based</td>\n<td>Build a BFT-consensus with own operator set</td>\n<td>Trustless</td>\n<td>It is expensive and cumbersome for a service developer</td>\n<td>Depends on size of the operator set</td>\n</tr>\n<tr>\n<td>ZK-based</td>\n<td>Build a custom zk circuit or a program that can be proven in a general purpose zkVM</td>\n<td>Trustless</td>\n<td>Involves rewrite of the service using zk DSLs or using Rust. Expensive to generate zk-proofs</td>\n<td>Restricted to what can be proven in zk circuits</td>\n</tr>\n<tr>\n<td>EigenLayer AVS-based</td>\n<td>Convert the service into Eigenlayer AVS</td>\n<td>Inherit Ethereum security without bootstrapping an operator set</td>\n<td>Requires rewrite of the code to comply with AVS protocol. Also AVS can only detect and penalise operator faults if they are observable on-chain.</td>\n<td>Economic security</td>\n</tr>\n<tr>\n<td>PoSI IVS-based</td>\n<td>Deploy existing code in docker containers with no code rewrite.</td>\n<td>Ability to detect non-attributable faults (those that are not normally visible on-chain such as censorship, or unauthorized upgrades of service algorithms). Small, configurable cost.</td>\n<td>Services should meet pre-requisites: open-source code, a publicly verifiable service image, a reproducible build process and dockerized deployment</td>\n<td>Multi-layered security model incorporating <em>consensus-based</em>, <em>TEE</em>, and <em>crypto-economic security</em> constructs.</td>\n</tr>\n</tbody>\n</table>\n</div><h2><a name=\"p-49574-credits-16\" class=\"anchor\" href=\"https://ethresear.ch#p-49574-credits-16\"></a>Credits</h2>\n<p>The concept and design for PoSI protocol and Integrity-verified services was initially developed as a collaboration between <a class=\"mention\" href=\"https://ethresear.ch/u/peshwar9\">@peshwar9</a> and <a class=\"mention\" href=\"https://ethresear.ch/u/mohsinriaz17\">@mohsinriaz17</a> with contribution from several others to refine and enhance it.</p>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://ethresear.ch/t/proof-of-service-integrity-posi-trustless-measurement-of-service-integrity/20255\">Read full topic</a></p>","link":"https://ethresear.ch/t/proof-of-service-integrity-posi-trustless-measurement-of-service-integrity/20255","pubDate":"Sun, 11 Aug 2024 17:44:55 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20255"},"source":{"@url":"https://ethresear.ch/t/proof-of-service-integrity-posi-trustless-measurement-of-service-integrity/20255.rss","#text":"Proof of Service Integrity (PoSI): Trustless measurement of service integrity"}},{"title":"Efficient Data Distribution with Reed-Solomon Codes for Sharded Storage","dc:creator":"snjax","category":"ZK Rollup","description":"<h2><a name=\"p-49526-introduction-1\" class=\"anchor\" href=\"https://ethresear.ch#p-49526-introduction-1\"></a>Introduction</h2>\n<p>This writeup presents an efficient method for distributing N data elements across n nodes using Reed-Solomon (RS) encoding, specifically designed for blockchain <a href=\"https://ethresear.ch/t/blockchain-sharded-storage-web2-costs-and-web3-security-with-shamir-secret-sharing/18881\">sharded storage</a> solutions. We address the challenge of scaling blockchain storage by introducing techniques that achieve O(N log n) decoding complexity, where N is the total amount of data and n is the number of nodes.</p>\n<p>A naive approach would be to simply blow up the data from N to bN, where b is the blowup factor. However, this would result in O(N log N) decoding complexity. Our method, by representing data as a table and creating data shards, achieves O(N log n) decoding complexity, which is significantly faster.</p>\n<p>It‚Äôs crucial to note that we don‚Äôt need to apply RS codes to all data together. This is because a node can only go offline as a whole - there can‚Äôt be a situation where two nodes lose half of their data each, requiring RS codes to recover the data. A node either loses all its data or provides it entirely.</p>\n<p>While our method doesn‚Äôt significantly improve the speed of calculating polynomial commitments (which remains O(N log N) for FRI), it greatly optimizes the data encoding-decoding procedure.</p>\n<h3><a name=\"p-49526-naive-approach-2\" class=\"anchor\" href=\"https://ethresear.ch#p-49526-naive-approach-2\"></a>Naive approach</h3>\n<p><img src=\"https://ethresear.ch/uploads/default/original/3X/6/9/691031aaa0990298d3f1755f55e1cc286cb49197.svg\" alt=\"\" data-base62-sha1=\"eZqPs9a40I3bVsvwbBOzjLaDker\" role=\"presentation\" width=\"600\" height=\"150\"></p>\n<h3><a name=\"p-49526-our-approach-3\" class=\"anchor\" href=\"https://ethresear.ch#p-49526-our-approach-3\"></a>Our approach</h3>\n<p><img src=\"https://ethresear.ch/uploads/default/original/3X/6/a/6a6eea46c44a4be6f7311ec8edbab96cf8f81cd0.svg\" alt=\"\" data-base62-sha1=\"fbyfhphCEh9idtAFNcOR36DdiFi\" role=\"presentation\" width=\"600\" height=\"240\"></p>\n<h2><a name=\"p-49526-notation-and-definitions-4\" class=\"anchor\" href=\"https://ethresear.ch#p-49526-notation-and-definitions-4\"></a>Notation and Definitions</h2>\n<p>Before proceeding with the detailed description of our method, let‚Äôs define the key terms and symbols used throughout this writeup:</p>\n<ul>\n<li>N: Total amount of data elements</li>\n<li>n: Number of nodes in the network</li>\n<li>k: Minimum number of nodes required to recover the original data</li>\n<li>b: Blowup factor, defined as b = n/k</li>\n<li>m: Number of rows in the data table representation</li>\n</ul>\n<h2><a name=\"p-49526-h-2-adicity-fields-case-5\" class=\"anchor\" href=\"https://ethresear.ch#p-49526-h-2-adicity-fields-case-5\"></a>2-Adicity Fields Case</h2>\n<p>We consider a 2-adic prime field, specifically the BabyBear field with prime p = 15 * 2^27 + 1.</p>\n<p>Let‚Äôs consider we have a vector <span class=\"math\">{a_i}</span> of N elements of field <span class=\"math\">F_p</span>. We want to distribute this vector among n servers, such that any k servers can recover the original vector. We use Reed-Solomon codes to achieve this.</p>\n<p>We represent the vector <span class=\"math\">{a_i}</span> as a table <span class=\"math\">{a_{ij}}</span> of size <span class=\"math\">m \\times k</span> with <span class=\"math\">m</span> rows and <span class=\"math\">k</span> columns.</p>\n<p>We define a bivariate polynomial <span class=\"math\">f(x,y)</span> to represent our data:</p>\n<p><span class=\"math\">f(x,y) = \\sum\\limits_{ij} a_{ij} L_i(x) \\lambda_j(y)</span></p>\n<p>where <span class=\"math\">L_i(x)</span> is a Lagrange polynomial of degree <span class=\"math\">m-1</span> and <span class=\"math\">\\lambda_j(y)</span> is a Lagrange polynomial of degree <span class=\"math\">k-1</span>.</p>\n<p>After performing FFT over each row of the table, <span class=\"math\">f(x,y)</span> takes the following form:</p>\n<p><span class=\"math\">f(x,y) = \\sum\\limits_{ij} b_{ij} L_i(x) y^j = \\sum\\limits_{j} f_j(x) y^j</span></p>\n<p>where <span class=\"math\">f_j(x)=\\sum\\limits_{i} b_{ij} L_i(x)</span> is a polynomial of degree <span class=\"math\">m-1</span>.</p>\n<p>Each node should receive a unique linear combination of the columns of the table. Then we can recover the original vector by solving a system of linear equations. Let‚Äôs represent the data shard as <span class=\"math\">f(x,y_0)</span>, where <span class=\"math\">y_0</span> is a fixed value for each shard.</p>\n<p><span class=\"math\">f(x,y) - f(x,y_0) = \\sum\\limits_{j} (y^j - y_0^j) f_j(x) = (y-y_0) q(x,y)</span></p>\n<p>where <span class=\"math\">q(x,y)</span> is a quotient polynomial.</p>\n<p>We make the substitution <span class=\"math\">y=x^m</span> without loss of any inner polynomial structure. This substitution effectively concatenates all columns of the table, one after another, which is convenient for creating a polynomial commitment.</p>\n<p>After the substitution, we get the following polynomial equation to check that the shard is a valid part of the original data:</p>\n<p><span class=\"math\"> f(x,x^m) - f(x, y_0) = (x^m - y_0) q(x,x^m) </span></p>\n<h2><a name=\"p-49526-circle-fields-case-6\" class=\"anchor\" href=\"https://ethresear.ch#p-49526-circle-fields-case-6\"></a>Circle Fields Case</h2>\n<p>We now consider the M31 field with p = 2^32 - 1. [HLP24] proposed a method called CFFT (Circular Fast Fourier Transform), which is analogous to FFT but works with polynomials defined on a complex circle.</p>\n<p>In the circle representation, the polynomial takes the form <span class=\"math\">f(x,y)=\\Re(f(z))</span>, where <span class=\"math\">|z|=1</span>.</p>\n<p>Due to the circle constraint <span class=\"math\">|z|^2 = x^2 + y^2 = 1</span>, the polynomial can be represented as:</p>\n<p><span class=\"math\">f(x,y) = f_0(x) + y f_1(x)</span></p>\n<p>where <span class=\"math\">f_0(x)</span> and <span class=\"math\">f_1(x)</span> are polynomials of degree <span class=\"math\">N/2-1</span>. Note that we have two polynomials of this degree, providing sufficient degrees of freedom.</p>\n<p>Let‚Äôs represent the data vector <span class=\"math\">{a_i}</span> as a table <span class=\"math\">{a_{ij}}</span> of size <span class=\"math\">m \\times k</span> with <span class=\"math\">m</span> rows and <span class=\"math\">k</span> columns. We perform circle FFT (CFFT) on each row of the table, resulting in <span class=\"math\">m</span> vectors of size <span class=\"math\">n</span>.</p>\n<p><span class=\"math\">f(x,y,u,v) = \\sum\\limits_{ij} a_{ij} L_i(x,y) \\lambda_j(u,v)</span></p>\n<p>It‚Äôs important to note that the function <span class=\"math\">f(x,y,u,v)</span> is defined on a torus: <span class=\"math\">x^2+y^2=1</span>, <span class=\"math\">u^2+v^2=1</span>.</p>\n<p>Let‚Äôs consider <span class=\"math\">f(x,y,u,v)</span> as <span class=\"math\">v</span>-even function. This approach is not useful directly for SNARKs, because then we have even constraint on function values and next row could be dependent on the previous one. However, it‚Äôs useful for data distribution.</p>\n<p>Then</p>\n<p><span class=\"math\">f(x,y,u,v) = f(x,y,u) = \\sum\\limits_{ij} a_{ij} L_i(x,y) \\Lambda_j(u) </span>,<br>\nwhere <span class=\"math\">\\Lambda_j(u)</span> is even Lagrange basis on the circle.</p>\n<p>After applying CFFT over each row, we get:</p>\n<p><span class=\"math\">f(x,y,u) = \\sum\\limits_{ij} b_{ij} L_i(x,y) u^j = \\sum\\limits_{j} f_j(x,y) u^j</span></p>\n<p>where <span class=\"math\">f_j(x,y)=\\sum\\limits_{i} b_{i} L_i(x,y)=f_{j,0}(x) + y f_{j,1}(x)</span> and each polynomial is <span class=\"math\">(m/2-1)</span>-ordered.</p>\n<p>Let‚Äôs consider <span class=\"math\">f(x,y,u_0)</span> as a data shard, where <span class=\"math\">u_0</span> is a fixed value for each shard.</p>\n<p><span class=\"math\">f(x,y,u) - f(x,y,u_0) = \\sum\\limits_{j} (u^j - u_0^j) f_j(x,y) = (u-u_0) q(x,y,u)</span></p>\n<p>where <span class=\"math\">q(x,y,u)</span> is a quotient polynomial.</p>\n<p>We make the substitution <span class=\"math\">u=x^{m/2}</span> in <span class=\"math\">f(x,y,u)</span>. This substitution does not result in information loss because <span class=\"math\">f_j(x,y)=f_{j,0}(x) + y f_{j,1}(x)</span>, where the degrees of <span class=\"math\">f_{j,0}(x)</span> and <span class=\"math\">f_{j,1}(x)</span> are <span class=\"math\">m/2-1</span>. The resulting polynomial <span class=\"math\">f(x,y,x^{m/2})</span> maintains the structure <span class=\"math\">f_0(x) + y f_1(x)</span> and remains defined on a circle, albeit with each one-dimensional component now of degree <span class=\"math\">N/2-1</span>. This substitution effectively concatenates all columns of the table, similar to the 2-adicity case.</p>\n<p>After the substitution, we get the following polynomial equation to check that the shard is a valid part of the original data:</p>\n<p><span class=\"math\">f(x,y,x^{m/2}) - f(x,y,u_0) = (x^{m/2}-u_0)q(x,y,x^{m/2})</span></p>\n<h2><a name=\"p-49526-applications-7\" class=\"anchor\" href=\"https://ethresear.ch#p-49526-applications-7\"></a>Applications</h2>\n<h3><a name=\"p-49526-recovering-the-source-data-8\" class=\"anchor\" href=\"https://ethresear.ch#p-49526-recovering-the-source-data-8\"></a>Recovering the source data</h3>\n<p>Any <span class=\"math\">k</span> shards are enough to recover the original data.</p>\n<p><span class=\"math\">f(x,y,u) = \\sum\\limits_{j} c_{ij} L_i(x,y) \\mu(u),</span></p>\n<p>where <span class=\"math\">\\{\\mu_i(u)\\}</span> is a Lagrange polynomial basis on the evaluation domain <span class=\"math\">H=\\{u_i\\}</span>, and <span class=\"math\">u_i</span> are fixed values for each shard.</p>\n<p><span class=\"math\"> \\mu_i(u) = d_i Z_{H}(u)/(u-u_i),</span><br>\nwhere <span class=\"math\">Z_{H}(u)</span> is a polynomial that is zero at all points of <span class=\"math\">H</span>, <span class=\"math\">d_i</span> is a normalization factor, so</p>\n<p><span class=\"math\"> \\mu_i(u) = \\begin{cases}\n1, &amp; u = u_i \\\\\n0 &amp; u \\neq u_i\n\\end{cases}\n</span></p>\n<p>The source values could be computed as<br>\n<span class=\"math\">a_{ij} = f(g^i.x, g^i.y, h^j.x)</span></p>\n<h3><a name=\"p-49526-polynomial-storing-9\" class=\"anchor\" href=\"https://ethresear.ch#p-49526-polynomial-storing-9\"></a>Polynomial storing</h3>\n<p>In some cases, we want to store something directly related to the polynomial commitment of <span class=\"math\">f</span> instead of <span class=\"math\">a_{ij}</span>. This is important for zk applications, like rollups.</p>\n<p>Due to the inner structure of coefficient representation, we can represent <span class=\"math\">g(x,y)</span> as <span class=\"math\">f(x,y,x^{m/2})</span>. That means that we can store rollup block data as a set of shards, keeping the source polynomial structure, keeping the source commitment. Then <span class=\"math\">a_{ij}</span> will be some kind of intermediate representation of the committed data.</p>\n<h2><a name=\"p-49526-algorithm-description-10\" class=\"anchor\" href=\"https://ethresear.ch#p-49526-algorithm-description-10\"></a>Algorithm description</h2>\n<pre data-code-wrap=\"python\"><code class=\"lang-python\">\ndef get_shards_and_commitments(data: List[M31], m:int, n:int, k:int, cd:Domain, rd:Domain, xrd:Domain)\n    # data is a list of N elements\n    # m is the number of rows in the table\n    # n is the number of nodes\n    # k is the number of nodes required to recover the original data\n    # cd is the evaluation domain for the columns\n    # rd is the evaluation domain for the rows\n    # xrd is evaluation domain for the shards (blown up rows)\n    # Returns polynomial commitments and prover data for all the data and shards\n    \n    # create a table of size m x k, fulfilled row by row\n    table = create_table(data, m, k)\n    \n    # perform cfft on each row of the table\n    for row in table:\n        row[:] = cfft(row, rd)\n    \n    # create shards\n    shards = [icfft(fit_to_domain_with_zeros(row, rd, xrd), xrd) for row in table]\n    \n    # convert to col-ordered table\n    shards = to_col_ordered(shards)\n\n    # convert table to col_ordered\n    table = to_col_ordered(table)\n\n    # compute monomial representation of $f(x,y,x^{m/2})$\n    f = concat([cfft(col, cd) for col in table])\n\n    return pcs_monomial_repr(f), [pcs(shard) for shard in shards]\n\n</code></pre>\n<h2><a name=\"p-49526-distributing-the-data-over-a-cluster-of-nodes-11\" class=\"anchor\" href=\"https://ethresear.ch#p-49526-distributing-the-data-over-a-cluster-of-nodes-11\"></a>Distributing the data over a cluster of nodes</h2>\n<p>In practice, the client should deliver the data to <span class=\"math\">n</span> nodes, and the total amount of data is <span class=\"math\">bN</span>. However, for big files, it could be inefficient due to the client‚Äôs limited bandwidth.</p>\n<p>Instead of this client-centralized approach, <span class=\"math\">b</span> nodes could deliver <span class=\"math\">N \\cdot (1-1/k)</span> total data to <span class=\"math\">k-1</span> nodes. There is no bottleneck at the client side (the client sends just <span class=\"math\">N</span> data to one node), but total network data bandwidth is <span class=\"math\">b N \\cdot (2-1/k) \\approx 2bN</span>.</p>\n<p><img src=\"https://ethresear.ch/uploads/default/original/3X/3/b/3be891968cd29eb75294d6219b0d063ddb3bb8f2.svg\" alt=\"\" data-base62-sha1=\"8xYrHU7QvO5070y1umvRyJ6kB9g\" role=\"presentation\" width=\"195\" height=\"493\"></p>\n<p>There is no valuable computational overhead to compute the shards vectors because with fft or cfft each node can perform a unique coset shift instead of blowup (and the sum of all shifted evaluation domains is the evaluation domain for the blowup).</p>\n<p><img src=\"https://ethresear.ch/uploads/default/original/3X/2/0/2015d84ea59b9b3aea04f0aa12ff6cc33087367f.svg\" alt=\"\" data-base62-sha1=\"4zQ53Q3ojMbyUkZQDmigfqHZ5BJ\" role=\"presentation\" width=\"340\" height=\"250\"></p>\n<h2><a name=\"p-49526-conclusion-12\" class=\"anchor\" href=\"https://ethresear.ch#p-49526-conclusion-12\"></a>Conclusion</h2>\n<p>We have extended our method of data representation to the M31 field, providing a robust framework for efficient data distribution in blockchain storage. By representing data as a table and using FFT/CFFT techniques, we achieve O(N log n) decoding complexity, significantly optimizing the data encoding-decoding procedure. This approach is particularly valuable in blockchain systems where nodes can only fail as a whole, and efficient data recovery is crucial.</p>\n<p>While the complexity of polynomial commitment calculations remains O(N log N) for FRI, our method provides substantial benefits in the overall data handling process, making it a promising solution for scalable blockchain storage.</p>\n<h2><a name=\"p-49526-references-13\" class=\"anchor\" href=\"https://ethresear.ch#p-49526-references-13\"></a>References</h2>\n<p><a href=\"https://eprint.iacr.org/2024/278\" rel=\"noopener nofollow ugc\">HLP24</a></p>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://ethresear.ch/t/efficient-data-distribution-with-reed-solomon-codes-for-sharded-storage/20232\">Read full topic</a></p>","link":"https://ethresear.ch/t/efficient-data-distribution-with-reed-solomon-codes-for-sharded-storage/20232","pubDate":"Wed, 07 Aug 2024 22:32:41 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20232"},"source":{"@url":"https://ethresear.ch/t/efficient-data-distribution-with-reed-solomon-codes-for-sharded-storage/20232.rss","#text":"Efficient Data Distribution with Reed-Solomon Codes for Sharded Storage"}},{"title":"Aligning DAO contributions with objectives","dc:creator":"lajarre","category":"Economics","description":"<h1><a name=\"aligning-dao-contributions-with-objectives-1\" class=\"anchor\" href=\"https://ethresear.ch#aligning-dao-contributions-with-objectives-1\"></a>Aligning DAO contributions with objectives</h1>\n<p>In this post, we‚Äôre approaching how to align DAO contributions in a setting where a clear goal is already defined.</p>\n<p>We will define an Objective Alignment Engine (OAE) as a class of mechanisms that fulfill this objective. We aim to define the contour of such mechanisms so that they optimize resource allocation and provide economic guarantees on the efficacy of incentives.</p>\n<p><em>A more complete description along with more concrete examples is available at <a href=\"https://www.notion.so/r-ag-oae-Objective-Alignment-Engine-6984df3b33cc468e85264a9b975437eb?pvs=21\" rel=\"noopener nofollow ugc\">[r.ag.oae] Objective Alignment Engine</a>.</em></p>\n<h2><a name=\"motivation-2\" class=\"anchor\" href=\"https://ethresear.ch#motivation-2\"></a>Motivation</h2>\n<p>Suppose a DAO where governance contributors are compensated based on a simple rule, like ‚Äúthe top 10 delegates by total votes delegates are paid $10k / month‚Äù. As protocol designers, this sounds suboptimal as we have no guarantees that the treasury is spent on the delegates who produce the most useful contributions to governance (e.g. produce the most complete proposals, or vote most consistently). Also, any such rules-based process inevitably becomes gameable under <a href=\"https://en.wikipedia.org/wiki/Goodhart%27s_law\" rel=\"noopener nofollow ugc\">Goodhart‚Äôs law</a>.</p>\n<p>We‚Äôd prefer that contributions were picked individually and reward contributors based on how aligned these contributions are with the overarching goals of the network (e.g., how much are such contributions participating in growth? or decentralization?).</p>\n<p>Importantly, we‚Äôd also prefer that there is an objective notion of alignment, enabling a mechanism that relies not only on individual preferences but as much as possible on eliciting information (as suggested in <a href=\"https://ethresear.ch/t/governance-mixing-auctions-and-futarchy/10772\">this post on mixing auctions and futarchy</a>).</p>\n<h2><a name=\"background-3\" class=\"anchor\" href=\"https://ethresear.ch#background-3\"></a>Background</h2>\n<p>On-chain protocols often struggle to align contributor incentives with network goals. While blockchains are designed to optimize resource spending for security, producing alignment with agreed-upon goals is typically left to external governance systems. OAE mechanisms bring contributions and incentives within the purview of the protocol designer.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/c/c/cc4f46fea1dfde8237a19aac23844864e00fd24f.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/cc4f46fea1dfde8237a19aac23844864e00fd24f\" title=\"image\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/c/c/cc4f46fea1dfde8237a19aac23844864e00fd24f_2_690x389.jpeg\" alt=\"image\" data-base62-sha1=\"t9pfNEuGQSnrmwbAWB8K12AvcAv\" width=\"690\" height=\"389\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/c/c/cc4f46fea1dfde8237a19aac23844864e00fd24f_2_690x389.jpeg, https://ethresear.ch/uploads/default/optimized/3X/c/c/cc4f46fea1dfde8237a19aac23844864e00fd24f_2_1035x583.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/c/c/cc4f46fea1dfde8237a19aac23844864e00fd24f_2_1380x778.jpeg 2x\" data-dominant-color=\"33332F\"></a></div><p></p>\n<p>This approach aligns with the ‚Äúskin in the game‚Äù and futarchy-like solutions suggested in <a href=\"https://vitalik.eth.limo/general/2021/08/16/voting3.html\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">Moving beyond coin voting governance</a>. We‚Äôll rely on the notion that there is a jury that is incentivized to produce a good judgment of whether contributions are aligned and scale this with additional mechanisms.</p>\n<h2><a name=\"assumptions-objective-definition-4\" class=\"anchor\" href=\"https://ethresear.ch#assumptions-objective-definition-4\"></a>Assumptions: objective definition</h2>\n<p>A central assumption that we take is that the DAO has a clearly defined objective. While this is theoretically difficult to achieve in a decentralized setting, most protocol values and visions are set initially by the core team and steered by a Foundation.</p>\n<p>For example, Ethereum focuses today on <a href=\"https://ethereum.org/en/roadmap/vision/\" rel=\"noopener nofollow ugc\">Scalability, Security, and Sustainability</a>, whereas Optimism has the <a href=\"https://optimism.io/vision\" rel=\"noopener nofollow ugc\">Superchain vision</a>.</p>\n<p>In the rest of this post, we assume an existing process produces a clear definition of an objective <span class=\"math\">o</span> (hence, the <em>Objective</em> part of the Alignment Engine).</p>\n<p>The existence of such an objective enables designing mechanisms that rely only on eliciting information from participants, namely whether a contribution is aligned or not with the objective.</p>\n<h2><a name=\"alignment-engine-5\" class=\"anchor\" href=\"https://ethresear.ch#alignment-engine-5\"></a>Alignment engine</h2>\n<h3><a name=\"jury-6\" class=\"anchor\" href=\"https://ethresear.ch#jury-6\"></a>Jury</h3>\n<p>Once an objective is defined, we want to set up a jury that can review any contribution and evaluate how aligned it is with the objective. This is the central part of this design.</p>\n<p>The main function of the jury is to produce ratings ‚Äúaligned‚Äù / ‚Äúmisaligned‚Äù on contributions that are produced on the protocol.</p>\n<p>To produce alignment within the jury itself, we rely on mechanisms that incentivize truthful reporting but don‚Äôt rely on verifiable outcomes (like, BTC/USD quote). Possible such mechanisms are SchellingCoin or <a href=\"https://arxiv.org/abs/2306.04305\" rel=\"noopener nofollow ugc\">self-resolving prediction markets for unverifiable outcomes</a> (Srinivasan et al, 2023).</p>\n<p>To enable incentivization and notably negative rewards, we expect jurors to stake tokens ($ALIGN) and receive token emissions as rewards.</p>\n<h3><a name=\"dispute-resolution-7\" class=\"anchor\" href=\"https://ethresear.ch#dispute-resolution-7\"></a>Dispute resolution</h3>\n<p>Here we assume that most contributions can be unequivocally qualified as ‚Äúaligned‚Äù or ‚Äúmisaligned‚Äù (ie there is a <em>clear</em> way to rate most contributions, as long as <span class=\"math\">o</span> is well defined).</p>\n<p>But equivocal cases will inevitably appear. When a contestable result is produced, a dispute resolution mechanism needs to be enforced (either an external one like a Kleros court or an Augur-style ALIGN token fork).</p>\n<h3><a name=\"calibration-8\" class=\"anchor\" href=\"https://ethresear.ch#calibration-8\"></a>Calibration</h3>\n<p>In general, a juror can be an agent making use of any tools available, including AI and prediction markets, to produce the best evaluations. But this leaves open the question of how to incentivize jurors to get better at their jobs so the jury doesn‚Äôt degenerate into a static committee.</p>\n<p>If part of the contributions have a ground truth to which their ratings can be compared (e.g. growth contributions that aim at increasing a key metric like TVL for a DeFi protocol or fees for an L2), jurors can be rewarded accordingly. This way, the mechanism can still leverage objective outcomes to improve its accuracy (or <em>be <a href=\"https://www.overcomingbias.com/p/meta-jury-markets\" rel=\"noopener nofollow ugc\">calibrated</a></em>).</p>\n<h3><a name=\"scaling-9\" class=\"anchor\" href=\"https://ethresear.ch#scaling-9\"></a>Scaling</h3>\n<p>Armed with such a jury, DAO contributions can theoretically be evaluated. To handle large numbers of contributions, two scaling options are available:</p>\n<ul>\n<li>Prediction markets: bettors predict jury decisions, creating ‚ÄúAligned‚Äù and ‚ÄúMisaligned‚Äù tokens.</li>\n<li>Peer prediction: raters evaluate contributions, with a small percentage reviewed by the jury.</li>\n</ul>\n<p>Spam protection through staked curation or auctions ensures only valuable contributions are evaluated.</p>\n<h2><a name=\"rewards-distribution-10\" class=\"anchor\" href=\"https://ethresear.ch#rewards-distribution-10\"></a>Rewards distribution</h2>\n<p>With contribution evaluation in place, the last bit is to distribute contribution rewards to incentivize the most aligned contributions to be produced in the future.</p>\n<p>Aligned contributions receive rewards from treasury or token emissions, proportional to their alignment rating. Highly aligned contributions may be automatically implemented in proposal-like scenarios</p>\n<p>This produces a positive feedback loop where:</p>\n<ol>\n<li>Better-aligned contributions receive more rewards</li>\n<li>This incentivizes more aligned contributions in the future</li>\n<li>The protocol becomes more resistant to misaligned or captured governance over time.</li>\n</ol>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/7/e/7e67510d59620761b9c2941d8a4067b859bc6ebb.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/7e67510d59620761b9c2941d8a4067b859bc6ebb\" title=\"image\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/7/e/7e67510d59620761b9c2941d8a4067b859bc6ebb_2_543x500.jpeg\" alt=\"image\" data-base62-sha1=\"i2dvZRif0cghJQd24wAFAIaZ6Nd\" width=\"543\" height=\"500\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/7/e/7e67510d59620761b9c2941d8a4067b859bc6ebb_2_543x500.jpeg, https://ethresear.ch/uploads/default/optimized/3X/7/e/7e67510d59620761b9c2941d8a4067b859bc6ebb_2_814x750.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/7/e/7e67510d59620761b9c2941d8a4067b859bc6ebb_2_1086x1000.jpeg 2x\" data-dominant-color=\"32322E\"></a></div><p></p>\n<h2><a name=\"attacks-11\" class=\"anchor\" href=\"https://ethresear.ch#attacks-11\"></a>Attacks</h2>\n<p>Some potential limitations and related attacks include:</p>\n<ol>\n<li><strong>Equivocal objective definition.</strong> Attackers may exploit ambiguous objectives to reward misaligned contributions. This can be mitigated by updating the objective when the DAO observes that equivocation happens.</li>\n<li><strong>Jurors collusion and bribing.</strong> This can be countered with staking mechanisms, reputation systems, random juror selection, or shielded voting.</li>\n<li><strong>Peer prediction and prediction markets manipulation.</strong> Usual caveats and mitigations apply.</li>\n</ol>\n<h2><a name=\"questions-12\" class=\"anchor\" href=\"https://ethresear.ch#questions-12\"></a>Questions</h2>\n<p>Such OAE mechanisms rely on the existence of an objective <span class=\"math\">o</span>. We haven‚Äôt answered how such an objective can be defined in a general setting. There is an argument that leaving it to regular token-voting just pushes the problem around and the overall mechanism inherits some of the issues of both sub-mechanisms. However, it appears that splitting the problem in two has benefits, as, once an objective is defined, more deterministic outcomes can be achieved through mechanism design.</p>\n<p>Also, other kinds of mechanisms can be devised that rely on subjective evaluations. Including subjective evaluations might render objective definition superfluous. But relying on a jury whose jurors input their own preferences leaves the question open of how the jury achieves legitimacy. A solution would be to rely on a measure of juror reputation, as pioneered by Backfeed.</p>\n            <p><small>3 posts - 3 participants</small></p>\n            <p><a href=\"https://ethresear.ch/t/aligning-dao-contributions-with-objectives/20204\">Read full topic</a></p>","link":"https://ethresear.ch/t/aligning-dao-contributions-with-objectives/20204","pubDate":"Thu, 01 Aug 2024 23:46:47 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20204"},"source":{"@url":"https://ethresear.ch/t/aligning-dao-contributions-with-objectives/20204.rss","#text":"Aligning DAO contributions with objectives"}},{"title":"ShardDAG: Ordering and Exploitation in Sharded Blockchains","dc:creator":"JamesHenderson","category":"Sharding","description":"<p><em>This article was prepared by James A. Henderson from</em> <a href=\"https://nil.foundation/\" rel=\"noopener nofollow ugc\">=nil; Foundation</a></p>\n<h2><a name=\"tldr-1\" class=\"anchor\" href=\"https://ethresear.ch#tldr-1\"></a>tl;dr</h2>\n<p>Ethereum‚Äôs design has moved away from state sharding; however, L2 architectures like zkSharding provide a unified protocol in which L2 dApps are composable yet scalable via state sharding, avoiding the need for state fragmentation emerging across distinct L2s. However, sharded systems are not without challenges. In particular, state sharding amplifies MEV exploitation and censorship problems that exist in non-sharded blockchains.</p>\n<p>We propose a shardDAG architecture for state sharded blockchains or multi-chain systems, combining protocol rules, rewards and penalties that constrain transaction exploitation [<a href=\"https://arxiv.org/abs/1904.05234\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">[1904.05234] Flash Boys 2.0: Frontrunning, Transaction Reordering, and Consensus Instability in Decentralized Exchanges</a>] and external influences like regulatory censorship  [<a href=\"https://www.mevwatch.info/\" rel=\"noopener nofollow ugc\">https://www.mevwatch.info/</a>, <a href=\"https://home.treasury.gov/news/press-releases/jy0916\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">U.S. Treasury Sanctions Notorious Virtual Currency Mixer Tornado Cash | U.S. Department of the Treasury</a>]. Constraints on exploitation and censorship are achieved using a DAG architecture that links shard blocks to each other. The DAG provides an enforceable order in which cross-shard transactions must be processed by each shard, thereby constraining manipulation of transaction processing order.</p>\n<h2><a name=\"motivation-2\" class=\"anchor\" href=\"https://ethresear.ch#motivation-2\"></a>Motivation</h2>\n<p>State sharded blockchains inherit magnified MEV exploitation and censorship problems that exist in non-sharded blockchains because transaction completion can require block proposers in many distinct shards, and each block proposer could exploit or censor transactions. Further, more severe transaction exploits are possible via inserting other exploitative transactions in intermediate blocks that occur between starting and finishing transaction processing.</p>\n<p>To understand this, the example below demonstrates a simple exploit scenario.</p>\n<p><em><strong>Exploit Example</strong></em></p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/d/b/db208f14e2f3355a7d1d888bbc8b90e969102b97.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/db208f14e2f3355a7d1d888bbc8b90e969102b97\" title=\"BasicExploit\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/d/b/db208f14e2f3355a7d1d888bbc8b90e969102b97_2_690x445.jpeg\" alt=\"BasicExploit\" data-base62-sha1=\"vguk2i1o9S5mmhCMuXMDyExsNQb\" width=\"690\" height=\"445\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/d/b/db208f14e2f3355a7d1d888bbc8b90e969102b97_2_690x445.jpeg, https://ethresear.ch/uploads/default/optimized/3X/d/b/db208f14e2f3355a7d1d888bbc8b90e969102b97_2_1035x667.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/d/b/db208f14e2f3355a7d1d888bbc8b90e969102b97_2_1380x890.jpeg 2x\" data-dominant-color=\"4E4E4E\"></a></div><br>\nFigure 1: Two shard chains. Blocks 0 and 1 of shard <em>A</em> each contain cross-shard transactions <em>t</em> and <em>u</em>  respectively, whose destinations are shard <em>B</em>. Suppose <em>t</em> can be exploited if in shard <em>B</em> <em>u</em> is processed earlier than <em>t</em>. Then the system is dangerous for <em>t</em>‚Äôs user without enforceable ordering rules that ensure <em>t</em> must be processed before <em>u</em> in shard <em>B</em>.<p></p>\n<h2><a name=\"why-cross-shard-transaction-data-availability-matters-3\" class=\"anchor\" href=\"https://ethresear.ch#why-cross-shard-transaction-data-availability-matters-3\"></a>Why Cross-Shard Transaction Data Availability Matters</h2>\n<p>Punishment for censoring a cross-shard transaction (CST), or processing in an incorrect, exploitative order can only be enforced provided that</p>\n<p>i) It can be established that all the required data was available to the shard, and</p>\n<p>ii) The shard subsequently failed to process the data correctly.</p>\n<p>Therefore, a mechanism is required for establishing <em>verifiable</em> cross-shard (or cross-chain, or cross-rollup) transaction data availability. The broad steps in achieving this are illustrated in Fig. 2. Preventing exploitation requires enforceable rules for ordering the processing of transactions and CSTs; however, enforcing processing order requires that each shard receives the CSTs that it is required to process. To be able to receive CSTs, that CST data must be available. Thus, constraining exploitation rests upon ensuring CST data availability.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/7/b/7bee56e632f92d068ac45ccb5bf63a201b085725.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/7bee56e632f92d068ac45ccb5bf63a201b085725\" title=\"ShardDAG StrategySteps\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/7/b/7bee56e632f92d068ac45ccb5bf63a201b085725_2_690x154.jpeg\" alt=\"ShardDAG StrategySteps\" data-base62-sha1=\"hGlmRB3Rv32vxqCpxC8FzlMm0lv\" width=\"690\" height=\"154\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/7/b/7bee56e632f92d068ac45ccb5bf63a201b085725_2_690x154.jpeg, https://ethresear.ch/uploads/default/optimized/3X/7/b/7bee56e632f92d068ac45ccb5bf63a201b085725_2_1035x231.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/7/b/7bee56e632f92d068ac45ccb5bf63a201b085725_2_1380x308.jpeg 2x\" data-dominant-color=\"5C5C5C\"></a></div><br>\nFigure 2: Goal: ShardDAG ordering aims to constrain manipulation, exploitation and censorship of transactions and cross-shard transactions. Step 3: These constraints require enforceable protocol rules for ordering the processing of transactions and cross-shard transactions. Step 2: Fairly enforcing ordering rules requires on-chain acknowledgement of receipt of cross-shard transactions. Step 1: Receipt of cross-shard transactions requires cross-shard transaction data availability.<p></p>\n<h2><a name=\"step-3-a-preview-how-dags-provide-order-4\" class=\"anchor\" href=\"https://ethresear.ch#step-3-a-preview-how-dags-provide-order-4\"></a>Step 3. A Preview: How DAGs Provide Order</h2>\n<p>Our solution to the transaction and cross-shard transaction ordering problem involves linking shard chains into a shard directed acyclic graph or shardDAG, and then ordering processing according to the partial order specified within shard block subgraphs.</p>\n<p>ShardDAG ordering is previewed in Fig. 3. The distinct shard chains are connected to form a shardDAG, providing an enforceable ordering of cross-shard transactions amongst the shard chains. Unlike in Fig. 1, in Fig. 3‚Äôs shardDAG, an exploitative CST in a later block cannot be processed before a CST in an earlier block.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/4/8/48bb4910acfa00365d8e0b97b45be64b0e32e732.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/48bb4910acfa00365d8e0b97b45be64b0e32e732\" title=\"ShardDAG NonOverloaded Ordering\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/4/8/48bb4910acfa00365d8e0b97b45be64b0e32e732_2_193x500.jpeg\" alt=\"ShardDAG NonOverloaded Ordering\" data-base62-sha1=\"anpDmZETjVUw8C8k2cvC2lRyo2S\" width=\"193\" height=\"500\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/4/8/48bb4910acfa00365d8e0b97b45be64b0e32e732_2_193x500.jpeg, https://ethresear.ch/uploads/default/optimized/3X/4/8/48bb4910acfa00365d8e0b97b45be64b0e32e732_2_289x750.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/4/8/48bb4910acfa00365d8e0b97b45be64b0e32e732_2_386x1000.jpeg 2x\" data-dominant-color=\"3F423A\"></a></div><br>\nFigure 3: Unlike the distinct shard chains in Fig. 1, the shardDAG (top) depicted here defines a partial ordering of shard blocks that fall under any particular block (here shard B block 2) and the cross-shard transactions that the blocks contain. (Middle) A Hasse diagram can be constructed to visualise a partial ordering of the shard blocks (for clarity lines connecting blocks have not been included). The shardDAG is topologically sorted (bottom) to produce a block containing an ordered set of transactions and CSTs. In general many topological sorts are possible, the block builder selects one, likely based on MEV.<p></p>\n<h2><a name=\"a-sharddag-for-data-availability-5\" class=\"anchor\" href=\"https://ethresear.ch#a-sharddag-for-data-availability-5\"></a>A ShardDAG for Data Availability</h2>\n<p>To establish cross-shard transaction data availability, the simple set of shard chains in Fig. 1 is extended to become a shardDAG that is crafted to incentivize data sharing. In this system all validators participate in a synchronization chain which aggregates and finalises state updates from shards that are each operated by distinct subsets of the total validator set. Transaction and CST processing is performed within shards only, hence the synchronization chain is not a processing bottleneck. Here the details of the synchronization chain are restricted to its involvement in the shardDAG‚Äîthe broader function of the synchronization chain in the sharded system is beyond the scope of this post.</p>\n<p>To form a shardDAG, shard blocks include links to other shard blocks in the form of:</p>\n<ul>\n<li><strong>a hash to the previous shard block in the same shard, as in a typical blockchain,</strong></li>\n<li><strong>a set of hashes to other shards blocks in other shards,</strong></li>\n<li><strong>a hash to a (valid) synchronization block, equal to or later than the most recent synchronization block already used by prior shard blocks that are included in the subgraph.</strong></li>\n</ul>\n<p>The formation of a shardDAG is illustrated in Fig. 4, where for clarity only edges in the subgraph of the white block are shown. The thick arrows are the white block‚Äôs hashes to other blocks.</p>\n<p>The following is a central concept in the function of the shardDAG.</p>\n<p><strong>When a shard <span class=\"math\">A</span> creates a shard block that includes the hash <span class=\"math\">h</span> of another shard block or synchronization block, this inclusion acts as an acknowledgement that shard <span class=\"math\">A</span> has received the block headers and outboxes of cross-shard transactions for <span class=\"math\">h</span> and <span class=\"math\">h</span><em>‚Äôs</em> entire subgraph in the shardDAG.</strong></p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/b/2/b2ba419c59a01907d08a616eb2b464634114c1d3.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/b2ba419c59a01907d08a616eb2b464634114c1d3\" title=\"SubGraphLowDetail\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/b/2/b2ba419c59a01907d08a616eb2b464634114c1d3_2_690x469.jpeg\" alt=\"SubGraphLowDetail\" data-base62-sha1=\"pv62BsYMnjDFdt1gNae1HRBjMA3\" width=\"690\" height=\"469\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/b/2/b2ba419c59a01907d08a616eb2b464634114c1d3_2_690x469.jpeg, https://ethresear.ch/uploads/default/optimized/3X/b/2/b2ba419c59a01907d08a616eb2b464634114c1d3_2_1035x703.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/b/2/b2ba419c59a01907d08a616eb2b464634114c1d3_2_1380x938.jpeg 2x\" data-dominant-color=\"383838\"></a></div><br>\nFigure 4: Illustration of the white block‚Äôs subgraph in the shard DAG. The white block‚Äôs header contains a list of hashes to other shard blocks (thick white arrows), and well as a single hash to a synchronization block (thick grey arrow). Thin grey edges trace the subgraph of the white block, beyond the blocks explicitly included in its header.<p></p>\n<h2><a name=\"step-2-enforcing-cst-receipt-6\" class=\"anchor\" href=\"https://ethresear.ch#step-2-enforcing-cst-receipt-6\"></a>Step 2. Enforcing CST Receipt</h2>\n<h3><a name=\"enforcing-cst-receipt-via-shard-chains-7\" class=\"anchor\" href=\"https://ethresear.ch#enforcing-cst-receipt-via-shard-chains-7\"></a>Enforcing CST Receipt via Shard Chains</h3>\n<p>To enforce shards to continually acknowledge receipt of new shard block data, the protocol specifies conditions on block validity. Suppose we have a shard block <span class=\"math\">b_i</span> and <span class=\"math\">b_i</span><em>‚Äôs</em> prior shard block <span class=\"math\">b_{i-1}</span> in the same shard as <span class=\"math\">b_i</span>.</p>\n<ul>\n<li><strong>[PARENT CONDITION]: For <span class=\"math\">b_i</span> to be a valid shard block, the graph difference of <span class=\"math\">b_i</span><em>‚Äôs</em> subgraph minus <span class=\"math\">b_{i-1}</span><em>‚Äôs</em> subgraph must contain shard blocks created by more than <span class=\"math\">F&gt;1</span> shards, where <span class=\"math\">F</span> is a system parameter controlling the branching of the DAG.</strong></li>\n</ul>\n<p><em>Example:</em></p>\n<p><em>In Fig. 4, the subgraph of the white shard A block only contains two blocks that are not in the subgraph of the previous shard A block, i.e. the white block itself, and the middle shard B block. If in this example F=1, then the white block is valid; however, if F&gt;1 then the white block is invalid.</em></p>\n<h3><a name=\"enforcing-cst-receipt-via-the-synchronization-chain-8\" class=\"anchor\" href=\"https://ethresear.ch#enforcing-cst-receipt-via-the-synchronization-chain-8\"></a>Enforcing CST Receipt Via the Synchronization Chain</h3>\n<p>The parent condition enforces receipt of CSTs, but does not guarantee that each CST reaches its destination so that transactions complete. Without additional rules it is possible (though unlikely) for sets of shards to create shard blocks whose subgraphs do not span all shards and therefore do not acknowledge receipt of CSTs from all shards, as illustrated in Fig. 6.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/c/9/c95bce910ccff1c8dbd9ffbaa913b546c5db043d.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/c95bce910ccff1c8dbd9ffbaa913b546c5db043d\" title=\"consensusParentCondition\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/c/9/c95bce910ccff1c8dbd9ffbaa913b546c5db043d_2_690x444.jpeg\" alt=\"consensusParentCondition\" data-base62-sha1=\"sJiFlI0Hn0xlOFVQMTnxxXf2x1X\" width=\"690\" height=\"444\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/c/9/c95bce910ccff1c8dbd9ffbaa913b546c5db043d_2_690x444.jpeg, https://ethresear.ch/uploads/default/optimized/3X/c/9/c95bce910ccff1c8dbd9ffbaa913b546c5db043d_2_1035x666.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/c/9/c95bce910ccff1c8dbd9ffbaa913b546c5db043d_2_1380x888.jpeg 2x\" data-dominant-color=\"444343\"></a></div><br>\nFigure 6: Despite the parent condition for valid shard blocks, it is possible (though unlikely) for shard subgraphs to not acknowledge receipt of CSTs from some other shards via shard block edges, indicated by the vertical dashed line. However, the synchronization parent condition eventually forces all shards to acknowledge all CSTs via synchronization block edges. Here the synchronization parent condition forces shard 4 to acknowledge receipt of the red CST (via the red edges) and therefore process it, because the dashed blue edge exceeds the limit (here <em>S</em>=2) of consecutive synchronization block hashes. For clarity only the subset of synchronization blocks edges that are relevant to illustrating the above point are shown.<p></p>\n<p>This is unlikely to occur in the shardDAG; however, the synchronization chain is used to ensure that it <em>cannot</em> occur via a further block validity condition:</p>\n<ul>\n<li><strong>[SYNCHRONIZATION PARENT CONDITION]: A valid shard block <em>b</em> cannot have more than <span class=\"math\">S</span> prior blocks from the same shard using the same synchronization block hash.</strong></li>\n</ul>\n<p>The value of <span class=\"math\">S</span> should be chosen depending on the ratio of rates of synchronization block to shard block creation. It is expected that synchronization blocks will be produced at a slower rate compared to shard blocks.</p>\n<p>A malicious shard can only produce <span class=\"math\">S</span> shard blocks before being forced to acknowledge receipt of new shard blocks via the synchronization chain. In Fig. 5, the red CST shard block will eventually be included in a synchronization block, in a worst case scenario waiting until a shard 1 validator becomes the synchronization block proposer. Thus, eventually all shards will acknowledge receiving the red CST, including the red CST‚Äôs destination shard, as indicated by the red arrows. The dashed blue arrow indicates that shard 4 block 3 would be invalid if it used this hash because more than <span class=\"math\">S</span> (here 2) consecutive shard blocks would hash to the same synchronization block.</p>\n<p>In this way, economically motivated validators (and especially synchronization block proposers) are motivated to share data so that finality can be reached and economic rewards can be distributed.</p>\n<h2><a name=\"step-1-enforcing-cst-data-availability-via-dag-edges-between-shards-9\" class=\"anchor\" href=\"https://ethresear.ch#step-1-enforcing-cst-data-availability-via-dag-edges-between-shards-9\"></a>Step 1. Enforcing CST Data Availability Via DAG Edges Between Shards</h2>\n<p>While the parent, and synchronization parent conditions force shards to acknowledge receipt of data, these rules do not force shards to <em>distribute</em> shard block data and establish data availability. Thus, the protocol specifies a rule on shard block finality to align data availability with economic incentives.</p>\n<ul>\n<li><strong>[CHILD CONDITION]: For a shard block <span class=\"math\">b</span> to be finalised within the synchronization chain, within the subgraph of any synchronization block, <span class=\"math\">b</span> must have child shard blocks created by more than <span class=\"math\">F</span> shards.</strong></li>\n</ul>\n<p>When a block satisfies the child condition its CSTs have been acknowledged as received by more than <em>F</em> other shards and the shard has therefore distributed its CST data.</p>\n<p>The child condition is illustrated in Fig. 5. For a shard block to acquire child shard blocks, other (honest) shards must first receive its subgraph data. Thus, shards are economically incentivised to possess and distribute data in their subgraphs.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/1/b/1b0c569adc1421ca246f774a9b776cda2aaa6465.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/1b0c569adc1421ca246f774a9b776cda2aaa6465\" title=\"ChildConditionEthREsearch\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/1/b/1b0c569adc1421ca246f774a9b776cda2aaa6465_2_688x500.jpeg\" alt=\"ChildConditionEthREsearch\" data-base62-sha1=\"3RhkeDD46aGIjVlhSUgVjmt1D25\" width=\"688\" height=\"500\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/1/b/1b0c569adc1421ca246f774a9b776cda2aaa6465_2_688x500.jpeg, https://ethresear.ch/uploads/default/optimized/3X/1/b/1b0c569adc1421ca246f774a9b776cda2aaa6465_2_1032x750.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/1/b/1b0c569adc1421ca246f774a9b776cda2aaa6465_2_1376x1000.jpeg 2x\" data-dominant-color=\"353535\"></a></div><br>\nFigure 5: Illustration of the child condition for the subgraph of the upper left synchronization block. In this example <em>F</em>=2. The white block in finalised because it has child shard blocks from three shards, indicated by thick white arrows. In contrast, the bottom right shard block is not finalised because it only has one child shard block indicated by the thick grey arrow.<p></p>\n<h2><a name=\"step-3-an-enforceable-dag-partial-order-of-transaction-and-cst-processing-10\" class=\"anchor\" href=\"https://ethresear.ch#step-3-an-enforceable-dag-partial-order-of-transaction-and-cst-processing-10\"></a>Step 3. An Enforceable DAG Partial Order of Transaction and CST Processing</h2>\n<p>The shardDAG provides a verifiable, enforceable ordering of transactions and CSTs, which constrains exploits and guarantees (eventual) transaction processing. Transactions and cross-shard transactions must be processed in an order consistent with the partial order of the shard blocks that they are each created in.</p>\n<p>Suppose that shard <em>B</em> creates a new shard block <em>b</em>. As illustrated in Fig.3, the the steps involved in ordering the processing of CSTs and transactions are:</p>\n<ol>\n<li>First <span class=\"math\">b</span><em>‚Äôs</em> hashes (DAG edges) to other shard blocks and a synchronization block are chosen. Hashes are only chosen if corresponding subgraph CST data is available, otherwise correct ordering cannot be known and penalties may ensue.</li>\n<li>The protocol rules described earlier require that the validator creating and proposing <span class=\"math\">b</span> has all the CST data from <span class=\"math\">b</span><em>‚Äôs</em> subgraph, call these <span class=\"math\">T</span>. The set of pending CSTs <span class=\"math\">P</span> whose destination is shard <span class=\"math\">B</span>, and which have not already been processed in an existing shard <span class=\"math\">B</span> block are extracted from <span class=\"math\">T</span> and any new transactions are added to <span class=\"math\">P</span>.</li>\n<li>The set of pending transactions and CSTs, <span class=\"math\">P</span> are (partially) ordered according to the shardDAG ordering of the shard blocks that they were created in, retaining the order of multiple CSTs created within a single block. <span class=\"math\">P</span> is topologically sorted to create a totally ordered set of transactions and CSTs.</li>\n<li>Block size limits may constrain the number of transactions and cross-shard transactions included in a shard block. If this occurs, it is optional to introduce priority of transactions and CSTs as illustrated in Fig. 7, whereby block proposers select transactions and CSTs to include based on priority fees, and MEV. However, this comes at the cost of potentially allowing exploitative transaction insertion. Pending transactions and CSTs must be processed if allowed by block size limits; any unused block space must be too small to contain any unprocessed transaction or CST.</li>\n<li>New transactions that do not fit into block processing can be included in a shard block‚Äôs outbox of CSTs. Such transactions enter the shardDAG for ordering and will therefore be processed in a later block along with other pending transactions and CSTs not included in <span class=\"math\">b</span>.</li>\n</ol>\n<p>Validators should only sign a proposed block once they have verified that the block proposer has followed this protocol ordering. If an invalid ordering is used then the block is invalid and/or the signing validators are subjected to penalties. We reiterate that because ordering rules involve only on-chain data, data availability of CSTs and block headers enables any validator or node to verify correctness of ordering.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/0/9/09afd7f7cf81fd6dacfe88bcc2f4b6c7eab46c0f.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/09afd7f7cf81fd6dacfe88bcc2f4b6c7eab46c0f\" title=\"ShardDAG Overloaded Ordering Only\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/0/9/09afd7f7cf81fd6dacfe88bcc2f4b6c7eab46c0f_2_690x407.jpeg\" alt=\"ShardDAG Overloaded Ordering Only\" data-base62-sha1=\"1nH2vxvlS1jBdkATbBGafTTa63Z\" width=\"690\" height=\"407\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/0/9/09afd7f7cf81fd6dacfe88bcc2f4b6c7eab46c0f_2_690x407.jpeg, https://ethresear.ch/uploads/default/optimized/3X/0/9/09afd7f7cf81fd6dacfe88bcc2f4b6c7eab46c0f_2_1035x610.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/0/9/09afd7f7cf81fd6dacfe88bcc2f4b6c7eab46c0f_2_1380x814.jpeg 2x\" data-dominant-color=\"424138\"></a></div><br>\nFigure 7: An extension of Fig.3 when shard B is overloaded and unprocessed transactions and CSTs exceed maximum block size (left). The block builder selects transactions and CSTs to remove from the topological sort for the new block (middle), so that the remaining transactions and CSTs do not exceed block size limits (right). Removed CSTs will be processed in later blocks. This removal of transactions and CSTs is expected to be based on priority fees and MEV. Unprocessed new transactions (b2‚Äô) may be included in an outbox as data so that they enter shardDAG ordering for processing in a later block, like b0 and b1 in earlier blocks, but these outboxed transactions are not processed in the current block.<p></p>\n<h2><a name=\"summary-11\" class=\"anchor\" href=\"https://ethresear.ch#summary-11\"></a>Summary</h2>\n<p>In state-sharded blockchains, censorship and insertion of exploitative transactions part-way through transaction processing can be constrained by shardDAG transaction and CST ordering. These shardDAG constraints are derived from ordering, which enforces processing of earlier transactions and CSTs before later ones. ShardDAG ordering rests upon economic incentives that motivate validators to suitably participate in the shardDAG to receive block rewards and avoid penalties.</p>\n<p>DAGs are a natural tool to be used in ordered systems. The shardDAG broadens the use of DAGs in blockchain, beyond their more common application in consensus mechanisms. The shardDAG has been presented here in a unified state sharded system, but the ideas can be applied to sets of distinct rollups or blockchains.</p>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://ethresear.ch/t/sharddag-ordering-and-exploitation-in-sharded-blockchains/20203\">Read full topic</a></p>","link":"https://ethresear.ch/t/sharddag-ordering-and-exploitation-in-sharded-blockchains/20203","pubDate":"Thu, 01 Aug 2024 23:12:07 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20203"},"source":{"@url":"https://ethresear.ch/t/sharddag-ordering-and-exploitation-in-sharded-blockchains/20203.rss","#text":"ShardDAG: Ordering and Exploitation in Sharded Blockchains"}},{"title":"Inclusion List Timing Constraints","dc:creator":"terence","category":"Block proposer","description":"<p>Special thanks to <a class=\"mention\" href=\"https://ethresear.ch/u/julian\">@Julian</a>, <a class=\"mention\" href=\"https://ethresear.ch/u/barnabe\">@barnabe</a> and <a class=\"mention\" href=\"https://ethresear.ch/u/manav2401\">@manav2401</a> for the reviews</p>\n<h2><a name=\"background-1\" class=\"anchor\" href=\"https://ethresear.ch#background-1\"></a>Background</h2>\n<p>Inclusion list have been an active topic since the <a href=\"https://notes.ethereum.org/@vbuterin/pbs_censorship_resistance\" rel=\"noopener nofollow ugc\">early</a> <a href=\"https://ethresear.ch/t/how-much-can-we-constrain-builders-without-bringing-back-heavy-burdens-to-proposers/13808\">days</a>. <a href=\"https://notes.ethereum.org/@fradamt/forward-inclusion-lists\" rel=\"noopener nofollow ugc\">Various</a> <a href=\"https://notes.ethereum.org/@fradamt/H1TsYRfJc\" rel=\"noopener nofollow ugc\">designs</a> have emerged over time, each with inevitable trade-offs concerning <strong>What can be constrained within a single Ethereum slot?</strong>.<br>\nThis post explores these trade-offs from the perspectives of <strong>different actors</strong> involved in ILs and defines the dependencies required for each actor to fulfill their role in integrating ILs into the protocol. We will compare and contrast multiple designs, focusing on the limitations related to <strong>timing, security, and feasibility</strong>.</p>\n<p>First, we will outline some definitions.</p>\n<h2><a name=\"il-definitions-2\" class=\"anchor\" href=\"https://ethresear.ch#il-definitions-2\"></a>IL Definitions</h2>\n<p><strong>Slot Time</strong>: In the context of Ethereum, a slot refers to a fixed interval currently set at 12 seconds. During each slot, the proposer/builder proposes a block, attesters vote on the block, and an aggregator aggregates the votes. The proposer of subsequent slot includes aggregated votes in their block, and the cycle repeats. Today out-of-protocol builders have an ~8-second window to prepare for the next slot‚Äôs block. All actions are synchronized with these validator duty intervals, and <strong>IL should not extend the current slot time</strong>.</p>\n<p><strong>Inclusion List:</strong> An inclusion list (IL) is a list of transactions that a block proposer commits to including in a block. Depends on the conditional vs unconditional constraint, if these transactions are not included in the block, then the block cannot be considered canonical, assuming honest attesters who will vote against the block. The IL consists of the following options and requirements.</p>\n<ol>\n<li><strong>Satisfactory Requirement</strong>:\n<ul>\n<li><strong>Conditional</strong>: The IL does not need to be satisfied if the target block is full.\n<ul>\n<li><strong>Forward-Looking</strong>: If the IL cannot be satisfied in the current target block, does it still apply to subsequent blocks? <a href=\"https://ethresear.ch/t/cumulative-non-expiring-inclusion-lists/16520\">More in this post</a></li>\n</ul>\n</li>\n<li><strong>Unconditional</strong>: The IL needs to be satisfied. This typically means the IL has its own gas limit.</li>\n</ul>\n</li>\n<li><strong>Satisfactory Time</strong>:\n<ul>\n<li><strong>Same Slot IL</strong>: The IL is satisfied within the same slot, similar to users sending a transactions wanting to be included on chain. With sufficient base fee and tip, we can expect the transaction to be included the slot of. For example, an IL transaction for slot <code>n+1</code> is satisfied in slot <code>n+1</code>.</li>\n<li><strong>Next Slot IL</strong>: The IL is satisfied in the subsequent slot with one slot delay. For example, an IL transaction for slot <code>n+1</code> is satisfied in slot <code>n+2</code>.</li>\n</ul>\n</li>\n<li><strong>IL constructor</strong>: The actor responsible for preparing and broadcasting the IL to the network. This role can be fulfilled by a single entity (like a proposer) or by a committee where the protocol reaches consensus on individual ILs from its members. The consensus of IL may be reached by IL aggregate which represents IL committee‚Äôs vote.</li>\n<li><strong>IL Gas Limit</strong>: IL gas limit has an implication on the size of IL which dirrectly affects the network propagation time and node‚Äôs verification time.</li>\n<li><strong>IL Ordering In Block</strong>: When the IL becomes part of the block, the transactions may be required to be placed in a specific order. This order could be:\n<ul>\n<li><strong>Top of the Block</strong>: Transactions are placed at the beginning of the block.</li>\n<li><strong>Anywhere in the Block</strong>: Transactions are placed anywhere within the block.</li>\n<li><strong>Bottom of the Block</strong>: Transactions are placed at the end of the block.</li>\n</ul>\n</li>\n<li><strong>Liveness Guarantee</strong> The IL must be made available to the block builder to avoid stalling the chain‚Äôs liveness. The delivery method of the IL to the builder varies based on the trust model. If a single person constructs the IL, stricter requirements may be necessary, such as additional attester validation along with the block.</li>\n<li><strong>No Free DA</strong> An IL that has not been satisfied in execution cannot be part of the consensus, as it would grant free DA. Free DA has to be tightly coupled with consensus and should not be mistaken for free bandwidth or temporary data storage. While nodes can use a small amount of bandwidth or store temporary data with anti-dos measures in place, this should not be conflated with free DA.</li>\n</ol>\n<p><strong>Block Builder</strong>: The actor tasked with fulfilling the IL and broadcasting the resulting product (ie. a block that fulfills the IL) over the network. In the case of a solo validator, the block proposer serves as the block builder, and the product is the execution payload of the block. For a MEV-boost validator, the block builder handles the fulfillment, which returns the signed header to proposer, and the relay broadcasts the final block to the network. It is often the case that the block proposer cannot verify the satisfactory fulfillment of the IL when signing the header request. Relays have to verify the payload satisfies IL ahead of time or assume optimistic.</p>\n<p><strong>IL Transaction Invalidation</strong>: Transactions in an IL may become <strong>not includable</strong> at the time of inclusion due to invalidations, such as an incorrect nonce or insufficient balance. This situation can arise under different conditions. For example, when multiple parties are involved in constructing their version of ILs, the transactions from each party might render each other not includable. Similarly, if one party constructs the IL while another party broadcasts the block at the same moment, there can also be invalidations, leading to mutual exclusion of the IL transactions and block transactions.</p>\n<p><strong>Head Block</strong>: Often referred to as the parent block, the IL should be constructed on top of the chain‚Äôs head from the perspective of the node. The builder, responsible for constructing the block and satisfying the IL, should also build on top of the head block in order to make sure that block and inclusion list are aligned.<br>\n<strong>Constraint</strong>: If an IL is built on head <code>a</code>, then to satisfy the IL, the builder‚Äôs block must also be built on top of head <code>a</code>.</p>\n<h2><a name=\"il-timings-3\" class=\"anchor\" href=\"https://ethresear.ch#il-timings-3\"></a>IL Timings</h2>\n<p><strong>IL Preparation Time</strong>: This is the time required for a party to prepare the IL, which is constructed on top of the head block. The larger the IL may require longer time to prepare.</p>\n<p><strong>IL Propagation Time</strong>: This is the time required for the IL to propagate across the network to other nodes. Factors influencing this time include the size of the IL, the number of ILs (committee size), and the network‚Äôs gossip rules.</p>\n<p><strong>IL Verification Time</strong>: This is the time required to verify the IL. The IL must be valid, otherwise builders can get grieved. In some scenarios, attesters must verify the IL before considering the current slot block as the head (. In other cases, the proposer must verify the IL before proposing the next slot block. The point is that some parties must verify the IL beforehand, and it‚Äôs crucial to consider who is bearing this cost.</p>\n<p><strong>Block Preparation Time</strong>: This is the time required to build an execution block. The block can be constructed either by the proposer or the builder. The IL‚Äôs satisfactory requirements must be met in the block. This means the block builder must verify the IL, parent block and ensure that the block satisfies IL requirements.</p>\n<p><strong>Block Propagation Time</strong>: This is the time taken for a block to be transmitted across the network and received by all participants. It‚Äôs crucial that the block is received and verified by attesters promptly, as delays can lead to the block not being considered as the head of the chain, increasing the risk of reorg.</p>\n<p><strong>Block Verification Time</strong>: This is the time taken for a node to verify the block and IL. The focus here is on execution verification time, as consensus verification is typically fast. A block must be verified as execution valid and meet the IL requirements before it can be considered the head of the chain.</p>\n<p>Based on the timing definition provided, we can outline the following dependencies:</p>\n<ul>\n<li>The parent head block <code>n</code> must be released before attestation cut off. The difference is between start of the slot. Head release time = <span class=\"math\">T_{HR}</span></li>\n<li>The head block must be propagated to peers on time. Head propagation time = <span class=\"math\">T_{HP}</span></li>\n</ul>\n<ul>\n<li>The IL constructor must see and validate the parent head block before creating the IL. Head validator time = <span class=\"math\">T_{HV}</span></li>\n<li>The IL must be constructed and released using for example a local mem pool. IL construction time = <span class=\"math\">T_{ILC}</span></li>\n<li>The IL must propagate through the network to reach the builders. IL propagation time = <span class=\"math\">T_{ILP}</span></li>\n<li>The block builder needs to verify the IL before submitting a bid.  IL verification time = <span class=\"math\">T_{ILV}</span>\n<ul>\n<li>This requirement may change in the context of slot auctions.</li>\n</ul>\n</li>\n<li>The proposer must see the bids before submitting a block. Bid propagation time = <span class=\"math\">T_{BP}</span></li>\n<li>The attester must verify the block <code>n+1</code> before considering it as the head. We can reuse head verification time above.</li>\n</ul>\n<p>In short, we could summarize: A single Ethereum slot should not exceed the following durations, ensuring that the end-to-end IL is applied, and the block remains canonical on the chain: <span class=\"math\">SLOT &gt;= T_{HR}+T_{HP}+2 * T_{HV}+T_{ILC}+T_{ILP}+T_{ILV}+T_{BP}</span></p>\n<h1><a name=\"different-versions-of-il-4\" class=\"anchor\" href=\"https://ethresear.ch#different-versions-of-il-4\"></a>Different versions of IL</h1>\n<p>Different versions of IL have varying constraint trade-offs. Some examples taken from <a href=\"https://eips.ethereum.org/EIPS/eip-7547\" rel=\"noopener nofollow ugc\">EIP-7547</a> and <a href=\"https://ethresear.ch/t/fork-choice-enforced-inclusion-lists-focil-a-simple-committee-based-inclusion-list-proposal/19870\">FOCIL</a>.</p>\n<h4><a name=\"eip-7547-in-mev-boost-5\" class=\"anchor\" href=\"https://ethresear.ch#eip-7547-in-mev-boost-5\"></a>EIP-7547 in MEV-Boost</h4>\n<ul>\n<li>The block builders for slot <code>n</code> constructs a block for slot <code>n</code> after verifying the block for slot <code>n-1</code>.</li>\n<li>The block proposer of slot <code>n</code> constructs an IL for slot <code>n+1</code> after verifying the block for slot <code>n-1</code>.</li>\n<li>The IL for slot <code>n+1</code> and the block for slot <code>n</code> may invalidate each other if they are sent by different parties.</li>\n<li>The block proposer/builder of slot <code>n+1</code> requires the IL and the block for slot <code>n</code> to build a block.</li>\n<li>The block proposer of slot <code>n+1</code> needs the IL and the block for slot <code>n</code> to build an IL.</li>\n<li>Attesters for slot <code>n+1</code> need the IL and the block for slot <code>n</code> to attest to the block. The block for slot <code>n+1</code> must link to a valid IL <code>n+1</code>, or it cannot be canonical.</li>\n</ul>\n<h4><a name=\"eip-7547-in-epbs-eip-7732-6\" class=\"anchor\" href=\"https://ethresear.ch#eip-7547-in-epbs-eip-7732-6\"></a>EIP-7547 in ePBS (EIP-7732)</h4>\n<ul>\n<li>The block proposer of slot <code>n</code> selects the builder‚Äôs bid of slot <code>n</code> after verifying the execution block for slot <code>n-1</code>.</li>\n<li>The block proposer of slot <code>n</code> constructs an IL for slot <code>n+1</code> after verifying the execution block for slot <code>n-1</code>.</li>\n<li>Since the bid commits to the transactions, the IL for slot <code>n+1</code> and the bid for slot <code>n</code> may conflict. This is different in slot auction.</li>\n<li>The builder reveals the execution block at slot <code>n</code>‚Äôs 6-seconds mark.</li>\n<li>Subsequent block builders require the execution block at slot <code>n</code> and the IL for slot <code>n+1</code> to place bids for slot <code>n+1</code>. This is different in slot auction.</li>\n<li>Attesters for slot <code>n+2</code> verify that the execution block for slot <code>n+1</code> satisfies the IL and is valid. We gain an extra slot time for validation due to <a href=\"https://ethresear.ch/t/advantage-of-pipelining-consensus-and-execution-delayed-execution/19668\">delayed execution property</a>.</li>\n</ul>\n<h4><a name=\"focil-in-mev-boost-ignoring-il-aggregation-step-7\" class=\"anchor\" href=\"https://ethresear.ch#focil-in-mev-boost-ignoring-il-aggregation-step-7\"></a>FOCIL in MEV-Boost (Ignoring IL Aggregation Step)</h4>\n<ul>\n<li>The block builder of slot <code>n</code> constructs a block for slot <code>n</code> after verifying the block for slot <code>n-1</code>.</li>\n<li>The IL committee builds the IL for slot <code>n</code> after verifying the block for slot <code>n-1</code>.</li>\n<li>The IL committee for slot <code>n</code> releases the IL during slot <code>n-1</code>.</li>\n<li>Attesters for slot <code>n</code> lock their view on the ILs.</li>\n<li>The builder of slot <code>n</code> includes the IL transactions into the block for slot <code>n</code></li>\n<li>At the start of slot <code>n</code>, the proposer requests the builder‚Äôs head, signs it, and broadcasts it.</li>\n<li>Attesters for slot <code>n</code> verify that the block satisfies the IL committee‚Äôs requirements according to their locked view in slot <code>n-1</code>.</li>\n</ul>\n<h4><a name=\"focil-in-epbs-same-slot-version-8\" class=\"anchor\" href=\"https://ethresear.ch#focil-in-epbs-same-slot-version-8\"></a>FOCIL in ePBS (Same Slot Version)</h4>\n<ul>\n<li>The block proposer of slot <code>n</code> selects the builder‚Äôs bid for slot <code>n</code> after verifying the execution block for slot <code>n-1</code>.</li>\n<li>The IL committee for slot <code>n+1</code> constructs the IL for slot <code>n+1</code> after the builder reveals the execution block for slot <code>n</code>.</li>\n<li>Builders for slot <code>n+1</code> verify the IL and make bids for slot <code>n+1</code>.</li>\n<li>The block proposer of slot <code>n+1</code> selects the builder‚Äôs bid for slot <code>n+1</code>.</li>\n<li>Attesters for slot <code>n+2</code> verify that the execution block for slot <code>n+1</code> satisfies the IL and is valid, providing close to an extra slot time due to delayed execution.</li>\n</ul>\n<h4><a name=\"focil-in-epbs-next-slot-version-9\" class=\"anchor\" href=\"https://ethresear.ch#focil-in-epbs-next-slot-version-9\"></a>FOCIL in ePBS (Next Slot Version)</h4>\n<ul>\n<li>The block proposer of slot <code>n</code> selects the builder‚Äôs bid for slot <code>n</code> after verifying the execution block for slot <code>n-1</code>.</li>\n<li>The IL committee for slot constructs the IL for slot <code>n+2</code> after the builder reveals the execution block for slot <code>n</code>.</li>\n<li>Builders for slot <code>n+2</code> verify the IL and make bids for slot <code>n+2</code>.</li>\n<li>The block proposer of slot <code>n+2</code> selects the builder‚Äôs bid for slot `n+2.</li>\n<li>Attesters for slot <code>n+3</code> verify that the execution block for slot <code>n+2</code> satisfies the IL and is valid, providing close to an extra slot time due to delayed execution.</li>\n</ul>\n<h2><a name=\"il-contentions-10\" class=\"anchor\" href=\"https://ethresear.ch#il-contentions-10\"></a>IL Contentions</h2>\n<p>ILs may compete with initiatives as the following:</p>\n<p><strong>Shorter Slot Time Contentions with IL</strong>: With shorter slot times, ILs may not be constructed and fulfilled on time. A proposer that cannot fulfill an IL results in a liveness fault. One way to address this is to extend the IL satisfactory rule to the next slot or to multiple subsequent slots, but this approach introduces risks of denial-of-service (DoS) attacks and more transaction invalidation concerns. There is a trade-off here.</p>\n<p><strong>Higher Gas Limit Contentions with IL</strong>: With a higher block gas limit, it takes longer to verify the block, which reduces the time available to construct the IL after verifying the block. Additionally, with a higher IL gas limit, it takes longer to propagate and verify the IL, reducing the time available to fulfill the IL by building the block.</p>\n<p><strong>DVT Contentions with IL</strong>: Distributed Validator Technology (DVT) requires more exchanges between validators before signing. This process includes beacon chain duties such as attesting, proposing, and submitting ILs. These additional exchanges require time, and there is a need to ensure that the IL, especially in more complex forms, does not make DVT operations impractical.</p>\n<p><strong>AVS Contentions with IL</strong>: Active Validator Service (AVS) also require more actions from validators. The specific details depend on the AVS implementation, but generally, requiring more time from validators to perform certain tasks can create contention with fulfilling IL obligations.</p>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://ethresear.ch/t/inclusion-list-timing-constraints/20198\">Read full topic</a></p>","link":"https://ethresear.ch/t/inclusion-list-timing-constraints/20198","pubDate":"Thu, 01 Aug 2024 16:02:42 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-20198"},"source":{"@url":"https://ethresear.ch/t/inclusion-list-timing-constraints/20198.rss","#text":"Inclusion List Timing Constraints"}}]}}}