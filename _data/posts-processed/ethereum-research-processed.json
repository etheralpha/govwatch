{"rss":{"@version":"2.0","@xmlns:discourse":"http://www.discourse.org/","@xmlns:atom":"http://www.w3.org/2005/Atom","@xmlns:dc":"http://purl.org/dc/elements/1.1/","channel":{"title":"Ethereum Research - Latest topics","link":"https://ethresear.ch/latest","description":"Latest topics","lastBuildDate":"Fri, 24 May 2024 21:34:51 +0000","atom:link":{"@href":"https://ethresear.ch/latest.rss","@rel":"self","@type":"application/rss+xml"},"item":[{"title":"Credibly Neutral Preconfirmation Collateral: The Preconfirmation Registry","dc:creator":"mteam88","category":"Layer 2","description":"<h1><a name=\"credibly-neutral-preconfirmation-collateral-1\" class=\"anchor\" href=\"https://ethresear.ch#credibly-neutral-preconfirmation-collateral-1\"></a>Credibly Neutral Preconfirmation Collateral</h1>\n<p>by <a href=\"https://x.com/mteamisloading\" rel=\"noopener nofollow ugc\">mteam</a> from <a href=\"https://x.com/Spire_Labs\" rel=\"noopener nofollow ugc\">Spire Labs</a><br>\ninspired+reviewed by <a href=\"https://x.com/drakefjustin\" rel=\"noopener nofollow ugc\">Justin Drake</a>.<br>\nreviewed by <a href=\"https://x.com/lvdaniels\" rel=\"noopener nofollow ugc\">Ladislaus</a>, <a href=\"https://x.com/MuratLite\" rel=\"noopener nofollow ugc\">Murat</a>, and others.<br>\n.<br>\n.<br>\n<em><strong>tl;dr</strong><br>\nWe introduce a design for a credibly neutral preconfirmations registry that solves the collateral problem for solo-stakers who want to earn additional yield from preconfs, while simultaneously improving capital efficiency for large operators who would like to opt-in to preconfirmations.</em><br>\n.<br>\n.</p>\n<h2><a name=\"introduction-2\" class=\"anchor\" href=\"https://ethresear.ch#introduction-2\"></a>Introduction</h2>\n<p>There is a fundamental requirement of any proposer-commitment design that the L1 proposer must post some collateral. This is true for Based Preconfirmations (even with delegation) and other systems. This collateral is necessary because, according to the Ethereum protocol, a L1 proposer always has the option to self-build a block. The block that they build may violate commitments that they have made (or that other delegated entities have made).</p>\n<p>In the next few paragraphs, we introduce a simple system for proposer to post this collateral in ETH (the most credibly neutral collateral). This system also enables large operators and solo-stakers alike to post collateral in efficient ways.</p>\n<p><em>See <a href=\"https://docs.google.com/presentation/d/1M5nEpjSuEnuew_P8bdLIk-zZ-v55mWgbeiZ5czto8bI/edit?usp=sharing\" rel=\"noopener nofollow ugc\">my presentation introducing this topic</a> for another intro.</em></p>\n<h2><a name=\"onchain-construction-3\" class=\"anchor\" href=\"https://ethresear.ch#onchain-construction-3\"></a>Onchain Construction</h2>\n<p>The onchain construction is very simple:</p>\n<p>We introduce the <code>PreconfirmationRegistry</code> L1 smart contract that serves as a source of collateral for backing preconfirmations.</p>\n<p>The contract provides 4 functionalities:</p>\n<h3><a name=\"penalties-4\" class=\"anchor\" href=\"https://ethresear.ch#penalties-4\"></a>Penalties</h3>\n<p>The <code>PreconfirmationRegistry</code> facilitates penalty application (i.e. slashing, freezing).</p>\n<p>Delegates can choose what slashing conditions to opt-in to. These slashing conditions can be described using an EVM bytecode function.</p>\n<h3><a name=\"registration-5\" class=\"anchor\" href=\"https://ethresear.ch#registration-5\"></a>Registration</h3>\n<p>The <code>PreconfirmationRegistry</code> provides a way for a registrant to post ETH as collateral. A registrant can be any entity, it is represented in the registry as an Ethereum address.</p>\n<p>Let a <strong>registrant’s collateral balance</strong> = ETH deposited - ETH currently penalized - ETH withdrawn.</p>\n<h3><a name=\"delegation-6\" class=\"anchor\" href=\"https://ethresear.ch#delegation-6\"></a>Delegation</h3>\n<p>Allows registrants to delegate their collateral to proposers.</p>\n<p>Can be used to delegate to any proposer.</p>\n<p>Let a <strong>proposer’s collateral balance</strong> be the sum of the registrant collateral balance of all registrants that have delegated to them.</p>\n<p>If a proposer’s collateral balance is above a parameter, <code>MINIMUM_COLLATERAL</code>, they are a preconfer. If a proposer’s collateral balance falls below <code>MINIMUM_COLLATERAL</code>, they are no longer considered a preconfer.</p>\n<p>When a penalty is applied to a preconfer, the penalty is applied to the registrant collateral of any registrants who delegate to the offending preconfer. The penalty is split proportionally amongst the collateral that is delegated to a proposer.</p>\n<p><em>Note: Delegation can be done offchain and validated onchain in the case of a slashing event. Offchain signatures need to be shared publicly so that others (gateways) can verify that a given proposer is a preconfer.</em></p>\n<h3><a name=\"leader-election-7\" class=\"anchor\" href=\"https://ethresear.ch#leader-election-7\"></a>Leader Election</h3>\n<p>The <code>PrceonfirmationRegistry</code> also elects a leader for the current L1 slot. It does this by checking the lookahead to determine the next proposer in line who is a preconfer (meets the <code>MINIMUM_COLLATERAL</code> threshold.) Based Rollups can select this elected leader as the sequencer for their chains to achieve composability through shared sequencing.</p>\n<p>We call this leader the <strong>registry sponsored leader</strong>. Any rollup interested in composability can use this leader. Rollups that have other requirements for their leader (regulatory, financial) can use their own leader election system, but may ise the registry sponsored leader as a starting point.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/d/3/d3d476034f8a84825dfc2b477c02d88c53eef94f.png\" data-download-href=\"https://ethresear.ch/uploads/default/d3d476034f8a84825dfc2b477c02d88c53eef94f\" title=\"image\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/d/3/d3d476034f8a84825dfc2b477c02d88c53eef94f_2_690x394.png\" alt=\"image\" data-base62-sha1=\"udVWooZBrw6qHCBCeH4xBNck9CT\" width=\"690\" height=\"394\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/d/3/d3d476034f8a84825dfc2b477c02d88c53eef94f_2_690x394.png, https://ethresear.ch/uploads/default/optimized/3X/d/3/d3d476034f8a84825dfc2b477c02d88c53eef94f_2_1035x591.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/d/3/d3d476034f8a84825dfc2b477c02d88c53eef94f_2_1380x788.png 2x\" data-dominant-color=\"E9F0EA\"></a></div><p></p>\n<h2><a name=\"offchain-construction-8\" class=\"anchor\" href=\"https://ethresear.ch#offchain-construction-8\"></a>Offchain Construction</h2>\n<h3><a name=\"underwriters-9\" class=\"anchor\" href=\"https://ethresear.ch#underwriters-9\"></a>Underwriters</h3>\n<p>The most important offchain construction that we introduce is the Underwriter. The Underwriter acts as a registrant and posts at least <code>MINIMUM_COLLATERAL</code> ETH as collateral to the <code>PreconfirmationRegistry</code> contract on behalf of a group of proposers. The Underwriter accepts collateral from proposers in any form (a liquid staking token, equity, reputation).</p>\n<p>Underwriters could be trustless DeFi applications, offchain market makers, etc.</p>\n<h3><a name=\"proposer-pools-10\" class=\"anchor\" href=\"https://ethresear.ch#proposer-pools-10\"></a>Proposer Pools</h3>\n<p>While large staking operators form large trust networks between many proposers and can provide collateral on their own, solo-stakers do not have the same access to resources.</p>\n<p>Solo-stakers may form “Proposer Pools” of a collection of proposers, all restaking their ETH to a single registrant (through an underwriter) to reach a registrant balance of <code>MINIMUM_COLLATERAL</code> or more.</p>\n<p><em>Note: Proposer pools have a 1/n trust model: a single proposer could renege on preconfirmation promises for a significant profit but the entire pool would be penalized. To disincentivize this situation, proposer pools could be designed so that EL rewards are distributed between all proposers in the pool (similar to smoothing pools). With a MaxEB increase above <code>MINIMUM_COLLATERAL</code> and DVT, the trust model becomes n/3.</em></p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/a/9/a9982df96fdbf69566a89c5cc1e4306b9bca08d4.png\" data-download-href=\"https://ethresear.ch/uploads/default/a9982df96fdbf69566a89c5cc1e4306b9bca08d4\" title=\"image\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/a/9/a9982df96fdbf69566a89c5cc1e4306b9bca08d4_2_454x500.png\" alt=\"image\" data-base62-sha1=\"ociJCi8J8RpsBFe52mwVXGXk3Mo\" width=\"454\" height=\"500\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/a/9/a9982df96fdbf69566a89c5cc1e4306b9bca08d4_2_454x500.png, https://ethresear.ch/uploads/default/optimized/3X/a/9/a9982df96fdbf69566a89c5cc1e4306b9bca08d4_2_681x750.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/a/9/a9982df96fdbf69566a89c5cc1e4306b9bca08d4_2_908x1000.png 2x\" data-dominant-color=\"E9F0EA\"></a></div><p></p>\n<h2><a name=\"considerations-11\" class=\"anchor\" href=\"https://ethresear.ch#considerations-11\"></a>Considerations</h2>\n<ul>\n<li><strong><a href=\"https://nakamoto.com/credible-neutrality/\" rel=\"noopener nofollow ugc\">credible neutrality:</a></strong> The <code>PreconfirmationRegistry</code> only accepts the purest form of collateral: ETH. This avoids any dependence on any LST/LRT and minimizes smart contract risk.</li>\n<li><strong>centralization:</strong> The <code>PreconfirmationRegistry</code> does not introduce any permissioned actors. Underwriter centralization is not dangerous to the protocol.</li>\n<li><strong>collateral depeg risk:</strong> An <a href=\"https://x.com/daedalus_angels/status/1787797086219419687\" rel=\"noopener nofollow ugc\">external collateral depeg</a> will not affect the collateral that backs preconfers. Underwriters are only vulnerable to permanent depegs as they are not forced to sell during a temporary depeg event.</li>\n<li><strong>smart contract risk:</strong> The <code>PreconfirmationRegistry</code> is a very simple contract but should be audited extensively. Underwriters are especially incentivized to audit the <code>PreconfirmationRegistry</code> contract.</li>\n<li><strong>roadmap compatibility:</strong> Proposer Pools have even better trust models with a <a href=\"https://ethresear.ch/t/increase-the-max-effective-balance-a-modest-proposal/15801\">MaxEB increase</a> like <a href=\"https://eips.ethereum.org/EIPS/eip-7251\" rel=\"noopener nofollow ugc\">EIP-7251</a> and <a href=\"https://ethereum.org/en/staking/dvt/\" rel=\"noopener nofollow ugc\">DVT.</a> With <a href=\"https://ethresear.ch/t/why-enshrine-proposer-builder-separation-a-viable-path-to-epbs/15710\">ePBS</a>, <a href=\"https://ethresear.ch/t/execution-tickets/17944/1\">Execution Tickets</a>, <a href=\"https://mirror.xyz/barnabe.eth/QJ6W0mmyOwjec-2zuH6lZb0iEI2aYFB9gE-LHWIMzjQ\" rel=\"noopener nofollow ugc\">Execution Auctions / APS-Burn</a> or any other upgrade where proposers do not serve as monopoly sequencers, the <code>PreconfirmationRegistry</code> is no longer useful.</li>\n<li><strong>mass exits:</strong> To avoid a situation where a registrant withdraws collateral that is actively backing a preconfirmation, exits must be delayed. This mandates that there are three states that a proposer can exist in: <code>[INCLUDER, EXITING, PRECONFER]</code>. New preconfirmations should not be backed by collateral from <code>EXITING</code> proposers.</li>\n<li><strong>forced ejection:</strong> In a penalty event, some preconfers may no longer have enough unpenalized collateral to back their preconfirmations. If these preconfers are in the lookahead and actively providing preconfirmations, they must be immediately exited and treated as <code>INCLUDER</code> proposers. Registrants who wish to avoid forced ejection of their delegated proposers should top up their registrant balance to a level significantly higher than <code>MINIMUM_COLLATERAL</code>.</li>\n<li><strong>Preconf Chaining:</strong> Most preconfirmations are only backed by a single proposer (and therefore a single collateral balance), this enables registrants to delegate to many proposers simultaneously. There may be situations where preconfirmations are backed by multiple proposers (think conditional preconfirmations or multi-block preconfirmations). In these situations, the collateral that backs a preconfirmation is the combined <em>unique</em> proposer collateral balance of proposers involved. The odds of preconf chains applying to proposers using the same collateral are higher for registrants with more delegates, and therefore registrants who can afford to post extra collateral.</li>\n</ul>\n<h2><a name=\"bonus-dynamic-collateral-requirements-12\" class=\"anchor\" href=\"https://ethresear.ch#bonus-dynamic-collateral-requirements-12\"></a>Bonus: Dynamic Collateral Requirements</h2>\n<p>The <code>MINIMUM_COLLATERAL</code> parameter is a key parameter for preconfirmation security and bootstrapping a robust Preconfer set. Setting <code>MINIMUM_COLLATERAL</code> ex-ante for all preconfirmations may lead to inefficiencies. For example, many retail users don’t need thousands of ETH backing their preconfirmations. Indeed, many types of transactions (ETH/ERC20 transfers) are time-insensitive; preconfirmations for these transactions do not require huge amounts of collateral.</p>\n<p>The solution to this inefficiency is setting a low <code>MINIMUM_COLLATERAL</code> parameter and allowing users to set their own collateral requirements (along the lines of <a href=\"https://ethresear.ch/t/user-defined-penalties-ensuring-honest-preconf-behavior/19545\">User-Defined Penalties: Ensuring Honest Preconf Behavior</a> by <a href=\"https://x.com/_JonahB_\" rel=\"noopener nofollow ugc\">Jonah from Blockchain Capital</a>).</p>\n<p>Note that it is still necessary to set a <code>MINIMUM_COLLATERAL</code> value that is significant (likely more than 32 ETH) to avoid an adverse selection problem: A user might not be able to get a preconfirmation with a high collateral backing if a low-collateral Preconfer is first in the lookahead, even if a high-collateral Preconfer is next. More research is required to determine this parameter.</p>\n<h2><a name=\"bonus-slashing-conditions-13\" class=\"anchor\" href=\"https://ethresear.ch#bonus-slashing-conditions-13\"></a>Bonus: Slashing Conditions</h2>\n<p>Slashing conditions represent generic agreements between proposers and users. Delegates (proposers) can choose what slashing conditions to use. To declare their preferences, delegates can sign off on EVM bytecode that represents a function. When executed, this bytecode returns the penalties that should be applied:</p>\n<pre data-code-wrap=\"solidity\"><code class=\"lang-plaintext\">struct Penalty {\n    uint weiSlashed,\n    uint weiFrozen,\n    uint blocksFrozen,\n    // other penalties //\n}\n</code></pre>\n<p>Rollups that want to incentivize proposers to adopt their slashing conditions can set up incentives (tokens, fees, etc.) out of the registry.</p>\n<p><em><strong>Note:</strong> Registrants might also choose slashing conditions for their delegates. For example, an Underwriter might accept collateral from an operator and register with the slashing conditions that the operator desires. This simply a way for operators to manage the slashing conditions that they need to think about.</em></p>\n<hr>\n<p><strong>References + Resources</strong><br>\nAll documents used can be found <a href=\"https://mteam.space/eth-sequencing-preconfs-resources/\" rel=\"noopener nofollow ugc\">here</a>.</p>\n<p>Especially useful:</p>\n<ul>\n<li><a href=\"https://x.com/drakefjustin\" rel=\"noopener nofollow ugc\">Justin’s</a> <a href=\"https://ethresear.ch/t/based-rollups-superpowers-from-l1-sequencing/15016\">Based Rollup</a> post</li>\n<li><a href=\"https://x.com/drakefjustin\" rel=\"noopener nofollow ugc\">Justin’s</a> <a href=\"https://ethresear.ch/t/based-preconfirmations/17353\">Based Preconfirmations</a> post</li>\n<li><a href=\"https://x.com/_JonahB_\" rel=\"noopener nofollow ugc\">Jonah’s</a> <a href=\"https://ethresear.ch/t/user-defined-penalties-ensuring-honest-preconf-behavior/19545\">User-Defined Penalties…</a> post</li>\n<li><a href=\"https://limechain.tech/\" rel=\"noopener nofollow ugc\">Limechain’s</a> <a href=\"https://github.com/LimeChain/based-preconfirmations-research\" rel=\"noopener nofollow ugc\">Based Preconfirmations Research</a> repo</li>\n</ul>\n<p>Similar (unrelated) work:</p>\n<ul>\n<li><a href=\"https://primev.xyz\" rel=\"noopener nofollow ugc\">Primev’s</a> <a href=\"https://docs.primev.xyz/developers/contracts\" rel=\"noopener nofollow ugc\">Registry</a></li>\n<li><a href=\"https://puffer.fi\" rel=\"noopener nofollow ugc\">Puffer’s</a> <a href=\"https://docs.puffer.fi/nodes/registration\" rel=\"noopener nofollow ugc\">Registration System</a></li>\n<li><a href=\"https://x.com/cairoeth\" rel=\"noopener nofollow ugc\">Cairo’s</a> <a href=\"https://ethresear.ch/t/towards-an-implementation-of-based-preconfirmations-leveraging-restaking/19211\">preconf-operator code</a></li>\n<li>various <a href=\"https://ethstaker.cc/smoothing-pools\" rel=\"noopener nofollow ugc\">Smoothing Pool</a> designs</li>\n</ul>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://ethresear.ch/t/credibly-neutral-preconfirmation-collateral-the-preconfirmation-registry/19634\">Read full topic</a></p>","link":"https://ethresear.ch/t/credibly-neutral-preconfirmation-collateral-the-preconfirmation-registry/19634","pubDate":"Fri, 24 May 2024 21:34:51 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-19634"},"source":{"@url":"https://ethresear.ch/t/credibly-neutral-preconfirmation-collateral-the-preconfirmation-registry/19634.rss","#text":"Credibly Neutral Preconfirmation Collateral: The Preconfirmation Registry"},"filter":false},{"title":"Anonymous Inclusion Lists (anon-ILs)","dc:creator":"soispoke","category":"Cryptography","description":"<p>by <a href=\"https://ethresear.ch/u/soispoke/summary\">Thomas Thiery</a> and <a href=\"https://x.com/luca_zanolini\" rel=\"noopener nofollow ugc\">Luca Zanolini</a>, in collaboration with <a href=\"https://ethresear.ch/u/mmaller/summary\">Mary Maller</a>, <a href=\"https://x.com/Simk1n\" rel=\"noopener nofollow ugc\">Mark Simkin</a>, and <a href=\"https://ethresear.ch/u/asanso/summary\">Antonio Sanso</a></p>\n<p>– May 23rd, 2024</p>\n<p><em>Special thanks to <a href=\"https://ethresear.ch/u/julian/summary\">Julian Ma</a>, <a href=\"https://ethresear.ch/u/barnabe/summary\">Barnabé Monnot</a> and <a href=\"https://ethresear.ch/u/fradamt/summary\">Francesco D’Amato</a> for helpful comments and feedback.</em></p>\n<h2><a name=\"introduction-1\" class=\"anchor\" href=\"https://ethresear.ch#introduction-1\"></a>Introduction</h2>\n<p>Relying on a few sophisticated entities for building blocks on Ethereum weakens the network’s censorship resistance properties. Currently, more than <a href=\"https://censorship.pics/\" rel=\"noopener nofollow ugc\">60% of blocks</a> are made by builders who actively censor transactions interacting with sanctioned addresses. As a result, there has been renewed interest in finding ways to enable the <a href=\"https://www.ethernodes.org/countries\" rel=\"noopener nofollow ugc\">more decentralized set</a> of proposers to force-include transactions in Ethereum blocks. This interest has materialized in <a href=\"https://github.com/michaelneuder/mev-bibliography?tab=readme-ov-file#censorship-resistance\" rel=\"noopener nofollow ugc\">research and development</a> efforts focused on Inclusion Lists (ILs). Significant progress has been made towards the first practical implementation of ILs, which is currently considered for inclusion in the upcoming Pectra fork (see <a href=\"https://ethresear.ch/t/no-free-lunch-a-new-inclusion-list-design/16389\">design</a>, <a href=\"https://eips.ethereum.org/EIPS/eip-7547\" rel=\"noopener nofollow ugc\">EIP</a>, and <a href=\"https://notes.ethereum.org/@mikeneuder/il-spec-overview\" rel=\"noopener nofollow ugc\">specs</a> <a href=\"https://gist.github.com/michaelneuder/ba32e608c75d48719a7ecba29ec3d64b\" rel=\"noopener nofollow ugc\">here</a>).</p>\n<p>Concurrent efforts have focused on improving the robustness of IL designs by limiting dependence on single entities for creating and proposing ILs, such as through <a href=\"https://ethresear.ch/t/the-more-the-less-censored-introducing-committee-enforced-inclusion-sets-comis-on-ethereum/18835\">Committee-enforced Inclusion Sets (COMIS)</a> and <a href=\"https://ethresear.ch/t/concurrent-block-proposers-in-ethereum/18777/6\">Multiple Concurrent Proposers</a>. However, to our knowledge, no efforts have been made to develop a mechanism that protects the identity of participants involved in the construction of an IL, while also reducing the surface for <a href=\"https://ethresear.ch/t/fun-and-games-with-inclusion-lists/16557\">commitment attack vectors</a> like bribing and extortion games.</p>\n<p>Protecting the identity of IL proposers is crucial to ensure privacy, safeguard against any form of accountability or identity reveal, and boost the adoption of ILs on Ethereum. This principle is akin to the confidentiality provided in voting systems, where participants can express their preferences without the risk of exposure or retaliation (e.g., legal repercussions). Here, we address this gap by introducing anonymous Inclusion Lists (anon-IL), a design that leverages linkable ring signatures and an anonymous broadcast protocol (ABP) to anonymize IL proposers on Ethereum.</p>\n<h4><a name=\"disclaimer-2\" class=\"anchor\" href=\"https://ethresear.ch#disclaimer-2\"></a>Disclaimer</h4>\n<p>This post is intended as an initial exploration of a distributed mechanism for anonymizing IL proposers, setting the stage for future research and discussions. We build the mechanism in a modular fashion, detailing each module’s role and the properties we believe are necessary to achieve anonymity. These modules can be swapped with others or studied as independent building blocks.</p>\n<h2><a name=\"high-level-idea-3\" class=\"anchor\" href=\"https://ethresear.ch#high-level-idea-3\"></a>High-level idea</h2>\n<p>Every slot <code>n</code>, a subset <span class=\"math\">C</span> of the beacon committee, referred to as the IL committee, is randomly selected from validators to participate in the construction of a global inclusion list (<span class=\"math\">IL^G</span>), composed of transactions <span class=\"math\">t</span> pending in the mempool. During the construction of <span class=\"math\">IL^G</span>, a subset <span class=\"math\">P</span> of IL committee members are secretly elected to become IL proposers and create, sign, and disseminate local inclusion lists <span class=\"math\">IL^L</span> without revealing their identities (<strong>Round 1</strong>). A randomly selected IL proposer, the IL aggregator <span class=\"math\">A</span>, collects all observed <span class=\"math\">IL^L</span> to create and distribute the raw <span class=\"math\">IL^G</span> transactions and their associated <span class=\"math\">IL^G_\\text{summary}</span> to the rest of <span class=\"math\">IL</span>  committee members, who then vote on the <span class=\"math\">IL^G_\\text{summary}</span> validity (<strong>Round 2</strong>). Figure 1. illustrates how <span class=\"math\">P</span>, <span class=\"math\">C</span> and <span class=\"math\">A</span> are selected from validators in the beacon committee. If deemed valid, block <code>n+1</code> must include the <span class=\"math\">IL^G_\\text{summary}</span>, a quorum certificate proving its validity and the transactions that satisfy summary entries. Crucially, we use a linkable ring signature scheme and an anonymous broadcast protocol (ABP) to ensure IL committee members can sign and broadcast messages (ILs, votes) without revealing their identity.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/8/e/8eb6e389256d6deab365d99d43f65547bdfd3ac4.png\" data-download-href=\"https://ethresear.ch/uploads/default/8eb6e389256d6deab365d99d43f65547bdfd3ac4\" title=\"Screenshot 2024-05-13 at 10.38.02\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/8/e/8eb6e389256d6deab365d99d43f65547bdfd3ac4_2_507x500.png\" alt=\"Screenshot 2024-05-13 at 10.38.02\" data-base62-sha1=\"kmvDzwPMjP4cIuiUKsP5g3pBBvC\" width=\"507\" height=\"500\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/8/e/8eb6e389256d6deab365d99d43f65547bdfd3ac4_2_507x500.png, https://ethresear.ch/uploads/default/optimized/3X/8/e/8eb6e389256d6deab365d99d43f65547bdfd3ac4_2_760x750.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/8/e/8eb6e389256d6deab365d99d43f65547bdfd3ac4_2_1014x1000.png 2x\" data-dominant-color=\"F0F0F0\"></a></div><p></p>\n<blockquote>\n<p><strong>Figure 1.</strong> <strong>Anon-IL participant selection.</strong> In each slot, 256 validators are randomly selected from the beacon committee to form the publicly known IL committee <span class=\"math\">C</span>. Half of the IL committee members (i.e., <code>≈128</code>), the IL proposers <span class=\"math\">P</span>, are secretly elected to participate in the IL construction. One of these proposers is randomly selected to serve as the IL aggregator <span class=\"math\">A</span>, who is in charge of gossiping the final global IL so it can be validated by other IL proposers.</p>\n</blockquote>\n<h2><a name=\"design-4\" class=\"anchor\" href=\"https://ethresear.ch#design-4\"></a><strong>Design</strong></h2>\n<p>In this section, we illustrate (Figure 2.) and provide a step-by-step description of the anon-IL mechanism.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/e/c/ecbce502f9d9d77875579518d3612c95e78e5653.png\" data-download-href=\"https://ethresear.ch/uploads/default/ecbce502f9d9d77875579518d3612c95e78e5653\" title=\"Screenshot 2024-04-24 at 16.51.22\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/e/c/ecbce502f9d9d77875579518d3612c95e78e5653_2_690x375.png\" alt=\"Screenshot 2024-04-24 at 16.51.22\" data-base62-sha1=\"xMho2FddtvumC4sBDT19lgWCS5l\" width=\"690\" height=\"375\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/e/c/ecbce502f9d9d77875579518d3612c95e78e5653_2_690x375.png, https://ethresear.ch/uploads/default/optimized/3X/e/c/ecbce502f9d9d77875579518d3612c95e78e5653_2_1035x562.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/e/c/ecbce502f9d9d77875579518d3612c95e78e5653_2_1380x750.png 2x\" data-dominant-color=\"EEEEE9\"></a></div><p></p>\n<blockquote>\n<p><strong>Figure 2.</strong> <strong>Diagram illustrating the anon-IL design.</strong></p>\n</blockquote>\n<h3><a name=\"round-1-5\" class=\"anchor\" href=\"https://ethresear.ch#round-1-5\"></a><strong>Round 1</strong></h3>\n<ol>\n<li>In each slot, 256 validators are selected from the beacon committee to build inclusion lists. These <code>256</code> IL committee members are publicly known.</li>\n<li>Out of the <code>256</code> IL committee members, only half of them, on average (i.e., <code>≈128</code>) are secretly elected as IL proposers <span class=\"math\">P</span> to prepare local inclusion lists (<span class=\"math\">IL^L</span>) of transactions observed in the mempool and participate in a ring signature scheme. Each IL proposer signs their list using their private key, along with the public keys of all <code>256</code> IL committee members. Each IL proposer then gossips their <span class=\"math\">IL^L</span>, along with its ring signature, to a dedicated <code>inclusion_set</code> subnet through an ABP, before the slot <code>n</code> deadline <span class=\"math\">d</span>.</li>\n</ol>\n<h3><a name=\"round-2-6\" class=\"anchor\" href=\"https://ethresear.ch#round-2-6\"></a>Round 2</h3>\n<ol>\n<li>An IL aggregator is randomly selected amongst IL proposers that successfully sent commitments during the first round of the linkable ring signature scheme (see <em>Building Blocks</em> section below). Its role is to collect all observed <span class=\"math\">IL^L</span> before the deadline <span class=\"math\">d</span>, constructs a final, deduplicated global inclusion list (<span class=\"math\">IL^G</span>) if transactions are seen in more than the inclusion threshold (e.g., <code>10%</code>) of the available <span class=\"math\">IL^L\\text{s}</span>, and derives an <span class=\"math\">IL^G</span> summary from them. <span class=\"math\">IL^G_\\text{summary}</span>  consists of a list of (<code>address</code>, <code>gasLimit</code>) pairs, which specify the <code>from</code> and <code>gasLimit</code> for each transaction across all  <span class=\"math\">IL^L</span>. Each pair is referred to as an <code>Entry</code>. The aggregator’s <span class=\"math\">IL^G_\\text{summary}</span> with signatures from all IL proposers and the list of raw transactions corresponding to summary entries are then broadcast in the <code>inclusion_set</code> subnet using the ABP used in <strong>Round 1</strong>.</li>\n<li>IL proposers also collect all observed <span class=\"math\">IL^L</span>, and construct their own <span class=\"math\">IL^Gs</span> to evaluate the <span class=\"math\">IL^G_\\text{summary}</span> produced by the aggregator. If transactions in their own <span class=\"math\">IL^G</span> overlap with a given percentage of entries in the aggregator’s <span class=\"math\">IL^G_\\text{summary}</span>, they vote <code>TRUE</code>.  This step ensures a quality check on the global IL proposed by the aggregator, and prevents the generation of arbitrary ILs by a single party. To preserve the anonymity of voters, votes are also gossiped using the same ring signature scheme and ABP.  If enough <code>TRUE</code> votes are received, the IL aggregator (anonymously) broadcasts a valid  <span class=\"math\">IL^G_\\text{summary}</span>, <span class=\"math\">IL^G</span> raw transactions, and a quorum certificate that verifies the accumulation of sufficient <code>TRUE</code> votes (<img src=\"https://ethresear.ch/images/emoji/facebook_messenger/white_check_mark.png?v=12\" title=\":white_check_mark:\" class=\"emoji\" alt=\":white_check_mark:\" loading=\"lazy\" width=\"20\" height=\"20\">) over the global topic, via the ABP.</li>\n</ol>\n<h3><a name=\"block-validity-7\" class=\"anchor\" href=\"https://ethresear.ch#block-validity-7\"></a><strong>Block validity</strong></h3>\n<ol>\n<li>\n<p>To be considered valid, the block <code>n+1</code> must include:</p>\n<ul>\n<li>The <span class=\"math\">IL^G_\\text{summary}</span> and its associated quorum certificate <img src=\"https://ethresear.ch/images/emoji/facebook_messenger/white_check_mark.png?v=12\" title=\":white_check_mark:\" class=\"emoji\" alt=\":white_check_mark:\" loading=\"lazy\" width=\"20\" height=\"20\"></li>\n<li>Raw transactions satisfying the <span class=\"math\">IL^G_\\text{summary}</span> entries</li>\n</ul>\n<p>Attesters must verify whether the block proposed by proposer <code>n+1</code> included all transactions satisfying the valid <span class=\"math\">IL^G_\\text{summary}</span> entries gossiped by the aggregator, in addition to all other standard validity checks before casting an attestation for the block <code>n+1</code>.</p>\n<p>Upon confirming the block’s validity, attesters cast an attestation for block <code>n+1</code>.</p>\n<p>If an <span class=\"math\">IL^G</span> is not made available on time or if a quorum of <code>TRUE</code> votes is not reached, block <code>n+1</code> is valid without including transactions satisfying an IL.</p>\n</li>\n</ol>\n<h2><a name=\"building-blocks-8\" class=\"anchor\" href=\"https://ethresear.ch#building-blocks-8\"></a><strong>Building blocks</strong></h2>\n<p>In this section, we introduce the process for selecting validators to become IL committee members and present the two main components of anon-IL: a linkable ring signature scheme, which allows selected validators to sign their local inclusion lists and votes, thereby proving their membership in the IL committee without revealing their identity; and a synchronous anonymous broadcast protocol, which enables IL committee members to disseminate messages across the peer-to-peer subnet without their identities being revealed by network traffic patterns.</p>\n<h3><a name=\"linkable-ring-signatures-scheme-9\" class=\"anchor\" href=\"https://ethresear.ch#linkable-ring-signatures-scheme-9\"></a>Linkable ring signatures scheme</h3>\n<p>A linkable ring signature is a cryptographic construct that allows a member of a group (ring) to anonymously sign a message on behalf of the group. This type of signature ensures the following properties:</p>\n<ol>\n<li><strong>Anonymity</strong>: The identity of the signer is hidden within the group. Any member of the ring could have potentially signed the message, making it impossible to determine the actual signer.</li>\n<li><strong>Linkability</strong>: Even though the identity of the signer is hidden, it is possible to determine if two different messages were signed by the same member of the group. This is done without revealing which member it was. This property prevents double-signing by the same individual without revealing their identity.</li>\n</ol>\n<p>Each participant in the ring maintains a pair of public and private keys. The public keys are known to everyone and are collectively used to form the ring. The signer selects several public keys from the group, typically including their own, to create a ring. This selection is done such that it is impossible to identify who among the participants is the actual signer, preserving anonymity within the group. Importantly, verification of the signature is straightforward and does not require any special access or permissions; anyone with access to the public keys of the ring members can verify that the signature is valid and was created by one of the ring’s members. This ensures that any participant could potentially be the signer of a specific transaction, maintaining robust anonymity and security.</p>\n<p>For the anon-IL design, we use the <a href=\"https://eprint.iacr.org/2014/764.pdf\" rel=\"noopener nofollow ugc\">“one-out-of-many”</a> ring signature scheme by <a href=\"https://eprint.iacr.org/2014/764\" rel=\"noopener nofollow ugc\">Groth and Kohlweiss</a>. In this scheme, participants “<em>have public keys that are commitments and demonstrate knowledge of an opening for one of the commitments to unlinkably identify themselves as belonging to the group”</em>. The only cryptography this scheme relies on is group operations and hash functions. The zero-knowledge prover and verifier also work out of the box and do not need edits, making it particularly suited for the anon-IL use case. Finally, we expect it to scale well for the number of participants selected in the IL committee.</p>\n<h3><a name=\"il-committee-selection-10\" class=\"anchor\" href=\"https://ethresear.ch#il-committee-selection-10\"></a>IL committee selection</h3>\n<ul>\n<li>Each slot, <code>256</code> validators in the beacon committee are randomly chosen to form the IL committee <span class=\"math\">C</span> (i.e., the ring). These IL committee members have to send a commitment to prove they are part of the ring.</li>\n<li>Half of the IL committee members (<code>128</code>) are then secretly elected to be IL proposers <span class=\"math\">P</span>  and actively participate in the construction of the IL.</li>\n<li>One IL aggregator <span class=\"math\">A</span> is chosen from the set of IL proposers that successfully sent a commitment during the first round of the ring signature scheme.</li>\n</ul>\n<h3><a name=\"anonymous-broadcast-protocol-11\" class=\"anchor\" href=\"https://ethresear.ch#anonymous-broadcast-protocol-11\"></a>Anonymous Broadcast Protocol</h3>\n<p>While we employ a linkable ring signature scheme to conceal the identity of the signer of an IL, it is also crucial to anonymize the sender. This necessity arises because, despite the signer’s identity being obscured by the ring signature scheme, there remains a risk that observers might link the signer’s identity to the entity that transmitted the ring-signed IL. This linkage could occur through the analysis of metadata or network patterns associated with the transmission. To prevent this and fully protect the anonymity of the proposer, an anonymous broadcast protocol seems essential. This protocol would ensure that the transmission of the signed IL cannot be traced back to its origin, thereby safeguarding the identities involved.</p>\n<p><strong>Overview</strong></p>\n<p>We introduce an Anonymous Broadcast Protocol (ABP) inspired by <a href=\"https://arxiv.org/pdf/1701.04439.pdf\" rel=\"noopener nofollow ugc\">Dandelion</a> and <a href=\"https://arxiv.org/pdf/1805.11060.pdf\" rel=\"noopener nofollow ugc\">Dandelion ++</a> and tailored to fit Ethereum’s requirements. The ABP is designed to safeguard committee members from de-anonymization attacks when gossiping messages (i.e., ILs and votes). This is achieved by routing their communications through a randomized, multi-phase process that conceals the origins of messages, thereby significantly complicating the efforts to trace these back to their original source based on network traffic. The protocol consists of two phases: the <em>STEM</em> phase and the <em>FLUFF</em> phase. During the <em>STEM</em> phase, each committee member, acting either as a relay or a diffuser, forwards their locally generated inclusion list to one or two peers. A committee member can either be a relay or a diffuser. If a committee member acts as a relay, upon receiving a local inclusion list, it will forward this list to another peer or two peers. If a committee member is a diffuser, it initiates the <em>FLUFF</em> phase by broadcasting the received list to all members. It is important to note that a diffuser’s role, which involves functioning as such for every message, is determined through a randomized mechanism that takes into account the slot number and the member’s identity.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/5/7/575ee622a8461194f628cc123b3b8665b360deca.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/575ee622a8461194f628cc123b3b8665b360deca\" title=\"Screenshot 2024-05-23 at 09.56.42\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/5/7/575ee622a8461194f628cc123b3b8665b360deca_2_690x198.jpeg\" alt=\"Screenshot 2024-05-23 at 09.56.42\" data-base62-sha1=\"csURjWrQRd5xgh2DwMtLv0Hx8jE\" width=\"690\" height=\"198\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/5/7/575ee622a8461194f628cc123b3b8665b360deca_2_690x198.jpeg, https://ethresear.ch/uploads/default/optimized/3X/5/7/575ee622a8461194f628cc123b3b8665b360deca_2_1035x297.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/5/7/575ee622a8461194f628cc123b3b8665b360deca_2_1380x396.jpeg 2x\" data-dominant-color=\"F6F6F6\"></a></div><p></p>\n<blockquote>\n<p><strong>Figure 3. Life cycle of a message during the execution of the ABP</strong> in slot <code>n</code> during (A) the STEM and (B) the FLUFF phase. Sender nodes are coloured in white, relay nodes are coloured in black, and diffuser nodes in red.</p>\n</blockquote>\n<p>For further clarity:</p>\n<ul>\n<li>The protocol starts with the <em>STEM</em> phase: each committee member sends their local inclusion list via two different routes within a 4-regular graph (i.e., a type of network where every node is connected to exactly 4 nodes). This 4-regular graph is part of a larger network <span class=\"math\">G</span>, which overlays all IL committee members selected for the specific slot.</li>\n<li>The structure of this graph requires each committee member to randomly select the next two relay nodes, which also introduces a random delay for each message hop throughout the graph.</li>\n<li>Upon receiving a local inclusion list from another member, the recipient determines its role for that slot — either a relay or a diffuser. As a relay, the member follows the forwarding procedure described in the previous point. As a diffuser, the member starts the <em>FLUFF</em> phase.</li>\n<li>In the <em>FLUFF</em> phase, committee members disseminate their local inclusion lists simultaneously to all members.</li>\n<li>While functioning as a relay during the <em>STEM</em> phase, a committee member also starts a timing deadline <span class=\"math\">f</span> for every message it receives. In this way we implement a fail-safe mechanism that requires relays to monitor whether their forwarded message is successfully diffused. This is designed to prevent black-hole attacks, where a malicious node in the path decides not to forward the message. Specifically, the protocol sets a random expiration timer at each <em>STEM</em> relay immediately upon receiving transaction messages. The relay then monitors the network to see if the transaction reappears. If the timer expires without the transaction reappearing, the node autonomously diffuses the transaction. In Dandelion++, this mechanism offers two key advantages: (1) it ensures that messages are guaranteed to eventually propagate through the network, and (2) the random timers help to anonymize peers initiating the spreading phase, mitigating the risk of black-hole attacks.</li>\n</ul>\n<p><strong>ABP Parameters</strong></p>\n<p>We conducted preliminary analyses to determine the ABP parameters necessary for it to function effectively under Ethereum’s time and bandwidth constraints. These analyses are an initial step toward understanding the trade-offs and consequences of selecting these parameters. A detailed, comprehensive analysis should also be conducted to evaluate the effects of delays, the number of participants, and role distribution (relays vs. diffusers) on the security and anonymization guarantees that anon-IL provides. As previously mentioned, our design requires two rounds of message exchange (one for local ILs, one for voting on the global IL), meaning the ABP must run twice per 12-second slot. We assume a maximum IL size of <code>3M</code> gas, which corresponds to approximately <code>0.33 Mb</code> (see Appendix 1.1 for more details). We expect the ring signature scheme to take around 1 second per round, leaving <code>5 seconds</code> per round for the ABP to complete both the <em>STEM</em> and <em>FLUFF</em> phases. We evaluated the impact of transmission delays and network size on propagation time (Appendix 1.2), and the impact of Byzantine nodes on message propagation success (Appendix 1.3). This evaluation helped us choose initial parameters for the ABP and allocate <code>2.5 seconds</code> for each phase (<em>STEM</em> and <em>FLUFF</em>), a network size of <code>128 nodes</code>, and an added transmission delay randomly chosen between <code>100 ms</code> and <code>900 ms</code>.</p>\n<h2><a name=\"evaluation-and-tradeoffs-12\" class=\"anchor\" href=\"https://ethresear.ch#evaluation-and-tradeoffs-12\"></a>Evaluation and tradeoffs</h2>\n<p>In this section, we discuss how to evaluate anon-IL and the tradeoffs that were made in its design.</p>\n<h3><a name=\"anonymity-guarantees-13\" class=\"anchor\" href=\"https://ethresear.ch#anonymity-guarantees-13\"></a>Anonymity guarantees</h3>\n<p>The core idea behind anon-IL is to allow validators to participate in building ILs without revealing their identity. This is achieved using a linkable ring signature scheme. Importantly, having twice as many IL committee members (<code>256</code>) as secret IL proposers (<code>128</code>) allows each participant to plausibly deny having signed or sent any specific message. Moreover, IL proposers use an anonymous broadcast protocol to gossip messages, further protecting their anonymity from external observers analyzing network traffic. The effectiveness of these anonymity guarantees depends on:</p>\n<ul>\n<li>The cryptographic integrity of the chosen ring signature scheme: Here, we utilize Groth-Kohlweiss signatures that enable all IL proposers to sign in under a second while maintaining robust security. The signatures can theoretically provide long-term anonymity that is secure against advances in cryptanalysis because the protocol achieves statistical zero-knowledge. A caveat: this assumes the validators are using good sources of randomness and that there are no implementation bugs.</li>\n<li>The ABP design and its associated parameters were inspired by <a href=\"https://arxiv.org/pdf/1805.11060\" rel=\"noopener nofollow ugc\">Dandelion++</a>. The parameters were adapted to meet the time constraints imposed by Ethereum’s 12-second slot duration. Further analyses are necessary to assess the anonymity guarantees provided by the roles assigned to nodes (relays or diffusers), the network size (i.e., the number of IL proposers), and the maximum random delay introduced when messages are broadcast to other nodes. Preliminary analyses in Appendix 1 helped establish credible parameters for this post. To comprehensively evaluate the protocol’s robustness, it is crucial to conduct in-depth simulations and set up devnets to assess the anonymity guarantees under real and varied network conditions.</li>\n</ul>\n<p>Assuming anon-IL provides strong anonymity guarantees, we believe it represents a substantial improvement over other IL designs. Allowing validators to participate in preserving <a href=\"https://ethresear.ch/t/uncrowdable-inclusion-lists-the-tension-between-chain-neutrality-preconfirmations-and-proposer-commitments/19372\">chain neutrality</a> while being protected from targeted legal or regulatory measures significantly improves the chances of IL adoption. Currently, according to censorship.pics, about 7.5% of proposers censor transactions. This percentage might increase with the introduction of ILs because proposer agency would be explicitly required. By protecting their identity, we allow the entire validator set, including proposers censoring transactions today, to participate in improving the censorship resistance properties of the network without being targeted by regulatory measures. Furthermore, relying on a secretly chosen set of IL proposers to participate in the construction of ILs decreases the viability of <a href=\"https://ethresear.ch/t/fun-and-games-with-inclusion-lists/16557\">commitment attacks</a>. It seems reasonable to conjecture that our design would require an attacker to bribe a significant fraction of the <code>256</code> IL committee members to have a transaction included or excluded from the global IL. Unlike <a href=\"https://ethresear.ch/t/the-more-the-less-censored-introducing-committee-enforced-inclusion-sets-comis-on-ethereum/18835\">COMIS</a>, in anon-IL the IL aggregator also uses the ABP to broadcast its global IL to other committee members, which essentially removes commitment attacks targeted to a single party, unless the aggregator willingly self-reveals. An attacker can always target the proposer <code>n+1</code>, but it would force it to miss its slot (otherwise the block isn’t valid), missing out on all execution and consensus layer rewards, and potentially incurring <a href=\"https://ethresear.ch/t/missed-slot-penalties-temperature-check/18713\">missed slot penalties</a> in the future.</p>\n<h3><a name=\"inclusion-guarantees-14\" class=\"anchor\" href=\"https://ethresear.ch#inclusion-guarantees-14\"></a>Inclusion guarantees</h3>\n<p>In anon-IL, inclusion guarantees are explicitly determined during <strong>Round 2</strong> with the inclusion threshold, with which IL aggregators include transactions if they are seen in more than <code>X%</code> of the <span class=\"math\">IL^L\\text{s}</span> they collected. We propose to set this inclusion threshold to <code>10%</code>, which means every transaction that ends up being included in more than <code>12 out 128</code> IL proposers’ local ILs should be included in the <span class=\"math\">IL^G</span> and its associated summary.  Choosing a relatively low, non-zero inclusion threshold provides good inclusion guarantees while preventing spam transactions coming a single party from filling the global IL. This approach avoids the scenario where a single IL proposer could flood the system with its transactions, ensuring that only those transactions that overlap with other proposers’ local ILs are included. By requiring that transactions must be seen in multiple local lists, the protocol mitigates the risk of a malicious IL proposer dominating the global list with spam transactions. This selective inclusion helps maintain the integrity and efficiency of the IL. Another parameter in <strong>Round 2</strong> also affects inclusion guarantees, since <code>TRUE</code> votes are cast only if transactions IL proposers <span class=\"math\">IL^G\\text{s}</span> satisfy at least some proportion of entries in the aggregator’s <span class=\"math\">IL^G_\\text{summary}</span>. This gives some leeway for IL proposers who may have missed some of the <span class=\"math\">IL^L\\text{s}</span> gossiped during Round 1 due to p2p network latency. However, we recommend a high overlap percentage (e.g., 90%) to constrain the aggregator’s  <span class=\"math\">IL^G</span> construction and improve inclusion guarantees.</p>\n<p>We also need to consider scenarios where ILs are full. How should IL proposers and the aggregator construct ILs when transactions eligible for inclusion exceed the IL gas limit (i.e., <code>3M</code> gas)? If stuffing ILs becomes a profitable strategy, coordinated IL proposers exceeding the inclusion threshold could potentially add the exact same transactions in their <span class=\"math\">IL^L\\text{s}</span>, thereby crowding out other candidate transactions. To mitigate this concern, we could:</p>\n<ul>\n<li>Establish a priority rule for ordering IL transactions: Transactions that appear most frequently across all collected <span class=\"math\">IL^L\\text{s}</span> should be given priority for inclusion.</li>\n<li>Increase the inclusion threshold.</li>\n<li>Increase IL size to fit more transactions. We could also consider conditional ILs that could be larger, or ILs with <a href=\"https://ethresear.ch/t/cumulative-non-expiring-inclusion-lists/16520\">cumulative, non-expiring</a> properties.</li>\n</ul>\n<h3><a name=\"incentives-scheme-15\" class=\"anchor\" href=\"https://ethresear.ch#incentives-scheme-15\"></a>Incentives scheme</h3>\n<p>The most obvious drawback of protecting IL proposers’ identities is that it makes it very difficult to devise incentive schemes to reward parties that provide useful inputs to the mechanism or penalize those who do not. In this post, anon-IL does not reward IL committee members in any way, and assumes that contributing to improving the censorship-resistance properties of the network is a task that validators can take on without expecting additional rewards. That said, we could design incentives that rely on metrics to evaluate the quality of the global IL constructed by IL proposers without having to identify specific contributors to reward individual inputs. For example, the IL committee members could be uniformly rewarded based on the overlap between all local ILs, encouraging IL proposers to include all public transactions they see pending in the mempool.</p>\n<p>Here’s a simple model to implement this, if we assume rewards come from fees associated with transactions (see conditional tipping). We let <span class=\"math\">C</span> represent the total number of committee members (in the current anon-IL design, <code>256</code>), and <span class=\"math\">T</span> denote the set of all transactions pending in the mempool. Each transaction <span class=\"math\">t</span> in <span class=\"math\">T</span> is associated with a fee <span class=\"math\">f_t</span>, and <span class=\"math\">I_i</span> is the set of transactions included by proposer <span class=\"math\">i</span> in their local ILs.</p>\n<ul>\n<li><strong>Reward Calculation</strong>:\n<ul>\n<li>The intersection <span class=\"math\">U</span> of transactions included by all IL committee members is computed as <span class=\"math\">U = I_1 \\cap I_2 \\cap \\ldots \\cap I_N</span>.</li>\n<li>The reward for each committee member <span class=\"math\">i</span>, <span class=\"math\">R_i</span>, is calculated as follows:</li>\n</ul>\n</li>\n</ul>\n<div class=\"math\">\nR_i = \\frac {1} {N} ∑_{t ∈ U} f_t\n</div>\n<ul>\n<li><strong>Example Scenarios</strong>:\n<ul>\n<li><strong>Scenario 1</strong>: All members (A, B, and C) include all 5 transactions in their ILs, with the transactions being <span class=\"math\">T = {t_1, t_2, t_3, t_4, t_5}</span> and fees <span class=\"math\">f_{t_1} = 0.1, f_{t_2} = 0.3, f_{t_3} = 0.4, f_{t_4} = 1, f_{t_5} = 0.6</span>. Given all members include all transactions, the reward calculation simplifies as each proposer includes the same set of transactions <span class=\"math\">U = T</span>, and<br>\n<span class=\"math\">R_i = \\frac {1} {3}(0.1+0.3+0.4+1+0.6) = 0.8</span> for each member.</li>\n<li><strong>Scenario 2</strong>: Suppose proposers A and B include 4 transactions each (say <span class=\"math\">t_1</span> to <span class=\"math\">t_4</span>), while C includes only 2 transactions (<span class=\"math\">t_1</span> and <span class=\"math\">t_2</span>). The transactions common to all members are <span class=\"math\">U = {t_1, t_2}</span>, and the rewards are computed as: <span class=\"math\">R_i = \\frac {1} {3}(0.1+0.3) = \\frac {0.4} {3} ≈ 0.133</span> each.</li>\n</ul>\n</li>\n</ul>\n<p>Note that if rewards came from issuance, we could also consider the number of IL proposers (out of all possible ones) who contributed to incentivize participation. Another interesting avenue would be to all committee members participate in a lottery. All <code>256</code> participants have a chance of winning the lottery and getting a share of the rewards, but the winning probability can be biased by having IL proposers and the aggregator secretly prove things about their role and their contributions. This would provide a way to reward individual roles or contributions, while still providing plausible deniability (e.g., “I got rewards because I got lucky but I didn’t actually participate in creating a list at all”). We think that exploring solutions to reward IL proposers for their contributions without compromising their anonymity—such as using shielded reward pools, stealth addresses, or fully homomorphic encryption in the future—merits further investigation.</p>\n<h3><a name=\"il-properties-16\" class=\"anchor\" href=\"https://ethresear.ch#il-properties-16\"></a>IL properties</h3>\n<ul>\n<li><strong>Spot:</strong> Since parties other than proposers are responsible for building $IL$s (<span class=\"math\">IL</span> proposers and aggregators), the anon-IL mechanism can run in parallel of the block construction process, which effectively gives real-time censorship resistance at the block level.</li>\n<li><strong><a href=\"https://ethresear.ch/t/unconditional-inclusion-lists/18500\">Unconditional</a></strong>: This property ensures that once an IL includes a transaction, that transaction is guaranteed to go onchain at the latest in slot <code>n+1</code>.\n<ul>\n<li><strong>End-of-block</strong>: The spot, unconditional anon-ILs should be appended at the end of block <code>n+1</code>. Importantly, if transactions satisfying IL summary requirements are already included in the payload, they will take precedence over IL transactions. Should this occur, IL transactions would be reverted.</li>\n</ul>\n</li>\n<li><strong><a href=\"https://ethresear.ch/t/uncrowdable-inclusion-lists-the-tension-between-chain-neutrality-preconfirmations-and-proposer-commitments/19372\">Uncrowdability</a>:</strong> We believe the aforementioned anon-IL properties make them “inconvenient enough” for uses other than chain neutrality. Frontrunnable, end-of-block transactions that need to be seen by a set of secretly elected participants (i.e., made public) offer few opportunities to introduce secondary markets for MEV or preconfirmations.</li>\n</ul>\n<h3><a name=\"byzantine-and-fault-tolerance-17\" class=\"anchor\" href=\"https://ethresear.ch#byzantine-and-fault-tolerance-17\"></a>Byzantine and fault tolerance</h3>\n<p>In anon-IL, Byzantine nodes are capable of launching various attacks at different stages of the mechanism. These attacks can be broadly categorized into two types:</p>\n<ul>\n<li><strong>De-anonymization Attacks:</strong> These are attempts by either external or internal parties to compromise the anonymity of IL committee members, proposers, and aggregators, thereby increasing the likelihood of revealing their identities. A critical factor to consider is that a single entity owning a significant stake could control a large portion of the IL committee. Therefore, the mechanism must be designed to resist de-anonymization efforts, even when many of the committee’s validators are affiliated with the same entity.</li>\n<li><strong>Liveness Attacks:</strong> IL proposers may choose not to engage in the creation, signing, or broadcasting of ILs. This non-participation can lead to liveness faults, characterized by the failure to propagate messages throughout the network. An example of this can be found in Appendix 1.2, where we examine the impact of so-called “black-hole” attacks — scenarios in which Byzantine nodes choose not to forward any messages — on the success of message propagation during the <em>STEM</em> phase. To counteract this attack, we introduce a fail-safe mechanism that requires nodes to monitor whether their messages have been successfully propagated by the end of the <em>STEM</em> phase and to initiate message diffusion themselves if propagation has not occurred.</li>\n</ul>\n<p>Thorough security analyses must be conducted to mitigate de-anonymization and liveness attacks to the best of our ability. However, it is also important to keep in mind that the worst case scenario leads to an IL not being built for one slot: Censorable transactions would likely still be pending in the mempool, and can be picked up by the next IL committee.</p>\n<h2><a name=\"limitations-18\" class=\"anchor\" href=\"https://ethresear.ch#limitations-18\"></a>Limitations</h2>\n<p>Our approach to anonymizing IL proposers on Ethereum, while robust in its design, encounters specific limitations that merit attention:</p>\n<ul>\n<li><strong>Adaptation of the Anonymous Broadcast Protocol (ABP)</strong>: A central element in our mechanism is the ABP, a modified version of the Dandelion++ protocol originally designed for asynchronous communication. For our purposes, we have adapted it to a synchronous setting, maintaining the original structure but with adjusted expectations for message propagation. A critical observation guiding this adaptation is that the complete propagation of all proposed ILs to every committee member is not necessary. This assumption allows for specific deadlines and acknowledges that some transactions, despite passing through multiple relays, may not reach all committee members. This could potentially exclude some transactions from consideration. Although this does not pose a significant concern, as our objective is to include a substantial portion of the proposed IL in the global inclusion list, a thorough security analysis is necessary to assess the trade-offs between anonymity and security stemming from these changes. While it is advantageous to begin with a protocol that has already been implemented elsewhere, it might be more practical in the future to design a protocol from scratch—one with fewer parameters. Conducting the necessary analyses to evaluate its robustness and security will ensure that it is optimally tailored to meet our specific needs.</li>\n<li><strong>Single Aggregator Model</strong>: The current protocol considers a single aggregator randomly selected among the IL proposers. While this simplifies the design and is not a constraint per se—multiple aggregators can be integrated without altering the core mechanism—this setup can introduce specific challenges. Discussions are needed to explore potential issues that may arise from having only one aggregator, such as bottlenecks in processing or points of failure that could be exploited by malicious actors.</li>\n<li>It is also crucial to examine how the RANDAO affects our protocol as validators are able to bias is to a small extent. An analysis should be conducted to understand how such biases could influence the parts of our mechanism where RANDAO is utilized.</li>\n</ul>\n<h2><a name=\"supplementary-material-19\" class=\"anchor\" href=\"https://ethresear.ch#supplementary-material-19\"></a>Supplementary Material</h2>\n<h3><a name=\"appendix-1-abp-parameters-20\" class=\"anchor\" href=\"https://ethresear.ch#appendix-1-abp-parameters-20\"></a>Appendix 1. ABP Parameters</h3>\n<p><strong>1.1. IL gas and size (h/t Toni)</strong></p>\n<p>Previous IL specs have often mentioned using an IL size of <code>3M gas</code>. We chose the same amount of gas for the anon-IL design, and demonstrate that the maximum size in bytes a block can have after snappy compression is one with <code>28%</code> of zero bytes (Figure S1). Given that zero bytes are cheaper (<code>4 gas</code>) than non-zero bytes (<code>16 gas</code>), we calculate the maximum size an IL of <code>3M gas</code> can have as follows: <span class=\"math\">3M \\times 0.28/4 + 3M \\times 0.72/16 = 0.33Mb</span>.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/8/1/813c54436b078bf41f92112b3901b9258649b974.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/813c54436b078bf41f92112b3901b9258649b974\" title=\"Screenshot 2024-04-25 at 10.42.20\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/8/1/813c54436b078bf41f92112b3901b9258649b974_2_690x281.jpeg\" alt=\"Screenshot 2024-04-25 at 10.42.20\" data-base62-sha1=\"irgQASvOpHyflXH048upTjXn2aE\" width=\"690\" height=\"281\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/8/1/813c54436b078bf41f92112b3901b9258649b974_2_690x281.jpeg, https://ethresear.ch/uploads/default/optimized/3X/8/1/813c54436b078bf41f92112b3901b9258649b974_2_1035x421.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/8/1/813c54436b078bf41f92112b3901b9258649b974_2_1380x562.jpeg 2x\" data-dominant-color=\"E7E4EB\"></a></div><p></p>\n<blockquote>\n<p><strong>Figure S1.</strong> A. Maximum block size in Mb after Snappy compression relative to the percentage of zero bytes for a 30M gas block. B. Heatmap showing the relationship between the percentage of zero bytes in a block and the compressed size (in MB) of the block after applying Snappy compression, with respect to varying gas limits (h/t Toni for both figures).</p>\n</blockquote>\n<p><strong>1.2. Impact of Transmission Delay and Network Size on Propagation Time</strong></p>\n<p>We then evaluated how changing the maximum transmission delay and the size of the network (i.e., the number of IL proposers) affected to the propagation time of a given message during the <em>STEM</em> and <em>FLUFF</em> phases.</p>\n<ul>\n<li><em>FLUFF</em> phase: According to the <a href=\"https://github.com/ethereum/consensus-specs/blob/836bc43a0667990dd1243cf3aaad7e35a32eab99/specs/phase0/p2p-interface.md#the-gossip-domain-gossipsub\" rel=\"noopener nofollow ugc\">consensus specifications</a> and given a mesh size <span class=\"math\">MS</span> of <code>8</code>, and secret IL proposers sending messages using the ABP for each round, we assume a minimum of <code>100 ms</code> transmission delay <span class=\"math\">T_{delay}</span>, and a maximum determined by a maximum random delay we add to each message transmission to help de-anonymizing participants. We thus use a simple analytical model to compute the propagation time <span class=\"math\">PT_{FLUFF}</span> needed to reach all nodes during the <em>FLUFF</em> phase:</li>\n</ul>\n<p><span class=\"math\">PT_{FLUFF} = T_{delay} \\times \\log_{(MS - 1)}(R)</span></p>\n<p>Where <span class=\"math\">\\log_{(MS - 1)}(R)</span> is used to calculating the number of hops required for a given message to reach all nodes. Using these parameters, the computed propagation time <span class=\"math\">*PT_{FLUFF}</span>* to reach all nodes during the <em>FLUFF</em> phase depending on <span class=\"math\">T_{delay}</span> is shown in Figure S2. A.</p>\n<ul>\n<li><em>STEM</em> phase: As a reminder, each slot, half of nodes are randomly chosen to be relays (forward to 1 or 2 neighbours), the other half are diffusers (forward to all other nodes). Given the more complex network dynamics involved in this phase, we use simulations to estimate <span class=\"math\">PT_{STEM}</span> relative to the network size and  <span class=\"math\">T_{delay}</span> (Figure S2.B.)</li>\n</ul>\n<p>We then simply add <span class=\"math\">PT_{FLUFF}</span> and <span class=\"math\">PT_{STEM}</span> to find viable parameters allowing to propagate messages to everyone under <code>5 seconds</code> per round (Figure S2.C.). As a result, we chose to allocate <code>2.5 seconds</code> for each phase, setting parameters to a network size of <code>128 nodes</code>, with a maximum added random delay of <code>900ms</code>.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/f/4/f4afd5311a8b999e4b07d666626b8768c89ad157.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/f4afd5311a8b999e4b07d666626b8768c89ad157\" title=\"Screenshot 2024-05-23 at 15.20.17\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/f/4/f4afd5311a8b999e4b07d666626b8768c89ad157_2_690x330.jpeg\" alt=\"Screenshot 2024-05-23 at 15.20.17\" data-base62-sha1=\"yUBdOnLcLHlBZUUUg4kUAiQGe1N\" width=\"690\" height=\"330\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/f/4/f4afd5311a8b999e4b07d666626b8768c89ad157_2_690x330.jpeg, https://ethresear.ch/uploads/default/optimized/3X/f/4/f4afd5311a8b999e4b07d666626b8768c89ad157_2_1035x495.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/f/4/f4afd5311a8b999e4b07d666626b8768c89ad157_2_1380x660.jpeg 2x\" data-dominant-color=\"99BAAA\"></a></div><p></p>\n<blockquote>\n<p><strong>Figure S2.</strong> <strong>Propagation Time relative to transmission delay and network size</strong> for (<strong>A</strong>) the FLUFF phase, (<strong>B</strong>) the STEM phase across 100 simulation runs, and (<strong>C</strong>) the total propagation time for a given round (FLUFF + STEM). The x-axis indicates the transmission delay <span class=\"math\">T_{delay}</span>, and the y-axis shows network sizes (64, 128, 256 nodes).  Color intensity varies from fast to slow propagation time.</p>\n</blockquote>\n<p><strong>1.3 Impact of Byzantine Nodes on Message Propagation Success</strong></p>\n<p>We considered the impact that Byzantine nodes could have on the propagation of messages (ILs and votes) across the network of IL committee members. In Figure S3, we show the proportion of messages successfully reaching all nodes, given different percentages of Byzantine participants during the STEM phase, for various network sizes.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/0/e/0ef468f4b6446bffe73e294ce7ec6dc22225b106.png\" data-download-href=\"https://ethresear.ch/uploads/default/0ef468f4b6446bffe73e294ce7ec6dc22225b106\" title=\"Byzantine_Nodes\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/0/e/0ef468f4b6446bffe73e294ce7ec6dc22225b106_2_690x345.png\" alt=\"Byzantine_Nodes\" data-base62-sha1=\"28ikuGb7dJ2xAG0o9tvLHfOM4Rw\" width=\"690\" height=\"345\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/0/e/0ef468f4b6446bffe73e294ce7ec6dc22225b106_2_690x345.png, https://ethresear.ch/uploads/default/optimized/3X/0/e/0ef468f4b6446bffe73e294ce7ec6dc22225b106_2_1035x517.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/0/e/0ef468f4b6446bffe73e294ce7ec6dc22225b106_2_1380x690.png 2x\"></a></div><p></p>\n<blockquote>\n<p><strong>Figure S3. Impact of Byzantine Nodes on Message Propagation Success.</strong> This heatmap displays the success rate of full message propagation across networks with varying sizes and proportions of Byzantine nodes, for the <em>STEM</em> phase and averaged across 100 simulation runs. The x-axis indicates the percentage of Byzantine nodes (0% to 50%), and the y-axis shows network sizes (64, 128, 256 nodes). Color intensity varies from blue (higher success rates) to red (lower success rates), illustrating how increased Byzantine presence affects network reliability.</p>\n</blockquote>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://ethresear.ch/t/anonymous-inclusion-lists-anon-ils/19627\">Read full topic</a></p>","link":"https://ethresear.ch/t/anonymous-inclusion-lists-anon-ils/19627","pubDate":"Thu, 23 May 2024 15:17:26 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-19627"},"source":{"@url":"https://ethresear.ch/t/anonymous-inclusion-lists-anon-ils/19627.rss","#text":"Anonymous Inclusion Lists (anon-ILs)"},"filter":false},{"title":"Lumoz Launches zkProver and zkVerifier based on EigenLayer","dc:creator":"nanfengpo","category":"ZK Rollup","description":"<p>Despite recent controversies surrounding its airdrop, there is no doubt that EigenLayer has emerged as one of the most prominent projects of 2024, thanks to its Re-staking mechanism. This mechanism has not only driven a surge in TVL but also prompted users to move their funds and confidence back to the Ethereum ecosystem, away from the frenzy of meme coins.</p>\n<p>According to public <a href=\"https://app.eigenlayer.xyz/\" rel=\"noopener nofollow ugc\">data</a>, as of the time of writing, EigenLayer’s ETH TVL has surpassed 5 million ETH, and the staking amount of its token, Eigen, has exceeded 54 million tokens. The number of active AVS (<a href=\"https://ethresear.ch\">Actively Validated Services</a>) and Operators stands at 11 and 251, respectively. The EigenLayer ecosystem is also booming, with over 20 leading projects across various sectors, including Lumoz, Espresso, Near, and Dodo, actively participating.</p>\n<p>This marks the beginning of a revolution aimed at reshaping blockchain security and profitability around ETH, leveraging EigenLayer. This article will use Lumoz as a case study to delve into the series of technical explorations conducted on EigenLayer, thereby further advancing the technology of Ethereum and the broader blockchain industry.</p>\n<h2><a name=\"h-1-lumoz-launches-avs-computation-layer-based-on-eigenlayer-1\" class=\"anchor\" href=\"https://ethresear.ch#h-1-lumoz-launches-avs-computation-layer-based-on-eigenlayer-1\"></a>1. Lumoz Launches AVS Computation Layer Based on EigenLayer</h2>\n<p>As a leader in modular computing layers and ZKRaas Platform, Lumoz has not only performed exceptionally well in the capital markets but has also continuously innovated in the technical field. In April 2024, Lumoz first announced the completion of its Pre-A financing round (with a current valuation of up to $300 million), and shortly thereafter, it announced support for Op Stack + ZK Fraud Proof Layer 2 architecture, pioneering a new model for L2 architecture.</p>\n<p>This week, Lumoz officially announced the launch of an AVS computation layer based on EigenLayer, composed of zkProver and zkVerifier, which significantly enhances computational power and security.</p>\n<p>Lumoz’s zkProver focuses on generating Zero-Knowledge Proofs (ZKP), verifying the authenticity of data without revealing the specific data itself. With powerful computational resources, zkProver can quickly generate efficient Zero-Knowledge Proofs, significantly improving the privacy and security of blockchain networks. zkVerifier, on the other hand, is responsible for verifying these Zero-Knowledge Proofs, ensuring their correctness and reliability. Combined with EigenLayer’s Re-staking mechanism, zkVerifier not only leverages Ethereum’s security but also provides additional economic incentives for validators. This dual verification mechanism greatly enhances the overall security of the network and reduces trust risks.</p>\n<p><em>Note: EigenLayer’s Re-staking mechanism enhances the security of the Ethereum ecosystem by providing AVS, addressing trust issues and the burden of capital costs.</em></p>\n<p>By integrating powerful computational resources with EigenLayer’s Re-staking mechanism, Lumoz has created an efficient and secure computational service ecosystem. This innovation not only improves the computational power and security of blockchain networks but also provides developers and users with more application scenarios and value. Through zkProver and zkVerifier, Lumoz brings unprecedented innovation and value to the blockchain field, driving technological advancement across the entire industry.</p>\n<h2><a name=\"h-2-lumoz-computation-layer-2\" class=\"anchor\" href=\"https://ethresear.ch#h-2-lumoz-computation-layer-2\"></a>2. Lumoz Computation Layer</h2>\n<p>The Lumoz Computation Layer architecture is a highly integrated and collaborative system, with its main components and functionalities as follows:</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/4/f/4fa2829a63a584f7eb2b536f543482ae1f2286ee.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/4fa2829a63a584f7eb2b536f543482ae1f2286ee\" title=\"\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/4/f/4fa2829a63a584f7eb2b536f543482ae1f2286ee_2_493x500.jpeg\" alt=\"\" data-base62-sha1=\"bmtTAvKY7uCRF721iyC2Oxp1Fme\" width=\"493\" height=\"500\" role=\"presentation\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/4/f/4fa2829a63a584f7eb2b536f543482ae1f2286ee_2_493x500.jpeg, https://ethresear.ch/uploads/default/optimized/3X/4/f/4fa2829a63a584f7eb2b536f543482ae1f2286ee_2_739x750.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/4/f/4fa2829a63a584f7eb2b536f543482ae1f2286ee_2_986x1000.jpeg 2x\" data-dominant-color=\"151716\"></a></div><p></p>\n<p>The main components include:</p>\n<ul>\n<li><strong>Ethereum</strong>: Utilizes the EigenLayer standard to build Active Verification Services (AVS). The staking mechanism of EigenLayer enhances the security of AVS.</li>\n<li><strong>EVM Chain</strong>: Supports a diverse blockchain environment compatible with the Ethereum Virtual Machine (EVM), including but not limited to Polygon zkEVM, Polygon CDK, ZKStack, and Scroll, ensuring broad compatibility and scalability.</li>\n<li><strong>Lumoz AVS Oracle</strong>: Responsible for acquiring and storing data from EVM-compatible chains, ensuring high availability and integrity of the data, thus providing a solid data foundation for the computation layer.</li>\n<li><strong>Lumoz Chain</strong>: Acts as the core management layer of the entire computation layer, responsible for task scheduling, reward distribution, and the management of zkProver and zkVerifier, including but not limited to the processes of node joining and exiting.</li>\n<li><strong>zkProver</strong>: Nodes that execute specific computational tasks.</li>\n<li><strong>zkVerifier</strong>: Verification nodes that validate the execution results.</li>\n</ul>\n<p>Through the close collaboration of these modules, the Lumoz Computation Layer not only provides a secure and efficient computational environment but also, through its modular design, lays a solid foundation for future expansion and upgrades.</p>\n<h2><a name=\"h-3-what-problems-can-it-solve-3\" class=\"anchor\" href=\"https://ethresear.ch#h-3-what-problems-can-it-solve-3\"></a>3. What Problems Can It Solve?</h2>\n<h3><a name=\"h-31-large-scale-computational-power-demand-4\" class=\"anchor\" href=\"https://ethresear.ch#h-31-large-scale-computational-power-demand-4\"></a>3.1 Large-Scale Computational Power Demand</h3>\n<p>Lumoz provides robust cloud infrastructure support for zero-knowledge proof (ZKP) computations. This support is crucial for ZK-Rollups, a blockchain scaling solution that executes transactions off-chain and uses ZKPs to verify the validity of these transactions. The proofs are then submitted on-chain, reducing the load on the main chain and increasing transaction throughput.</p>\n<p>Lumoz Cloud Infrastructure Capabilities:</p>\n<ul>\n<li><strong>Compatibility</strong>: Lumoz’s cloud infrastructure is compatible with various ZK-Rollup solutions such as Polygon CDK, zkSync, StarkNet, and Scroll. This means it can serve these different platforms without each platform needing to establish its own infrastructure.</li>\n<li><strong>ZK-PoW Algorithm</strong>: Lumoz combines miners’ computational resources with cloud infrastructure through the Zero-Knowledge Proof of Work (ZK-PoW) algorithm, enabling miners to contribute their computational power to support ZKP computations.</li>\n<li><strong>Performance and Efficiency</strong>: By supporting parallel computation for ZKPs, computational efficiency is significantly improved as multiple tasks can be executed simultaneously. Additionally, sequential submission ensures orderly processing of transactions.</li>\n<li><strong>Recursive Aggregation Algorithm</strong>: Optimizing the recursive aggregation algorithm reduces the number of required ZKPs, thereby lowering computational complexity and costs.</li>\n<li><strong>Network Communication Improvements</strong>: Enhancements in network communication reduce data transmission time, improving the overall system response speed.</li>\n<li><strong>Cost-Effectiveness</strong>: Through the aforementioned optimizations, Lumoz can reduce the costs associated with ZKP computations, making ZK-Rollup solutions more economically efficient.</li>\n</ul>\n<p>Lumoz’s cloud infrastructure provides a powerful, flexible, and cost-effective solution for ZKP computations, contributing to the advancement and application of blockchain technology.</p>\n<h3><a name=\"h-32-reducing-zk-proof-gas-5\" class=\"anchor\" href=\"https://ethresear.ch#h-32-reducing-zk-proof-gas-5\"></a>3.2 Reducing zk Proof Gas</h3>\n<p>The design strategy of zkVerifier aims to enhance efficiency, scalability, and effectively reduce transaction costs, as reflected in the following aspects:</p>\n<ul>\n<li><strong>Integration of Multiple Proof Sources</strong>: zkVerifier can integrate proofs from different sources, supporting a wide range of zero-knowledge proof applications. This flexibility is a key advantage in the blockchain ecosystem, as it allows various projects and applications to utilize zkVerifier services.</li>\n<li><strong>Gas Cost Savings</strong>: Through meticulously designed proof processing and verification mechanisms, zkVerifier significantly reduces the gas cost of submitting proofs, providing users with a more cost-effective blockchain service experience.</li>\n<li><strong>Adaptability to Proof Characteristics</strong>: zkVerifier demonstrates adaptability to the characteristics of proofs generated by different proof systems, including proof size, verification time, and verification logic. This adaptability is central to ensuring the efficient operation of the system.</li>\n<li><strong>Customized Release Strategies</strong>: Based on the characteristics of different proofs, zkVerifier has designed customized release strategies that optimize the use of on-chain resources and ensure efficient proof transmission, helping to reduce network congestion and improve transaction speed.</li>\n<li><strong>Deployment of Dedicated Verifiers</strong>: zkVerifier deploys dedicated verifiers, which are key mechanisms to ensure proof validity. These verifiers ensure that only verified proofs can be published to Ethereum, maintaining the security and reliability of the system.</li>\n<li><strong>Optimization of Data Availability Layer</strong>: zkVerifier’s data availability layer ensures the durability and accessibility of proofs while providing a cost-effective storage strategy, which is crucial for reducing the operational costs of the system.</li>\n<li><strong>Deep Integration with Ethereum</strong>: zkVerifier publishes verification results to Ethereum, where Ethereum generates verification proofs. This step is crucial for ensuring cross-chain interoperability and trust, facilitating seamless collaboration between zkVerifier and major blockchain networks like Ethereum.</li>\n<li><strong>Authority of Verification Proofs</strong>: The verification proofs generated by Ethereum provide the final authoritative confirmation of the data validity provided by zkVerifier. This is essential for establishing trust in zkVerifier data within the Ethereum network.</li>\n</ul>\n<p>These innovative designs of zkVerifier not only address the challenges faced by existing blockchain technology but also achieve significant advancements in enhancing efficiency, reducing costs, and improving interoperability. This design helps to promote the broader application of blockchain technology and provides users with a more secure and efficient service environment.</p>\n<h2><a name=\"h-4-detailed-workflow-6\" class=\"anchor\" href=\"https://ethresear.ch#h-4-detailed-workflow-6\"></a>4. Detailed Workflow</h2>\n<h3><a name=\"h-41-zkprover-7\" class=\"anchor\" href=\"https://ethresear.ch#h-41-zkprover-7\"></a>4.1 zkProver</h3>\n<p>zkProver is the core component responsible for generating zero-knowledge proofs (ZKPs). ZKPs allow the prover to demonstrate the correctness of a certain assertion to the verifier without revealing any additional information. zkProver includes various types of provers such as zkRollup Prover, zkFraud Prover, and zkML Prover, each optimized for specific computational tasks to ensure optimal performance and system efficiency within their respective domains.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/3/e/3eff1a5965e046e6f0ad163d4be95e74257d330c.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/3eff1a5965e046e6f0ad163d4be95e74257d330c\" title=\"\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/3/e/3eff1a5965e046e6f0ad163d4be95e74257d330c_2_690x489.jpeg\" alt=\"\" data-base62-sha1=\"8Zi9PUSSFaXfxehoylc5lt8YL6s\" width=\"690\" height=\"489\" role=\"presentation\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/3/e/3eff1a5965e046e6f0ad163d4be95e74257d330c_2_690x489.jpeg, https://ethresear.ch/uploads/default/optimized/3X/3/e/3eff1a5965e046e6f0ad163d4be95e74257d330c_2_1035x733.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/3/e/3eff1a5965e046e6f0ad163d4be95e74257d330c_2_1380x978.jpeg 2x\" data-dominant-color=\"151814\"></a></div><p></p>\n<p><strong>Workflow:</strong></p>\n<ol>\n<li><strong>Task Acquisition:</strong> The Lumoz AVS Oracle and Dispatch module retrieve tasks from the blockchain and synchronize them to the Lumoz Chain. These tasks consist of assertions or computations that require proof.</li>\n<li><strong>Task Distribution:</strong> Tasks are distributed to different Provers via the Dispatch module. Acting as the task scheduling center, Dispatch determines which type of Prover is best suited to handle each task based on its nature and requirements. The Dispatch module dynamically allocates computational resources through intelligent algorithms, optimizing resource distribution in real-time based on task load and the performance of each Prover, ensuring stable system operation during high-demand periods.</li>\n<li>**Proof Generation:**<strong>a, zkRollup Prover:</strong> Focuses on generating proofs related to transaction batch compression, enhancing blockchain processing speed and scalability.<strong>b, zkFraud Prover:</strong> Generates fraud proofs that help detect and prevent improper behavior.<strong>c, zkML Prover:</strong> Specializes in generating complex proofs related to machine learning model verification, ensuring the validity of model outputs without revealing the model itself or its input data.<strong>d, Other Provers:</strong> Handle specific types of proofs as needed.</li>\n<li><strong>Proof Submission:</strong> The generated proofs are sent to the Lumoz Chain for verification and archiving.</li>\n</ol>\n<h3><a name=\"h-42-zkverifier-8\" class=\"anchor\" href=\"https://ethresear.ch#h-42-zkverifier-8\"></a>4.2 zkVerifier</h3>\n<p>zkVerifier is another key component in the architecture, responsible for verifying the ZKPs generated by zkProver. It ensures the correctness and validity of the proofs submitted to the chain, thereby safeguarding the trust and security of the system. Through an optimized verification process, zkVerifier efficiently handles proofs, reducing operational costs and gas consumption.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/6/4/64136a1901b29ae5be439c939975916683752c1d.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/64136a1901b29ae5be439c939975916683752c1d\" title=\"\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/6/4/64136a1901b29ae5be439c939975916683752c1d_2_563x500.jpeg\" alt=\"\" data-base62-sha1=\"ehjldNyiY42LYAjWQB5IUj3x6Kp\" width=\"563\" height=\"500\" role=\"presentation\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/6/4/64136a1901b29ae5be439c939975916683752c1d_2_563x500.jpeg, https://ethresear.ch/uploads/default/optimized/3X/6/4/64136a1901b29ae5be439c939975916683752c1d_2_844x750.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/6/4/64136a1901b29ae5be439c939975916683752c1d_2_1126x1000.jpeg 2x\" data-dominant-color=\"151615\"></a></div><p></p>\n<p><strong>Workflow:</strong></p>\n<ol>\n<li>Proof Submission: Proofs generated by zkProver are submitted to the Lumoz Chain, initiating the verification task.</li>\n<li>Proof Verification: The Lumoz Chain sends the verification task to multiple zkVerifiers, which independently perform distributed verification.</li>\n<li>Collective Decision: At least two-thirds of the verification nodes confirm the proof’s validity, ensuring the authority and consistency of the verification results.</li>\n<li>Verification Result Processing: Valid proofs and their results are transmitted back to the Lumoz Proof Contract on the blockchain by the Lumoz AVS Oracle. The Task Manager Contract records and responds to the task results on the Lumoz Chain.</li>\n</ol>\n<h2><a name=\"summary-9\" class=\"anchor\" href=\"https://ethresear.ch#summary-9\"></a>Summary</h2>\n<p>Lumoz announces the launch of zkProver and zkVerifier based on EigenLayer, significantly enhancing the efficiency of computation and verification. The re-staking mechanism of EigenLayer effectively ensures the security and profitability of the entire service process. With specialized node design, Lumoz can provide solutions for different computational tasks, achieving optimal performance and efficiency. Additionally, through the re-staking mechanism, Lumoz offers substantial returns to stakers, further enhancing the economic security of the system.</p>\n<p>In the future, we hope to see more projects like EigenLayer and Lumoz emerge, addressing current blockchain challenges, genuinely solving user pain points, and actively exploring and attempting more efficient and secure solutions. This will ultimately drive the progress and prosperity of the entire industry.</p>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://ethresear.ch/t/lumoz-launches-zkprover-and-zkverifier-based-on-eigenlayer/19622\">Read full topic</a></p>","link":"https://ethresear.ch/t/lumoz-launches-zkprover-and-zkverifier-based-on-eigenlayer/19622","pubDate":"Thu, 23 May 2024 09:18:53 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-19622"},"source":{"@url":"https://ethresear.ch/t/lumoz-launches-zkprover-and-zkverifier-based-on-eigenlayer/19622.rss","#text":"Lumoz Launches zkProver and zkVerifier based on EigenLayer"},"filter":false},{"title":"Queue End Of Block Transaction OPCODE","dc:creator":"MicahZoltu","category":"Execution Layer Research","description":"<h2><a name=\"abstract-1\" class=\"anchor\" href=\"https://ethresear.ch#abstract-1\"></a>Abstract</h2>\n<p>A new OPCODE that allows queuing some piece of code with a well defined gas used that will execute at the end of a block.  If two transactions queue the same end-of-block code, it will only execute once.  Gas costs are covered with ETH in the calling contract.</p>\n<h2><a name=\"motivation-2\" class=\"anchor\" href=\"https://ethresear.ch#motivation-2\"></a>Motivation</h2>\n<p>This would enable things like block auctions, by allowing a bunch of people to submit transactions to swap some asset, and then they would all execute together via a block-auction at the end of the block in a way defined by the contract, rather than in a sequential order that they appear.  Each transaction would queue the end-of-block code execution.  If a single transaction does a swap on some pool, then the end-of-block execution would not change anything from today.  If multiple people submit swaps on some pool within a single block, then the contract can execute a block-auction rather than executing the swaps in the order they are received.  This allows the contract to get the best price for everyone and combat things like in-block front-running.  This does <em>not</em> address cross-block front-running/back-running, but that is far harder to execute than within-block front-running and sandwiching.</p>\n<h2><a name=\"specification-3\" class=\"anchor\" href=\"https://ethresear.ch#specification-3\"></a>Specification</h2>\n<p>Mostly TBD, but gas paid by the contract allows for cost sharing strategies between transactors (e.g., split costs and refund at end) and requiring a fixed gas usage for the end-of-block execution helps with solving the bin-filling problem introduced by delayed execution.</p>\n<h2><a name=\"considerations-4\" class=\"anchor\" href=\"https://ethresear.ch#considerations-4\"></a>Considerations</h2>\n<p>It could be useful to allow for specifying dependencies, so one contract could say “I want my end-of-block execution to run after this other contract’s end-of-block execution”.  Care would need to be taken to avoid circular dependencies, but this could be achieved by just asserting that if a circular dependency is detected then all contracts in the circle do not get their end-of-block execution.  This strongly encourages people to <em>only</em> depend on immutable end-of-block executors with fixed dependency trees.</p>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://ethresear.ch/t/queue-end-of-block-transaction-opcode/19621\">Read full topic</a></p>","link":"https://ethresear.ch/t/queue-end-of-block-transaction-opcode/19621","pubDate":"Thu, 23 May 2024 07:49:03 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-19621"},"source":{"@url":"https://ethresear.ch/t/queue-end-of-block-transaction-opcode/19621.rss","#text":"Queue End Of Block Transaction OPCODE"},"filter":false},{"title":"ZKThreads: A canonical ZK sharding framework for dApps","dc:creator":"guthlStarkware","category":"ZK Rollup","description":"<p><strong>TL;DR:</strong> We propose zkThread, an application-level component allowing users to locally prove a batch of transactions and update the canonical state.</p>\n<p>This protocol allows turning any smart contract or set of smart contracts into their own execution environment at will while leaving the system in a synchronized environment.</p>\n<p>Notice this protocol can also be implemented at the OS level without requiring any change on the user journey.</p>\n<p>This design pattern showcases Horizontal Scaling done right. zkThreads extends the base layer throughput and network capacity at Zero Overhead from the core protocol perspective.</p>\n<p>We believe this model to be a new paradigm in the Fractal Scaling family alongside L3s and other designs known as zkSharding. You can find more details and contribute to its creation on <a href=\"https://github.com/keep-starknet-strange/zkthread\" rel=\"noopener nofollow ugc\">here</a> and a first implementation can be found under this <a href=\"https://github.com/dojoengine/dojo/tree/main/crates/saya\" rel=\"noopener nofollow ugc\">repository</a> under the Saya settlement service developed by <a href=\"https://cartridge.gg\" rel=\"noopener nofollow ugc\">Cartridge</a>.</p>\n<p>As a metaphor, imagine a chain where you can temporarily fork the chain locally to batch txs on your own. Others have hinted at such a design under the name Stateful Coprocessor or Execution Coprocessor.</p>\n<p>Thanks a lot to <a href=\"https://twitter.com/0xfishylosopher/\" rel=\"noopener nofollow ugc\">Jay Yu</a> from <a href=\"https://twitter.com/stanfordcrypto\" rel=\"noopener nofollow ugc\">Stanford Blockchain</a> and <a href=\"https://twitter.com/tarrenceva\" rel=\"noopener nofollow ugc\">Tarrence</a> from <a href=\"https://cartridge.gg/\" rel=\"noopener nofollow ugc\">Cartridge</a> for all the help in formalising and writing this post.</p>\n<p><strong>Background</strong></p>\n<p>In the context of a Validity-Rollup, the OS underpinning the Rollup is usually optimized for being provable, making proof a first-class primitive of the whole system. One important aspect is the ease of proving as one needs to run in a decentralized world with constrained machines.</p>\n<p>Under the current system, Starknet and other chains only allow a smart contract to modify its storage slots.<br>\n</p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/a/d/ad676517d8e89bbc4d937ee07128835d0c72d402.png\" data-download-href=\"https://ethresear.ch/uploads/default/ad676517d8e89bbc4d937ee07128835d0c72d402\" title=\"image\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/a/d/ad676517d8e89bbc4d937ee07128835d0c72d402_2_690x345.png\" alt=\"image\" data-base62-sha1=\"oK07Ke2I0FNy2wexYsCqL9z6RiO\" width=\"690\" height=\"345\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/a/d/ad676517d8e89bbc4d937ee07128835d0c72d402_2_690x345.png, https://ethresear.ch/uploads/default/optimized/3X/a/d/ad676517d8e89bbc4d937ee07128835d0c72d402_2_1035x517.png 1.5x, https://ethresear.ch/uploads/default/original/3X/a/d/ad676517d8e89bbc4d937ee07128835d0c72d402.png 2x\" data-dominant-color=\"EAE8EE\"></a></div><p></p>\n<p><strong>Proposal</strong></p>\n<p>Under zkThread, a new contract would be introduced to allow for proof verification of generic transactions against a specific OS version, a set of contracts, an input, and an output &lt;key, value&gt; state list. Assuming the input state list matches the current canonical state values and assuming the proof verifies, the OS can self-apply the output &lt;key, value&gt; to the canonical state.</p>\n<p>We will call a <strong>zkThread</strong>, the operation governing the runtime of the zkThread contracts updates.</p>\n<p><strong>Stated Goals</strong></p>\n<p>This protocol enables a whole new primitive into the network</p>\n<ul>\n<li>All compatible dApps become L3-ready</li>\n<li>Self Sharded Synchronous state</li>\n<li>Infinitely Adjustable TPS through permissionless self-update</li>\n<li>Future-proof backward compatibility</li>\n</ul>\n<p><strong>Setup</strong><br>\n</p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/4/d/4d2ea6cbd7ef6a2fd9520727e728980356cbce58.png\" data-download-href=\"https://ethresear.ch/uploads/default/4d2ea6cbd7ef6a2fd9520727e728980356cbce58\" title=\"image\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/4/d/4d2ea6cbd7ef6a2fd9520727e728980356cbce58_2_690x386.png\" alt=\"image\" data-base62-sha1=\"b0MInaxvuXs79F89b38Tq8ZsvVu\" width=\"690\" height=\"386\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/4/d/4d2ea6cbd7ef6a2fd9520727e728980356cbce58_2_690x386.png, https://ethresear.ch/uploads/default/optimized/3X/4/d/4d2ea6cbd7ef6a2fd9520727e728980356cbce58_2_1035x579.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/4/d/4d2ea6cbd7ef6a2fd9520727e728980356cbce58_2_1380x772.png 2x\" data-dominant-color=\"ECE9ED\"></a></div><p></p>\n<p>For a set of L2 Smart Contracts, one can define a zkThread by</p>\n<ul>\n<li>Batcher: an entity or set of entities that sequences the zkThread</li>\n<li>Prover: an entity or set of entities that proves the zkThread and forwards it to the L2</li>\n<li>A set of L2 contracts falling targeted by the zkThread</li>\n</ul>\n<p>We call a Sub-block the output of the Batcher.</p>\n<p>For a zkThread, the Batcher creates a sub-block and provides it to the Prover.</p>\n<p>Once proven,sub-blocks are forwarded as a transaction to the L2.</p>\n<p>Assuming all transactions in the sub-block are valid, a transaction is emitted from the zkThread to the L2 as follows</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/5/b/5bfafec8753e568daf47182021da94dd16225cde.png\" data-download-href=\"https://ethresear.ch/uploads/default/5bfafec8753e568daf47182021da94dd16225cde\" title=\"image\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/5/b/5bfafec8753e568daf47182021da94dd16225cde_2_690x384.png\" alt=\"image\" data-base62-sha1=\"d7HcGEPNFLW34Wb4X5niG0ubliC\" width=\"690\" height=\"384\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/5/b/5bfafec8753e568daf47182021da94dd16225cde_2_690x384.png, https://ethresear.ch/uploads/default/optimized/3X/5/b/5bfafec8753e568daf47182021da94dd16225cde_2_1035x576.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/5/b/5bfafec8753e568daf47182021da94dd16225cde_2_1380x768.png 2x\" data-dominant-color=\"EDE9ED\"></a></div><p></p>\n<p>The zkThread transaction is then sequenced by the L2 and run against the canonical state<br>\n</p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/c/3/c3b9902412fe93266b9309cb5b5f4a10f327c263.png\" data-download-href=\"https://ethresear.ch/uploads/default/c3b9902412fe93266b9309cb5b5f4a10f327c263\" title=\"image\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/c/3/c3b9902412fe93266b9309cb5b5f4a10f327c263_2_690x392.png\" alt=\"image\" data-base62-sha1=\"rVsFLR0AsQwbTx22QxHfQpM6ps7\" width=\"690\" height=\"392\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/c/3/c3b9902412fe93266b9309cb5b5f4a10f327c263_2_690x392.png, https://ethresear.ch/uploads/default/optimized/3X/c/3/c3b9902412fe93266b9309cb5b5f4a10f327c263_2_1035x588.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/c/3/c3b9902412fe93266b9309cb5b5f4a10f327c263_2_1380x784.png 2x\" data-dominant-color=\"ECE9ED\"></a></div><p></p>\n<p>If the proof validates against the canonical state, the state updates are accepted and incorporated into the canonical state.<br>\n</p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/8/a/8a396a5cf7e88f798ab726157d5a3da6ca323c7f.png\" data-download-href=\"https://ethresear.ch/uploads/default/8a396a5cf7e88f798ab726157d5a3da6ca323c7f\" title=\"image\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/8/a/8a396a5cf7e88f798ab726157d5a3da6ca323c7f_2_690x388.png\" alt=\"image\" data-base62-sha1=\"jIMTZdDjLs5TDrDw47l4ukH1Z3F\" width=\"690\" height=\"388\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/8/a/8a396a5cf7e88f798ab726157d5a3da6ca323c7f_2_690x388.png, https://ethresear.ch/uploads/default/optimized/3X/8/a/8a396a5cf7e88f798ab726157d5a3da6ca323c7f_2_1035x582.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/8/a/8a396a5cf7e88f798ab726157d5a3da6ca323c7f_2_1380x776.png 2x\" data-dominant-color=\"ECE9ED\"></a></div><p></p>\n<p>In the negative flow, the transaction just reverts and the Prover pays the transaction fees.<br>\n</p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/8/5/850d64651564478bfc37889a3bff85a7ac2a28e1.png\" data-download-href=\"https://ethresear.ch/uploads/default/850d64651564478bfc37889a3bff85a7ac2a28e1\" title=\"image\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/8/5/850d64651564478bfc37889a3bff85a7ac2a28e1_2_690x386.png\" alt=\"image\" data-base62-sha1=\"iZ2ca1u6n5TkYFaY0UmyVuaDMOt\" width=\"690\" height=\"386\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/8/5/850d64651564478bfc37889a3bff85a7ac2a28e1_2_690x386.png, https://ethresear.ch/uploads/default/optimized/3X/8/5/850d64651564478bfc37889a3bff85a7ac2a28e1_2_1035x579.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/8/5/850d64651564478bfc37889a3bff85a7ac2a28e1_2_1380x772.png 2x\" data-dominant-color=\"ECE8EC\"></a></div><p></p>\n<p><strong>Conclusion</strong><br>\nThis new scaling model is perfectly suited for critical DeFi applications, Gaming and all dApps which wish to use the base layer infrastructure but have strong constraints on Responsiveness, Fees and even Privacy such as Order Book. You can find more details and contribute to its creation <a href=\"https://github.com/keep-starknet-strange/zkthread\" rel=\"noopener nofollow ugc\">here</a> and a first implementation can be found under this <a href=\"https://github.com/dojoengine/dojo/tree/main/crates/saya\" rel=\"noopener nofollow ugc\">repository</a> under the Saya settlement service developed by <a href=\"https://cartridge.gg\" rel=\"noopener nofollow ugc\">Cartridge</a>.</p>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://ethresear.ch/t/zkthreads-a-canonical-zk-sharding-framework-for-dapps/19619\">Read full topic</a></p>","link":"https://ethresear.ch/t/zkthreads-a-canonical-zk-sharding-framework-for-dapps/19619","pubDate":"Thu, 23 May 2024 07:27:02 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-19619"},"source":{"@url":"https://ethresear.ch/t/zkthreads-a-canonical-zk-sharding-framework-for-dapps/19619.rss","#text":"ZKThreads: A canonical ZK sharding framework for dApps"},"filter":false},{"title":"EVM Native Sequencing Rules","dc:creator":"Lilyjjo","category":"Execution Layer Research","description":"<p>The goal of this post is to introduce the concept of Sequencing Rules and provide a possible sketch of what a Sequencing Rule-enabled EVM would look like. Sequencing Rules offer a rational solution to both Ethereum’s MEV and protocol innovation mindshare loss problems.</p>\n<h2><a name=\"sequencing-rules-the-why-1\" class=\"anchor\" href=\"https://ethresear.ch#sequencing-rules-the-why-1\"></a><strong>Sequencing Rules: The Why</strong></h2>\n<p>Ethereum is facing a MEV crisis. FUD is <a href=\"https://x.com/dankrad/status/1791379755922498027\" rel=\"noopener nofollow ugc\">building on Twitter</a> as block builders grow in their influence over the chain’s functioning. Block builders are collecting an <a href=\"https://www.relayscan.io/builder-profit?t=7d\" rel=\"noopener nofollow ugc\">uncomfortable amount of capital</a> with each block, yet they provide little to negative value in return. This behavior makes sense: value has been left on the table, so why shouldn’t they collect it? A rational way to stop the growing block builder oligopoly is to enable Ethereum’s on-chain applications to fully capture the value that they create.</p>\n<p>So far, discussions on fixing block builders’ power have focused only on lower-level structural L1 changes<sup><a href=\"https://ethresear.ch/t/execution-tickets/17944\">1</a>,<a href=\"https://ethresear.ch/t/state-lock-auctions-towards-collaborative-block-building/18558\">2</a>,<a href=\"https://ethresear.ch/t/exploring-paths-to-a-decentralized-censorship-resistant-and-non-predatory-mev-ecosystem/17312\">3</a></sup>, leaving out the actual source of value creation and leakage: the on-chain applications themselves. The best entity to decide how to fairly distribute the value created from ordering is the entity that is producing the value. For the sake of Ethereum’s long-term success, on-chain applications need to be able to express and control how their transactions are sequenced with supporting L1/L2 infrastructure.</p>\n<p>The rest of this post will:</p>\n<ul>\n<li>Introduce the concept of Sequencing Rules</li>\n<li>Provide a sketch of what native EVM sequencing support could look like</li>\n<li>Provide a <a href=\"https://github.com/Lilyjjo/tldr-research\" rel=\"noopener nofollow ugc\">proof-of-concept example</a> of an AMM that auctions off the right of the first swap on Ethereum</li>\n</ul>\n<h2><a name=\"sequencing-rules-the-what-2\" class=\"anchor\" href=\"https://ethresear.ch#sequencing-rules-the-what-2\"></a>Sequencing Rules: The What</h2>\n<p>Sequencing rules are not a new concept but have recently seen increased usage by blockchain developers.</p>\n<p>Sequencing rules can be conceptualized as follows:</p>\n<ol>\n<li>On-chain applications decide how they want their transactions to be sequenced.</li>\n<li>Blocks are built that respect that sequencing.</li>\n</ol>\n<p>Blockchain applications can benefit from this programming pattern due to blockchains’ inherent discrete view of time. During the 12 seconds between Ethereum’s blocks, the outside world’s valuation of different pieces of state is in flux, creating arbitrage value in the ability to act first on those pieces of state. Block builders make money by exploiting this in the form of acts like CEX-DEX arbitrage. This phenomenon is also observed in traditional finance (TradFi) with the <a href=\"https://academic.oup.com/qje/article/130/4/1547/1916146\" rel=\"noopener nofollow ugc\">high-speed arms race</a> between high-frequency trading (HFT) firms, which operate in a similar scenario but on a millisecond timeframe instead of seconds.</p>\n<p>As the field of protocol development matures, protocols are starting to manage these value-pressurized pieces of state with varying degrees of success. Examples vary but all showcase the benefits of managing one’s own sequencing:</p>\n<ul>\n<li><a href=\"https://x.com/penumbrazone\" rel=\"noopener nofollow ugc\">Penumbra</a>, a new L1 DEX, enforces ordered batch execution of all business logic, enabling all users to benefit equally from the accrued time arbitrage value.</li>\n<li>HyperLiquid’s <a href=\"https://x.com/chameleon_jeff/status/1743650555879190808\" rel=\"noopener nofollow ugc\">new L1</a> prioritizes retail and makers over toxic takers by running cancels and post-only orders first.</li>\n<li>Skip’s <a href=\"https://docs.skip.money/slinky/overview/\" rel=\"noopener nofollow ugc\">Slinky</a> project surfaces oracle data at the block level to ensure all applications can utilize fresh oracle data.</li>\n<li><a href=\"https://uma.xyz/oval\" rel=\"noopener nofollow ugc\">Oval</a> auctions off the right to be the first person to act on updated oracles information.</li>\n<li>Years of research<sup><a href=\"https://ethresear.ch/t/mev-capturing-amm-mcamm/13336\">1</a>,<a href=\"https://arxiv.org/abs/2210.10601\" rel=\"noopener nofollow ugc\">2</a>,<a href=\"https://arxiv.org/html/2403.03367v1\" rel=\"noopener nofollow ugc\">3</a></sup> have been conducted on how to implement first-swap auctions for AMMs on Ethereum, though no production-grade result is running yet.</li>\n</ul>\n<p>Sequencing rules for blockchain applications are natural, yet Ethereum does not offer native solutions to enable developers to program their applications accordingly.</p>\n<h2><a name=\"sequencing-rules-the-how-3\" class=\"anchor\" href=\"https://ethresear.ch#sequencing-rules-the-how-3\"></a>Sequencing Rules: The How</h2>\n<p>As seen in the list above, protocols are starting to migrate to other ecosystems with novel L1 implementations because their sequencing needs are not being met on Ethereum. Instead of Ethereum’s on-chain protocols capturing the time-accrued value, block builders are. Ethereum’s EVM needs sequencing rules.</p>\n<p>Ethereum’s EVM programming environment is different from an L1 that is specialized for a specific application because it is a shared general execution environment. Applications and transactions share both block space and state with each other. As a result, anyone implementing sequencing rules for an EVM should consider:</p>\n<ul>\n<li>On-chain applications cannot assume a piece of state’s value will not change unless it is explicitly controlled.</li>\n<li>Not all on-chain applications need sequencing.</li>\n<li>Not all actions within an application need sequencing.</li>\n</ul>\n<p>I will now lay out a rough draft version of how one could implement sequencing rules for Ethereum. In order to meet the above considerations, I propose adding two new transaction types:</p>\n<ol>\n<li>A new ‘bundle’ transaction type. This transaction would be signed by an EOA and would contain a payload of ordered transactions. We’ll call this EOA a bundler. This ‘transaction’ itself does not trigger on-chain execution, it simply just orders other transactions.</li>\n<li>A new transaction type that specifies the bundler (just an EOA) that is able to include the transaction in a bundle.</li>\n</ol>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/b/3/b376ab484f0a2eaa09bcb254d7f12439f442621d.png\" data-download-href=\"https://ethresear.ch/uploads/default/b376ab484f0a2eaa09bcb254d7f12439f442621d\" title=\"IMG_0025\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/b/3/b376ab484f0a2eaa09bcb254d7f12439f442621d_2_689x500.png\" alt=\"IMG_0025\" data-base62-sha1=\"pBBIiDg19vfKNLGcdpmPWsWroPr\" width=\"689\" height=\"500\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/b/3/b376ab484f0a2eaa09bcb254d7f12439f442621d_2_689x500.png, https://ethresear.ch/uploads/default/optimized/3X/b/3/b376ab484f0a2eaa09bcb254d7f12439f442621d_2_1033x750.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/b/3/b376ab484f0a2eaa09bcb254d7f12439f442621d_2_1378x1000.png 2x\" data-dominant-color=\"F4F3EA\"></a></div><p></p>\n<p>EVM block construction would be modified to enforce the following rules:</p>\n<ul>\n<li>A bundler can only have a single bundle transaction included in a block, and optionally, a bundle is only valid in a certain block. Some business applications would benefit from being able to run bundles in only certain blocks.</li>\n<li>A bundle can specify a bundler that is able to include it in a bundle, for meta-bundle programming.</li>\n<li>A transaction can only be included in a bundle if it specifies bundler, and if a transaction specifies a bundler, the transaction can only be included in a block if it is in a bundle. This is to prevent bundles from clashing with each other, which would cause builders to have extra incentive to include one bundler over another.</li>\n<li>Unlike Ethereum’s current block builder’s bundle interface, transactions in a bundle do not have any non-revert guarantees. On-chain application logic must handle possible reverts. This is again to prevent bundles from clashing with each other.</li>\n</ul>\n<p>The EVM itself would be modified to include the new following global variables:</p>\n<ul>\n<li><code>bundle.signer</code>: the EOA who signed the bundle. Useful for on-chain applications to designate sequencing rights to a specific off-chain entity. The zero address if not in a bundle.</li>\n<li><code>bundle.number</code>: the global number of the bundle’s ordering. Useful for meta-bundle programming. Zero if not in a bundle.</li>\n<li><code>bundle.tx_number</code>: which number this transaction is in the bundle. Useful for on-chain applications to enable special logic depending on transaction sequence. Zero if not in a bundle.</li>\n</ul>\n<p>These new EVM rules and global variables could be a strong starting point for on-chain applications to express how they’d like to be sequenced.</p>\n<p>There are numerous security and caveats to consider in this implementation. EVM bundle creators would need to take care to only sequence on state that they directly control from the start of the block. This is because all other state is potentially manipulatable by outside entities. Bundle creators would have to assume that all transactions could revert due to insufficient gas funds, that any piece of unprotected state could be changed, and that any starting point besides its own external functions are non-deterministic. Sequencing rule assumptions about mutable state could be a new class of audit vulnerabilities.</p>\n<p>Additionally, these rules or language expansions do not preclude block builders existing or making money. Bundlers could construct multiple bundles and rely on block building services to take advantage of the highest result. Inter-bundle arbitrage could be a new solver target. Analogous to the EVM global variables proposed above, <code>tx.number</code> could be included to allow block builders to explicitly sell the right to be the first transaction included.</p>\n<p>Notably, this implementation lacks specification on how on-chain applications would construct bundles. This would be up to the applications to chose between different trust and privacy tradeoffs. Some options would include using:</p>\n<ul>\n<li>Flashbot’s <a href=\"https://suave-alpha.flashbots.net/\" rel=\"noopener nofollow ugc\">Suave</a> TEE enabled decentralized platform for business applications needing confidential compute.</li>\n<li>A sequencing layer, like <a href=\"https://x.com/AstriaOrg\" rel=\"noopener nofollow ugc\">Astria</a>, to construct generic bundles.</li>\n</ul>\n<h2><a name=\"sequencing-rules-an-example-4\" class=\"anchor\" href=\"https://ethresear.ch#sequencing-rules-an-example-4\"></a>Sequencing Rules: An Example</h2>\n<p>I came up with the above Ethereum compatible sequencing rule proposal while trying to program a <a href=\"https://github.com/Lilyjjo/tldr-research\" rel=\"noopener nofollow ugc\">first swap auction for a AMM on Ethereum</a>. This proof of concept aims to implement the sequencing rule ‘the first swap should be auctioned’ for the sake of rerouting some of the CEX-DEX arbitrage back to the pool’s LPs. It utilizes block builder’s current <a href=\"https://docs.flashbots.net/flashbots-auction/advanced/rpc-endpoint#eth_sendbundle\" rel=\"noopener nofollow ugc\">bundle infrastructure</a> to craft bundles and inserts logic on-chain via a signed transaction to enforce that the bundle’s sequence is respected. This proof of concept uses Flashbot’s SUAVE TEE enabled programming environment to craft bundles for the AMM in a trust-reduced manner. This implementation could be easily rewritten with the above EVM native bundle proposal with much better execution costs and guarantees.</p>\n<p>I wrote this post because I’m a frustrated protocol developer who wants to capture the maximal value for my actual users. These are just my thoughts on how we can potentially make “Ethereum Great Again” <img src=\"https://ethresear.ch/images/emoji/facebook_messenger/green_heart.png?v=12\" title=\":green_heart:\" class=\"emoji\" alt=\":green_heart:\" loading=\"lazy\" width=\"20\" height=\"20\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/blue_heart.png?v=12\" title=\":blue_heart:\" class=\"emoji\" alt=\":blue_heart:\" loading=\"lazy\" width=\"20\" height=\"20\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/sparkles.png?v=12\" title=\":sparkles:\" class=\"emoji\" alt=\":sparkles:\" loading=\"lazy\" width=\"20\" height=\"20\">.</p>\n<p>Please leave comments if you have them!</p>\n<p>Thank you to my teammates <a href=\"https://x.com/itamarreif\" rel=\"noopener nofollow ugc\">Itamar</a> and <a href=\"https://x.com/visavishesh\" rel=\"noopener nofollow ugc\">Vishesh</a> at <a href=\"https://x.com/AstriaOrg\" rel=\"noopener nofollow ugc\">Astria</a> for agreeing to talk about auctions for way too long, <a href=\"https://x.com/thelatestindefi\" rel=\"noopener nofollow ugc\">The Latest in Defi Research</a> for providing the community to iterate on these thoughts, and to the Suave team for letting me learn how to build bundles on their platform.</p>\n<p>*Note: these @'s have no endorsement or involvement in this post, these words and opinions are my own :).</p>\n            <p><small>9 posts - 5 participants</small></p>\n            <p><a href=\"https://ethresear.ch/t/evm-native-sequencing-rules/19606\">Read full topic</a></p>","link":"https://ethresear.ch/t/evm-native-sequencing-rules/19606","pubDate":"Wed, 22 May 2024 17:06:44 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-19606"},"source":{"@url":"https://ethresear.ch/t/evm-native-sequencing-rules/19606.rss","#text":"EVM Native Sequencing Rules"},"filter":false},{"title":"Unveiling the Power of Self-Sovereign Identity and Account Abstraction for Privacy-Preserving User Operations","dc:creator":"EugeRe","category":"Execution Layer Research","description":"<p>This is a part of a longer research on the topic which ultimately intends to establish a common framework to originate on-chain data and process it to the networks supporting data minimization to balance user privacy and compliance needs.</p>\n<p>I wanted to thank <a href=\"https://www.linkedin.com/in/erwin-voloder-mes-317735125/?original_referer=https%3A%2F%2Fwww%2Egoogle%2Ecom%2F&amp;originalSubdomain=hr\">Erwin Voloder</a>, <a href=\"https://twitter.com/PeteCooling\">Pete Cooling</a>, <a href=\"https://twitter.com/kimdhamilton?lang=en\">Kim Hamilton</a> and <a href=\"https://www.linkedin.com/in/martinschaeffner/\">Martin Schaffner</a>, who personally supported this research in different ways and the people from ERC-4337 Team, specifically <a class=\"mention\" href=\"https://ethresear.ch/u/yoavw\">@yoavw</a> , <a class=\"mention\" href=\"https://ethresear.ch/u/zincoshine\">@zincoshine</a> AA Mafia Telegram Group, <a href=\"https://x.com/alexanderchopan\">Alex</a> and <a href=\"https://twitter.com/randomishwalk?lang=en\">Eric</a>  for further support. This is an ongoing project, I hope you appreciate the forward thinking and we are continuing to work on it. Any feedback or support is appreciated, in light blue hyperlinked public content for reference.</p>\n<p><strong>ABSTRACT</strong><br>\nThis research explores the innovative integration of Self-Sovereign Identity (SSI) systems with Account Abstraction (AA) to enhance privacy, compliance, and user experience on the Ethereum blockchain. By leveraging verifiable credentials (VCs) and Ethereum attestations (EAs), the proposed framework empowers bundlers to pre-validate transactions, reducing on-chain reverts and penalties. The implementation of Merkle proofs and Zero-Knowledge Proofs (ZKPs) ensures efficient data processing and minimal disclosure, addressing both scalability and security concerns.</p>\n<p>A significant highlight is the introduction of keystore rollups, which manage encryption keys off-chain to facilitate atomic cross-chain transactions. These rollups promote interoperability between sequencing networks, ensuring seamless data exchange and robust security. The research underscores the potential of modular blockchain networks and advocates for the adoption of ERC-4337 and future cryptographic advancements to standardize and optimize Ethereum’s execution layer.<br>\n<strong></strong></p><div class=\"lightbox-wrapper\"><strong><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/2/e/2e77cc94de2442ed8b9e865737b216b820de2396.png\" data-download-href=\"https://ethresear.ch/uploads/default/2e77cc94de2442ed8b9e865737b216b820de2396\" title=\"\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/2/e/2e77cc94de2442ed8b9e865737b216b820de2396_2_597x354.png\" alt=\"\" data-base62-sha1=\"6D4DbTTkaljJMbgMGtKlmte2pVQ\" width=\"597\" height=\"354\" role=\"presentation\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/2/e/2e77cc94de2442ed8b9e865737b216b820de2396_2_597x354.png, https://ethresear.ch/uploads/default/optimized/3X/2/e/2e77cc94de2442ed8b9e865737b216b820de2396_2_895x531.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/2/e/2e77cc94de2442ed8b9e865737b216b820de2396_2_1194x708.png 2x\" data-dominant-color=\"666666\"></a></strong></div><p></p>\n<p><strong>THE WORK</strong><br>\nUsing verifiable credentials (VCs) or Ethereum attestations (EAs) to empower bundlers in a shared mempool can potentially reduce the risk of on-chain reverts by sequencers and penalties for block builders. By including data assertions in user operations, bundlers are supported in the pre-validate certain aspects of the transactions. This pre-validation can help identify and filter out operations with a high risk of reverting during execution. This reduces the chances of sequencers including such operations in blocks, lowering the overall revert risk. VCs and EAs provide cryptographic proofs that can be verified by sequencers. These proofs can increase trust in the validity of the operations, making sequencers more confident about including them in blocks.</p>\n<p>This has potential positive consequences in terms of reducing risk of penalties for block builders. . Data assertions containing proofs about transaction ordering can help sequencers resist such manipulation attempts, potentially reducing penalties for block builders who are susceptible to MEV.</p>\n<p>The effectiveness of data assertions in reducing reverts and penalties depends on factors like network assertation standardization and native account abstraction adoption but using VCs and EAs in a shared mempool with ERC-4337 could be considered as first step to it and has the potential to significantly reduce the risk of on-chain reverts and penalties for sequencers and block builders.</p>\n<p>Overall, the complexity of implementing and maintaining new verification logic for bundlers may be compensated by an overall better synergy with the other actors in the network. Specifically on the logic side, general standards like did:pkh or did:dis could find common ground of assessment. In fact, the same verification logic is standards practice for user authentication where user store different assertation on the identity within the wallet application. Extending the same logic approach into the context of smart contract accounts we would suggest for bundlers to store data processing assertation into the mempool of future transactions until consolidated finality is reached.<br>\nAt the same time, a standardized method for signature validation will be required. ERC-1271 enhances the security and interoperability of the system. So to ensure that all signatures whether aggregated or individual, are verified uniformly, reducing the risk of fraud and enhancing trust in the system.<br>\nIn that context ERC-1271 facilitates efficient cross-chain operations by ensuring that signatures required for these transactions are validated consistently across different networks. This reduces the complexity and potential errors in verifying multiple signatures, making cross-chain transactions more efficient and reliable.</p>\n<p><a href=\"https://notes.ethereum.org/@yoav/unified-erc-4337-mempool\">The same verification and validation logic could be extended into a future unified mempool once potentially account abstraction would be natively implemented following 7560/7562 rules.</a></p>\n<p>Including proofs of VCs or EAs adds data to user operations, potentially leading to larger bundles and higher gas costs. This can put pressure on mempool capacity. Utilizing Merkle proofs within VCs can allow bundlers to verify the inclusion of specific data elements without needing the entire credential, reducing the amount of data processed. Merkle trees are a cryptographic data structure that allows for efficient verification of the membership of a specific data element within a larger set.</p>\n<p>After user authentication, for each user operation, the bundler includes a Merkle proof. This proof is a concise piece of data that demonstrates the specific assertion’s inclusion within the Merkle tree of the entire bundle. This can significantly reducing the overall size of the bundle compared to including the full VCs or EAs.</p>\n<p>VCs and EAs still remain crucial for containing the actual data and claims associated with user operations. Merkle proof act as a verification tool. They provide a concise way to prove that a specific VC or EA exists within a larger bundle of assertions without revealing the entire content of the VC/EA itself. This may help mitigate pressure on the mempool and potentially lowers gas costs.</p>\n<p>This would imply for bundlers to access a privacy preserving shared mempool ID and establish a dedicated membership set for associated bundle of transactions, so that Sequencers can verify the inclusion of user operations in the bundle. Sequencers or other network participants can efficiently verify the validity of data assertions using the Merkle proofs. They only need to verify the proof itself, not the entire data within the assertion, reducing the computational burden.</p>\n<p>VCs and EAs rely on the underlying logic verification process for authentication and authorization that should be implemented by bundlers. Verifying VCs or EAs requires processing cryptographic proofs. This can be computationally expensive for bundlers, especially for complex assertions.</p>\n<p><a href=\"https://papers.ssrn.com/sol3/papers.cfm?abstract_id=4563364\">Merkle proofs can be combined with ZKPs for a powerful solution.</a> ZKPs can be used within the data assertions themselves to prove the validity of claims without revealing the underlying data. Merkle proofs ensure the integrity of the bundle and verify the inclusion of specific assertions with ZKPs within the bundle. Also, using ZKPs in VCs or EAs could reduce the amount of data included in the bundle, minimizing disclosure, and lowering computational costs.</p>\n<p>Combining SSI verification with AA provides Ethereum a customizable authorization logic that can leverage national data repositories and business and regulatory standards before easily executing global on-chain operations. In this context, embedding a trust less verification logic can support standardizing user operations and streamlining sequencing activities, and so harmonizing operations across L2 transactions for unlocking cross chain atomic transaction and still ensuring efficient data processing compliant with data minimization.</p>\n<p>The transaction generation, submission and execution flow can be represented with an interchained process of triangles of trust representing each moment as described here.</p>\n<p><strong></strong></p><div class=\"lightbox-wrapper\"><strong><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/9/5/957433820f871fd453df50f9074cc21fd4bd9e1e.png\" data-download-href=\"https://ethresear.ch/uploads/default/957433820f871fd453df50f9074cc21fd4bd9e1e\" title=\"\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/9/5/957433820f871fd453df50f9074cc21fd4bd9e1e_2_643x361.png\" alt=\"\" data-base62-sha1=\"lk86o2b0PTKtbNka0sbQn3ZyNdk\" width=\"643\" height=\"361\" role=\"presentation\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/9/5/957433820f871fd453df50f9074cc21fd4bd9e1e_2_643x361.png, https://ethresear.ch/uploads/default/optimized/3X/9/5/957433820f871fd453df50f9074cc21fd4bd9e1e_2_964x541.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/9/5/957433820f871fd453df50f9074cc21fd4bd9e1e_2_1286x722.png 2x\" data-dominant-color=\"F4F4F4\"></a></strong></div><p></p>\n<p>The market pushing for an evolution of networks towards to modular blockchains is proposing concepts of shared mempools and shared sequencing that can embed trustless verification logic typical of SSI systems to establish a root of trust from user authentication until block validation still relying on Ethereum main network as indisputable security layer.</p>\n<p>This combination minimizes data disclosure while maintaining efficient verification, making the system more scalable and privacy-preserving.</p>\n<p><strong><a href=\"https://hackmd.io/@haichen/keystore\">Key store contract</a> <a href=\"https://hackmd.io/@haichen/keystore\">for flexible and efficient key management system</a></strong></p>\n<p>To further enhance standardization and interoperability considering key management an important function to manage user authentication and transaction authorization. A keystore contract paired with zero-knowledge proofs (ZKPs) has the potential to significantly improve the verification logic and overall functionality of data assertions within the ERC-4337 framework.</p>\n<p>The keystore contract can securely store and manage encryption keys used by bundlers to encrypt user operations within bundles after authentication. This can ensure that only authorized parties (with the appropriate decryption key) can access the sensitive data within the bundle.<br>\n</p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/4/2/42da34932f49f48f96077877f991029db0d43fb4.png\" data-download-href=\"https://ethresear.ch/uploads/default/42da34932f49f48f96077877f991029db0d43fb4\" title=\"image\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/4/2/42da34932f49f48f96077877f991029db0d43fb4_2_517x182.png\" alt=\"image\" data-base62-sha1=\"9xp0Z7yHybgHoue33xAye0bRoAk\" width=\"517\" height=\"182\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/4/2/42da34932f49f48f96077877f991029db0d43fb4_2_517x182.png, https://ethresear.ch/uploads/default/optimized/3X/4/2/42da34932f49f48f96077877f991029db0d43fb4_2_775x273.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/4/2/42da34932f49f48f96077877f991029db0d43fb4_2_1034x364.png 2x\" data-dominant-color=\"C6C7C1\"></a></div><p></p>\n<p>The keystore contract can facilitate the pairing of the correct key with specific data assertions within a bundle. This allows different network participants (builders and sequencers) to efficiently verify the authenticity of the data using the corresponding ZKPs without needing the actual data itself. A minimal keystore rollup deployed on Layer 2 can handle a large volume of key management and verification processes off-chain, reducing the load on the main Ethereum network.</p>\n<p>Many layers 2 networks are working on the rollup can be designed to be interoperable with different Layer 2 networks also leveraging shared sequencing. This allows for seamless data exchange and verification between different ecosystems, fostering a more interconnected environment supported of atomic cross chain transaction data process minimization and standardization.</p>\n<p><strong>Here is a potential process workflow and designed architecture:</strong></p>\n<p>The architecture is composed by three main layers:</p>\n<ol>\n<li>An application layer comprises wallets, PKIs apps, and SSI wallet such as Polygon ID, ZkSync ID, and other apps. These wallets and applications generate Verifiable Credentials (VCs) to prove ownership, such as being a DAO member. Users create operations as user intents via bundlers, enabling transactions and interactions on the blockchain. This layer facilitates the generation and management of credentials and user operations as “user intents” through apps, serving as the interface between users and the underlying blockchain infrastructure.</li>\n<li>A network layer based on different L2s, which include a Keystore contract and Smart Contract Accounts. This layer is responsible for generating Zero-Knowledge Proofs (ZKPs) for bundlers and Merkle proofs for Sequencers. The Keystore contract manages encryption keys and user authentication, ensuring secure handling of credentials and operations. Smart Contract Accounts validate user operations, generating cryptographic proofs to ensure the integrity and validity of transactions before they are submitted to the blockchain for execution.</li>\n<li>A sequencing layer which interconnect L2s with Ethereum main-net and manages the execution of batches of transactions anchoring Roll-up IDs to sequencing networks ( projects like SUAVE, Polygon Agg Layer, Espresso Capuccino). Main functions here are batching, validation of  transactions via the Keystore roll-up, and  the Roll-up contract within Ethereum’s slots. This layer ensures efficient transaction processing by batching multiple operations into single transactions, reducing on-chain congestion and costs. Additionally, it enable cross-chain atomic transactions, enabling seamless interoperability across different blockchain networks, ensuring that transactions are securely validated and finalized.</li>\n</ol>\n<p><strong></strong></p><div class=\"lightbox-wrapper\"><strong><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/6/7/676efe42126406535aece6ca6d086ff7e6396736.png\" data-download-href=\"https://ethresear.ch/uploads/default/676efe42126406535aece6ca6d086ff7e6396736\" title=\"\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/6/7/676efe42126406535aece6ca6d086ff7e6396736_2_687x392.png\" alt=\"\" data-base62-sha1=\"eL0YQ2NAoChvwfY0ub9iXBZr64e\" width=\"687\" height=\"392\" role=\"presentation\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/6/7/676efe42126406535aece6ca6d086ff7e6396736_2_687x392.png, https://ethresear.ch/uploads/default/optimized/3X/6/7/676efe42126406535aece6ca6d086ff7e6396736_2_1030x588.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/6/7/676efe42126406535aece6ca6d086ff7e6396736_2_1374x784.png 2x\" data-dominant-color=\"303030\"></a></strong></div><p></p>\n<ol>\n<li>User Authentication: Users authenticate using Verifiable Credentials (VCs) . They share Zero-Knowledge Proofs (ZKPs) of their credentials through a smart contract registry and sign user operations on a dedicated bundler.</li>\n<li>Bundler Operations: Bundlers access a shared mempool ID, create bundles of verified user operations, establish a dedicated Merkle tree for each bundle post-authentication, and share the Merkle proofs and ZKPs with the Sequencer. They submit the transaction bundles to the Smart Contract Account (entry point).</li>\n<li>Sequencer Verification: Sequencers verify Merkle proofs and ZKPs related to VCs. They validate bundles of transactions through the Smart Contract Account and submit them to the Block-builder for inclusion in a new block.</li>\n<li>Keystore Rollup: The keystore contract and rollup manage key functions, including user authentication, transaction submission, validation, and key recovery.</li>\n<li>Batching Transactions: Sequencer batch transactions into new block of Roll up IDs and submit them in batches via the Rollup contracts for validation on L1, verified by ZK validity proofs.</li>\n<li>Rollup Validation: The Rollup contract validates ZK proofs of batches, and the block is  finalized or reverted if validation fails.</li>\n</ol>\n<p>Specifically in this scenario, proposals as ERC 5792 acts as a crucial bridge between user-facing applications and the infrastructure of the ERC-4337 framework. The proposal defines a common language for wallets, apps, and bundlers to communicate each other and it has the potential to significantly enhance the adoption of Smart Contract Accounts and position as the go-to standard for data assertions on the Ethereum blockchain.</p>\n<p>Wallets and apps could signal user preferences (e.g., gas fees, preferred chain ID, or shared sequencer), required data assertions (VCs/EAs) for specific transactions.</p>\n<p>Bundlers could leverage the received signals to automatically construct appropriate bundles for user transactions including user operations data, Merkle proofs for associated VCs/EAs and ZKP of user data claim. With this having an overall improvement for user flexibility, network decentralization and scalability.</p>\n<p>The proposed design also goes into the direction of modular networks that can be built over Ethereum network by the Ethereum community. In this modular scenario ERC 4337 and future developments benefits from possible future implementations as Verkle trees or consensus related proposals as ePBS.</p>\n<p>Bundlers create bundles containing user operations, Merkle proofs, VCs/EAs (potentially with ZKPs), and additional data.</p>\n<p>Sequencers verify Merkle proofs and potentially VCs/EAs within bundles, order bundles, perform additional verification if needed, submit pre-built blocks to validators.</p>\n<p>Before accepting the request, the sequencer should:</p>\n<ul>\n<li>If block range was given, check that the block number is within the range.</li>\n<li>If timestamps range was given, check that the block’s timestamp is within the range.</li>\n<li>For an address with a storage root hash, validate the current root is unmodified.</li>\n<li>For an address with a list of slots, it should verify that all these slots hold the exact value specified.</li>\n</ul>\n<p><a href=\"https://notes.ethereum.org/@yoav/SkaX2lS9j#\">The sequencer should REJECT the request if any address is doesn’t pass the above rules.</a></p>\n<p>Builders construct valid blocks based on pre-verified and potentially pre-ordered bundles received from sequencers, considering block gas limits and network conditions. Ultimately, validators verify the validity of submitted blocks (including the validity of the included bundles), reach consensus on block inclusion in the blockchain.</p>\n<p><strong>CONCLUSION</strong><br>\nDriving towards the adoption of blockchain services implies relying on modular networks that can balance security, scalability and decentralization to populate an ecosystem of applications as plug and play solutions for dedicated use cases, in this regard combining SSI verification logic into the network operations to users and machines to support accountability and compliant data processing process is key. Smart Contract Accounts can facilitate adoption by flexible UX and shared sequencing networks support cross chain atomic transaction reconciliation. The narrative of this research wants to emphasize the need to abstract complexities from accounts, and networks where decentralized identifiers and keystore roll up can facilitate the verification and execution of sequencing networks.</p>\n<p><strong>Takeaways</strong>:</p>\n<ul>\n<li>\n<p><strong>SSI</strong>: Integrates trustless identification, enhancing privacy and data minimization.</p>\n</li>\n<li>\n<p><strong>AA</strong>: Simplifies user experience and facilitates regulatory compliance and governance needs.</p>\n</li>\n<li>\n<p><strong>Verifiable Credentials (VCs) and Ethereum Attestations (EAs)</strong>: Used to empower bundlers, reducing the risk of on-chain reverts and penalties for block builders by providing cryptographic proofs.</p>\n</li>\n<li>\n<p><strong>Merkle Proofs</strong>: Efficiently verify specific data elements within larger sets, mitigating mempool pressure and lowering gas costs.</p>\n</li>\n<li>\n<p><strong>Zero-Knowledge Proofs (ZKPs)</strong>: Enhance privacy by proving the validity of claims without revealing underlying data.</p>\n</li>\n<li>\n<p><strong>Shared Mempools</strong>: Facilitate bundler operations and reduce computational burdens.</p>\n</li>\n<li>\n<p><strong>Keystore rollups</strong> Enhance atomic cross-chain transactions across sequencing networks by providing a scalable and interoperable key management solution that ensures seamless data exchange and verification across different L2.*</p>\n</li>\n</ul>\n<p><strong>References</strong>:<br>\n<a href=\"https://notes.ethereum.org/@yoav/AA-roadmap-May-2024\">Notes on the Account Abstraction roadmap</a><br>\n<a href=\"https://github.com/ethereum/RIPs/blob/e3bead34f1bcf1aa37fd51923ad99a77b801775c/RIPS/rip-7560.md#unused-gas-penalty-charge\">RIP 7560</a><br>\n<a href=\"https://eips.ethereum.org/EIPS/eip-7562\">EIP 7562</a><br>\n<a href=\"https://hackmd.io/@alexforshtat/native-account-abstraction-roadmap\">Roadmap for Native Account Abstraction Introduction</a>)<br>\n<a href=\"https://notes.ethereum.org/@yoav/unified-erc-4337-mempool\">Unified ERC-4337 mempool</a><br>\n<a href=\"https://papers.ssrn.com/sol3/cf_dev/AbsByAuth.cfm?per_id=6131244\">Blockchain Privacy and Regulatory Compliance: Towards a Practical Equilibrium</a><br>\n<a href=\"https://hackmd.io/@haichen/keystore\">Keystore Design</a><br>\n<a href=\"https://notes.ethereum.org/@vbuterin/minimal_keystore_rollup\">Dedicated minimal rollup for keystores</a><br>\n<a href=\"https://notes.ethereum.org/@yoav/SkaX2lS9j#\">Integration API for EIP-4337 bundler with an L2 validator/sequencer</a><br>\n<a href=\"https://etherspot.io/blog/decentralized-future-erc-4337-shared-mempool-launches-on-ethereum/\">Decentralized Future: ERC-4337 Shared Mempool Launches on Ethereum</a><br>\n<a href=\"https://www.w3.org/TR/vc-data-model-2.0/#:~:text=A%20verifiable%20credential%20is%20a,certificates%2C%20and%20digital%20educational%20certificates.\">Verifiable Credentials Data Model v2.0</a><br>\n<a href=\"https://attest.org/\">Ethereum Attestation Service</a><br>\n<a href=\"https://mirror.xyz/0xeee68aECeB4A9e9f328a46c39F50d83fA0239cDF/afmS07VvelERZHzG6SSzhOKJlNwhU3jsE-4atkbNZto\">Supercharging Account Abstraction with Attestations</a><br>\n<a href=\"https://hackmd.io/@mdehoog/mksr\">Minimal KeyStore Rollup spec</a><br>\n<a href=\"https://eips.ethereum.org/EIPS/eip-1271\">ERC-1271: Standard Signature Validation Method for Contracts</a></p>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://ethresear.ch/t/unveiling-the-power-of-self-sovereign-identity-and-account-abstraction-for-privacy-preserving-user-operations/19599\">Read full topic</a></p>","link":"https://ethresear.ch/t/unveiling-the-power-of-self-sovereign-identity-and-account-abstraction-for-privacy-preserving-user-operations/19599","pubDate":"Mon, 20 May 2024 15:05:28 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-19599"},"source":{"@url":"https://ethresear.ch/t/unveiling-the-power-of-self-sovereign-identity-and-account-abstraction-for-privacy-preserving-user-operations/19599.rss","#text":"Unveiling the Power of Self-Sovereign Identity and Account Abstraction for Privacy-Preserving User Operations"},"filter":false},{"title":"Derivatives Market for Implementing Based Sequencing","dc:creator":"0xTariz","category":"Economics","description":"<p>Authors: <a href=\"https://x.com/Hyunxukee\" rel=\"noopener nofollow ugc\">Tariz</a> (<a href=\"https://x.com/radius_xyz\" rel=\"noopener nofollow ugc\">Radius</a>)</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/1/0/1082a792a892a3e09ad171507d684219426b59dc.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/1082a792a892a3e09ad171507d684219426b59dc\" title=\"8qmb0g\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/1/0/1082a792a892a3e09ad171507d684219426b59dc_2_690x388.jpeg\" alt=\"8qmb0g\" data-base62-sha1=\"2m3z4sIChJ9yHQOLZQ26ZnXfs7y\" width=\"690\" height=\"388\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/1/0/1082a792a892a3e09ad171507d684219426b59dc_2_690x388.jpeg, https://ethresear.ch/uploads/default/original/3X/1/0/1082a792a892a3e09ad171507d684219426b59dc.jpeg 1.5x, https://ethresear.ch/uploads/default/original/3X/1/0/1082a792a892a3e09ad171507d684219426b59dc.jpeg 2x\" data-dominant-color=\"77605A\"></a></div><p></p>\n<p><em>Special thanks to <a href=\"https://x.com/NathanYJLee\" rel=\"noopener nofollow ugc\">Nathan</a> from <a href=\"https://x.com/factomind\" rel=\"noopener nofollow ugc\">Factomind</a> for his valuable advice on the design of the derivatives market.</em></p>\n<h1><a name=\"tldr-1\" class=\"anchor\" href=\"https://ethresear.ch#tldr-1\"></a><strong>TL;DR</strong></h1>\n<p>This article introduces a derivatives market designed to implement based sequencing for fast finality in rollups. The proposed market aims to align incentives between Ethereum and rollups, mitigate operational risks associated with rollups, and promote voluntary participation and fair competition among rollups, proposers, and builders.</p>\n<p>The unique design allows rollups to act as preconf providers, offering users fast preconfirmation while minimizing censorship, sandwich attacks, and frontrunning risks.</p>\n<blockquote>\n<p><em>For the full proposal, please refer to the complete <a href=\"https://mirror.xyz/tariz.eth/-TZxI3AplP-O11i-yTnyfPjwiaPOUvaWOZ32xqbpnQE\" rel=\"noopener nofollow ugc\">blog post</a>. This summary covers only the key design aspects.</em></p>\n</blockquote>\n<h1><a name=\"motivation-2\" class=\"anchor\" href=\"https://ethresear.ch#motivation-2\"></a>Motivation</h1>\n<p>If rollups, acting as preconf providers, pay proposers to pre-purchase the block building rights for specific slots, they can deterministically promise settlement to users by owning the Ethereum block. This mechanism allows rollups to achieve fast preconfirmation through self-sequencing. However, the difficulty in predicting future block prices introduces operational risks for rollups. To offset these operational risks and create a fair market that encourages active participation from traders, I propose a series of derivatives.</p>\n<blockquote>\n<p><em>This idea is connected to the implementation of delegated preconf mentioned in <a class=\"mention\" href=\"https://ethresear.ch/u/justindrake\">@JustinDrake</a> <a href=\"https://ethresear.ch/t/based-preconfirmations/17353\">based preconfirmation</a>.</em></p>\n</blockquote>\n<h1><a name=\"forward-contract-3\" class=\"anchor\" href=\"https://ethresear.ch#forward-contract-3\"></a><strong>Forward Contract</strong></h1>\n<p>The process of a rollup purchasing the block building rights for a specific slot from a proposer can be likened to a forward contract in financial markets. To understand the operational risks a rollup might face in this transaction, let’s consider a basic scenario involving a 32-slot lookahead for the proposer and a slot auction.</p>\n<ol>\n<li>At t = 1, the rollup participates in a slot auction to purchase a forward contract with the proposer for a specific slot.</li>\n<li>From t = 2 onwards, after securing the slot, the rollup sequences its users’ transactions, providing preconfirmation to users and generating revenue from the block.</li>\n<li>At t = 3, the rollup requests the execution of the forward contract, compressing its transactions into an Ethereum block and submitting them to the proposer.</li>\n<li>At t = 4, the proposer fulfills the contract by signing the received block and proposing it on Ethereum.</li>\n</ol>\n<p><strong>Operational Risks for Rollups</strong></p>\n<ol>\n<li><strong>Excessive Payment Risk</strong>: Rollups may find it challenging to accurately predict block value, leading to overpayment for block space. This occurs because they have to participate in slot auctions and purchase the entire space even if they only need a portion for settlement.</li>\n<li><strong>Revenue Uncertainty</strong>: Rollups cannot reliably predict their future revenue. If transaction costs exceed revenue, they may face potential financial risks.</li>\n<li><strong>Increased Labor Costs</strong>: To ensure stable operations, rollups must now engage in activities such as predicting Ethereum block values, competing with builders, and accurately forecasting revenues, which were previously unnecessary.</li>\n</ol>\n<h1><a name=\"derivative-market-4\" class=\"anchor\" href=\"https://ethresear.ch#derivative-market-4\"></a>Derivative Market</h1>\n<p>To mitigate the operational risks faced by rollups, we propose a derivatives market involving specialized participants, builders. This market includes two key derivatives: a forward contract between the builder and the proposer, and a swap contract between the rollup and the builder.</p>\n<ol>\n<li>At t = 1, the builder participates in a slot auction and enters into a forward contract with the proposer for the block building right.</li>\n<li>At t = 2, the rollup and the builder enter into a swap contract. This contract obligates the builder to include the rollup’s transactions in the block.</li>\n<li>At t = 3, utilizing the block building right secured through the swap contract, the builder constructs the rollup block up until t = 4, thereby generating revenue.</li>\n<li>At t = 4, the rollup demands contract fulfillment according to the obligations stipulated in the swap contract:\n<ul>\n<li>The rollup requires the builder to include its transactions in the Ethereum block secured through the forward contract.</li>\n<li>To maximize revenue, the builder places the rollup’s transactions at the bottom of the Ethereum block and its own transactions at the top, forming a complete block.</li>\n</ul>\n</li>\n<li>At t = 5, the builder delivers the Ethereum block to the proposer, who then proposes it on Ethereum, fulfilling the forward contract.</li>\n</ol>\n<p><strong>Motivation for Participation</strong></p>\n<ul>\n<li><strong>Rollup</strong>: Rollups participate to provide deterministic preconfirmation to users regarding their inclusion in Ethereum, while mitigating the operational risks associated with purchasing block space. Preconfirmed transactions are guaranteed inclusion in the Ethereum block, avoiding the risk of spending more than their revenue on block space. This eliminates the need for unnecessary labor in price prediction and auction participation.</li>\n<li><strong>Builder</strong>: Builders participate to reduce the risk of overpayment from slot auctions. The secured Ethereum block space, along with the rollup block, offers dual revenue streams, diversifying and reducing the risk of loss.</li>\n<li><strong>Proposer</strong>: Proposers participate to receive compensation for rollup preconfirmation. Builders consider the revenue generated from rollup blocks when bidding in slot auctions, aligning proposer incentives with rollup settlement.</li>\n</ul>\n<h1><a name=\"additional-design-5\" class=\"anchor\" href=\"https://ethresear.ch#additional-design-5\"></a><strong>Additional Design</strong></h1>\n<p>To effectively implement these financial products, it is crucial to create an environment where all participants can compete fairly and engage actively. This involves three key additional design elements.</p>\n<p><strong>Conditional Swap Contract</strong></p>\n<p>Rollups may be hesitant to participate if they are required to allocate all potential revenue opportunities to builders through a swap contract. To encourage rollup participation, a conditional swap contract is proposed.</p>\n<p>In this arrangement, if the builder generates profits from the rollup’s block building that exceed the fixed costs paid in the forward contract with the proposer, the rollup is allowed to stop providing the remaining block space to the builder. The rollup can then use the remaining block space to either build independently or auction it to builders for additional revenue.</p>\n<p>This approach preserves the builder’s incentive to participate while protecting the rollup’s opportunity to generate revenue.</p>\n<p><strong>Competitive Proposer Market</strong></p>\n<p>Settlement is essential for rollups to inherit Ethereum’s security. When rollups are compelled to purchase blocks, proposers/builders gain significant pricing power, potentially leading to an uneven playing field that undermines market fairness and efficiency.</p>\n<p>To reduce the pricing power of any single builder, multiple builders should be encouraged to participate in swap transactions, fostering competition among them. This requires expanding the forward contract market to include multiple proposers with block building rights for different slots.</p>\n<p>Such a structure ensures that the variable value of the rollup’s block aligns more closely with the fixed cost of acquiring Ethereum block space. This is analogous to achieving a ‘par value’ of zero for swap contracts in a competitive market, maintaining reasonable costs for rollups. The lookahead necessary to achieve this par value requires further discussion.</p>\n<p><strong>Syndicated Rollup Strategy: Derivatives for All Rollups</strong></p>\n<p>Builders may be unwilling to engage with rollups that have relatively low block value, potentially marginalizing app-specific rollups in the market.</p>\n<p>The Syndicated Rollup Strategy groups multiple rollups into a syndicate, enhancing their market participation. Cross-rollup arbitrage has the potential to increase the value of each block. Builders receive the block building rights for the rollups in the group, and the rollups require the builder to include all group transactions in the Ethereum block.</p>\n<h1><a name=\"building-blocks-in-rollups-6\" class=\"anchor\" href=\"https://ethresear.ch#building-blocks-in-rollups-6\"></a><strong>Building Blocks in Rollups</strong></h1>\n<p>This section describes how builders secure rollup block building rights through swap contracts, focusing on censorship resistance and fast preconfirmation for user-centric rollups.</p>\n<p><strong>Censorship Resistance</strong></p>\n<p>In a structure similar to Proposer-Builder Separation (PBS), rollups that enter into swap contracts receive blocks from builders and execute them. However, this setup may expose users to censorship, sandwich attacks, and frontrunning by builders. Rollups can address these issues by integrating Radius’s <a href=\"https://docs.theradius.xyz/testnet/curie-testnet/encrypted-mempool\" rel=\"noopener nofollow ugc\">sequencing engine</a>.</p>\n<ul>\n<li><strong>Encrypted Mempool (using <a href=\"https://ethresear.ch/t/radius-skde-enhancing-rollup-composability-with-trustless-sequencing/19185\">delay encryption</a>)</strong>: Users’ transactions are encrypted until the promise of inclusion in the rollup block is issued.</li>\n<li><strong>Decryption and Execution</strong>: Once inclusion is confirmed, transactions are decrypted and executed by the rollup, providing preconfirmation similar to standard transactions.</li>\n<li><strong>Economic Order Guarantees</strong>: By assigning an order to the inclusion promises, the economic guarantees ensure that transactions cannot be reordered after decryption, minimizing the risk of frontrunning and sandwich attacks.</li>\n</ul>\n<p><strong>Fast Preconfirmation</strong></p>\n<p>Rollups can achieve fast preconfirmation by designating the preconf provider as their sequencer and implementing self-sequencing. Block space is divided into two segments: Top-of-Block (ToB) and Bottom-of-Block (BoB).</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/d/2/d23430465b0f7160e93904427eba688aef1fff2f.png\" data-download-href=\"https://ethresear.ch/uploads/default/d23430465b0f7160e93904427eba688aef1fff2f\" title=\"스크린샷 2024-05-07 오후 12.44.26\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/d/2/d23430465b0f7160e93904427eba688aef1fff2f_2_690x366.png\" alt=\"스크린샷 2024-05-07 오후 12.44.26\" data-base62-sha1=\"tZy56lMBexmrb7iz0LDznXskJiv\" width=\"690\" height=\"366\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/d/2/d23430465b0f7160e93904427eba688aef1fff2f_2_690x366.png, https://ethresear.ch/uploads/default/optimized/3X/d/2/d23430465b0f7160e93904427eba688aef1fff2f_2_1035x549.png 1.5x, https://ethresear.ch/uploads/default/original/3X/d/2/d23430465b0f7160e93904427eba688aef1fff2f.png 2x\" data-dominant-color=\"E8E7E6\"></a></div><p></p>\n<ul>\n<li>\n<p><strong>Top-of-Block (ToB)</strong>: This space is allocated to the builder under the swap contract. The builder creates a backrunning bundle based on the rollup’s previous block state and submits it to the rollup’s sequencer.</p>\n</li>\n<li>\n<p><strong>Bottom-of-Block (BoB)</strong>: This space is reserved for end-user transactions. The rollup sequences these transactions and provides preconfirmation.</p>\n<p>Using Radius’s sequencing engine in BoB protects users’ transactions from censorship by the sequencer and harmful MEV by the builder, as the builder cannot see the user’s transactions when creating the ToB.</p>\n</li>\n</ul>\n<p><strong>Syndicated Rollup Strategy</strong></p>\n<p>In a syndicated rollup strategy, a group of rollups entering into swap contracts with a builder allocates ToB space to the builder. The builder submits a cross-rollup bundle to be included in the ToB.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/c/4/c4dcc9cf943b6b8894cbabc1360b8aa91e92b141.png\" data-download-href=\"https://ethresear.ch/uploads/default/c4dcc9cf943b6b8894cbabc1360b8aa91e92b141\" title=\"스크린샷 2024-05-10 오전 11.09.13 (1)\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/c/4/c4dcc9cf943b6b8894cbabc1360b8aa91e92b141_2_690x432.png\" alt=\"스크린샷 2024-05-10 오전 11.09.13 (1)\" data-base62-sha1=\"s5wCva1N40Czigkkoa0abMvvOA9\" width=\"690\" height=\"432\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/c/4/c4dcc9cf943b6b8894cbabc1360b8aa91e92b141_2_690x432.png, https://ethresear.ch/uploads/default/original/3X/c/4/c4dcc9cf943b6b8894cbabc1360b8aa91e92b141.png 1.5x, https://ethresear.ch/uploads/default/original/3X/c/4/c4dcc9cf943b6b8894cbabc1360b8aa91e92b141.png 2x\" data-dominant-color=\"F0EFEE\"></a></div><p></p>\n<p>A <a href=\"https://docs.theradius.xyz/testnet/portico-testnet/multi-rollup-sequencing\" rel=\"noopener nofollow ugc\">Shared Sequencing Engine</a> aims to ensures smooth contract execution between rollups and builders. It will verifies that the builder submitting the bundle is a party to the swap contract and is designed to ensure that all rollups in the group fulfill the contract by including the builder’s submitted bundles in ToB.</p>\n<p>Rollups can choose the shared sequencing engine for BoB sequencing. This allows the selected sequencer to act as a shared preconf provider, supporting atomic inclusion for end-users across multiple rollups.</p>\n<h1><a name=\"conclusion-7\" class=\"anchor\" href=\"https://ethresear.ch#conclusion-7\"></a><strong>Conclusion</strong></h1>\n<p>I am enthusiastic about the future of a rollup-centric Ethereum and am dedicated to exploring designs that benefit rollup users. A derivatives market that incentivizes voluntary participation of Ethereum for rollup settlements can significantly contribute to the effective implementation of based sequencing. My future research related to the derivatives market includes the following areas:</p>\n<ul>\n<li>Exploring the technical requirements necessary for market implementation.</li>\n<li>Updating the design to accommodate rollups utilizing blobspace.</li>\n<li>Proposing additional designs that can contribute to Ethereum’s decentralization, potentially considering the separation of beacon proposers and execution proposers as suggested in <a class=\"mention\" href=\"https://ethresear.ch/u/mikeneuder\">@mikeneuder</a> <a href=\"https://ethresear.ch/t/execution-tickets/17944\">Execution Ticket</a> and <a class=\"mention\" href=\"https://ethresear.ch/u/barnabe\">@barnabe</a> <a href=\"https://mirror.xyz/barnabe.eth/QJ6W0mmyOwjec-2zuH6lZb0iEI2aYFB9gE-LHWIMzjQ\" rel=\"noopener nofollow ugc\">APS-Burn</a>.</li>\n</ul>\n<p>Beyond the derivatives market, I am exploring various methods for implementing based sequencing. I look forward to contributing to this field through diverse feedback and collaboration within the community.</p>\n            <p><small>6 posts - 4 participants</small></p>\n            <p><a href=\"https://ethresear.ch/t/derivatives-market-for-implementing-based-sequencing/19593\">Read full topic</a></p>","link":"https://ethresear.ch/t/derivatives-market-for-implementing-based-sequencing/19593","pubDate":"Mon, 20 May 2024 03:49:17 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-19593"},"source":{"@url":"https://ethresear.ch/t/derivatives-market-for-implementing-based-sequencing/19593.rss","#text":"Derivatives Market for Implementing Based Sequencing"},"filter":false},{"title":"DAS fork-choice","dc:creator":"fradamt","category":"Consensus","description":"<p><em>Written by <a href=\"https://twitter.com/fradamt\" rel=\"noopener nofollow ugc\">Francesco</a>, <a href=\"https://twitter.com/luca_zanolini\" rel=\"noopener nofollow ugc\">Luca</a> and <a href=\"https://twitter.com/robsaltini\" rel=\"noopener nofollow ugc\">Roberto</a></em></p>\n<p>The goal of this document is to deepen our understanding of the interactions between the fork-choice and the data availability layer after introduction of data availability sampling (DAS), with the aim of mitigating potential attacks that arise. To achieve this, we first identify potential attacks under the current fork-choice specification and suggest strategies to counter them. This analysis assumes familiarity with <a href=\"https://github.com/ethereum/consensus-specs/blob/d29581315579d37064abf21b174750f9d5c099c0/specs/phase0/fork-choice.md\" rel=\"noopener nofollow ugc\">the current fork-choice</a> and <a href=\"https://notes.ethereum.org/@luca-zanolini/Skf98kZ_i\" rel=\"noopener nofollow ugc\">known attacks</a>, and with <a href=\"https://github.com/ethereum/consensus-specs/blob/d29581315579d37064abf21b174750f9d5c099c0/specs/_features/eip7594/das-core.md\" rel=\"noopener nofollow ugc\">PeerDAS</a>.</p>\n<h2><a name=\"distribution-phase-and-sampling-phase-1\" class=\"anchor\" href=\"https://ethresear.ch#distribution-phase-and-sampling-phase-1\"></a>Distribution phase and sampling phase</h2>\n<p>Recall that in <a href=\"https://ethresear.ch/t/peerdas-a-simpler-das-approach-using-battle-tested-p2p-components/16541\">PeerDas</a>, each blob is individually extended horizontally, stacked vertically and subdivided in <code>NUM_COLUMNS</code> columns, which are used as the sampling unit. PeerDas comprises two phases: a distribution phase and a sampling phase. In the distribution phase, columns are allocated among subsets of validators, with each subset tasked with the custody of one or more columns (<code>CUSTODY_REQUIREMENT</code>). Subsequently, in the sampling phase, validators request samples to verify data availability. These samples, or columns, are acquired from peers through a request/response mechanism. The distribution phase can also serve as a kind of preliminary sampling phase, enabling a validator to consider data available if all the columns it’s required to custody are available, even before completing the actual sampling phase. This proves especially valuable when employing a <em>trailing fork-choice</em> function, a concept explaned further below.</p>\n<h2><a name=\"tight-fork-choice-2\" class=\"anchor\" href=\"https://ethresear.ch#tight-fork-choice-2\"></a>Tight fork-choice</h2>\n<p>Ideally, <em>almost</em> all honest validators would ever only vote for blocks that are fully available, without needing to download all of the data. To achieve this, we can require a sufficiently high amount of sampling to be completed before ever voting for a block. We refer to this as the <em>tight fork-choice</em>. In PeerDAS, this would mean that validators are required to perform peer sampling immediately upon receiving a block, and cannot vote for it without completing it. This gives us a useful property, which we call <em><span class=\"math\">\\delta</span>-safety of sampling</em>, for some <span class=\"math\">\\delta \\in [0,1/2]</span> dependent on the amount of sampling (<span class=\"math\">\\delta \\to 0</span> as number of samples increases)</p>\n<blockquote>\n<p><span class=\"math\">\\delta</span>-safety of sampling: If some data is less than half-available, at most a fraction <span class=\"math\">\\delta</span> of the honest validators will perceive it as available. As a consequence, no more than a fraction <span class=\"math\">\\delta</span> of the honest validators would vote for an unavailable block.</p>\n</blockquote>\n<h2><a name=\"trailing-fork-choice-3\" class=\"anchor\" href=\"https://ethresear.ch#trailing-fork-choice-3\"></a>Trailing fork-choice</h2>\n<p>However, to avoid additional steps between the distribution of blocks and columns and voting, one might consider relaxing this requirement, with the goal of taking peer sampling out of the critical path. Specifically, <a href=\"https://ethresear.ch/t/peerdas-a-simpler-das-approach-using-battle-tested-p2p-components/16541#a-note-on-fork-choice-14\">it has been proposed</a>, and <a href=\"https://github.com/ethereum/consensus-specs/issues/3652\" rel=\"noopener nofollow ugc\">is still being discussed</a>, that validators could forego completing the peer sampling process before casting a vote for the currently proposed block, and postpone it until the next slot (or even further in the future). Instead, they would base their vote on the outcome of the column distribution; if all the data within its assigned subnets is available, a validator deems the entire block available and votes accordingly. Peer sampling for this block would then only be required to be completed before the next slot. We refer to this as <em>the trailing fork-choice</em>.</p>\n<p>Using the trailing fork-choice does not necessarily mean entirely giving up on <span class=\"math\">\\delta</span>-safety of sampling, even during the “trailing period”. In fact, incorporating a sufficient amount of <a href=\"https://ethresear.ch/t/subnetdas-an-intermediate-das-approach/17169\"><em>subnet sampling</em></a> in the column distribution phase allows us to preserve some level of <span class=\"math\">\\delta</span>-safety. In practice, we will do less subnet sampling than we would peer sampling, because subnet sampling is more bandwidth intensive due to the gossip amplification factor it incurs. Therefore, the <span class=\"math\">\\delta</span>-safety from subnet sampling will be for a higher <span class=\"math\">\\delta</span> than for peer sampling, meaning that a higher percentage of honest validators can be tricked into voting incorrectly.</p>\n<p>When discussing the trailing fork-choice in the rest of the document, we are going to use <span class=\"math\">\\delta_p</span> to refer to the <span class=\"math\">\\delta</span>-safety of peer sampling, and <span class=\"math\">\\delta_s</span> to refer to that of subnet sampling. We also going to assume that <span class=\"math\">\\delta_s \\gg \\delta_p</span>, i.e., that the safety loss from peer sampling is negligible compared to the safety loss from subnet sampling.</p>\n\n<h2><a name=\"attacks-4\" class=\"anchor\" href=\"https://ethresear.ch#attacks-4\"></a>Attacks</h2>\n<h3><a name=\"refresher-ex-ante-reorgs-5\" class=\"anchor\" href=\"https://ethresear.ch#refresher-ex-ante-reorgs-5\"></a>Refresher: Ex-ante reorgs</h3>\n<p>Ex-ante reorg attacks are a <a href=\"https://arxiv.org/pdf/2302.11326\" rel=\"noopener nofollow ugc\">well-known</a> threat to the current Ethereum consensus protocol. An adversary controlling a significant fraction of validators can influence the blockchain’s canonical chain through strategic block withholding. In this attack, the adversary privately constructs blocks and orchestrates votes among its validators across multiple slots, ultimately outvoting honest blocks upon their release. This can happen either by overcoming proposer boost with a well-timed release of the withheld blocks and attestations, or by directly overcoming the votes of honest validators.</p>\n<p>We now show an instance of the former strategy, where adversarial blocks <span class=\"math\">B</span> and <span class=\"math\">C</span> are withheld together with adversarial attestations comprising 21% of each committee. An honest proposer extends block <span class=\"math\">A</span> with block <span class=\"math\">D</span>, and the adversary then reveals the withheld objects before the attestation deadline. Since the adversarial votes outweigh proposer boost, the honest block does not get voted and is orphaned.</p>\n\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/8/4/84b2e4a3709361e8d59950234884b8efc69ca94d.png\" data-download-href=\"https://ethresear.ch/uploads/default/84b2e4a3709361e8d59950234884b8efc69ca94d\" title=\"\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/8/4/84b2e4a3709361e8d59950234884b8efc69ca94d_2_690x230.png\" alt=\"\" data-base62-sha1=\"iVUiM6YAuJbuLjxCcmMKSZN6SId\" role=\"presentation\" width=\"690\" height=\"230\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/8/4/84b2e4a3709361e8d59950234884b8efc69ca94d_2_690x230.png, https://ethresear.ch/uploads/default/optimized/3X/8/4/84b2e4a3709361e8d59950234884b8efc69ca94d_2_1035x345.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/8/4/84b2e4a3709361e8d59950234884b8efc69ca94d_2_1380x460.png 2x\" data-dominant-color=\"F4F6F1\"></a></div><p></p>\n<p>These attacks remain viable even with the addition of DAS, and in fact can become more effective because of it, as we discuss in the upcoming sections.</p>\n<h3><a name=\"proposer-sees-unavailable-attesters-see-available-enhanced-ex-ante-reorgs-6\" class=\"anchor\" href=\"https://ethresear.ch#proposer-sees-unavailable-attesters-see-available-enhanced-ex-ante-reorgs-6\"></a>Proposer sees <em>unavailable</em>, attesters see <em>available</em>: enhanced ex-ante reorgs</h3>\n<h4><a name=\"with-the-tight-fork-choice-7\" class=\"anchor\" href=\"https://ethresear.ch#with-the-tight-fork-choice-7\"></a>With the tight fork-choice</h4>\n<p>The adversary is able to somewhat strengthen the ex-ante reorg attack from the previous section, by leveraging the fraction <span class=\"math\">\\delta</span> of honest validators which it can trick into thinking that an unavailable block is available. It proceeds as following:</p>\n<ol>\n<li>Instead of completely withholding block <span class=\"math\">B</span>, the adversary publishes it but does not fully publish the associated data. It does so in such a way that it maximizes the amount of honest validators whose subnet sampling is successful, and thus who think that B is available.</li>\n<li>Therefore, <span class=\"math\">\\delta</span> such validators vote for <span class=\"math\">B</span>, joining the <span class=\"math\">\\beta</span> adversarial validators.</li>\n<li>The adversary then extends <span class=\"math\">B</span> with another block <span class=\"math\">C</span>, itself fully available. Again, <span class=\"math\">\\delta</span> honest validators and <span class=\"math\">\\beta</span> adversarial validators vote for <span class=\"math\">C</span></li>\n<li>This continues until an honest slot, whose proposer attempts to fork <span class=\"math\">B</span> out (unless they happen to be in the <span class=\"math\">\\delta</span> which see it as available). At this point, the adversary makes <span class=\"math\">B</span> available, and the honest proposal does not get voted if the votes on the adversarial chain overcome the proposer boost.</li>\n</ol>\n<p>Compared to the previous attack, the adversary gains an extra <span class=\"math\">\\delta</span> per slot. It is therefore important to do enough sampling to keep <span class=\"math\">\\delta</span> low.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/c/d/cddc68f29f049beb3c25464648d8c51340f11d41.png\" data-download-href=\"https://ethresear.ch/uploads/default/cddc68f29f049beb3c25464648d8c51340f11d41\" title=\"\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/c/d/cddc68f29f049beb3c25464648d8c51340f11d41_2_690x227.png\" alt=\"\" data-base62-sha1=\"tn86FyT7EhtWKxyE7j1dccmNTY5\" role=\"presentation\" width=\"690\" height=\"227\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/c/d/cddc68f29f049beb3c25464648d8c51340f11d41_2_690x227.png, https://ethresear.ch/uploads/default/optimized/3X/c/d/cddc68f29f049beb3c25464648d8c51340f11d41_2_1035x340.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/c/d/cddc68f29f049beb3c25464648d8c51340f11d41_2_1380x454.png 2x\" data-dominant-color=\"F1F6EE\"></a></div><p></p>\n<h4><a name=\"with-the-trailing-fork-choice-8\" class=\"anchor\" href=\"https://ethresear.ch#with-the-trailing-fork-choice-8\"></a>With the trailing fork-choice</h4>\n<p>As already mentioned, here we are going to assume that <span class=\"math\">\\delta_p \\ll \\delta_s</span> and only worry about the effect of <span class=\"math\">\\delta_s</span>. The adversary is only able to exploit <span class=\"math\">\\delta_s</span> <em>during the trailing period</em>. With a trailing period of one slot, it can at most add a single <span class=\"math\">\\delta_s</span> to its attack budget.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/c/9/c9feb4d9369e37cf736b329f4fc213e5e197c18c.png\" data-download-href=\"https://ethresear.ch/uploads/default/c9feb4d9369e37cf736b329f4fc213e5e197c18c\" title=\"\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/c/9/c9feb4d9369e37cf736b329f4fc213e5e197c18c_2_690x247.png\" alt=\"\" data-base62-sha1=\"sOVG0EEvuuLQFHjw5esyTZu4SMQ\" role=\"presentation\" width=\"690\" height=\"247\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/c/9/c9feb4d9369e37cf736b329f4fc213e5e197c18c_2_690x247.png, https://ethresear.ch/uploads/default/optimized/3X/c/9/c9feb4d9369e37cf736b329f4fc213e5e197c18c_2_1035x370.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/c/9/c9feb4d9369e37cf736b329f4fc213e5e197c18c_2_1380x494.png 2x\" data-dominant-color=\"F4F7F1\"></a></div><p></p>\n<p>This attack informs the need to do enough subnet sampling that ex ante reorgs attack do not become significantly easier. For example, if <span class=\"math\">\\delta_s</span> is 20%, a 10% attacker could do such a reorg about 100 times a day, instead of only about once a day. Even worse, <a href=\"https://github.com/ethereum/consensus-specs/blob/d29581315579d37064abf21b174750f9d5c099c0/specs/_features/eip7594/das-core.md#custody-setting\" rel=\"noopener nofollow ugc\">with the current parameters of the PeerDAS spec</a>, an attacker controlling a single proposer can perform a reorg! This is because <code>CUSTODY_REQUIREMENT</code>, the minimum number of subnets that a validator participates in, is set to 1, which makes <span class=\"math\">\\delta_s</span> nearly 50%. For example, the attacker can make the data available in 15 out of the 32 subnets, and convince all validators in those subnets to vote for their unavailable block, overcoming proposer boost.</p>\n<h5><a name=\"mitigation-9\" class=\"anchor\" href=\"https://ethresear.ch#mitigation-9\"></a>Mitigation</h5>\n<p>As already discussed <a href=\"https://ethresear.ch/t/from-4844-to-danksharding-a-path-to-scaling-ethereum-da/18046#possible-fork-choice-attack-vectors-9\">here</a>, this attack vector can be mitigated by attesters of slot <span class=\"math\">n+1</span> complete peer sampling 10s into slot <span class=\"math\">n</span>, while the proposer can keep trying to sample until they propose. If the proposer extends a block which an attester sees as unavailable, they try to sample again. This is in spirit much like <a href=\"https://ethresear.ch/t/view-merge-as-a-replacement-for-proposer-boost/13739\">view-merge</a>, but does not require any extra message in the proposal. In the previously described attacks, this mitigation would make it so that the attesters of slot 4 do not see <span class=\"math\">B</span> as available <em>unless the proposer of <span class=\"math\">D</span> does as well</em>: either the proposer sees <span class=\"math\">B</span> as available and <span class=\"math\">D</span> extends <span class=\"math\">C</span>, or the proposer sees <span class=\"math\">B</span> as unavailable <em>and so do attesters</em>. In either case, they vote for <span class=\"math\">D</span>.</p>\n<p>This mitigation has the downside of worsening the timing assumptions around peer sampling, reducing the benefits of the trailing fork-choice. Still, if this was the only fork-choice problem caused by DAS, we might be ok with solving it this way and otherwise keeping things as is. The next attack does not seem to have such a simple mitigation, and motivates our desire to move to the <em>(block, slot)</em> fork-choice to more effectively address the attack vectors related to (un)availability.</p>\n<h3><a name=\"proposer-sees-available-attesters-see-unavailable-10\" class=\"anchor\" href=\"https://ethresear.ch#proposer-sees-available-attesters-see-unavailable-10\"></a>Proposer sees <em>available</em>, attesters see <em>unavailable</em></h3>\n<h4><a name=\"targeted-data-release-11\" class=\"anchor\" href=\"https://ethresear.ch#targeted-data-release-11\"></a>Targeted data release</h4>\n<p>The attack is going to rely on being able to convince an honest proposer that an unavailable block is available, <em>even after it performs peer sampling for it</em>. How realistic this assumption is depends on how exactly peer sampling is performed. For example, suppose that nodes whose sampling queries fail just try again with other peers. Then, if the adversary wants to target a specific proposer, it has to:</p>\n<ol>\n<li>Link the proposer’s validator identity to a node</li>\n<li>Ensure that it controls at least one peer of the node, and advertise that it custodies all of the columns</li>\n<li>Make all of the data unavailable</li>\n<li>Wait for the node to send sampling query to the peer it controls, after having failed with other peers, and respond to all of them.</li>\n</ol>\n<h4><a name=\"tricking-an-honest-proposer-into-extending-an-unavailable-chain-12\" class=\"anchor\" href=\"https://ethresear.ch#tricking-an-honest-proposer-into-extending-an-unavailable-chain-12\"></a>Tricking an honest proposer into extending an unavailable chain</h4>\n<p>Given this capability, the adversary can manipulate an honest proposer into extending an unavailable chain, leading to their block being reorged. <em>In this scenario, we only assume that the adversary controls two successive proposers</em>, in this case for slots 2 and 3, respectively. The sequence of events unfolds as follows:</p>\n<ol>\n<li>The adversary only publishes a single unavailable block <span class=\"math\">B</span> during slot 2 and does not publish any block in slot 3.</li>\n<li>Importantly, the adversary convinces the proposer for slot 4 that <span class=\"math\">B</span> is available. As a result, the proposer for slot 4 does not attempt to reorg <span class=\"math\">B</span> through a <a href=\"https://github.com/ethereum/consensus-specs/pull/3034\" rel=\"noopener nofollow ugc\">proposer boost reorging</a> for the following reasons:\n<ul>\n<li>The proposer perceives <span class=\"math\">B</span> as available.</li>\n<li>Even if <span class=\"math\">B</span> does not receive any votes, the proposer boost reorging mechanism does not currently attempt reorgs that span more than one slot (as a liveness protection).</li>\n</ul>\n</li>\n<li>As a result:\n<ul>\n<li>Since all other validators see <span class=\"math\">B</span> as unavailable, they continue to vote for <span class=\"math\">A</span>.</li>\n<li>The proposer for slot 5 extends <span class=\"math\">A</span> with <span class=\"math\">D</span>, effectively reorging the honest and available block <span class=\"math\">C</span>.</li>\n</ul>\n</li>\n</ol>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/6/9/69d01104b892c87145507660d3e466307f2767f2.png\" data-download-href=\"https://ethresear.ch/uploads/default/69d01104b892c87145507660d3e466307f2767f2\" title=\"\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/6/9/69d01104b892c87145507660d3e466307f2767f2_2_690x357.png\" alt=\"\" data-base62-sha1=\"f63UInx6xKPuF8xoF6egt0yJYoW\" role=\"presentation\" width=\"690\" height=\"357\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/6/9/69d01104b892c87145507660d3e466307f2767f2_2_690x357.png, https://ethresear.ch/uploads/default/optimized/3X/6/9/69d01104b892c87145507660d3e466307f2767f2_2_1035x535.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/6/9/69d01104b892c87145507660d3e466307f2767f2_2_1380x714.png 2x\" data-dominant-color=\"F5FBF5\"></a></div><p></p>\n<p>The attack could even target multiple honest proposers in a row, leading to all of their blocks being orphaned! This is particularly serious given that the attacker does not need to control a significant amount of stake to pull this off.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/5/8/58bd729c0b54244e6513f1924747003c590d64db.png\" data-download-href=\"https://ethresear.ch/uploads/default/58bd729c0b54244e6513f1924747003c590d64db\" title=\"\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/5/8/58bd729c0b54244e6513f1924747003c590d64db_2_690x351.png\" alt=\"\" data-base62-sha1=\"cF1UfjMuWBXu7Ng5j5ji5f4Bvon\" role=\"presentation\" width=\"690\" height=\"351\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/5/8/58bd729c0b54244e6513f1924747003c590d64db_2_690x351.png, https://ethresear.ch/uploads/default/optimized/3X/5/8/58bd729c0b54244e6513f1924747003c590d64db_2_1035x526.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/5/8/58bd729c0b54244e6513f1924747003c590d64db_2_1380x702.png 2x\" data-dominant-color=\"F4FBF4\"></a></div><p></p>\n<h2><a name=\"block-slot-fork-choice-13\" class=\"anchor\" href=\"https://ethresear.ch#block-slot-fork-choice-13\"></a>(block-slot) fork-choice</h2>\n<p>The attacks discussed above can be effectively addressed by employing a variation of the fork-choice rule known as the (block, slot) fork-choice function. This modification, proposed <a href=\"https://github.com/ethereum/consensus-specs/pull/2197\" rel=\"noopener nofollow ugc\">a few years ago</a>, is specifically designed to account for attestations associated with <em>empty slots</em>. At any given slot <span class=\"math\">t</span>, considering a proposal <span class=\"math\">B</span> extending the head of the canonical chain <span class=\"math\">A</span>, we also take into account the empty slot identified by <span class=\"math\">A</span>. To clarify, with this modification, we consider votes for a block <span class=\"math\">A</span> as votes for pairs (block, slot) (rather than just votes for block <span class=\"math\">A</span>).</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/c/a/ca8ed21df874838328758b89a3fbd77b2e0897d0.png\" data-download-href=\"https://ethresear.ch/uploads/default/ca8ed21df874838328758b89a3fbd77b2e0897d0\" title=\"\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/c/a/ca8ed21df874838328758b89a3fbd77b2e0897d0_2_690x381.png\" alt=\"\" data-base62-sha1=\"sTUrlEXOZ2W3qmI9wceLzoNkwj6\" role=\"presentation\" width=\"690\" height=\"381\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/c/a/ca8ed21df874838328758b89a3fbd77b2e0897d0_2_690x381.png, https://ethresear.ch/uploads/default/optimized/3X/c/a/ca8ed21df874838328758b89a3fbd77b2e0897d0_2_1035x571.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/c/a/ca8ed21df874838328758b89a3fbd77b2e0897d0_2_1380x762.png 2x\" data-dominant-color=\"FBFBFB\"></a></div><p></p>\n<p>In the figure above, we show the difference between the current fork-choice (left) and the (block, slot) fork-choice (right), in the case when a block <span class=\"math\">B</span> is proposed a bit late. Essentially, this approach enables us to concurrently consider both <span class=\"math\">(B,t+1)</span> and <span class=\"math\">(A,t+1)</span> at slot <span class=\"math\">t+1</span>. This effectively mitigates the attacks discussed earlier, as we show below.</p>\n<h3><a name=\"revisiting-the-last-attack-14\" class=\"anchor\" href=\"https://ethresear.ch#revisiting-the-last-attack-14\"></a>Revisiting the last attack</h3>\n<p>Consider the following scenario (which is the starting point of the attack <strong>Proposer sees available, attesters see unavailable</strong>):</p>\n<ol>\n<li>Block <span class=\"math\">A</span> is a fully available block assigned to slot <span class=\"math\">t</span>.</li>\n<li>Block <span class=\"math\">B</span>, on the other hand, is unavailable but appears available to a few validators due to adversary manipulation.</li>\n</ol>\n<p>Following the current fork-choice function, during slot <span class=\"math\">t+1</span>:</p>\n<ol>\n<li>The majority of validators recognize <span class=\"math\">B</span> as unavailable and consequently vote for <span class=\"math\">A</span>.</li>\n<li>A minority of validators cast their votes for <span class=\"math\">B</span>.</li>\n</ol>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/8/d/8d16ac21fce958d43583605625e57fb83dcb2721.png\" data-download-href=\"https://ethresear.ch/uploads/default/8d16ac21fce958d43583605625e57fb83dcb2721\" title=\"\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/8/d/8d16ac21fce958d43583605625e57fb83dcb2721_2_476x500.png\" data-base62-sha1=\"k87TIEntrupil7mtePDykP5D6q5\" alt=\"\" width=\"476\" height=\"500\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/8/d/8d16ac21fce958d43583605625e57fb83dcb2721_2_476x500.png, https://ethresear.ch/uploads/default/optimized/3X/8/d/8d16ac21fce958d43583605625e57fb83dcb2721_2_714x750.png 1.5x, https://ethresear.ch/uploads/default/original/3X/8/d/8d16ac21fce958d43583605625e57fb83dcb2721.png 2x\" data-dominant-color=\"FCFCFC\"></a></div><p></p>\n<p>By introducing the (block,slot) fork-choice function, the majority of validators would then effectively vote for the pair <span class=\"math\">(A,t+1)</span>.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/c/7/c72faacf4a867710311217a025f904385fbf8daf.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/c72faacf4a867710311217a025f904385fbf8daf\" title=\"Block Availability Diagram\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/c/7/c72faacf4a867710311217a025f904385fbf8daf_2_521x500.jpeg\" data-base62-sha1=\"sq58SnzglRUOxjtO88jt2ITQtkj\" alt=\"Block Availability Diagram\" width=\"521\" height=\"500\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/c/7/c72faacf4a867710311217a025f904385fbf8daf_2_521x500.jpeg, https://ethresear.ch/uploads/default/optimized/3X/c/7/c72faacf4a867710311217a025f904385fbf8daf_2_781x750.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/c/7/c72faacf4a867710311217a025f904385fbf8daf_2_1042x1000.jpeg 2x\" data-dominant-color=\"FCFCFC\"></a></div><p></p>\n<p>Continuing the sequence of events in the attack, at slot <span class=\"math\">t+2</span>, the adversary abstains from proposing any block. Consequently, the majority of validators will opt to vote for <span class=\"math\">A</span> which effectively means voting for the pair <span class=\"math\">(A, t+2)</span>.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/f/9/f9ebb54f7e36792f39c1947864807bfb983729b0.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/f9ebb54f7e36792f39c1947864807bfb983729b0\" title=\"\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/f/9/f9ebb54f7e36792f39c1947864807bfb983729b0_2_690x481.jpeg\" alt=\"\" data-base62-sha1=\"zETTlDBmXzAXk9wN1VHferfJIR2\" role=\"presentation\" width=\"690\" height=\"481\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/f/9/f9ebb54f7e36792f39c1947864807bfb983729b0_2_690x481.jpeg, https://ethresear.ch/uploads/default/optimized/3X/f/9/f9ebb54f7e36792f39c1947864807bfb983729b0_2_1035x721.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/f/9/f9ebb54f7e36792f39c1947864807bfb983729b0_2_1380x962.jpeg 2x\" data-dominant-color=\"FCFCFC\"></a></div><p></p>\n<p>At this point, although the adversary makes the honest proposer for slot <span class=\"math\">t+3</span> believes that <span class=\"math\">B</span> is available, such proposer would still extend <span class=\"math\">A</span> since the chain <span class=\"math\">(A,t+2)</span> is heavier compared to the chain with head <span class=\"math\">(B,t+1)</span>.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/4/9/494fcc892e75772d9ff62e59f9ce7a258450d343.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/494fcc892e75772d9ff62e59f9ce7a258450d343\" title=\"\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/4/9/494fcc892e75772d9ff62e59f9ce7a258450d343_2_690x369.jpeg\" alt=\"\" data-base62-sha1=\"asxP4R1kRKvqxrHQvZPoTj9yfh9\" role=\"presentation\" width=\"690\" height=\"369\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/4/9/494fcc892e75772d9ff62e59f9ce7a258450d343_2_690x369.jpeg, https://ethresear.ch/uploads/default/optimized/3X/4/9/494fcc892e75772d9ff62e59f9ce7a258450d343_2_1035x553.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/4/9/494fcc892e75772d9ff62e59f9ce7a258450d343_2_1380x738.jpeg 2x\" data-dominant-color=\"FBFBFB\"></a></div><p></p>\n<h3><a name=\"block-slot-spec-15\" class=\"anchor\" href=\"https://ethresear.ch#block-slot-spec-15\"></a>(block, slot) spec</h3>\n<p>Take a block <span class=\"math\">A</span> proposed by the block proposer for slot <span class=\"math\">t</span> and a vote <span class=\"math\">v</span> for block <span class=\"math\">A</span> cast in slot <span class=\"math\">t+d</span>. Then, <span class=\"math\">v</span> is considered as a vote for any of the tuples <span class=\"math\">\\{(A,t),(A,t+1),\\cdots,(A,t+d)\\}</span>, because <span class=\"math\">v</span> states that the head of the canonical chain is <span class=\"math\">A</span> in all of those slots.</p>\n<p>Consequently, the fork-choice function also proceeds by (block, slot) rather than just by blocks.<br>\nSpecifically, the children of <span class=\"math\">(A,t)</span> are all those (block, slot) pairs <span class=\"math\">(B,t+1)</span> where <span class=\"math\">B</span> is either <span class=\"math\">A</span> or a child of <span class=\"math\">A</span>. This means that in this context, <span class=\"math\">(A,t+1)</span> is considered a child of <span class=\"math\">(A,t)</span>. Therefore, votes cast in support of any child of <span class=\"math\">A</span> are now weighed against votes cast in support of the <em>empty slot</em> <span class=\"math\">(A, t+1)</span>. The fork-choice proceeds in this way until it reaches the current slot, at which point, it outputs the block of the head (block, slot) pair. Note that by the way we have defined things, the support of the pair <span class=\"math\">(A,t+d)</span> includes all votes cast for any block <span class=\"math\">C</span> that is both descendant of <span class=\"math\">A</span> and proposed in a slot higher than <span class=\"math\">t+d</span>, but such that its chain does not include any block proposed in slot <span class=\"math\">t+d</span>.</p>\n<p>We illustrate this in the following figure. On the left it’s the actual block tree with attestations. On the right it’s the block tree as it is interpreted when running the fork-choice. At slot <span class=\"math\">t+1</span>, the choice is between <span class=\"math\">(B,t+1)</span> and <span class=\"math\">(A,t+1)</span>, and the weight of the latter is made up of attestations to <span class=\"math\">A</span> in slots <span class=\"math\">\\ge t+1</span> (the green and orange ones) and attestations to <span class=\"math\">C</span> at slot <span class=\"math\">t+2</span> (the yellow ones), since these also indicate that <span class=\"math\">A</span> is the head at slot <span class=\"math\">t+1</span>.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/f/f/ffbba585b63cf2fee3497800f6be629976103156.png\" data-download-href=\"https://ethresear.ch/uploads/default/ffbba585b63cf2fee3497800f6be629976103156\" title=\"\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/f/f/ffbba585b63cf2fee3497800f6be629976103156_2_690x442.png\" alt=\"\" data-base62-sha1=\"AujMIXyJM4rTJRuIsNLYuXrpnAW\" role=\"presentation\" width=\"690\" height=\"442\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/f/f/ffbba585b63cf2fee3497800f6be629976103156_2_690x442.png, https://ethresear.ch/uploads/default/optimized/3X/f/f/ffbba585b63cf2fee3497800f6be629976103156_2_1035x663.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/f/f/ffbba585b63cf2fee3497800f6be629976103156_2_1380x884.png 2x\" data-dominant-color=\"FAFAFA\"></a></div><p></p>\n<p><a href=\"https://github.com/ethereum/consensus-specs/compare/dev...fradamt:consensus-specs:block-slot\" rel=\"noopener nofollow ugc\">Here</a> is an early attempt at a simple specification of the (block, slot) fork-choice. The loop in <code>get_head</code> is modified to proceed slot by slot. At each slot the heaviest child of the current <code>head</code>, <code>best_child</code>, is compared against <code>empty_slot_weight</code>, the weight of “the subtree rooted at the empty slot”, which is computed by <code>get_empty_slot_weight</code> by interpreting votes as explained above. We include here the modified <code>get_head</code> and the important part of <code>get_empty_slot_weight</code> (in both cases, other than for removing the parts related to the backoff logic, which we discuss later).</p>\n<pre><code class=\"lang-python\">def get_head(store: Store) -&gt; Root:\n    # Get filtered block tree that only includes viable branches\n    blocks = get_filtered_block_tree(store)\n    # Execute the LMD-GHOST fork choice\n    head = store.justified_checkpoint.root\n    slot = Slot(blocks[head].slot + 1)\n    while slot &lt;= get_current_slot(store):\n        children = [\n            root for root in blocks.keys()\n            if (blocks[root].parent_root == head\n                and blocks[root].slot == slot)\n        ]\n        if len(children) &gt; 0:\n            best_child = max(children, key=lambda root: (get_weight(store, root), root))\n            best_child_weight = get_weight(store, best_child)\n            empty_slot_weight = get_empty_slot_weight(store, head, slot)\n            if best_child_weight &gt;= empty_slot_weight:\n                head = best_child\n        slot = Slot(slot + 1)\n    return head\n\ndef get_empty_slot_weight(store: Store, \n                          root: Root, \n                          slot: Slot) -&gt; Gwei:\n    ...\n    attestation_score = Gwei(sum(\n        state.validators[i].effective_balance for i in unslashed_and_active_indices\n        if (i in store.latest_messages\n            and i not in store.equivocating_indices\n            and (\n                (store.latest_messages[i].root == root\n                 and store.latest_messages[i].slot &gt;= slot\n                or (store.latest_messages[i].slot &gt; slot\n                    and not store.latest_messages[i].root == root\n                    and get_ancestor(store, store.latest_messages[i].root, slot) == root\n                    )\n            ))))\n    ...\n    return attestation_score + proposer_score\n</code></pre>\n<h3><a name=\"backoff-scheme-16\" class=\"anchor\" href=\"https://ethresear.ch#backoff-scheme-16\"></a>Backoff scheme</h3>\n<p>One of the disadvantages of the current proposal is that the performance under bad network conditions becomes worse. Chain growth stops completely if block latency is &gt; <code>SECONDS_PER_SLOT / 3</code> (= 4 seconds in the current config).</p>\n<p>Therefore, a <em>backoff</em> scheme is necessary to facilitate chain progression during periods of extended latency. Without such a mechanism, the chain would continuously build on the same (empty) block, resulting in a sequence of empty blocks and an inability to extend the chain with non-empty ones.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/b/2/b2ec5b729fd1162a23940f6ed1592be4519ce4f7.png\" data-download-href=\"https://ethresear.ch/uploads/default/b2ec5b729fd1162a23940f6ed1592be4519ce4f7\" title=\"\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/b/2/b2ec5b729fd1162a23940f6ed1592be4519ce4f7_2_690x381.png\" alt=\"\" data-base62-sha1=\"pwPnJgvsiO1CwJXJPOD0FJVkvRl\" role=\"presentation\" width=\"690\" height=\"381\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/b/2/b2ec5b729fd1162a23940f6ed1592be4519ce4f7_2_690x381.png, https://ethresear.ch/uploads/default/optimized/3X/b/2/b2ec5b729fd1162a23940f6ed1592be4519ce4f7_2_1035x571.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/b/2/b2ec5b729fd1162a23940f6ed1592be4519ce4f7_2_1380x762.png 2x\" data-dominant-color=\"FAF9FB\"></a></div><p></p>\n<p>The backoff scheme is devised to alleviate prolonged periods of empty blocks within the chain. When such instances occur, the scheme intervenes by aiding potential non-empty blocks in accumulating the necessary attestations. As these supported blocks successfully advance the chain, the backoff mechanism is gradually deactivated. This gradual deactivation process continues until the system reaches a state where the backoff mechanism is no longer necessary.</p>\n<p>The activation and deactivation of the backoff mechanism are represented by the <code>backoff_status</code>, which is created and updated within <code>get_head</code>. Crucially, if two honest validators are on the same path while executing <code>get_head</code>, they will share identical backoff statuses. This means that, under synchrony, for honest validators selecting the same branch of the block tree, the backoff mechanism is synchronized, activating and deactivating simultaneously. In the spec linked above, <em>an active backoff has the effect of delaying by one slot the counting of votes for the empty slot</em>: votes for <span class=\"math\">A</span> only count for the empty slot <span class=\"math\">(A,s)</span> if they are <em>at least from slot <span class=\"math\">s+1</span></em>. In other words, we take all votes <em>directly</em> for empty slots and move them back by one slot: votes to <span class=\"math\">(A,t+1)</span> count for <span class=\"math\">(A,t)</span>, votes for <span class=\"math\">(A,t+2)</span> count for <span class=\"math\">(A,t+1)</span> etc… For example, look at the green attestations, which vote for <span class=\"math\">A</span> at slot <span class=\"math\">t+1</span>. When the backoff is not active, these contribute weight to <span class=\"math\">(A,t+1)</span> (more precisely, are counted by <code>get_empty_slot_weight</code> when run at slot <span class=\"math\">t+1</span> with <span class=\"math\">A</span> being <code>head</code>), but when the backoff is active they go back to only contributing to <span class=\"math\">(A,t)</span>. Same goes for the orange attestations to <span class=\"math\">(A,t+2)</span>, which only contribute to <span class=\"math\">(A,t+1)</span> when the backoff is active.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/1/d/1d83659c84d77e80dfbd0579a3b7a776c1f25faa.png\" data-download-href=\"https://ethresear.ch/uploads/default/1d83659c84d77e80dfbd0579a3b7a776c1f25faa\" title=\"\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/1/d/1d83659c84d77e80dfbd0579a3b7a776c1f25faa_2_690x304.png\" alt=\"\" data-base62-sha1=\"4d5mwjp8bogYY1MVjwaUqzrKxUS\" role=\"presentation\" width=\"690\" height=\"304\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/1/d/1d83659c84d77e80dfbd0579a3b7a776c1f25faa_2_690x304.png, https://ethresear.ch/uploads/default/optimized/3X/1/d/1d83659c84d77e80dfbd0579a3b7a776c1f25faa_2_1035x456.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/1/d/1d83659c84d77e80dfbd0579a3b7a776c1f25faa_2_1380x608.png 2x\" data-dominant-color=\"F9F9F9\"></a></div><p></p>\n<p>In the next figure, network latency is high, and all block proposals are late by a few seconds, so they never get any votes. At first, this leads to <span class=\"math\">B</span> being orphaned, because all votes go to <span class=\"math\">(A,t+1)</span>. For simplicity, we assume that the backoff immediately activates on that branch. In slot <span class=\"math\">t+2</span>, <span class=\"math\">C</span> is also late, and all votes again go to <span class=\"math\">A</span>. Due to the backoff being active, these votes do not count for <span class=\"math\">(A,t+2)</span> but only for <span class=\"math\">(A,t+1)</span>, so <span class=\"math\">C</span> is still the head of the chain, and is voted in the next slot. Again, because the backoff is active, those votes only count for <span class=\"math\">(C,t+2)</span> and not for <span class=\"math\">(C,t+3)</span>, i.e., they do not count “against” <span class=\"math\">D</span>, the block proposed at slot <span class=\"math\">t+3</span>. In order for a block to get orphaned, it now needs to be <em>one whole slot late</em>: votes for <span class=\"math\">A</span> at slot <span class=\"math\">t+3</span> would count for <span class=\"math\">(A,t+2)</span> and thus against <span class=\"math\">C</span>, but there will be no such votes as long as <span class=\"math\">C</span> arrives before slot <span class=\"math\">t+3</span>.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/9/5/95acaec4f5b3d5a1b4e2e92602279fba6cab09fa.png\" data-download-href=\"https://ethresear.ch/uploads/default/95acaec4f5b3d5a1b4e2e92602279fba6cab09fa\" title=\"\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/9/5/95acaec4f5b3d5a1b4e2e92602279fba6cab09fa_2_690x345.png\" alt=\"\" data-base62-sha1=\"lm574rIdlaC6sXNfasnMA8s5blw\" role=\"presentation\" width=\"690\" height=\"345\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/9/5/95acaec4f5b3d5a1b4e2e92602279fba6cab09fa_2_690x345.png, https://ethresear.ch/uploads/default/optimized/3X/9/5/95acaec4f5b3d5a1b4e2e92602279fba6cab09fa_2_1035x517.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/9/5/95acaec4f5b3d5a1b4e2e92602279fba6cab09fa_2_1380x690.png 2x\" data-dominant-color=\"FAFAFB\"></a></div><p></p>\n<p>The specific mechanism to activate the backoff scheme are still a work in progress, and the spec modification has been written so that all of the relevant logic is confined to <code>update_backoff_status</code>, called at the end of each iteration of the loop in <code>get_head</code>.</p>\n<h3><a name=\"attacks-to-the-das-fork-choice-with-block-slot-17\" class=\"anchor\" href=\"https://ethresear.ch#attacks-to-the-das-fork-choice-with-block-slot-17\"></a>Attacks to the DAS fork-choice with (block, slot)</h3>\n<p>By adopting the (block,slot) fork-choice function, if a block is unavailable by its attestation deadline, most honest validators will not vote for it. Instead, they will vote for the empty block. With this, we would hope to achieve a stronger property than <span class=\"math\">\\delta</span>-safety of sampling:</p>\n<blockquote>\n<p>If the validator set is <span class=\"math\">&gt; \\frac{1}{2(1-\\delta)}</span> honest and the network is synchronous, no unavailable block is ever in the canonical chain of any honest validator</p>\n</blockquote>\n<p>The reasoning seems simple: if a block <span class=\"math\">B</span> is unavailable at a given time when the fork-choice is being run, than <span class=\"math\">\\delta</span>-safety of sampling ensures that at most a fraction <span class=\"math\">\\delta</span> of the honest validators in the committee of any previous slot could have voted for it. In particular, at least <span class=\"math\">1-\\delta</span> of the honest validators of <span class=\"math\">B</span>'s proposal slot would have voted for the empty slot. If <span class=\"math\">&gt; \\frac{1}{2(1-\\delta)}</span> of the validators are honest, then this is <span class=\"math\">&gt; \\frac{1}{2}</span> of the validators, and the empty slot would have a majority and win.</p>\n<p><em>Things are unfortunately not actually so simple.</em> In the above, we have made the assumption that validators that do not vote for <span class=\"math\">B</span> will instead vote “for the empty slot”. In fact, there could be multiple “empty slots” to vote for, if there is already a chain split, for example caused by a balancing attack, as in the left figure below. The honest votes then get split among multiple branches, and an unavailable block can still “look” canonical to validators that have been tricked into seeing it as available. Another way to achieve the same thing is by equivocating with available blocks and an unavailable block, to split most of the honest votes between the available ones, instead of having them go to the empty block, as in the right figure below.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/3/3/339a3e61a64ac47087c23992f0123a283cededdf.png\" data-download-href=\"https://ethresear.ch/uploads/default/339a3e61a64ac47087c23992f0123a283cededdf\" title=\"\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/3/3/339a3e61a64ac47087c23992f0123a283cededdf_2_690x416.png\" alt=\"\" data-base62-sha1=\"7muOCOdUET2eOsOekd9nrd63PFZ\" role=\"presentation\" width=\"690\" height=\"416\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/3/3/339a3e61a64ac47087c23992f0123a283cededdf_2_690x416.png, https://ethresear.ch/uploads/default/optimized/3X/3/3/339a3e61a64ac47087c23992f0123a283cededdf_2_1035x624.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/3/3/339a3e61a64ac47087c23992f0123a283cededdf_2_1380x832.png 2x\" data-dominant-color=\"F9F9F7\"></a></div><p></p>\n<h3><a name=\"a-direction-for-further-improvement-the-majority-fork-choice-18\" class=\"anchor\" href=\"https://ethresear.ch#a-direction-for-further-improvement-the-majority-fork-choice-18\"></a>A direction for further improvement: the majority fork-choice</h3>\n<p>It is not at the moment clear whether it is possible to completely eliminate this attack vector with “known tools” (we consider the (block, slot) fork-choice such, since it has been discussed for years, though not implemented). One potentially promising direction is to do something akin to (block, slot) but even a bit more extreme: at slot <span class=\"math\">t</span> in the <code>get_head</code> loop, we could find the <code>best_child</code> and then pit it against <em>all of the voting weight from slots <span class=\"math\">\\ge t</span> which did not vote on the <code>best_child</code>’s subtree</em>. In other words, we require a block from slot <span class=\"math\">t</span> to have a majority of all attesting weight from slots <span class=\"math\">\\ge t</span>. This way, it wouldn’t matter if the adversary finds ways to split honest votes: <em>a vote is against a block whenever it could have been for it but isn’t</em>.</p>\n<p>This would very clearly gives us the stronger property we previously wished for, because an unavailable block would need to get a majority of each committee’s weight in order to win out against the empty slot. The challenge is making sure that such a change does not break anything else in subtle ways, worsen known attacks, or make it much easier to stall liveness.</p>\n<p>You can find the preliminary spec changes from the previous (block, slot) spec to the majority fork-choice <a href=\"https://github.com/ethereum/consensus-specs/commit/baece58837fcfc745443a7144f2558463d6ff5b9\" rel=\"noopener nofollow ugc\">here</a>. The important bit is that now <code>get_empty_slot_weight</code> counts weight from all attestations which could be on the subtree of <code>best_child_root</code> but are not.</p>\n<pre><code class=\"lang-python\">attestation_score = Gwei(sum(\n    state.validators[i].effective_balance for i in unslashed_and_active_indices\n    if (i in store.latest_messages\n        and i not in store.equivocating_indices\n        and store.latest_messages[i].slot &gt;= slot + 1 if is_backoff_active else 0\n        and not get_ancestor(store, store.latest_messages[i].root, slot) != best_child_root)\n))\n</code></pre>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://ethresear.ch/t/das-fork-choice/19578\">Read full topic</a></p>","link":"https://ethresear.ch/t/das-fork-choice/19578","pubDate":"Fri, 17 May 2024 06:34:58 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-19578"},"source":{"@url":"https://ethresear.ch/t/das-fork-choice/19578.rss","#text":"DAS fork-choice"},"filter":false},{"title":"Distributed storage and cryptographically secured retrieval of SSZ objects for Portal Network","dc:creator":"pipermerriam","category":"Execution Layer Research","description":"<p>In our research into how to efficiently store Ethereum’s state data in an archival format similar to Erigon’s reverse diff based approach we found a novel way to store large SSZ objects in a DHT such that:</p>\n<ul>\n<li>The data is evenly distributed across the keyspace of the DHT</li>\n<li>The data is cryptographically anchored to the SSZ merkle root for both gossip and retrieval.</li>\n</ul>\n<p>This approach appears to be extensible to any SSZ object.</p>\n<h3><a name=\"portal-network-context-1\" class=\"anchor\" href=\"https://ethresear.ch#portal-network-context-1\"></a>Portal Network context</h3>\n<blockquote>\n<p>While it is possible this approach could extend to other DHT networks, our research focuses solely on the Portal Network.</p>\n</blockquote>\n<p>In order for our networks to be secure, Portal requires that all data be cryptographically anchored during both the gossip and retrieval.  In this context, cryptographic anchoring is the process through which a node in the network is able to verify that the data they are looking at is both well formed <strong>and</strong> that it represents data that belongs in the network.  An example of this would be an ommer header, which would be well formed and would pass validation as a viable header, but it should not be stored in our networks since it is not canonical.</p>\n<h2><a name=\"ssz-objects-mapped-to-a-dht-2\" class=\"anchor\" href=\"https://ethresear.ch#ssz-objects-mapped-to-a-dht-2\"></a>SSZ objects mapped to a DHT</h2>\n<p>For the SSZ object in question, we first compute the SSZ root hash which we’ll refer to as the <code>PrimaryRoot</code>.</p>\n<p>Next, we serialize the object into it’s encoded representation, a stream of bytes.  We then compute a second SSZ root hash using the ssz schema of a simple <code>List[uint8, max_length=...]</code>.  This second root hash will be referred to as the <code>FlattenedRoot</code>.</p>\n<p>The bytes of the encoded SSZ object can then be mapped 1:1 onto the DHT keyspace based on the position of the bytes with respect to the total encoded length, with the 0th byte being mapped to the <code>0x00..00</code> location in the network, and the <code>nth</code> byte being mapped to the node-id that corresponds to <code>(2**256 -1) / n</code>.</p>\n<blockquote>\n<p>In our setup, our individual nodes are able to trust that <code>FlattenedRoot</code> and <code>PrimaryRoot</code> both represent the same data.  However, it seems this scheme would allow for nodes in the network to perform verification against both roots if desired.</p>\n</blockquote>\n<h3><a name=\"gossip-3\" class=\"anchor\" href=\"https://ethresear.ch#gossip-3\"></a>Gossip</h3>\n<p>In order for nodes to accept a sequence of bytes for storage during the gossip process they must be able to verify:</p>\n<ul>\n<li>The location in the network that the bytes belong.</li>\n<li>That the bytes are cryptographically anchored to the respective ssz roots <code>PrimaryRoot</code> and <code>FlattenedRoot</code></li>\n</ul>\n<p>During gossip a contiguous section the encoded SSZ object bytes would be selected, and a SSZ merkle proof against the <code>FlattenedRoot</code> is constructed.  We’ll refer to this proof as the <code>flat_proof</code>.  In the event that the system also requires proofs against the <code>PrimaryRoot</code> then this secondary proof would also need to be constructed against the subset of the data that the selected bytes represents which we’ll call the <code>primary_proof</code>.  Care would need to be taken in the selection of bytes to ensure that its bounds are picked to match up with the encoded object boundaries.</p>\n<p>The gossip payload would include these elements.</p>\n<ul>\n<li>The section of bytes to be stored.</li>\n<li>The <code>flat_proof</code></li>\n<li>The <code>primary_proof</code> if desired.</li>\n</ul>\n<p>Since the <code>flat_proof</code> is against a flat <code>List[uint8, ...]</code> data structure, the accompanying merkle proof will have sufficient information to determine exactly where in the overall sequence of bytes the receive payload would belong.  This allow the receiving node to cryptographically validate that the payload belongs in their storage based on on their node-id as well as verifying that the payload is correctly anchored to the <code>FlattenedRoot</code> and optionally the <code>PrimaryRoot</code> if both proving methods are desired.</p>\n<h3><a name=\"retrieval-4\" class=\"anchor\" href=\"https://ethresear.ch#retrieval-4\"></a>Retrieval</h3>\n<blockquote>\n<p>For retrieval we assume the object has been fully seeded into the network and all portions of its encoded bytes are retrievable.</p>\n</blockquote>\n<p>All SSZ objects have a “schema” and this schema provides a deterministic way to find where a specific part of that object is located in the encoded binary format without requiring the full data structure to be decoded.  Only a small subset of the data must be decoded to retrieve individual parts of the object.</p>\n<p>Since the raw bytes of the encoded SSZ object are available from the network, this facilitates what is effectively the ability to read bytes from anywhere in the stream by fetching them from the network.  Each payload can be cryptographically verified with the accompanying <code>flat_proof</code> and <code>primary_proof</code>.</p>\n<p>Each SSZ object will require some amount of custom logic in order to retrieve the data from the network, though a sufficiently advanced SSZ library should be able to implement this logic in a generic format as it would be the same logic necessary to do selective decoding of only part of an SSZ object.</p>\n<h2><a name=\"applications-of-this-approach-5\" class=\"anchor\" href=\"https://ethresear.ch#applications-of-this-approach-5\"></a>Applications of this approach</h2>\n<p>We are exploring the idea of gaining more efficient storage by densely packing data from deep in Ethereum’s history into large SSZ objects which are then stored using this schema in the network.  This format allows for both random access into the data structure as well as bulk retrieval of the full data structure by retrieving all of the byte sequences stored within the network.</p>\n<p>This approach allows for efficient algorithms such as performing a binary search over a sorted SSZ list stored using this mechanism.  This allows for us to implement a version of Erigon’s diff based storage approach to storing Ethereum’s state data, effectively trading more client side compute for less required storage in the overall network.  For Ethereum’s archive data this results in roughly a 10x reduction in total needed storage for the merkle patricia tree and likely significantly higher savings for the verkle trie due to it’s very wide branching factor.</p>\n<p>It is also likely that applying this approach to ethereum’s history data would allow for more efficient bulk retrieval of historical headers and block bodies.</p>\n<p>There are also likely applications for storing the Consensus state in this manner as it would allow for random access retrieval of any part of the state.</p>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://ethresear.ch/t/distributed-storage-and-cryptographically-secured-retrieval-of-ssz-objects-for-portal-network/19575\">Read full topic</a></p>","link":"https://ethresear.ch/t/distributed-storage-and-cryptographically-secured-retrieval-of-ssz-objects-for-portal-network/19575","pubDate":"Thu, 16 May 2024 20:24:12 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-19575"},"source":{"@url":"https://ethresear.ch/t/distributed-storage-and-cryptographically-secured-retrieval-of-ssz-objects-for-portal-network/19575.rss","#text":"Distributed storage and cryptographically secured retrieval of SSZ objects for Portal Network"},"filter":false},{"title":"Sierpinski Triangle Topology","dc:creator":"cryptskii","category":"Sharding","description":"<h1><a name=\"tldr-1\" class=\"anchor\" href=\"https://ethresear.ch#tldr-1\"></a>TL;DR</h1>\n<p>We propose integrating the Sierpinski triangle topology into blockchain sharding to enhance scalability, load balancing, and fault tolerance. This novel sharding mechanism exploits the fractal structure and self-similarity properties of the Sierpinski triangle, optimizing inter-shard and intra-shard communication, data replication, and node assignment. Our approach significantly improves transaction throughput, consensus efficiency, and resilience against Byzantine failures.</p>\n<h2><a name=\"background-2\" class=\"anchor\" href=\"https://ethresear.ch#background-2\"></a>Background</h2>\n<h3><a name=\"blockchain-sharding-3\" class=\"anchor\" href=\"https://ethresear.ch#blockchain-sharding-3\"></a>Blockchain Sharding</h3>\n<p>Existing blockchain systems face significant challenges in terms of scalability and security. Sharding partitions a blockchain network into multiple shards, each capable of processing transactions independently, thus improving scalability. However, sharding introduces challenges such as cross-shard communication, data consistency, and security against adversarial attacks.</p>\n<h3><a name=\"sierpinski-triangle-topology-4\" class=\"anchor\" href=\"https://ethresear.ch#sierpinski-triangle-topology-4\"></a>Sierpinski Triangle Topology</h3>\n<p>The Sierpinski triangle, a fractal structure with self-similarity, can be leveraged to optimize blockchain sharding. Its hierarchical organization facilitates efficient communication and load balancing in distributed systems.</p>\n<h2><a name=\"proposal-5\" class=\"anchor\" href=\"https://ethresear.ch#proposal-5\"></a>Proposal</h2>\n<p>We introduce a novel sharding mechanism based on the Sierpinski triangle topology. Nodes are mapped to the vertices of the Sierpinski triangle, and the shard formation algorithm assigns nodes to shards based on their positions in the fractal structure.</p>\n<h3><a name=\"shard-formation-6\" class=\"anchor\" href=\"https://ethresear.ch#shard-formation-6\"></a>Shard Formation</h3>\n<p>Nodes are mapped to the vertices of a Sierpinski triangle, ensuring balanced distribution across shards.</p>\n<h4><a name=\"algorithm-1-shard-formation-7\" class=\"anchor\" href=\"https://ethresear.ch#algorithm-1-shard-formation-7\"></a>Algorithm 1: Shard Formation</h4>\n<pre data-code-wrap=\"latex\"><code class=\"lang-plaintext\">\\begin{algorithm}\n\\caption{Shard Formation}\n\\begin{algorithmic}\n\\Require $N$ nodes, $K$ shards, Sierpinski depth $D$\n\\Ensure Node-to-shard assignment $A$\n\\State $A \\gets \\emptyset$\n\\State $S \\gets SierpinskiTriangle(D)$\n\\State $V \\gets Vertices(S)$\n\\State $\\pi \\gets RandomPermutation(V)$\n\\For{$i \\gets 1$ to $N$}\n    \\State $v \\gets \\pi[i]$\n    \\State $s \\gets \\left\\lfloor \\frac{K \\cdot TriangleIndex(v)}{3^D} \\right\\rfloor$\n    \\State $A \\gets A \\cup \\{(i, s)\\}$\n\\EndFor\n\\State \\Return $A$\n\\end{algorithmic}\n\\end{algorithm}\n</code></pre>\n<h3><a name=\"intra-shard-consensus-8\" class=\"anchor\" href=\"https://ethresear.ch#intra-shard-consensus-8\"></a>Intra-Shard Consensus</h3>\n<p>Nodes in each shard reach consensus using <a href=\"https://ethresear.ch/t/triadic-consensus-a-fast-and-resilient-consensus-mechanism-for-sharded-blockchains/19504\">Triadic Consensus</a>, leveraging the self-similarity of the Sierpinski triangle.</p>\n<h4><a name=\"algorithm-2-intra-shard-consensus-9\" class=\"anchor\" href=\"https://ethresear.ch#algorithm-2-intra-shard-consensus-9\"></a>Algorithm 2: Intra-Shard Consensus</h4>\n<pre data-code-wrap=\"latex\"><code class=\"lang-plaintext\">\\begin{algorithm}\n\\caption{Intra-Shard Consensus}\n\\begin{algorithmic}\n\\Require Shard $s$, transaction set $T_s$\n\\Ensure Ordered list of valid transactions $L_s$\n\\State $L_s \\gets \\emptyset$\n\\For{$t \\in T_s$}\n    \\State Broadcast $t$ to all nodes in shard $s$\n    \\State Run [Triadic Consensus] to reach consensus on $t$\n    \\If{$t$ is valid and committed}\n        \\State $L_s \\gets L_s \\cup \\{t\\}$\n    \\EndIf\n\\EndFor\n\\State \\Return $L_s$\n\\end{algorithmic}\n\\end{algorithm}\n</code></pre>\n<h3><a name=\"cross-shard-communication-10\" class=\"anchor\" href=\"https://ethresear.ch#cross-shard-communication-10\"></a>Cross-Shard Communication</h3>\n<p>A hierarchical scheme based on the Sierpinski triangle topology minimizes communication overhead and latency.</p>\n<h4><a name=\"algorithm-3-cross-shard-communication-11\" class=\"anchor\" href=\"https://ethresear.ch#algorithm-3-cross-shard-communication-11\"></a>Algorithm 3: Cross-Shard Communication</h4>\n<pre data-code-wrap=\"latex\"><code class=\"lang-plaintext\">\\begin{algorithm}\n\\caption{Cross-Shard Communication}\n\\begin{algorithmic}\n\\Require Source shard $s$, destination shard $d$, message $m$\n\\Ensure Message $m$ delivered to shard $d$\n\\State $v_s \\gets RepresentativeVertex(s)$\n\\State $v_d \\gets RepresentativeVertex(d)$\n\\State $P \\gets ShortestPath(v_s, v_d)$\n\\For{$v \\in P$}\n    \\State $s' \\gets Shard(v)$\n    \\If{$s' \\neq s$}\n        \\State Forward $m$ to a node in shard $s'$\n    \\EndIf\n\\EndFor\n\\end{algorithmic}\n\\end{algorithm}\n</code></pre>\n<h2><a name=\"security-analysis-12\" class=\"anchor\" href=\"https://ethresear.ch#security-analysis-12\"></a>Security Analysis</h2>\n<h3><a name=\"byzantine-fault-tolerance-13\" class=\"anchor\" href=\"https://ethresear.ch#byzantine-fault-tolerance-13\"></a>Byzantine Fault Tolerance</h3>\n<p>Our mechanism tolerates up to <span class=\"math\">f &lt; \\frac{N_s}{3}</span> Byzantine nodes in each shard, ensuring robust intra-shard consensus.</p>\n<h3><a name=\"adaptive-adversary-resistance-14\" class=\"anchor\" href=\"https://ethresear.ch#adaptive-adversary-resistance-14\"></a>Adaptive Adversary Resistance</h3>\n<p>Random node-to-shard assignment and the self-similarity property of the Sierpinski triangle ensure resistance to adaptive adversaries.</p>\n<h2><a name=\"performance-evaluation-15\" class=\"anchor\" href=\"https://ethresear.ch#performance-evaluation-15\"></a>Performance Evaluation</h2>\n<p>Simulations demonstrate that our Sierpinski triangle-based sharding mechanism achieves superior transaction throughput, lower latency, and better scalability compared to random and hash-based sharding approaches.</p>\n<h3><a name=\"transaction-throughput-16\" class=\"anchor\" href=\"https://ethresear.ch#transaction-throughput-16\"></a>Transaction Throughput</h3>\n<p>The throughput of the system scales with the number of shards. If there are <span class=\"math\">\\ell</span> shards, each processing <span class=\"math\">N</span> transactions per epoch, the total throughput is <span class=\"math\">O(\\ell \\cdot N)</span> transactions per epoch.</p>\n<h3><a name=\"communication-cost-17\" class=\"anchor\" href=\"https://ethresear.ch#communication-cost-17\"></a>Communication Cost</h3>\n<p>The communication cost per epoch for the coordinator to collect the proofs is <span class=\"math\">O(\\ell)</span>. The size of the proof added to the blockchain is <span class=\"math\">O(1)</span>.</p>\n<h3><a name=\"verification-time-18\" class=\"anchor\" href=\"https://ethresear.ch#verification-time-18\"></a>Verification Time</h3>\n<p>The verification time for the aggregated proof is <span class=\"math\">O(\\log \\ell)</span>, providing an exponential speedup compared to verifying each shard individually.</p>\n<h4><a name=\"example-configuration-19\" class=\"anchor\" href=\"https://ethresear.ch#example-configuration-19\"></a>Example Configuration</h4>\n<p>For a network with <span class=\"math\">\\ell = 2^{10}</span> shards, each processing <span class=\"math\">N = 2^{20}</span> transactions in 2-minute epochs:</p>\n<ul>\n<li>Peak throughput: <span class=\"math\">\\approx 1</span> billion transactions per epoch, or 500,000 transactions per second.</li>\n<li>Verification time: <span class=\"math\">\\approx 100</span> ms on ordinary hardware.</li>\n<li>Proof size: <span class=\"math\">\\approx 1</span> KB per epoch.</li>\n</ul>\n<h2><a name=\"conclusion-20\" class=\"anchor\" href=\"https://ethresear.ch#conclusion-20\"></a>Conclusion</h2>\n<p>We proposed a novel Sierpinski triangle-based sharding mechanism, demonstrating significant improvements in scalability and security. Future work includes real-world implementation and exploring further applications in state sharding and data availability.</p>\n<pre><code class=\"lang-auto\"></code></pre>\n            <p><small>2 posts - 1 participant</small></p>\n            <p><a href=\"https://ethresear.ch/t/sierpinski-triangle-topology/19566\">Read full topic</a></p>","link":"https://ethresear.ch/t/sierpinski-triangle-topology/19566","pubDate":"Thu, 16 May 2024 01:16:48 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-19566"},"source":{"@url":"https://ethresear.ch/t/sierpinski-triangle-topology/19566.rss","#text":"Sierpinski Triangle Topology"},"filter":false},{"title":"Introducing OneBalance","dc:creator":"thegostep","category":"Applications","description":"<p>By <a href=\"https://twitter.com/thegostep\" rel=\"noopener nofollow ugc\">Stephane Gosselin</a> and <a href=\"https://twitter.com/ankitchiplunkar\" rel=\"noopener nofollow ugc\">Ankit Chiplunkar</a> on behalf of Frontier Research</p>\n<p><em>For most recent information about OneBalance, please visit <a href=\"https://frontier.tech/onebalance\" rel=\"noopener nofollow ugc\">frontier.tech</a>.</em><br>\n<em>See Research Day 2024 <a href=\"https://docs.google.com/presentation/d/1sOuDB-HUiOyxiX3qrmGRfOm7NyxsIxLzBIDqRi0xJdU/edit?usp=sharing\" rel=\"noopener nofollow ugc\">slides</a> and <a href=\"https://www.youtube.com/watch?v=okDSIm7PE6I\" rel=\"noopener nofollow ugc\">recording</a>.</em></p>\n<h1><a name=\"motivation-1\" class=\"anchor\" href=\"https://ethresear.ch#motivation-1\"></a>Motivation</h1>\n<p>Web3 and the crypto ecosystem more broadly has historically had a chain centric worldview. We believe this is an outdated framework originating from a perceived scarcity in blockspace due to the bundling of credible commitment machines with global consensus.</p>\n<p>We believe an ecosystem wide transition towards an account centric worldview which bundles accounts with credible commitment machines is both necessary and inevitable in order to consolidated a fragmented user experience.</p>\n<p>We propose a new account model called “<em>Credible Accounts</em>” and introduce a framework called “<em>OneBalance”</em> for creating and managing these accounts. With this proposal, we hope to provide a missing component of the web3 stack that will help onboard the first billion humans onto crypto.</p>\n<h1><a name=\"tldr-2\" class=\"anchor\" href=\"https://ethresear.ch#tldr-2\"></a>TLDR</h1>\n<p>OneBalance is a framework for creating and managing accounts on credible commitment machines. We call these Credible Accounts.</p>\n<p>Each account can thought of as an rollup which allows users to conveniently manage their state and reliably request state transitions on any chain.</p>\n<p>This is achieved through the introduction of two key concepts:</p>\n<ol>\n<li>Accounts on credible commitment machines, and</li>\n<li>Resource locks</li>\n</ol>\n<p>A credible commitment machine is responsible for securing the account, issuing resource locks over the state it holds, and validating the fulfillment of such locks.</p>\n<p>By introducing Credible Accounts, we hope to accelerate the transition of the ecosystem from EOAs, the JSON-RPC API, and the transaction supply chain, towards an architecture built around message passing of resource locks and fulfillment proofs.</p>\n<p><strong>A Credible Account on OneBalance can:</strong></p>\n<ul>\n<li>Combine token balances from every chain</li>\n<li>Abstract gas on any chain</li>\n<li>Swap and send tokens to and from any chain</li>\n<li>Issue complex permissions over any subset of user state</li>\n<li>Incentivize and enforce atomic asynchronous composability across multiple chains</li>\n<li>Authenticate user using modern methods such as passkey, session keys, FIDO</li>\n<li>Fast confirmations through separation of fulfillment from settlement</li>\n</ul>\n<p>Many use cases are unlocked with these new capabilities. Users can spend any token to pay for state transitions. They can aggregate liquidity that lives both on-chain and off-chain. They even have the building blocks to build a decentralized Fireblocks, or a non-custodial Binance.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/b/9/b9c28cc78642455ccebc698c9de49bf17f43d00a.png\" data-download-href=\"https://ethresear.ch/uploads/default/b9c28cc78642455ccebc698c9de49bf17f43d00a\" title=\"OneBalance Account Framework\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/b/9/b9c28cc78642455ccebc698c9de49bf17f43d00a_2_690x388.png\" alt=\"OneBalance Account Framework\" data-base62-sha1=\"qvj9vkQ3GwzxC80TI5jH9HJb14S\" width=\"690\" height=\"388\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/b/9/b9c28cc78642455ccebc698c9de49bf17f43d00a_2_690x388.png, https://ethresear.ch/uploads/default/optimized/3X/b/9/b9c28cc78642455ccebc698c9de49bf17f43d00a_2_1035x582.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/b/9/b9c28cc78642455ccebc698c9de49bf17f43d00a_2_1380x776.png 2x\" data-dominant-color=\"EED7BA\"></a></div><p></p>\n<h1><a name=\"wallet-10-externally-owned-accounts-3\" class=\"anchor\" href=\"https://ethresear.ch#wallet-10-externally-owned-accounts-3\"></a>Wallet 1.0 - Externally Owned Accounts</h1>\n<p>The web3 market structure equilibrium, as defined by Ethereum, is the use of public-private key-pair, aka, Externally Owned Account (EOA) to manage all aspects of a user’s state.</p>\n<p>Since EOAs sit outside the blockchain, the chain has no view over what message have been signed. The chain relies on the use of nonces to sequence user state transaction requests, often called transactions.</p>\n<p>Here, we simplify down a smart contract blockchain such as Ethereum to a Credible Commitment Machine bundled with Global Consensus.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/9/6/9699fa9c1bf230afc00d597a1fc098f5ba09a076.png\" data-download-href=\"https://ethresear.ch/uploads/default/9699fa9c1bf230afc00d597a1fc098f5ba09a076\" title=\"Externally Owned Accounts\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/9/6/9699fa9c1bf230afc00d597a1fc098f5ba09a076_2_448x159.png\" alt=\"Externally Owned Accounts\" data-base62-sha1=\"luhwaMDjKK5G8oVex56BS2ofKRw\" width=\"448\" height=\"159\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/9/6/9699fa9c1bf230afc00d597a1fc098f5ba09a076_2_448x159.png, https://ethresear.ch/uploads/default/optimized/3X/9/6/9699fa9c1bf230afc00d597a1fc098f5ba09a076_2_672x238.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/9/6/9699fa9c1bf230afc00d597a1fc098f5ba09a076_2_896x318.png 2x\" data-dominant-color=\"EDD3B3\"></a></div><p></p>\n<h3><a name=\"credible-commitment-machines-4\" class=\"anchor\" href=\"https://ethresear.ch#credible-commitment-machines-4\"></a><strong>Credible Commitment Machines</strong></h3>\n<p><a href=\"https://en.wikipedia.org/wiki/Thomas_Schelling\" rel=\"noopener nofollow ugc\">Thomas Schelling’s</a> 1960 <em><strong>The Strategy of Conflict</strong></em> famously introduced the game theory concept of “focal point” better known as his name sake “Schelling point” .</p>\n<p>A lesser know contribution of this work was the introduction of “credible commitments” which he describes as “a promise or threat believable to others by creating a situation where the costs of reneging on the commitment are higher than the benefits”.</p>\n<p>According to Schelling, a credible commitment must provide:</p>\n<ol>\n<li><strong>Irrevocability</strong>: Making the commitment in such a way that it cannot be easily reversed. This might involve physical actions or formal agreements that lock the party into their commitment.</li>\n<li><strong>Increased Costs</strong>: Ensuring that backing out of the commitment imposes significant costs, either financially, reputationally, or strategically.</li>\n<li><strong>Observable Commitment</strong>: The commitment must be visible and understandable to other parties, ensuring they believe in the credibility of the commitment.</li>\n</ol>\n<p>The concept was further refined by <a href=\"https://www.fon.hum.uva.nl/rob/Courses/InformationInSpeech/CDROM/Literature/LOTwinterschool2006/szabo.best.vwh.net/idea.html\" rel=\"noopener nofollow ugc\">Nick Szabo in 1997</a> with the introduction of the concept of smart contracts as software enforced contracts, which was further explored by <a href=\"https://papers.agoric.com/assets/pdf/papers/digital-path.pdf\" rel=\"noopener nofollow ugc\">Mark S. Miller and Marc Stiegler in 2003</a>.</p>\n<p>These investigations lead to the <a href=\"https://ethereum.org/content/whitepaper/whitepaper-pdf/Ethereum_Whitepaper_-_Buterin_2014.pdf\" rel=\"noopener nofollow ugc\">Ethereum Whitepaper</a> published by Vitalik Buterin in 2014 proposing Ethereum as the first smart contract blockchain capable of creating and enforcing arbitrary credible commitments.</p>\n<p>Many important contributions to the topic followed with a noteworthy contribution by <a href=\"https://web.stanford.edu/~mohamwad/CredibleMechanisms.pdf\" rel=\"noopener nofollow ugc\">Mohammad Akbarpour and Shengwu Li in 2019</a> providing a formal definition to Credible Mechanisms and introducing the auction trilemma.</p>\n<p>Loosely defined, we refer to a Credible Commitment Machine as a secure computer able to programmatically issue and enforce commitments such that they are believable or “credible” to a third party observer.</p>\n<h3><a name=\"eoas-and-request-equivocation-5\" class=\"anchor\" href=\"https://ethresear.ch#eoas-and-request-equivocation-5\"></a><strong>EOAs and Request Equivocation</strong></h3>\n<p>EOAs are not credible commitment machines. Since the chain has no view over what the user has signed, it must consider any transaction signed with the same nonce as valid. This means that at any time, a user can equivocate their state transition request by signing and submit a new transaction which overwrites their nonce.</p>\n<p>This makes EOAs, and the transaction supply chain more broadly, incapable of providing credible commitments as they violate the principle of irrevocability. ****Downstream parties in the transaction supply chain such as solvers are unable to rely on the commitments made by EOAs as they may be equivocated at any time.</p>\n<p>To date, every system looking to protect against request equivocation have relied on locking funds in a deposit smart contract. This is the approach used by all types of bridges (L2, intent, POA, IBC, ZK). All implementations of secure cross chain interactions rely on the transfer of assets to a smart contract as a request which cannot be equivocated.</p>\n<p>The class of networks based on HTLCs such as the Interledger Protocol all use timelocked requests as a form of credible commitment for security passing economic messages between ledgers.</p>\n<h1><a name=\"wallet-20-smart-contract-accounts-6\" class=\"anchor\" href=\"https://ethresear.ch#wallet-20-smart-contract-accounts-6\"></a>Wallet 2.0 - Smart Contract Accounts</h1>\n<p>Smart Contract Accounts (SCAs) solve the request equivocation problem by bringing the signer on chain. This allows the account to leverage the chain’s credible commitment machine and global consensus to timestamp and sequence each state transition requests issued by the user thereby preventing equivocation.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/8/6/860b98a163a541999228b08fc63ef52bccda7155.png\" data-download-href=\"https://ethresear.ch/uploads/default/860b98a163a541999228b08fc63ef52bccda7155\" title=\"Smart Contract Accounts\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/8/6/860b98a163a541999228b08fc63ef52bccda7155_2_448x159.png\" alt=\"Smart Contract Accounts\" data-base62-sha1=\"j7OPcpUdfNx08W6KDqWSeBEyFyB\" width=\"448\" height=\"159\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/8/6/860b98a163a541999228b08fc63ef52bccda7155_2_448x159.png, https://ethresear.ch/uploads/default/optimized/3X/8/6/860b98a163a541999228b08fc63ef52bccda7155_2_672x238.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/8/6/860b98a163a541999228b08fc63ef52bccda7155_2_896x318.png 2x\" data-dominant-color=\"EDD3B3\"></a></div><p></p>\n<p>Vitalik has long been a proponent of smart contract wallets as these offer great UX features broadly referred to as account abstraction which includes gas abstraction, social recovery, permissions policies, and modern authentication methods.</p>\n<p>Despite addressing the equivocation problem, smart contract accounts deployed to chains with global consensus like Ethereum are prohibitively expensive and slow. This is because virtual machines such as the EVM require the sequential execution of global locks over all user accounts for every state transition request. This is equivalent to forming a single global queue of all users waiting to do something on chain.</p>\n<h3><a name=\"the-account-dilemma-7\" class=\"anchor\" href=\"https://ethresear.ch#the-account-dilemma-7\"></a>The Account Dilemma</h3>\n<p>We observe a tradeoff between EOAs and SCAs. On one side we have EOAs which are fast and cheap, but cannot make credible commitments due to request equivocation. On the other side we have SCAs which can make credible commitments, but are slow and expensive due to global consensus. We call this tradeoff the Account Dilemma.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/3/8/388e6f420274cdb504f0e98be46be09230a816dc.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/388e6f420274cdb504f0e98be46be09230a816dc\" title=\"The Account Dilemma\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/3/8/388e6f420274cdb504f0e98be46be09230a816dc_2_448x292.jpeg\" alt=\"The Account Dilemma\" data-base62-sha1=\"84jTZoWH0ARNM9R5kUfVg87meTi\" width=\"448\" height=\"292\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/3/8/388e6f420274cdb504f0e98be46be09230a816dc_2_448x292.jpeg, https://ethresear.ch/uploads/default/optimized/3X/3/8/388e6f420274cdb504f0e98be46be09230a816dc_2_672x438.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/3/8/388e6f420274cdb504f0e98be46be09230a816dc_2_896x584.jpeg 2x\" data-dominant-color=\"EFEEED\"></a></div><p></p>\n<h1><a name=\"wallet-30-credible-accounts-8\" class=\"anchor\" href=\"https://ethresear.ch#wallet-30-credible-accounts-8\"></a>Wallet 3.0 - Credible Accounts</h1>\n<p>We propose a new account model called Credible Accounts which aims to solve the Account Dilemma. Credible Accounts live in a secure computer of the users choice that can make credible commitments about what messages it will and won’t sign.</p>\n<p>By unbundling global consensus from the Smart Contract Account model, we are able to keep the speed and cost advantage of EOAs while retaining the UX improvements and non-equivocation guarantees of SCAs.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/8/3/837f659d705ce4c043148cb3ae81b8324adc5686.png\" data-download-href=\"https://ethresear.ch/uploads/default/837f659d705ce4c043148cb3ae81b8324adc5686\" title=\"Credible Accounts\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/8/3/837f659d705ce4c043148cb3ae81b8324adc5686_2_448x159.png\" alt=\"Credible Accounts\" data-base62-sha1=\"iLhuHVU9DvXwQ0Yw1bJ7F1vQIwC\" width=\"448\" height=\"159\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/8/3/837f659d705ce4c043148cb3ae81b8324adc5686_2_448x159.png, https://ethresear.ch/uploads/default/optimized/3X/8/3/837f659d705ce4c043148cb3ae81b8324adc5686_2_672x238.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/8/3/837f659d705ce4c043148cb3ae81b8324adc5686_2_896x318.png 2x\" data-dominant-color=\"EED5B4\"></a></div><p></p>\n<h3><a name=\"onebalance-a-framework-for-credible-accounts-9\" class=\"anchor\" href=\"https://ethresear.ch#onebalance-a-framework-for-credible-accounts-9\"></a>OneBalance: a framework for Credible Accounts</h3>\n<p>Each OneBalance account can be thought of as its own rollup. The account wraps individual user state from all chains and replicates it in a virtual environment. This virtual environment issues state transition requests as “resource locks” and fulfills those state transitions through cross-chain execution proofs. This virtual environment is secured by a credible commitment machine.</p>\n<p>Since a OneBalance account provides the same guarantees as a SCA, it comes with all the same UX benefits of account abstraction, such as gas abstraction, social recovery, permission policies, and modern authentication methods.</p>\n<p>A OneBalance account can create an arbitrary number of sub accounts across any number of chains and manage any state present on those chains. It is backwards compatible with all chains, smart contracts, and assets including Ethereum, Solana, Bitcoin, ERC20s, NFTs, DAOs, multisigs, defi protocols, and deposits or points programs. This multi-ecosystem compatibility is not possible with other current account model.</p>\n<div class=\"md-table\">\n<table>\n<thead>\n<tr>\n<th>Capability</th>\n<th style=\"text-align:center\">EOAs</th>\n<th style=\"text-align:center\">SCAs</th>\n<th style=\"text-align:center\">OneBs</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Fast &amp; Cheap</td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/white_check_mark.png?v=12\" title=\":white_check_mark:\" class=\"emoji only-emoji\" alt=\":white_check_mark:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/x.png?v=12\" title=\":x:\" class=\"emoji only-emoji\" alt=\":x:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/white_check_mark.png?v=12\" title=\":white_check_mark:\" class=\"emoji only-emoji\" alt=\":white_check_mark:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n</tr>\n<tr>\n<td>UX features</td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/x.png?v=12\" title=\":x:\" class=\"emoji only-emoji\" alt=\":x:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/white_check_mark.png?v=12\" title=\":white_check_mark:\" class=\"emoji only-emoji\" alt=\":white_check_mark:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/white_check_mark.png?v=12\" title=\":white_check_mark:\" class=\"emoji only-emoji\" alt=\":white_check_mark:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n</tr>\n<tr>\n<td>Equivocation protection</td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/x.png?v=12\" title=\":x:\" class=\"emoji only-emoji\" alt=\":x:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/white_check_mark.png?v=12\" title=\":white_check_mark:\" class=\"emoji only-emoji\" alt=\":white_check_mark:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/white_check_mark.png?v=12\" title=\":white_check_mark:\" class=\"emoji only-emoji\" alt=\":white_check_mark:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n</tr>\n<tr>\n<td>Multi-ecosystem compatibility</td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/x.png?v=12\" title=\":x:\" class=\"emoji only-emoji\" alt=\":x:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/x.png?v=12\" title=\":x:\" class=\"emoji only-emoji\" alt=\":x:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/white_check_mark.png?v=12\" title=\":white_check_mark:\" class=\"emoji only-emoji\" alt=\":white_check_mark:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n</tr>\n</tbody>\n</table>\n</div><p>The OneBalance framework for Credible Accounts is implemented in a modular way using standards developed by the <a href=\"https://frontier.tech/cake-working-group\" rel=\"noopener nofollow ugc\">CAKE Working Group</a> to allow users / apps / wallets to pick an choose any component of the <a href=\"https://frontier.tech/the-cake-framework\" rel=\"noopener nofollow ugc\">CAKE Framework</a> needed for their use case.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/b/9/b9c28cc78642455ccebc698c9de49bf17f43d00a.png\" data-download-href=\"https://ethresear.ch/uploads/default/b9c28cc78642455ccebc698c9de49bf17f43d00a\" title=\"OneBalance Framework\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/b/9/b9c28cc78642455ccebc698c9de49bf17f43d00a_2_690x388.png\" alt=\"OneBalance Framework\" data-base62-sha1=\"qvj9vkQ3GwzxC80TI5jH9HJb14S\" width=\"690\" height=\"388\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/b/9/b9c28cc78642455ccebc698c9de49bf17f43d00a_2_690x388.png, https://ethresear.ch/uploads/default/optimized/3X/b/9/b9c28cc78642455ccebc698c9de49bf17f43d00a_2_1035x582.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/b/9/b9c28cc78642455ccebc698c9de49bf17f43d00a_2_1380x776.png 2x\" data-dominant-color=\"EED7BA\"></a></div><p></p>\n<h2><a name=\"resource-locks-10\" class=\"anchor\" href=\"https://ethresear.ch#resource-locks-10\"></a><strong>Resource Locks</strong></h2>\n<p>A resource lock is a credible commitment made by a user to escrow some state conditional on particular conditions fulfilled, or an expiry time.</p>\n<p>An example could be a cross-chain request to purchase an NFT on Solana using USDC deposited in the OneBalance account from Ethereum.</p>\n<pre><code class=\"lang-json\">resource_lock: {\n\tlock: 1500 USDC,\n\tfulfill: DeGods #12345,\n\texpiry: Solana block 245547084\n}\n</code></pre>\n<p>Resource locks are necessary to prevent solvers from being griefed by a user through double spending or equivocating their request during execution.</p>\n<p>Since the user makes a commitment not to overwrite their request within a time window, it removes the uncertainty solvers typically incur between a transaction being signed and the finalized chain state.</p>\n<p>A lock is analogous to depositing funds in a smart contract, or issuing an ERC20 approval, but without spending gas or waiting for on-chain finality since it is done within the account itself.</p>\n<p>The lock expiry needs to be of long enough duration to provide solvers the chance to execute the requested state transition on the destination chain and submit a proof of fulfillment to the fulfillment engine.</p>\n<p>Crucially, this introduces a separation between fulfillment time and settlement time. Since the account provides local assurance of the lock, solvers can bring a requested state transition on a destination chain without waiting for finality on the origin chain.</p>\n<p>This allows users to buy SOL with ETH at the speed of Solana without being constrained by the speed of Ethereum. This fulfillment speed can be extended to execution of any state transition such as sniping an NFT, sending money to your grandmother, or anything else users do on blockchains.</p>\n<p>Resource locks can implement constraints which sit anywhere along the spectrum of permissions.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/c/3/c3a8e48441d80f71c6492fdfd765b4c80ba01467.png\" data-download-href=\"https://ethresear.ch/uploads/default/c3a8e48441d80f71c6492fdfd765b4c80ba01467\" title=\"Permission Spectrum\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/c/3/c3a8e48441d80f71c6492fdfd765b4c80ba01467_2_690x228.png\" alt=\"Permission Spectrum\" data-base62-sha1=\"rUSXmQx7rt0DTvtzaBYrEzsP0l9\" width=\"690\" height=\"228\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/c/3/c3a8e48441d80f71c6492fdfd765b4c80ba01467_2_690x228.png, https://ethresear.ch/uploads/default/optimized/3X/c/3/c3a8e48441d80f71c6492fdfd765b4c80ba01467_2_1035x342.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/c/3/c3a8e48441d80f71c6492fdfd765b4c80ba01467_2_1380x456.png 2x\" data-dominant-color=\"EED7B9\"></a></div><p></p>\n<p>Permissions could be stateful or stateless. For example:</p>\n<ul>\n<li><strong>Scoped session keys</strong>: a stateless permission for an app like a Telegram bot to take arbitrary actions on subsets of a user’s token balances</li>\n<li><strong>Circuit breaker</strong>: a stateful permission to sell all open positions if there is no account activity or market volatility above a predefined threshold</li>\n<li><strong>Limit order:</strong> a stateful permission to post an order if a pair reaches a certain price on a DEX</li>\n<li><strong>MFA</strong>: a stateless permission to post a transaction if two valid authentication methods are provided</li>\n</ul>\n<h2><a name=\"credible-commitment-machine-11\" class=\"anchor\" href=\"https://ethresear.ch#credible-commitment-machine-11\"></a><strong>Credible Commitment Machine</strong></h2>\n<p>A credible commitment machine is a secure computer on which the account lives and is trusted to provide assurances over the valid issuance of resource locks and the validation of their fulfillment.</p>\n<p>We present here four possible architectures of credible commitment machines which provide for secure issuance and enforcement of locks: Trusted Execution Environments (TEEs), Multi-Party Computation / chain signatures (MPC), Smart Contract Accounts (SCAs), and in protocol virtual machine changes.</p>\n<p>These mechanisms are being developed and refined as we speak, it is likely that the ideal architecture today will look vastly different than the one five years from now.</p>\n<p>This is why a OneBalance account allows users to migrate between CCMs over time as they look for better properties.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/8/a/8abeab85e3de0dc9203c0882c3d468e7c31ddcc9.png\" data-download-href=\"https://ethresear.ch/uploads/default/8abeab85e3de0dc9203c0882c3d468e7c31ddcc9\" title=\"Credible Commitment Machine\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/8/a/8abeab85e3de0dc9203c0882c3d468e7c31ddcc9_2_690x467.png\" alt=\"Credible Commitment Machine\" data-base62-sha1=\"jNooLP7z6yF1ovVqqlFnBC7nMud\" width=\"690\" height=\"467\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/8/a/8abeab85e3de0dc9203c0882c3d468e7c31ddcc9_2_690x467.png, https://ethresear.ch/uploads/default/optimized/3X/8/a/8abeab85e3de0dc9203c0882c3d468e7c31ddcc9_2_1035x700.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/8/a/8abeab85e3de0dc9203c0882c3d468e7c31ddcc9_2_1380x934.png 2x\" data-dominant-color=\"EFD7BA\"></a></div><p></p>\n<h1><a name=\"roadmap-12\" class=\"anchor\" href=\"https://ethresear.ch#roadmap-12\"></a>Roadmap</h1>\n<p>OneBalance v1:</p>\n<ul>\n<li>add support for transactions and swaps of any token on any chain</li>\n<li>add support for session keys for trusted applications</li>\n<li>add support for user rage quit through exit hatch</li>\n</ul>\n<p>OneBalance v2:</p>\n<ul>\n<li>add support for stateless policies</li>\n<li>add support for arbitrary transactions</li>\n<li>add support for authentication modules</li>\n</ul>\n<p>OneBalance v3:</p>\n<ul>\n<li>add support for stateful policies</li>\n</ul>\n<p>OneBalance v4:</p>\n<ul>\n<li>add liveness guarantees through account replication</li>\n</ul>\n<div class=\"md-table\">\n<table>\n<thead>\n<tr>\n<th></th>\n<th style=\"text-align:center\">EOA</th>\n<th style=\"text-align:center\">OneBalance v1</th>\n<th style=\"text-align:center\">OneBalance v2</th>\n<th style=\"text-align:center\">OneBalance v3</th>\n<th style=\"text-align:center\">OneBalance v4</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>self-custody</td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/white_check_mark.png?v=12\" title=\":white_check_mark:\" class=\"emoji only-emoji\" alt=\":white_check_mark:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/white_check_mark.png?v=12\" title=\":white_check_mark:\" class=\"emoji only-emoji\" alt=\":white_check_mark:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/white_check_mark.png?v=12\" title=\":white_check_mark:\" class=\"emoji only-emoji\" alt=\":white_check_mark:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/white_check_mark.png?v=12\" title=\":white_check_mark:\" class=\"emoji only-emoji\" alt=\":white_check_mark:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/white_check_mark.png?v=12\" title=\":white_check_mark:\" class=\"emoji only-emoji\" alt=\":white_check_mark:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n</tr>\n<tr>\n<td>transfers</td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/white_check_mark.png?v=12\" title=\":white_check_mark:\" class=\"emoji only-emoji\" alt=\":white_check_mark:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/white_check_mark.png?v=12\" title=\":white_check_mark:\" class=\"emoji only-emoji\" alt=\":white_check_mark:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/white_check_mark.png?v=12\" title=\":white_check_mark:\" class=\"emoji only-emoji\" alt=\":white_check_mark:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/white_check_mark.png?v=12\" title=\":white_check_mark:\" class=\"emoji only-emoji\" alt=\":white_check_mark:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/white_check_mark.png?v=12\" title=\":white_check_mark:\" class=\"emoji only-emoji\" alt=\":white_check_mark:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n</tr>\n<tr>\n<td>swaps</td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/white_check_mark.png?v=12\" title=\":white_check_mark:\" class=\"emoji only-emoji\" alt=\":white_check_mark:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/white_check_mark.png?v=12\" title=\":white_check_mark:\" class=\"emoji only-emoji\" alt=\":white_check_mark:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/white_check_mark.png?v=12\" title=\":white_check_mark:\" class=\"emoji only-emoji\" alt=\":white_check_mark:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/white_check_mark.png?v=12\" title=\":white_check_mark:\" class=\"emoji only-emoji\" alt=\":white_check_mark:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/white_check_mark.png?v=12\" title=\":white_check_mark:\" class=\"emoji only-emoji\" alt=\":white_check_mark:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n</tr>\n<tr>\n<td>session keys</td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/x.png?v=12\" title=\":x:\" class=\"emoji only-emoji\" alt=\":x:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/white_check_mark.png?v=12\" title=\":white_check_mark:\" class=\"emoji only-emoji\" alt=\":white_check_mark:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/white_check_mark.png?v=12\" title=\":white_check_mark:\" class=\"emoji only-emoji\" alt=\":white_check_mark:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/white_check_mark.png?v=12\" title=\":white_check_mark:\" class=\"emoji only-emoji\" alt=\":white_check_mark:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/white_check_mark.png?v=12\" title=\":white_check_mark:\" class=\"emoji only-emoji\" alt=\":white_check_mark:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n</tr>\n<tr>\n<td>transactions</td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/white_check_mark.png?v=12\" title=\":white_check_mark:\" class=\"emoji only-emoji\" alt=\":white_check_mark:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/x.png?v=12\" title=\":x:\" class=\"emoji only-emoji\" alt=\":x:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/white_check_mark.png?v=12\" title=\":white_check_mark:\" class=\"emoji only-emoji\" alt=\":white_check_mark:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/white_check_mark.png?v=12\" title=\":white_check_mark:\" class=\"emoji only-emoji\" alt=\":white_check_mark:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/white_check_mark.png?v=12\" title=\":white_check_mark:\" class=\"emoji only-emoji\" alt=\":white_check_mark:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n</tr>\n<tr>\n<td>stateless policies</td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/x.png?v=12\" title=\":x:\" class=\"emoji only-emoji\" alt=\":x:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/x.png?v=12\" title=\":x:\" class=\"emoji only-emoji\" alt=\":x:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/white_check_mark.png?v=12\" title=\":white_check_mark:\" class=\"emoji only-emoji\" alt=\":white_check_mark:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/white_check_mark.png?v=12\" title=\":white_check_mark:\" class=\"emoji only-emoji\" alt=\":white_check_mark:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/white_check_mark.png?v=12\" title=\":white_check_mark:\" class=\"emoji only-emoji\" alt=\":white_check_mark:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n</tr>\n<tr>\n<td>auth modules</td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/x.png?v=12\" title=\":x:\" class=\"emoji only-emoji\" alt=\":x:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/x.png?v=12\" title=\":x:\" class=\"emoji only-emoji\" alt=\":x:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/white_check_mark.png?v=12\" title=\":white_check_mark:\" class=\"emoji only-emoji\" alt=\":white_check_mark:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/white_check_mark.png?v=12\" title=\":white_check_mark:\" class=\"emoji only-emoji\" alt=\":white_check_mark:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/white_check_mark.png?v=12\" title=\":white_check_mark:\" class=\"emoji only-emoji\" alt=\":white_check_mark:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n</tr>\n<tr>\n<td>stateful policies</td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/x.png?v=12\" title=\":x:\" class=\"emoji only-emoji\" alt=\":x:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/x.png?v=12\" title=\":x:\" class=\"emoji only-emoji\" alt=\":x:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/x.png?v=12\" title=\":x:\" class=\"emoji only-emoji\" alt=\":x:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/white_check_mark.png?v=12\" title=\":white_check_mark:\" class=\"emoji only-emoji\" alt=\":white_check_mark:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/white_check_mark.png?v=12\" title=\":white_check_mark:\" class=\"emoji only-emoji\" alt=\":white_check_mark:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n</tr>\n<tr>\n<td>liveness guarantees</td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/white_check_mark.png?v=12\" title=\":white_check_mark:\" class=\"emoji only-emoji\" alt=\":white_check_mark:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/x.png?v=12\" title=\":x:\" class=\"emoji only-emoji\" alt=\":x:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/x.png?v=12\" title=\":x:\" class=\"emoji only-emoji\" alt=\":x:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/x.png?v=12\" title=\":x:\" class=\"emoji only-emoji\" alt=\":x:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td style=\"text-align:center\"><img src=\"https://ethresear.ch/images/emoji/facebook_messenger/white_check_mark.png?v=12\" title=\":white_check_mark:\" class=\"emoji only-emoji\" alt=\":white_check_mark:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n</tr>\n</tbody>\n</table>\n</div><hr>\n<h2><a name=\"acknowledgements-13\" class=\"anchor\" href=\"https://ethresear.ch#acknowledgements-13\"></a>Acknowledgements</h2>\n<p>Thank you to the collective consciousness of the crypto ecosystem for fostering a fertile ground for innovation.</p>\n<p>In no particular order, thank you to the following collaborators for the many stimulating discussions which lead to the creation of this proposal:</p>\n<p>Murat Akdeniz, Ahmed Al-Balaghi, Viktor Bunin, Jonah Burian, Vitalik Buterin, Philippe Castonguay, Vaibhav Chellani, Valery Cherepanov, Jasper De Gooijer, Nicolas Della Penna, Justin Drake, Brendan Farmer, Ben Fisch, Mattia Gagliardi, Johnny Gannon, Matt Garnett, Ivo Georgiev, Christopher Goes, Pedro Gomes, Mason Hall, Sam Hart, Connor Howe, Sreeram Kannan, Hart Lambur, Zaki Manian, Robert Miller, Alex Obadia, Puja Ohlhaver, Anatolii Padenko, Nick Pai, Illia Polosukhin, Karthik Senthil, Tomasz Stanczak, Henri Stern, Alex Stokes, Caleb Tebbe, Dror Tirosh, Dean Tribble, Drew Van der Werff, Alex Watts, Yoav Weiss, Nathan Worsley, Evgeny Yurtae, Philipp Zentner, Noah Zinsmeister, apriori, jxom, awkweb.</p>\n<h2><a name=\"discussion-14\" class=\"anchor\" href=\"https://ethresear.ch#discussion-14\"></a>Discussion</h2>\n<h3><a name=\"why-are-you-doing-this-15\" class=\"anchor\" href=\"https://ethresear.ch#why-are-you-doing-this-15\"></a>Why are you doing this?</h3>\n<p>Our mission is to help the web3 ecosystem to transition to an account centric worldview in order to bring web3 to the first 1 billion people.</p>\n<p>We believe non-coercive credible commitment machines are essential for human coordination in the digital age.</p>\n<p>We believe the chain centric worldview is an outdated framework originating from the historical scarcity in blockspace. (<a href=\"https://www.usv.com/writing/2016/08/fat-protocols/\" rel=\"noopener nofollow ugc\">sorry Joel</a>)</p>\n<p>Much like the shift from the Geocentric worldview to the Heliocentric worldview unlocked a wealth of discoveries, we believe the shift from a chain centric worldview to an account centric worldview will unlock the full potential of web3.</p>\n<h3><a name=\"what-does-this-mean-from-a-user-perspective-16\" class=\"anchor\" href=\"https://ethresear.ch#what-does-this-mean-from-a-user-perspective-16\"></a>What does this mean from a user perspective?</h3>\n<p>Users don’t need to care about which chains they are interacting with + can get close to instant fulfillment.</p>\n<p>Lets take a complex, yet common example:</p>\n<blockquote>\n<p>User wants to buy an NFT traded on Solana with a price of 10 SOL, but only has USDC on Ethereum.</p>\n</blockquote>\n<p>This state transition request requires the following sequential operations to take place:</p>\n<ol>\n<li>Generate: Create a new Ed25519 keypair in a solana wallet</li>\n<li>Swap: USDC for ETH to pay for gas on Ethereum</li>\n<li>Bridge: Send USDC to bridge contract on Ethereum and get USDC minted on Solana</li>\n<li>Swap: USDC for SOL to pay for gas on Solana</li>\n<li>Swap: USDC for SOL to purchase NFT</li>\n<li>Execute: Execute calldata on marketplace to purchase the NFT</li>\n</ol>\n<p>Today, users are required to manually perform each of these actions and wait for the previous one to be settled or finalized before performing the following one. Some of these operations are even technically impossible in a non-custodial way using EOAs without chain level gas abstraction.</p>\n<p>The critical path of execution here requires waiting for the settlement of two Ethereum transactions and two Solana transactions + waiting for the finality of Ethereum. With Ethereum’s current block finality time, we are looking at a minimum of 15min to complete execution.</p>\n<p>Lets look at the equivalent using a OneBalance account:</p>\n<blockquote>\n<p>User wants to buy an NFT traded on Solana with a price of 10 SOL, but only has USDC on OneBalance.</p>\n</blockquote>\n<p>This state transition request requires the following sequential operations to take place:</p>\n<ol>\n<li>\n<p>Create a resource lock on OneBalance as follows:</p>\n<pre><code class=\"lang-json\">resource_lock: {\n\tlock: 1500 USDC,\n\tfulfill: DeGods #12345,\n\texpiry: Solana block 245547084\n}\n</code></pre>\n</li>\n</ol>\n<p>There are no additional steps for the user to take.</p>\n<p>Behind the scenes, a solver purchases the NFT and credits it to the OneBalance proxy account of the user on Solana, and claims the resources in the lock.</p>\n<p>Since a OneBalance account separates fulfillment from settlement, the user gets execution at the speed of transaction execution on their destination network, in this case Solana. The user can perform any operation on any chain using any token they hold in their OneBalance account.</p>\n<h3><a name=\"show-me-some-sequence-diagrams-17\" class=\"anchor\" href=\"https://ethresear.ch#show-me-some-sequence-diagrams-17\"></a>Show me some sequence diagrams.</h3>\n<p>Ok.</p>\n<p>Lets walkthrough a few examples on how interoperability is achieved under different conditions:</p>\n<ol>\n<li><strong>The user has EOA account and wants to do a cross-chain contract call while not having gas on target chain</strong>\n<ol>\n<li>The user signs two transactions using their EOA, the first transfers gas amount from the origin chain to the solver escrow address and the second calls the contract on the target chain.</li>\n<li>As soon as the solver simulates these two transactions, they have a guarantee that the user will pay them the correct gas amount (user’s commitment is enforced).</li>\n<li>The solver instantly funds user’s EOA account on the target chain, and executes the contract call transaction without waiting for settlement or finality of first transaction.</li>\n<li>The solver can include the first transaction (gas payment) within the expiry window of commitment.</li>\n</ol>\n</li>\n</ol>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/1/3/13a5cb8d20d6ab799b12095e82e6bbed0147e295.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/13a5cb8d20d6ab799b12095e82e6bbed0147e295\" title=\"image\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/1/3/13a5cb8d20d6ab799b12095e82e6bbed0147e295_2_517x265.jpeg\" alt=\"image\" data-base62-sha1=\"2NOhKJ80jYf4AtN7lKjlvF8woLP\" width=\"517\" height=\"265\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/1/3/13a5cb8d20d6ab799b12095e82e6bbed0147e295_2_517x265.jpeg, https://ethresear.ch/uploads/default/optimized/3X/1/3/13a5cb8d20d6ab799b12095e82e6bbed0147e295_2_775x397.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/1/3/13a5cb8d20d6ab799b12095e82e6bbed0147e295_2_1034x530.jpeg 2x\" data-dominant-color=\"F1F1F1\"></a></div><p></p>\n<ol start=\"2\">\n<li><strong>The user has Smart Contract account and wants to do a cross-chain swap while not having gas on target chain.</strong>\n<ol>\n<li>The user signs a UserOp authenticating the transfer of required tokens to the solvers escrow address.</li>\n<li>As soon as the solver simulates the transaction, they have a guarantee that the user will pay them the required tokens (user’s commitment is enforced).</li>\n<li>The solver procures the required tokens on the target chain and deposits them into the users account on the target chain without waiting for settlement or finality.</li>\n<li>The solver can include the UserOp (token deposit in escrow) eventually.</li>\n</ol>\n</li>\n</ol>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/4/6/4620414fdd10e1da61a13fb84436b2daa33a49c2.png\" data-download-href=\"https://ethresear.ch/uploads/default/4620414fdd10e1da61a13fb84436b2daa33a49c2\" title=\"image\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/4/6/4620414fdd10e1da61a13fb84436b2daa33a49c2_2_517x260.png\" alt=\"image\" data-base62-sha1=\"a0mwOjpmsOM8mxaJLvvjDW2qDR0\" width=\"517\" height=\"260\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/4/6/4620414fdd10e1da61a13fb84436b2daa33a49c2_2_517x260.png, https://ethresear.ch/uploads/default/optimized/3X/4/6/4620414fdd10e1da61a13fb84436b2daa33a49c2_2_775x390.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/4/6/4620414fdd10e1da61a13fb84436b2daa33a49c2_2_1034x520.png 2x\" data-dominant-color=\"F1F1F1\"></a></div><p></p>\n<p>As we can see in the above examples a user commitment via nonce lock is same as delegating eventual state update to solvers. This reduces latency introduced by finality especially in a cross-chain setting.</p>\n<h3><a name=\"how-does-this-relate-to-account-abstraction-and-4337-18\" class=\"anchor\" href=\"https://ethresear.ch#how-does-this-relate-to-account-abstraction-and-4337-18\"></a>How does this relate to account abstraction and 4337?</h3>\n<p>Account abstraction and 4337 are often associated with Smart Contract Accounts and refer to both the set of UX improvements offered by an SCA (account abstraction) and a specific standard for implementation of these UX improvements (EIP-4337).</p>\n<p>The OneBalance account model provides the same UX improvements as SCAs and is backwards compatible with using 4337 for settlement of locks on chain as user ops.</p>\n<p>However, since OneBalance is a general framework for the creation of credible accounts, it is not limited to chains where account abstraction and 4337 are actively being used.</p>\n<p>OneBalance is supportive of chains and proxy accounts which opt for using dos resistant user ops like 4337.</p>\n<h3><a name=\"how-do-you-guarantee-atomic-asynchronous-execution-across-chains-19\" class=\"anchor\" href=\"https://ethresear.ch#how-do-you-guarantee-atomic-asynchronous-execution-across-chains-19\"></a><strong>How do you guarantee atomic asynchronous execution across chains?</strong></h3>\n<p>We can’t. But we can incentivize it.</p>\n<p>Accounts can enforce two types of constraints:</p>\n<ul>\n<li>Constraints over what states of the world it requires in order to issue a lock</li>\n<li>Constraints over what states of the world it requires in order to fulfill a lock</li>\n</ul>\n<p>OneBalance can <em>incentivize</em> atomicity, but it cannot guarantee it.</p>\n<ul>\n<li>For example: Take a lock that requests sequencing of state transitions across chain A and chain B, with a desired atomicity such that B is executed if and only if A is executed. If the lock is public and the only condition on inclusion of B is the existence of a valid signature from the requesting account, then B could be included regardless of A if it exposes sufficient MEV to compensate its inclusion.</li>\n</ul>\n<p>However! Since executing B without A invalidates the fulfillment conditions of the lock, then the solver cannot extract any value from the lock. This means that from the user perspective, atomicity is maintained. Some people refer to this as “economic atomicity”. For locks with complex multi chain atomicity requirements, Solvers take on the risk of non-execution.</p>\n<p>This “lock leaking” due to MEV problem can be resolved at the routing layer by routing the state transition request through a secure OFA that prevents information leakage.</p>\n<p>Novel mechanisms are being developed at the settlement layer to help solvers manage their settlement risk using things like pre-confirmations or proof aggregation. Importantly, these help manage solver execution risk and therefore help minimize non-execution risk for users of a OneBalance account, but the OneBalance account already has economic atomicity guarantees.</p>\n<h3><a name=\"is-onebalance-just-htlcs-for-ethereum-20\" class=\"anchor\" href=\"https://ethresear.ch#is-onebalance-just-htlcs-for-ethereum-20\"></a><strong>Is OneBalance just HTLCs for Ethereum?</strong></h3>\n<p>I prefer to call it turbo HTLCs <img src=\"https://ethresear.ch/images/emoji/facebook_messenger/smile.png?v=12\" title=\":smile:\" class=\"emoji\" alt=\":smile:\" loading=\"lazy\" width=\"20\" height=\"20\"></p>\n<p>The design of intent bridges work similarly to HTLCs in that they lock user funds on the originating chain until a proof is provided of the completion of a state transition on the destination chain.</p>\n<p>Instead of being constrained by the speed of the originating chains, OneBalance accounts are constrained by the speed of the credible commitment engine in generating these locks. This means that on a TEE architecture, locks can be issued at clock speed of a single server, hence turbo HTLCs!</p>\n<h3><a name=\"how-does-this-thing-scale-to-one-billion-concurrent-users-21\" class=\"anchor\" href=\"https://ethresear.ch#how-does-this-thing-scale-to-one-billion-concurrent-users-21\"></a>How does this thing scale to one billion concurrent users?</h3>\n<p>OneBalance accounts create “local” locks, whereas regular accounts can only create “global” locks. Global locks require locking the state of all accounts in the execution environment during sequencing, whereas local locks only require locking the state of accounts which are party to the lock.</p>\n<p>Unlike global locks, local locks provide the opportunity for lock sequencing to be parallelized on distinct machines.</p>\n<h3><a name=\"where-does-the-account-live-22\" class=\"anchor\" href=\"https://ethresear.ch#where-does-the-account-live-22\"></a><strong>Where does the account live?</strong></h3>\n<p>The account lives in a secure computer of the users choice that can make credible commitments about what messages it will and won’t sign.</p>\n<p>The four architectures for credible commitment enforcement presented above provide such environments, but each have their tradeoffs. OneBalance accounts are not opinionated to the type of credible commitment enforcement mechanism used.</p>\n<p>Crucially, as the sophistication of these architectures evolve over time, the tradeoff space will change and so will user preferences. As such, OneBalance accounts must remain flexible to supporting different architectures.</p>\n<h3><a name=\"is-onebalance-a-standard-23\" class=\"anchor\" href=\"https://ethresear.ch#is-onebalance-a-standard-23\"></a>Is OneBalance a standard?</h3>\n<p>No.</p>\n<p>OneBalance is a framework for building accounts on top of credible commitment machines. OneBalance will use the standards developed by the <a href=\"https://frontier.tech/cake-working-group\" rel=\"noopener nofollow ugc\">CAKE Working Group</a> plug and play with all components of the CAKE stack.</p>\n<h3><a name=\"are-you-providing-pre-confirmations-24\" class=\"anchor\" href=\"https://ethresear.ch#are-you-providing-pre-confirmations-24\"></a>Are you providing pre-confirmations?</h3>\n<p>No. OneBalance provides resource locks.</p>\n<p>Lets explore the difference between the two.</p>\n<p>Pre-confirmations is a mechanism being actively developed by several teams in the ecosystem to offer better inclusion guarantees for entities sending transactions to the blockchain.</p>\n<p>Resource locks is a mechanism for offering guarantees to solvers that a user cannot double spend or equivocate on their state transition request.</p>\n<p>Both mechanisms are aimed at reducing the execution risk of solvers, pre-confirmations are guarantees provided by proposers, resource locks are guarantees provided by users.</p>\n<p>Both pre-confirmations and resource locks can be enforced by the same credible commitment mechanism.</p>\n<p>For example: If Ethereum validators were to deposit their staked ETH in a OneBalance account, they could create resource locks which specify slashing rules if certain transaction inclusion commitments are invalidated. This could be implemented with a restaking contract like eigenlayer.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/4/c/4c3e7151fe217186184497d8a2de952f5383661d.png\" data-download-href=\"https://ethresear.ch/uploads/default/4c3e7151fe217186184497d8a2de952f5383661d\" title=\"image\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/4/c/4c3e7151fe217186184497d8a2de952f5383661d_2_345x107.png\" alt=\"image\" data-base62-sha1=\"aSu4n7oFHtoFPTUPDc9fI5jzJmt\" width=\"345\" height=\"107\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/4/c/4c3e7151fe217186184497d8a2de952f5383661d_2_345x107.png, https://ethresear.ch/uploads/default/optimized/3X/4/c/4c3e7151fe217186184497d8a2de952f5383661d_2_517x160.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/4/c/4c3e7151fe217186184497d8a2de952f5383661d_2_690x214.png 2x\" data-dominant-color=\"EEEEEE\"></a></div><p></p>\n<h3><a name=\"how-does-a-lock-turn-into-a-state-transition-on-chain-25\" class=\"anchor\" href=\"https://ethresear.ch#how-does-a-lock-turn-into-a-state-transition-on-chain-25\"></a>How does a lock turn into a state transition on chain?</h3>\n<p>OneBalance accounts are responsible for issuing and enforcing resource locks over state transition requests.</p>\n<p>Routing of the request in order to provide fulfillment is a downstream module which the upstream app / user must define. For certain kinds of requests, it may be beneficial to route directly to a chain’s transaction pool, other requests may benefit from using a solver network or orderflow auction, and others from specifying an exclusive solver.</p>\n<p>OneBalance is unopinionated about the routing mechanism.</p>\n<h3><a name=\"is-onebalance-a-competitor-to-insert-my-bags-here-26\" class=\"anchor\" href=\"https://ethresear.ch#is-onebalance-a-competitor-to-insert-my-bags-here-26\"></a>Is OneBalance a competitor to (insert my bags here)?</h3>\n<p>Probably not.</p>\n<p>OneBalance is providing a framework for orchestration of stateful accounts. Our goal is to displace the industry wide reliance on imperative state transition requests issued by user managed EOAs. OneBalance is not opinionated on the architecture of the stateful accounts or the credible commitment mechanisms used to secure them.</p>\n<p>OneBalance uses a modular architecture that allows for the following components to be integrated:</p>\n<ol>\n<li>Orderflow sources: wallets / apps / tg bots / waas</li>\n<li>Fulfillment engines: orderflow auctions / solvers / solver networks / market makers / intent networks / bridges</li>\n<li>Settlement engines: any L1 or L2 (yes, even BTC)</li>\n</ol>\n<p>The design for OneBalance emerged from our work with members of the <a href=\"https://frontier.tech/cake-working-group\" rel=\"noopener nofollow ugc\">CAKE working group</a>.</p>\n<p>Looking at the CAKE framework, OneBalance sits between the permissioning layer and the solver layer and is compatible with all the other necessary components of the cake.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/4/4/44ee9a1604244965ad249dee7879f0b982740679.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/44ee9a1604244965ad249dee7879f0b982740679\" title=\"image\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/4/4/44ee9a1604244965ad249dee7879f0b982740679_2_291x375.jpeg\" alt=\"image\" data-base62-sha1=\"9PNFyfuSXvJIce2xK4UFNt85MWR\" width=\"291\" height=\"375\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/4/4/44ee9a1604244965ad249dee7879f0b982740679_2_291x375.jpeg, https://ethresear.ch/uploads/default/optimized/3X/4/4/44ee9a1604244965ad249dee7879f0b982740679_2_436x562.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/4/4/44ee9a1604244965ad249dee7879f0b982740679_2_582x750.jpeg 2x\" data-dominant-color=\"E6E4DC\"></a></div><p></p>\n<h3><a name=\"are-onebalance-accounts-custodial-27\" class=\"anchor\" href=\"https://ethresear.ch#are-onebalance-accounts-custodial-27\"></a>Are OneBalance accounts custodial?</h3>\n<p>No.</p>\n<p>All OneBalance accounts are issued withdrawal receipts which allow them to permissionlessly exit their assets back to the settlement chain where the assets originate.</p>\n<p>This means at any point, a user is able to “rage quit” and recover their assets on the source chain.</p>\n<p>This mechanism is implemented differently depending on the accounting engine used, but essentially boils down to the same outcome: users can withdraw their funds by submitting withdrawal receipts to their proxy accounts on origination chains.</p>\n<p>I firmly believe freedom of exit is an essential characteristic of non-oppressive human coordination system design. I have never and will never design a system without freedom of exit.</p>\n<h3><a name=\"are-onebalance-accounts-really-compatible-with-any-chain-28\" class=\"anchor\" href=\"https://ethresear.ch#are-onebalance-accounts-really-compatible-with-any-chain-28\"></a>Are OneBalance accounts really compatible with any chain?</h3>\n<p>Kinda.</p>\n<p>All chains are supported, but the capabilities differ based on the VM used and the fulfillment speed differs based on the consensus. More details on this in the future.</p>\n<h3><a name=\"are-onebalance-accounts-vulnerable-to-vampire-attacks-29\" class=\"anchor\" href=\"https://ethresear.ch#are-onebalance-accounts-vulnerable-to-vampire-attacks-29\"></a>Are OneBalance accounts vulnerable to vampire attacks?</h3>\n<p>Yes. This is a good thing.</p>\n<p>If someone can build a system which delivers higher combined utility (functionality + economic incentive) to users than OneBalance accounts, users should be able to exit. This is necessary to avoid anti-competitive monopolies that censor innovation.</p>\n<p>To whoever wants to try, I say bring it on.</p>\n<h3><a name=\"is-this-a-keystore-rolluphttpshackmdioilikesymmetryintro-keystore-rollup-30\" class=\"anchor\" href=\"https://ethresear.ch#is-this-a-keystore-rolluphttpshackmdioilikesymmetryintro-keystore-rollup-30\"></a>Is this a <a href=\"https://hackmd.io/@ilikesymmetry/intro-keystore-rollup\" rel=\"noopener nofollow ugc\">Keystore Rollup</a>?</h3>\n<p>No.</p>\n<p>As they are defined today, a keystore rollup solves the problem of having a central source of truth for account permissions, across all chains. It doesn’t offer cross-chain guarantees to solvers. A OneBalance account does not need a keystore rollup since on chain keys don’t change.</p>\n<p>If a Keystore Rollup was to attempt to issue locks, they could only be communicated at L1 finality speed.</p>\n<h3><a name=\"what-is-the-trust-model-31\" class=\"anchor\" href=\"https://ethresear.ch#what-is-the-trust-model-31\"></a><strong>What is the trust model?</strong></h3>\n<p>Instead of requiring mutual trust between users and solvers, the OneBalance model requires each party to trust the credible commitment mechanism used to issue and enforce resource locks.</p>\n<h3><a name=\"does-onebalance-remove-the-need-for-bridges-32\" class=\"anchor\" href=\"https://ethresear.ch#does-onebalance-remove-the-need-for-bridges-32\"></a>Does OneBalance remove the need for bridges?</h3>\n<p>No.</p>\n<p>Bridges are necessary mechanisms to provide fulfillment of locks and settlement of inventory outside of the critical path of user request execution.</p>\n<h3><a name=\"what-is-the-relationship-between-frontier-research-onebalance-and-the-cake-working-group-33\" class=\"anchor\" href=\"https://ethresear.ch#what-is-the-relationship-between-frontier-research-onebalance-and-the-cake-working-group-33\"></a>What is the relationship between Frontier Research, OneBalance, and the CAKE Working Group?</h3>\n<p><a href=\"https://frontier.tech\" rel=\"noopener nofollow ugc\">Frontier Research</a> is and remains an independent research and advisory group formed to bridge the gap between fundamental research and commercial products.</p>\n<p>Frontier founded the <a href=\"https://frontier.tech/cake-working-group\" rel=\"noopener nofollow ugc\">CAKE Working Group</a> along with other collaborators such as Anoma, Across, and Ethereum Foundation members to foster conversation around common interfaces and language to accelerate the development of chain abstraction technology.</p>\n<p>Frontier is spinning out OneBalance as an independent project to accelerate the transition of an account centric worldview for web3.</p>\n<p>All three groups of humans will continue to follow their individual missions moving forward.</p>\n<h3><a name=\"what-are-the-latency-and-consistency-guarantees-of-this-account-model-34\" class=\"anchor\" href=\"https://ethresear.ch#what-are-the-latency-and-consistency-guarantees-of-this-account-model-34\"></a>What are the latency and consistency guarantees of this account model?</h3>\n<p>wip</p>\n<h3><a name=\"how-do-you-prevent-sequencer-dos-35\" class=\"anchor\" href=\"https://ethresear.ch#how-do-you-prevent-sequencer-dos-35\"></a>How do you prevent sequencer DOS?</h3>\n<p>wip</p>\n<h3><a name=\"how-does-a-onebalance-account-recover-from-a-fault-in-an-underlying-chain-36\" class=\"anchor\" href=\"https://ethresear.ch#how-does-a-onebalance-account-recover-from-a-fault-in-an-underlying-chain-36\"></a>How does a OneBalance account recover from a fault in an underlying chain?</h3>\n<p>wip</p>\n<h3><a name=\"how-quickly-can-lock-resolution-take-place-37\" class=\"anchor\" href=\"https://ethresear.ch#how-quickly-can-lock-resolution-take-place-37\"></a>How quickly can lock resolution take place?</h3>\n<p>wip</p>\n<h3><a name=\"is-this-a-new-kind-of-blockchain-38\" class=\"anchor\" href=\"https://ethresear.ch#is-this-a-new-kind-of-blockchain-38\"></a>Is this a new kind of blockchain?</h3>\n<p>wip</p>\n<h3><a name=\"what-are-the-benefits-and-drawbacks-of-using-a-onebalance-account-vs-a-smart-contract-account-39\" class=\"anchor\" href=\"https://ethresear.ch#what-are-the-benefits-and-drawbacks-of-using-a-onebalance-account-vs-a-smart-contract-account-39\"></a>What are the benefits and drawbacks of using a OneBalance account vs a Smart Contract Account?</h3>\n<p>wip</p>\n<h3><a name=\"can-you-build-complex-applications-like-a-dex-on-top-of-resource-locks-40\" class=\"anchor\" href=\"https://ethresear.ch#can-you-build-complex-applications-like-a-dex-on-top-of-resource-locks-40\"></a>Can you build complex applications like a dex on top of resource locks?</h3>\n<p>wip</p>\n            <p><small>19 posts - 12 participants</small></p>\n            <p><a href=\"https://ethresear.ch/t/introducing-onebalance/19557\">Read full topic</a></p>","link":"https://ethresear.ch/t/introducing-onebalance/19557","pubDate":"Wed, 15 May 2024 01:33:45 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-19557"},"source":{"@url":"https://ethresear.ch/t/introducing-onebalance/19557.rss","#text":"Introducing OneBalance"},"filter":false},{"title":"Optimizing ZK-Rollup Scalability, Security, and Censorship Resistance with Epidemic MPC, Efficient Data Structures, and Advanced Cryptographic Techniques","dc:creator":"cryptskii","category":"ZK Rollup","description":"<p>We propose an optimized ZK-rollup architecture that integrates epidemic multi-party computation (MPC), sparse Merkle tries, triadic ternary tries, erasure coding, and fully homomorphic encryption (FHE) to achieve high scalability, security, privacy, and censorship resistance. The system leverages the scalability benefits of epidemic MPC, where the per-node computation complexity decreases as <span class=\"math\">O(1/N)</span> with the number of nodes <span class=\"math\">N</span>. Erasure coding enhances fault tolerance and data availability, while FHE ensures privacy during computation. Sparse Merkle tries provide compact data representation and proof efficiency, and triadic ternary tries enable fast data retrieval. Preliminary evaluations demonstrate significant improvements in throughput, latency, and proof size compared to state-of-the-art ZK-rollup implementations.</p>\n<ol>\n<li>\n<p>Introduction<br>\nExisting ZK-rollup implementations face challenges in terms of scalability, privacy, and censorship resistance due to centralized computation, monolithic state representations, and reliance on a single sequencer or small validator set. This paper proposes an optimized ZK-rollup architecture that integrates advanced cryptographic techniques and efficient data structures to address these challenges and achieve high scalability, security, privacy, and censorship resistance.</p>\n</li>\n<li>\n<p>Background<br>\nZK-rollups are a layer-2 scaling solution for public blockchains that enables off-chain transaction processing while maintaining the security and decentralization of the underlying blockchain. However, current ZK-rollup implementations suffer from scalability bottlenecks, privacy risks, and censorship vulnerabilities. Efficient data structures and proof schemes, along with advanced cryptographic techniques, are crucial for optimizing ZK-rollup performance.</p>\n</li>\n<li>\n<p>Proposed Architecture<br>\nOur proposed ZK-rollup architecture combines the following key components:</p>\n</li>\n</ol>\n<ul>\n<li>Epidemic MPC for scalable computation across subgroups</li>\n<li>Sparse Merkle tries for compact state commitments and proofs</li>\n<li>Triadic ternary tries for efficient transaction and account data retrieval</li>\n<li>Erasure coding for fault tolerance and data availability</li>\n<li>Fully homomorphic encryption for privacy-preserving computation</li>\n</ul>\n<p>3.1 Epidemic MPC<br>\nThe epidemic MPC paradigm partitions nodes into subgroups that independently process disjoint transaction batches, reducing per-node complexity while maintaining fault tolerance. The average per-node computation complexity is <span class=\"math\">O(C/N * (k/N)^2)</span>, where <span class=\"math\">C</span> is the total MPC task complexity and <span class=\"math\">k</span> is the number of subgroups. While this complexity has a quadratic dependence on <span class=\"math\">k</span> and <span class=\"math\">N</span>, careful optimization of subgroup sizing and load balancing can help mitigate scalability limitations.</p>\n<p>3.2 Efficient Data Structures<br>\nSparse Merkle tries provide compact state representations and efficient proof generation, with a space complexity of <span class=\"math\">O(n * k)</span> for storing <span class=\"math\">n</span> key-value pairs with maximum key length <span class=\"math\">k</span>. Triadic ternary tries enable fast transaction and account data retrieval within each subgroup, accelerating proof generation and overall system performance.</p>\n<p>3.3 Advanced Cryptographic Techniques<br>\nErasure coding enhances fault tolerance and data availability by allowing the system to recover from node failures and distribute the workload. Fully homomorphic encryption enables computations on encrypted data, preserving privacy during the MPC process. The proposed hybrid approach combines erasure coding and FHE to achieve a balanced solution for scalability, fault tolerance, and privacy, with strong guarantees provided by the hybrid MPC-zkRollup protocol.</p>\n<ol start=\"4\">\n<li>Formalization and Analysis<br>\nWe formalize the key concepts and provide detailed algorithms and proofs for the proposed architecture:</li>\n</ol>\n<p>4.1 Epidemic MPC Network<br>\nAn epidemic MPC network is defined as a tuple <span class=\"math\">(N, S, T)</span>, where <span class=\"math\">N</span> is the set of nodes, <span class=\"math\">S</span> is a partition of <span class=\"math\">N</span> into <span class=\"math\">k</span> subgroups, and <span class=\"math\">T</span> is the set of MPC tasks. The average per-node computation complexity is <span class=\"math\">O(C/N * (k/N)^2)</span>, demonstrating the potential for significant scalability improvements as the number of nodes and subgroups increases.</p>\n<p>4.2 Sparse Merkle Trie/Verkle<br>\nA sparse Merkle trie storing a set of <span class=\"math\">n</span> key-value pairs with maximum key length <span class=\"math\">k</span> occupies <span class=\"math\">O(n * k)</span> space, highlighting the potential for storage efficiency.</p>\n<p>4.3 Triadic Ternary Trie<br>\nA triadic ternary trie storing a set of <span class=\"math\">n</span> key-value pairs with maximum key length <span class=\"math\">k</span> trits occupies <span class=\"math\">O(n * k)</span> space, indicating the potential for efficient data storage and retrieval.</p>\n<p>4.4 Fault Tolerance and Privacy Analysis<br>\nThe hybrid MPC-zkRollup protocol with an <span class=\"math\">(n, k)</span>-erasure code and a secure FHE scheme achieves fault tolerance against up to <span class=\"math\">n - k</span> node failures and preserves the privacy of the input data against semi-honest adversaries controlling up to <span class=\"math\">N - 1</span> MPC nodes.</p>\n<ol start=\"5\">\n<li>\n<p>Advantages and Trade-offs<br>\nThe proposed architecture offers high scalability, enhanced privacy, and censorship resistance due to the distributed nature of epidemic MPC and the infeasibility of controlling a majority in each subgroup. Compact proofs enable succinct on-chain verification, reducing the burden on the underlying blockchain. However, there may be trade-offs in terms of increased complexity and potential latency due to the coordination and communication overhead among subgroups.</p>\n</li>\n<li>\n<p>Future Directions and Open Questions<br>\nRealizing the full potential of this approach requires further research on formal security proofs, optimized smart contract implementations, parameter tuning, and the integration of advanced cryptographic primitives like KZG-based polynomial commitments for greater expressiveness and cross-rollup interoperability.</p>\n</li>\n<li>\n<p>Conclusion<br>\nThe proposed ZK-rollup architecture, which integrates epidemic MPC, sparse Merkle tries, triadic ternary tries, erasure coding, and fully homomorphic encryption, presents a promising avenue for building highly performant, secure, and censorship-resistant ZK-rollup systems. By carefully balancing the trade-offs between scalability, privacy, and efficiency, this approach paves the way for large-scale adoption of layer-2 solutions on public blockchains. Further optimizations and research can help address the scalability limitations imposed by the quadratic complexity term and unlock the full potential of this approach for large-scale, secure, and privacy-preserving blockchain applications.</p>\n</li>\n</ol>\n            <p><small>2 posts - 1 participant</small></p>\n            <p><a href=\"https://ethresear.ch/t/optimizing-zk-rollup-scalability-security-and-censorship-resistance-with-epidemic-mpc-efficient-data-structures-and-advanced-cryptographic-techniques/19556\">Read full topic</a></p>","link":"https://ethresear.ch/t/optimizing-zk-rollup-scalability-security-and-censorship-resistance-with-epidemic-mpc-efficient-data-structures-and-advanced-cryptographic-techniques/19556","pubDate":"Tue, 14 May 2024 17:25:37 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-19556"},"source":{"@url":"https://ethresear.ch/t/optimizing-zk-rollup-scalability-security-and-censorship-resistance-with-epidemic-mpc-efficient-data-structures-and-advanced-cryptographic-techniques/19556.rss","#text":"Optimizing ZK-Rollup Scalability, Security, and Censorship Resistance with Epidemic MPC, Efficient Data Structures, and Advanced Cryptographic Techniques"},"filter":false},{"title":"User-Defined Penalties: Ensuring Honest Preconf Behavior","dc:creator":"jonahb27","category":"Economics","description":"<p><em>Thank you <a href=\"https://twitter.com/drakefjustin\">Justin Drake</a> and <a href=\"https://twitter.com/sproule_\">Ryan Sproule</a> for the help.</em></p>\n<p><strong>tl;dr:</strong> <em>Allow users to specify their preferred penalty when requesting a preconf, enabling the market to naturally establish preconf cryptoeconomic security parameters, rather than setting parameters upfront.</em></p>\n<p>As the community settles on a design for preconfs, a critical choice arises: how can we ensure crypto-economic security for preconfs? Specifically, what incentives exist to prevent safety or liveness faults? I’ll present a high-level overview of the current solutions before proposing an alternative.</p>\n<p>Here are the current mechanisms (they can be used in combination):</p>\n<ol>\n<li><strong>Basic Slashing:</strong> If a proposer is responsible for a safety or liveness fault, they are slashed.\n<ul>\n<li><strong>Open Question:</strong> How much should be slashed, and what amount of stake should the proposer put up?</li>\n</ul>\n</li>\n<li><strong>Freezing:</strong> The proposer’s stake is frozen, causing them to lose the time value of their money.\n<ul>\n<li><em><a href=\"https://twitter.com/drakefjustin\">Justin Drake</a> suggested during the <a href=\"https://github.com/ethereum/pm/issues/1035\">Ethereum sequencing call #7</a> that this approach could help ease the adoption of the preconf protocol since preconfs introduce new behaviors the market needs to adjust to.</em></li>\n<li><strong>Open Question:</strong> How much stake should be frozen, and for how long?</li>\n</ul>\n</li>\n<li><strong>Dynamic Reputation Slashing:</strong> Each fault by a validator results in a progressively stricter penalty; for instance, they might be slashed more or locked up longer.\n<ul>\n<li><strong>Open Question:</strong> What should the penalty curve look like? Should it be time-based and reset after a period of honest behavior?</li>\n</ul>\n</li>\n<li><strong>Insurance:</strong> Proposers must compensate users whose preconfs fail due to faults. Effectively, users’ preconfs are insured.\n<ul>\n<li><strong>Open Question:</strong> How much insurance should be offered?</li>\n</ul>\n</li>\n</ol>\n<p>All these mechanisms require us to know ex ante what preconf users want. Inevitably, this will be opinionated and lead to deadweight loss, as some users who might want a preconf could feel uncomfortable with the setup. Moreover, some proposers might feel uncomfortable with the parameterization and choose not to offer preconfs. The best solution is to allow users to work with proposers to agree on the appropriate level of crypto-economic security.</p>\n<p>My Solution: <strong>User-Defined Penalties</strong></p>\n<p>Users should be able to specify their desired level of crypto-economic security by attaching a penalty structure to their preconf. This structure will detail the consequences of a fault.</p>\n<p>For instance:</p>\n<pre><code class=\"lang-rust\">// Here, users can define a penalty associated with any specific fault,\n// and the system is generic enough to allow for arbitrarily complex rules.\nstruct PreconfAgreement&lt;C: Condition, P: Penalize&gt; {\n    faults: Vec&lt;Fault&lt;C, P&gt;&gt;,\n}\n\nstruct Fault&lt;C: Condition, P: Penalize&gt; {\n    condition: C,\n    penalties: Vec&lt;P&gt;,\n}\n\ntrait Condition {\n    fn should_penalize(...) -&gt; bool;\n}\n\ntrait Penalize {\n    fn penalize(...);\n}\n</code></pre>\n<p><em>Note: There is a DoS vector associated with unbounded compute when evaluating conditions. Some gas metering should be used, or conditions should be constructed as succinct statements (e.g., a SNARK).</em></p>\n<p>This solution is unbiased and allows the market to determine the appropriate parameters naturally. Users can decide the level of security they want rather than leaving it up to the protocol to estimate, while proposers can choose their risk-reward profile. Heavier penalties will likely result in higher costs for users.</p>\n<p><strong>Complexity Concerns:</strong></p>\n<ul>\n<li><strong>Proposers’ Perspective:</strong> With preconfs, we already assume that proposers (or their gateways) are sophisticated, and giving them the ability to manage their own risk profiles should benefit them. Inexperienced proposers can set a simple threshold for the maximum penalty they are willing to incur and, as they gain experience, adjust it more systematically.</li>\n<li><strong>Users’ Perspective:</strong> This approach shouldn’t add complexity, as wallets can easily abstract the penalty decision, much like they abstract gas fee choices. Fine-grained choices can be offered as an opt-in feature for more advanced users.</li>\n</ul>\n            <p><small>5 posts - 4 participants</small></p>\n            <p><a href=\"https://ethresear.ch/t/user-defined-penalties-ensuring-honest-preconf-behavior/19545\">Read full topic</a></p>","link":"https://ethresear.ch/t/user-defined-penalties-ensuring-honest-preconf-behavior/19545","pubDate":"Mon, 13 May 2024 16:14:42 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-19545"},"source":{"@url":"https://ethresear.ch/t/user-defined-penalties-ensuring-honest-preconf-behavior/19545.rss","#text":"User-Defined Penalties: Ensuring Honest Preconf Behavior"},"filter":false},{"title":"Embedded fee markets and ERC-4337 (part 1)","dc:creator":"DavideRezzoli","category":"Economics","description":"<p>by: Davide Rezzoli (<a class=\"mention\" href=\"https://ethresear.ch/u/daviderezzoli\">@DavideRezzoli</a>) and Barnabé Monnot (<a class=\"mention\" href=\"https://ethresear.ch/u/barnabe\">@barnabe</a>)</p>\n<p>Many thanks to Yoav Weiss (<a class=\"mention\" href=\"https://ethresear.ch/u/yoavw\">@yoavw</a>) for introducing us to the problem, Dror Tirosh (<a class=\"mention\" href=\"https://ethresear.ch/u/drortirosh\">@drortirosh</a>) for helpful comments on the draft, and the 4337 team for support. Reviews ≠ endorsements, all errors are the authors’ own.</p>\n<p>This work was done for <a href=\"https://efdn.notion.site/ROP-7-Economic-models-of-signature-aggregation-in-account-abstraction-ec5390efab864ed49a8535e8bdfff182\" rel=\"noopener nofollow ugc\">ROP-7</a></p>\n<hr>\n<p>Transaction fee mechanisms have become the workhorse models to understand the intermediation of block producers between users wishing to transact and “the chain” (or “the protocol”) which users transact on. Given the ability to use some of the supply provided by the chain, the block producers must arbitrate which users will have ability to use the scarce resource of on-chain execution, and at what cost. On Ethereum, for the question of cost, block producers are constrained by the EIP-1559 fee mechanism, which dynamically sets a reserve price block-to-block, called “base fee”. The base fee is a price, expressed per units of gas, which a user transaction must pay to be included and executed. The user may provide so-called “priority fees” beyond the base fee, to further incentivise the block producers in times of congestion.</p>\n<p>In this note, we investigate the question of <em>embedded fee markets</em>, i.e., fee markets which “live” within other fee markets. This question was discussed in a different context in a recent paper by Maryam Bahrani, Pranav Garimidi and Tim Roughgarden, “<a href=\"https://eprint.iacr.org/2024/331\" rel=\"noopener nofollow ugc\">Transaction Fee Mechanism Design in a Post-MEV World</a>”. In this paper, the authors model the use of searchers, further intermediating access to the chain between users and block producers. Block producers receive “hints” from searchers, embodied by atomic bundles of transactions to be included by the chain. The fee market of searchers is driven by the maximisation objective of a quantity known as MEV, or maximal extractable value.</p>\n<p>In our setting, users wish to access the chain but do not express their demand using protocol-legible transactions. Instead, users produce “operations”, to be bundled by entities known as “bundlers”, who then originate a protocol-legible transaction packing the operations together towards execution. Thus, to the EIP-1559 fee mechanism, bundlers are the users of the chain, yet the actual users must first obtain inclusion in the bundle of a bundler before they may gain inclusion to the chain. In other words, we may see this setting as part of the larger question of <a href=\"https://ethresear.ch/t/uncrowdable-inclusion-lists-the-tension-between-chain-neutrality-preconfirmations-and-proposer-commitments/19372#comparison-between-inclusion-lists-pepc-and-multiple-concurrent-block-producers-3\">block co-creation</a>, which arises with (partial) builders/searchers as well as inclusion lists.</p>\n<p>Our hope is for these dynamics to be as transparent as possible, such that there is not either more cognitive overhead or opportunities for the user to be unduly exploited by the bundler, compared to going on-chain directly. We hope for even stronger results, cases where indeed the users benefit from the bundler intermediation, when amortised costs allow users to enjoy greater welfare.</p>\n<p>To investigate the distinction between direct fee markets and their embedded (sub-)mechanisms, we must precise the economic constraints which a bundler abides by. In the following section, we offer a simple model of the bundler cost function motivated by the practice, in particular bundlers participating in the ERC-4337 protocol, which we briefly recapitulate.</p>\n<h2><a name=\"model-1\" class=\"anchor\" href=\"https://ethresear.ch#model-1\"></a>Model</h2>\n<h3><a name=\"bundling-in-erc-4337-2\" class=\"anchor\" href=\"https://ethresear.ch#bundling-in-erc-4337-2\"></a>Bundling in ERC-4337</h3>\n<p>A user wishing to perform some activity on-chain via bundlers issues a User Operation (UserOp, or operation). This UserOp is emitted from the user’s wallet, e.g., after interacting with a DApp. Once the UserOp is broadcast, some bundler receiving the operation may decide to include it in a bundle. A bundle is an “externally-owned account” (EOA) meta-transaction, which writes the data of the included UserOps in its <code>bundle.calldata</code> field. The bundler issues the bundle towards inclusion in a block by a block producer (we discuss the relation between bundler and block producer in a future note).</p>\n<p>Once the bundle is included in the block, and the block makes its way to the chain, the bundle is executed along with other transactions in the block. Essentially, the bundle execution steps are as follows:</p>\n<ul>\n<li><strong>Pre-verification:</strong> A bundler’s EOA transaction will consume 21,000 gas, and the call to the EntryPoint contract will set up key variables to keep track of the execution of the operations in the operation loop.</li>\n<li><strong><a href=\"https://eips.ethereum.org/EIPS/eip-4337#required-entry-point-contract-functionality\" rel=\"noopener nofollow ugc\">Operation loop</a>:</strong> For each operation included in the bundle, the following two steps take place:\n<ul>\n<li><strong>Verification step:</strong> UserOps perform operations containing a verification step, which is encoded in a “smart contract wallet” deployed initially by the user (during an initial UserOp). The verification step may simply check a signature, or perform more complex operations to “grant” the right for the UserOp to proceed with its execution. The verification step is metered by <code>op.verificationGasLimit</code>.</li>\n<li><strong>Execution step:</strong> The core of the UserOp, the execution step performs the operation described in <code>op.callData</code>. This step is also metered, using <code>op.callGasLimit</code>.</li>\n</ul>\n</li>\n</ul>\n<p>As is made clear by the previous decomposition, the pre-verification step is executed once, offering the possibility to amortise the pre-verification costs across all included users. When the bundle is executed, all costs (e.g., <code>block.basefee</code> + priority fees paid by the bundler to the block producer including them) are charged to the bundler, who must ensure that user operations compensate her enough for the costs incurred. We make these statements precise in the following section.</p>\n<h3><a name=\"fee-market-model-for-bundles-3\" class=\"anchor\" href=\"https://ethresear.ch#fee-market-model-for-bundles-3\"></a>Fee market model for bundles</h3>\n<p>We attempt to remain consistent with classic fee markets models. A user <span class=\"math\">t</span> who wishes to emit an operation has some value <span class=\"math\">v_t</span> for the execution of the operation. We assume all operations to have the same size <span class=\"math\">S</span> (i.e., same gas used for the verification and execution steps), and we thus express all quantities as prices per unit of gas.</p>\n<p>Users express their wish to be included by emitting a bid <span class=\"math\">b_t</span> along with their operation. For now, we do not assume a specific grammar for the user to express their bid for inclusion, e.g., the ability to express a max fee and priority fee along with their operation, as they would with EIP-1559. User operations are collected in a mempool <span class=\"math\">\\mathbf{M}</span>, representing the pending status of these operations until inclusion.</p>\n<p>The EIP-1559 fee market exposes a reserve price <span class=\"math\">r</span> known as “base fee”, which bundlers must incur when their bundle is executed. If the bundle contains <span class=\"math\">n</span> operations, the bundler must then expense at least <span class=\"math\">n \\times S \\times r</span>. Additionally, since the bundle consumes “pre-verification gas”, say, some quantity <span class=\"math\">F</span>, the bundler will additionally pay <span class=\"math\">F \\times r</span>. The operations included in the bundle are given by the set <span class=\"math\">\\mathbf{B}</span>.</p>\n<h3><a name=\"bundler-cost-functions-4\" class=\"anchor\" href=\"https://ethresear.ch#bundler-cost-functions-4\"></a>Bundler cost functions</h3>\n<p>We now consider the costs incurred by bundlers for the inclusion of their bundles in the block.</p>\n<p><strong>On-chain cost function:</strong> A bundler issuing bundle <span class=\"math\">\\mathbf{B}</span> when the base fee is <span class=\"math\">r</span> expends a cost:</p>\n<div class=\"math\">\nC_\\text{on-chain}(\\mathbf{B}, r) = F \\times r + n \\times S \\times r\n</div>\n<p>The bundler problem mirrors the block producer problem expressed in <a href=\"https://arxiv.org/abs/2106.01340\" rel=\"noopener nofollow ugc\">[Roughgarden 2021]</a>. There, the block producer had to ensure the provision of some value <span class=\"math\">\\mu</span> compensating her for the cost of including an additional transaction to their block (e.g., <span class=\"math\">\\mu</span> may compensate for the extra load of the block, which delays its propagation and thus increases re-org risk). The block-level fee market must then ensure that the block producer is at least compensated for the total cost <span class=\"math\">n \\times S \\times \\mu</span>, should the block producer include <span class=\"math\">n</span> transactions in their block. The bundler-level fee market will require to at least compensate the bundler for exogenous costs <span class=\"math\">C_\\text{on-chain}(\\mathbf{B}, r)</span>  they incur from the larger fee market they are embedded in.</p>\n<p>ERC-4337 offers the possibility amortise costs beyond sharing the pre-verification gas costs. Should all operations employ the same signature scheme for their verification step, the signatures of these operations may be <em><a href=\"https://youtu.be/CgXzDuN5Xqc?si=lnpEZLKPCp6sjKAp&amp;t=2004\" rel=\"noopener nofollow ugc\">aggregated</a></em> by the bundler, such that instead of verifying on-chain <span class=\"math\">n</span> signatures, a single signature may be verified. In this case, the bundler cost function will need to account for the off-chain costs which the bundler incurs when performing the aggregation. In the following, we make the assumption that such costs are linear in the number of operations, a similar assumption to <a href=\"https://arxiv.org/abs/2404.06495\" rel=\"noopener nofollow ugc\">[Wang et al., 2024]</a>, at a marginal cost <span class=\"math\">\\omega</span>.</p>\n<p>We also account for the reduced gas consumption of each operation, due to savings from the aggregation. When aggregated, operations are not required to publish their signature, but they do require an additional pairing operation. On chains where calldata cost is expensive, but pairing operations/computation are cheap, aggregation thus provides per-operation savings. In this case, we denote by <span class=\"math\">S' &lt; S</span> the reduced size of a transaction. We also need to account for the increased pre-verification gas use <span class=\"math\">F' &gt; F</span>, which now contains the publication and verification of the single on-chain aggregated signature.</p>\n<p><strong>Aggregated cost function:</strong> A bundler issuing bundle <span class=\"math\">\\mathbf{B}</span> with aggregated signatures when the base fee is <span class=\"math\">r</span> expends a cost:</p>\n<div class=\"math\">\nC_\\text{agg}(\\mathbf{B}, r) = F' \\times r + n \\times S' \\times r + n \\times \\omega\n</div>\n<p>In this note, we will not go further, but one may also consider the data publication costs which a bundler may need to expend when their bundle settles on a rollup. We suggest two ways of modelling this and leave this question for future work:</p>\n<ul>\n<li>Either the bundler herself is responsible for data publication (e.g., as a sequencer), and thus requires to obtain from users the necessary amount of funds to pay eventual data publication costs.</li>\n<li>Or the bundle-level fee market is embedded in a larger batch-level fee market, via which the rollup exposes to rollup users (including the bundler) the amount they are required to pay due to congestion (e.g., a base fee) and eventual data publication costs. In this case, the rollup is responsible for balancing their own future costs with their present revenues.</li>\n</ul>\n<h3><a name=\"revisiting-fee-market-quantities-5\" class=\"anchor\" href=\"https://ethresear.ch#revisiting-fee-market-quantities-5\"></a>Revisiting fee market quantities</h3>\n<p>We may now formally express the relevant concepts for the bundle-level fee market, deriving them straightforwardly from previous literature, while taking the embedding into account.</p>\n<p><strong>Bundle-level allocation rule:</strong> A (bundle-level) allocation <span class=\"math\">x</span> decides the set of user operations which the bundler includes in their bundle, given the current mempool <span class=\"math\">\\mathbf{M}</span> and the base fee <span class=\"math\">r</span>.</p>\n<div class=\"math\">\nx_t(\\textbf{M}, r) \\in \\{0, 1\\}, \\forall t\n</div>\n<p><strong>Bundle-level payment rule:</strong> Given the set of selected operations <span class=\"math\">\\mathbf{B}</span>, a payment rule assigns to each included user a fee:</p>\n<div class=\"math\">\np_t(\\textbf{B})\n</div>\n<p><strong>User utility function:</strong> <span class=\"math\">u_t(b_t) = v_t - p_t(\\mathbf{B})</span></p>\n<p>In principle, we could allow for the existence of a burning rule <span class=\"math\">q_t(\\mathbf{B})</span> expressing the fact that the bundler may not receive the totality of all included user payments. We do not consider it in this note however.</p>\n<p><strong>(Myopic) bundler utility function:</strong> <span class=\"math\">u(\\mathbf{B}, r) = \\sum_{t \\in \\mathbf{B}} p_t(\\mathbf{B}) - C(\\mathbf{B}, r)</span></p>\n<p>A bundle-level TFM <span class=\"math\">(x, p)</span> is incentive-compatible for myopic bundlers (MBIC) if, for every mempool <span class=\"math\">\\textbf{M}</span> and base fee <span class=\"math\">r</span>, a myopic bundler maximises its utility by following the suggestion of the allocation rule <span class=\"math\">x</span> (i.e., setting <span class=\"math\">\\textbf{B} = x(\\textbf{M}, r)</span>).</p>\n<h3><a name=\"forming-multiple-bundles-6\" class=\"anchor\" href=\"https://ethresear.ch#forming-multiple-bundles-6\"></a>Forming multiple bundles</h3>\n<p>In the preceding section, we’ve only considered the possibility for the bundler to issue a single bundle. However, we may be interested in the possibility for the bundler to make more than one bundle out of the operations available in the mempool. Given the mempool <span class=\"math\">\\mathbf{M}</span>, let <span class=\"math\">P(\\mathbf{M})</span> represent the set of partitions of the mempool, assigning each operation to a single bundle (we may assume that for each partition, there is a set indexed 0 which contains all the operations not assigned to a bundle for inclusion). The allocation rule then returns the index of the set in the partition to which the operation is assigned.</p>\n<div class=\"math\">\nx(\\textbf{M}, r) \\in P(\\textbf{M})\n</div>\n<p>We can write the set of bundles output by the partition <span class=\"math\">x(\\textbf{M}, \\beta)</span> as <span class=\"math\">\\mathcal{B}(x(\\textbf{M}, r))</span>. Intuitively, these bundles are made up from the operations which do not belong to the set indexed 0. Given a set of bundles <span class=\"math\">\\mathcal{B}</span>, the payment rule is then:</p>\n<div class=\"math\">\np_t(\\mathcal{B})\n</div>\n<p>The user utility function becomes:</p>\n<div class=\"math\">\nu_t(b_t) = v_t - p_t(\\mathcal{B})\n</div>\n<p>and the bundler utility function becomes:</p>\n<div class=\"math\">\nu(\\mathcal{B}, r) = \\sum_{B \\in \\mathcal{B}} \\sum_{t \\in {B}} p_t(\\mathcal{B}) - C(\\mathcal{B}, r)\n</div>\n<h2><a name=\"the-bundler-game-7\" class=\"anchor\" href=\"https://ethresear.ch#the-bundler-game-7\"></a>The bundler game</h2>\n<p>Inclusion of transactions in blocks must remunerate some quantity <span class=\"math\">\\mu</span> to the block producers, which is assumed to be linear in the transaction size in e.g., <a href=\"https://arxiv.org/abs/2106.01340\" rel=\"noopener nofollow ugc\">[Roughgarden, 2021]</a>. This quantity denotes the opportunity cost for the block producer to add an extra transaction to their block, e.g., increasing their gossiping delay and thereby increasing their chances of the block getting re-orged. In Proof-of-Stake, even though the protocol’s schedule allows for enough time to propagate a full block, <a href=\"https://ethresear.ch/t/timing-games-implications-and-possible-mitigations/17612#impact-on-blob-inclusion-ht-dankrad-for-mentioning-this-10\">timing games</a> have induced “last-second” propagation dynamics which have once again made this <span class=\"math\">\\mu</span> parameter relevant.</p>\n<p>In any case, we may observe that the cost-sharing problem at block-level and at bundle-level are very different. At block-level, a transaction need not know what else is going on inside the block to devise its inclusion bid according to EIP-1559 (it may want to know what is going on with respect to MEV <a href=\"https://eprint.iacr.org/2024/331\" rel=\"noopener nofollow ugc\">[Bahrani et al., 2024]</a>, but we’ll consider this a separate issue for now). At bundle-level, bundle overhead costs are no longer linear in the number of transactions, but a fixed overhead may be amortised by many transactions. Further, should the aggregation cost of the user operations be non-linear in the number of transactions (e.g., some proofs are effectively sub-linear in the size being proven), offering the possibility to amortise the total cost over many users.</p>\n<p>This leads to the following game: The bundler wishes for users to place their bids as if they were bidding for the <em>worst case</em>, where the user is alone in the bundle and must compensate by themselves the full overhead gas <span class=\"math\">F</span>. Practically, the user would be faced with the problem of setting three relevant parameters on their operation:</p>\n<ul>\n<li><code>op.maxPriorityFeePerGas</code> and <code>op.maxFeePerGas</code> may be set according to the heuristics a user would use under EIP-1559, i.e., given some estimate amount of gas their operation plans to consume, the user would set these attributes to calibrate how much they are willing to pay in the worst case (<code>maxFee</code>) and how much they are willing to top up in order to pay the eventual block producer (<code>maxPriority</code>). But how should the user estimate the gas?</li>\n<li><code>op.preVerificationGas</code> is an attribute of the UserOperation which must be set to indicate the amount of “extra gas” the user’s operation plans to consume. In our model, we let <span class=\"math\">F</span> denote this “fixed gas overhead”. If <span class=\"math\">n</span> users were included in the bundle, each user ought to set <code>preVerificationGas = F / n</code>. However, should the user prepare their operation with a worst-case scenario in mind, they would set <code>preVerificationGas = F</code>.</li>\n</ul>\n<p><code>preVerificationGas</code> is then the principal vector via which users mediate their bid and attempt to account for the amortisation of costs by the bundler. Assume <span class=\"math\">n</span> users do come to the market with their operations, and all are convinced by the bundler to bid in the worst-case of being alone in the bundle. We’ll also assume that the users are setting their <code>maxPriorityFeePerGas</code> to zero for the sake of this example. Then these <span class=\"math\">n</span> users are all setting <code>preVerificationGas = F</code>, and the bundler is able to output a bundle remunerating them with:</p>\n<div class=\"math\">\nn \\times F \\times r\n</div>\n<p>while they must incur a cost:</p>\n<div class=\"math\">\nF \\times r\n</div>\n<p>once they publish the bundle bundling all <span class=\"math\">n</span> operations together in a block. This yields the bundler a profit <span class=\"math\">\\pi = (n-1) \\times F \\times r</span>.</p>\n<p>This situation may be represented by a two-stage game, where the users first produce their user operations, and the bundler subsequently decides to bundle them. We assume that users do not possess information about the current amount of pending users, and so are unable to estimate the bundler’s true ability to amortise their fixed costs.</p>\n<p>In the first stage, users send their operations, which commit to their attributes such as <code>preVerificationGas</code>. In the second stage, the bundler having received all user transactions decides to output a bundle or set of bundles. Interestingly, even if the users know how many other users will play in the first stage, i.e., even if <span class=\"math\">n</span> is common knowledge across all users, the bundler may be able to force the users into setting the worst-case <code>preVerificationGas = F</code> by threatening to play <span class=\"math\">\\mathcal{B}_\\text{pessimistic} = \\{ \\{ 1 \\}, \\{ 2 \\}, \\{ 3 \\}, \\dots, \\{ n \\} \\}</span>, i.e., threatening to keep every user in their own separate bundle and charging them the maximum amount gas <span class=\"math\">F</span>.</p>\n<p>Note that this threat may not be credible, as users would expect the bundler to prefer playing <span class=\"math\">\\mathcal{B}_\\text{ideal} = \\{ \\{1, 2, 3, \\dots, n \\} \\}</span>, i.e., output a single bundle with all operations included there, realising <span class=\"math\">\\pi</span>. However, users may not have access to the true value of <span class=\"math\">n</span>, and thus they are unable to set their <code>preVerificationGas</code> in a way that forces the bundler to ideally bundle all of them.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/2/a/2a1e3be0f917af5d2d8d3fa4c487a848543c76b2.png\" data-download-href=\"https://ethresear.ch/uploads/default/2a1e3be0f917af5d2d8d3fa4c487a848543c76b2\" title=\"Ideal case: costs are split between the users in the bundle. Pessimistic case: users overpay, and costs are not split.\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/2/a/2a1e3be0f917af5d2d8d3fa4c487a848543c76b2_2_484x500.png\" alt=\"Ideal case: costs are split between the users in the bundle. Pessimistic case: users overpay, and costs are not split.\" data-base62-sha1=\"60APqXwY3iqF7PWcsFuLI0CLetc\" width=\"484\" height=\"500\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/2/a/2a1e3be0f917af5d2d8d3fa4c487a848543c76b2_2_484x500.png, https://ethresear.ch/uploads/default/optimized/3X/2/a/2a1e3be0f917af5d2d8d3fa4c487a848543c76b2_2_726x750.png 1.5x, https://ethresear.ch/uploads/default/original/3X/2/a/2a1e3be0f917af5d2d8d3fa4c487a848543c76b2.png 2x\" data-dominant-color=\"F3EEF1\"></a></div><p></p>\n<p>An extension of this model may consider the Bayesian case, where the users have access to a distribution over <span class=\"math\">n</span>, i.e., they may anticipate some random variable <span class=\"math\">n</span> users to show up at any given time step, according to some distribution (e.g., Poisson arrivals), even if they do not know in advance the outcome of the random variable. This may lead to inefficient outcomes, as the following example shows:</p>\n<blockquote>\n<p>Alice expects 9 other users to show up besides herself, and so she sets her <code>preVerificationGas</code> to 1 as she knows <span class=\"math\">F = 10</span>. Alice’s value and the value of all other users is compatible with them setting <code>preVerificationGas = 3</code>, but she attempts to pay the least amount possible for her inclusion. As it turns out, only 5 users appear on the market, who have all set their <code>preVerificationGas</code> to 1 too. The bundler will not be compensated for <code>F = 10</code> units of gas, thus the bundler does not output a bundle and users receive 0 utility. This is obviously suboptimal, as the users could have all set <code>preVerificationGas = 2</code> for instance and receive 1 utility (the maximum <code>preVerificationGas</code> they were willing to set minus the actual <code>preVerificationGas</code> they paid to be included).</p>\n</blockquote>\n<h2><a name=\"future-work-8\" class=\"anchor\" href=\"https://ethresear.ch#future-work-8\"></a>Future work</h2>\n<p>As the bundler game shows, an allocation problem faces the user wishing to be included by the bundler. In the next note, we will address different approaches to recovering “good UX” for the user to prevent them from overpaying a bundler who is better informed about the demand for its bundle capacity. The next exploration will require an understanding of the market structure tying users, bundlers and builders/block producers together.</p>\n            <p><small>2 posts - 2 participants</small></p>\n            <p><a href=\"https://ethresear.ch/t/embedded-fee-markets-and-erc-4337-part-1/19542\">Read full topic</a></p>","link":"https://ethresear.ch/t/embedded-fee-markets-and-erc-4337-part-1/19542","pubDate":"Mon, 13 May 2024 09:55:52 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-19542"},"source":{"@url":"https://ethresear.ch/t/embedded-fee-markets-and-erc-4337-part-1/19542.rss","#text":"Embedded fee markets and ERC-4337 (part 1)"},"filter":false},{"title":"Sandwitch attacks on ePBS","dc:creator":"potuz","category":"Consensus","description":"<p>In this quick note we analyze the special case of ex-anti and sandwitch attacks on ePBS vs the current implementation. We show that with the proposed values for proposer and builder’s boosts as in <a href=\"https://ethresear.ch/t/payload-boosts-in-epbs/18769\" class=\"inline-onebox\">Payload boosts in ePBS</a> the situation is actually an improvement over the status quo.</p>\n<p>This short note contains the raw numbers and it’s meant to be a quick update, no fancy diagrams, for such I recommend looking at the design notes in <a href=\"https://hackmd.io/@potuz/rJ9GCnT1C\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">ePBS specification notes - HackMD</a> or even the forkchoice implementation notes in <a href=\"https://hackmd.io/@potuz/SJdXM43x0\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">ePBS Forkchoice annotated spec - HackMD</a></p>\n<h2><a name=\"ex-anti-reorgs-the-need-for-proposer-boost-1\" class=\"anchor\" href=\"https://ethresear.ch#ex-anti-reorgs-the-need-for-proposer-boost-1\"></a>Ex-anti reorgs, the need for proposer boost</h2>\n<p>The classical 1-slot ex-anti reorg goes like this. The proposer of slot <code>N</code> plans to reorg the block of <code>N+1</code>. For this they withhold their block during their time. After the proposer of <code>N+1</code> reveals his block (based on <code>N-1</code>) the attacker reveals their block <code>N</code> together with <span class=\"math\">\\beta</span> attestations for it. The attack is succesful if</p>\n<p><span class=\"math\"> \\beta &gt; PB </span>.</p>\n<p>Which in the current situation makes us resilient to these attacks up to a 40% adversary.</p>\n<h2><a name=\"ex-anti-on-epbs-2\" class=\"anchor\" href=\"https://ethresear.ch#ex-anti-on-epbs-2\"></a>Ex anti on ePBS</h2>\n<p>On ePBS the situation for an ex-anti attack changes due to the (block, slot) voting nature of fork choice. The attack goes as follows.</p>\n<ul>\n<li>Since the proposer of <code>N</code> wants to get their payload included, they can’t simply reveal their block after <code>N+1</code> does. They have to have a timely payload so that the PTC votes for it.</li>\n<li>They therefore reveal their consensus block targeting a split view of the attesters at 1/4 of a slot. <span class=\"math\">1-x</span> of the committee votes for <code>N-1</code>, as they didn’t see the block on time, and <span class=\"math\">x - \\beta</span> vote for <code>N</code> (the adversary withholds their attestations).</li>\n<li>The builder of <code>N</code> reveals on time and the PTC attests to the builder’s presence.</li>\n<li>The proposer of <code>N+1</code> will reveal a block based on <code>N-1</code> only if<br>\n<span class=\"math\"> 1 - 2x &gt; RB - \\beta</span><br>\nwhere RB is the reveal boost that the builder of <code>N</code> received.</li>\n<li>The attacker now reveals their attestations for <code>N</code>.</li>\n</ul>\n<p>The attack is successful if <span class=\"math\"> RB &gt; PB + 1 - 2x</span> But given the above inequality this implies <span class=\"math\">RB &gt; PB + RB - \\beta</span>. Therefore we obtain as in the current status quo <span class=\"math\">\\beta &gt; PB</span>.</p>\n<p>Since in ePBS the proposer boost PB is set to <span class=\"math\">20%</span>. One is inclined to think that we have ex-anti reorg protections only up to 20%, a considerable downgrade from the current implementation. But notice that <strong>the payload of N+1 is not reorged</strong>. In fact, the builder of N+1 will not reveal their block since the head is N when the attack is successful, and because of the <em>builder withholding safety</em>, their bid payment will not be necessary. In fact, in order to reorg the payload as well in ePBS, we would require a sandwich attack.</p>\n<h2><a name=\"sandwich-attacks-the-classical-case-3\" class=\"anchor\" href=\"https://ethresear.ch#sandwich-attacks-the-classical-case-3\"></a>Sandwich attacks the classical case</h2>\n<p>A sandwich attack is very similar to an ex-anti one, but now the adversary is proposing slots N and N+2 and plans to reorg the block N. Their setup is just as in the ex-anti attack: they reveal the block N late, together with <span class=\"math\">\\beta</span> attestations for it. Block <code>N+1</code> is early and receives <span class=\"math\">1 - \\beta</span> attestations (the attacker votes for <code>N</code> during N+1. The attacker then reveals N+2 based on N, obtaining proposer boost and attempting to reorg N+1. The attack is successful if<br>\n<span class=\"math\">2 \\beta + PB &gt; 1 - \\beta \\Leftrightarrow 3\\beta &gt; 1 - PB</span><br>\nFrom where with the current values we obtain protection against this attack against validators up to <span class=\"math\">\\beta = 20\\%</span>.</p>\n<h2><a name=\"sandwich-attack-in-epbs-4\" class=\"anchor\" href=\"https://ethresear.ch#sandwich-attack-in-epbs-4\"></a>Sandwich attack in ePBS</h2>\n<p>In ePBS the sandwich attack starts also as an ex-anti setup. In particular, to get the proposer of N+1 to base their block on N-1, the setup requires<br>\n<span class=\"math\"> 1 - 2x &gt; RB - \\beta</span><br>\nas above. The consensus block of N+1 receives <span class=\"math\">1 - \\beta</span> votes just as in the current implementation, and the builder of N+1 reveals timely obtaining a builder’s boost: this is the main difference, <strong>the builder’s boost makes this sandwich attack much more difficult</strong>.<br>\nThe attacker then reveals their N+2 block based on N. Obtaining proposer boost. The attacker’s branch then has weight <span class=\"math\">PB + \\beta + x</span>. While the canonical branch has weight <span class=\"math\">RB + 1 - \\beta + 1 - x</span>. The attack is successful then if<br>\n<span class=\"math\"> PB + 2\\beta &gt; RB + 1 + (1 - 2x) </span><br>\nWhich according to the inequality above implies <span class=\"math\">PB + 2 \\beta &gt; 2RB + 1 - \\beta</span>, from where<br>\n<span class=\"math\">\\beta &gt; \\frac{2RB +  1 - PB}{3}</span><br>\nWhich with the proposed values of RB = 40% and PB = 20% gives protection against this attack by an attacker up to 50%, a significant improvement over the current situation.</p>\n<p>Multiple slot post-anti reorgs become worse in ePB. To give some numbers, in the current implementation we are resistant to 60% attackers for 1 slot post-anti reorgs and 53% for 2 slots post-anti-reorgs. On ePBS these numbers become 40% and 37%.</p>\n            <p><small>3 posts - 2 participants</small></p>\n            <p><a href=\"https://ethresear.ch/t/sandwitch-attacks-on-epbs/19538\">Read full topic</a></p>","link":"https://ethresear.ch/t/sandwitch-attacks-on-epbs/19538","pubDate":"Mon, 13 May 2024 07:18:54 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-19538"},"source":{"@url":"https://ethresear.ch/t/sandwitch-attacks-on-epbs/19538.rss","#text":"Sandwitch attacks on ePBS"},"filter":false},{"title":"FullDAS: towards massive scalability with 32MB blocks and beyond","dc:creator":"cskiraly","category":"Sharding","description":"<p>Author: Csaba Kiraly, in collaboration with Leonardo Bautista-Gomez and Dmitriy Ryajov, from the <a href=\"https://codex.storage\" rel=\"noopener nofollow ugc\">Codex.storage</a> research team.</p>\n<p><em>Note: this document describes the current state of our thinking, result of a collaborative effort and numerous discussions with other teams. It would not had been possible without the contribution and ideas of <a class=\"mention\" href=\"https://ethresear.ch/u/dankrad\">@dankrad</a> , <a class=\"mention\" href=\"https://ethresear.ch/u/djrtwo\">@djrtwo</a> , <a class=\"mention\" href=\"https://ethresear.ch/u/fradamt\">@fradamt</a> , <a class=\"mention\" href=\"https://ethresear.ch/u/agemanning\">@AgeManning</a> , <a class=\"mention\" href=\"https://ethresear.ch/u/nashatyrev\">@Nashatyrev</a> , <a class=\"mention\" href=\"https://ethresear.ch/u/matt\">@matt</a> , <a class=\"mention\" href=\"https://ethresear.ch/u/pop\">@pop</a> , and <a class=\"mention\" href=\"https://ethresear.ch/u/echo\">@Echo</a> .</em></p>\n<h2><a name=\"tldr-1\" class=\"anchor\" href=\"https://ethresear.ch#tldr-1\"></a>TL;DR</h2>\n<ul>\n<li>Danksharding was planned for 32MB blocks, but our current <strong>networking stack</strong> can’t handle that, <strong>becoming the bottleneck</strong>. With HW accelerated KZG on the horizon for the block encoding, our networking stack will have to scale even more.</li>\n<li>DAS encompasses two different concepts: <strong>Data Availability</strong> achieved by dispersal to custody, and <strong>Sampling</strong> from custody. We can use this distinction to our advantage, designing an efficient dispersal, and an efficient sampling protocol.</li>\n<li><strong>liteDAS</strong> is our sampling protocol, designed to provide low-latency, bandwidth efficient, and robust sampling.</li>\n<li><strong>Dispersal</strong> can be done with protocols similar to GossipSub, but changes are required.</li>\n<li>With the combination of deterministic custody assignments and <strong>Topic Routing</strong>, we can find peers fast enough for dispersal and for sampling.</li>\n<li>To enable sampling, we should also enable <strong>Ephemeral Connect</strong>, not supported by the current stack.</li>\n<li><strong>2D encoding</strong> (or some other locally repairable code) is required for in-network-repair, the key to <strong>availability amplification</strong>.</li>\n</ul>\n<h2><a name=\"introduction-2\" class=\"anchor\" href=\"https://ethresear.ch#introduction-2\"></a>Introduction</h2>\n<p>The <a href=\"https://notes.ethereum.org/@dankrad/new_sharding\" rel=\"noopener nofollow ugc\">original Danksharding proposal</a> targeted 32 MB blocks, and this size was mainly chosen due to compute constraints for the KZG commitments used in the <a href=\"https://ethresear.ch/t/lossydas-lossy-incremental-and-diagonal-sampling-for-data-availability/18963#sampling-over-the-das-encoding-3\">DAS data structure</a>. Since then, there have been various iterations on the network design, aiming to efficiently make the block data available in a P2P structure, and to let nodes sample from this structure. However, none of these constructs convincingly support blocks of 32MB, making the performance of the networking solution the real bottleneck. In this post we look at these networking issues and propose solutions, with the aim of making 32 MB (and possibly beyond) achievable.</p>\n<h3><a name=\"das-data-availability-vs-sampling-3\" class=\"anchor\" href=\"https://ethresear.ch#das-data-availability-vs-sampling-3\"></a>DAS: Data Availability vs. Sampling</h3>\n<p>The goal of DAS (Data Availability Sampling) is to ascertain, with high probability, that a given block of data was made available to anyone interested, and to do this without requiring any single node in the system to hold - or even to temporarily receive - the whole block of data.</p>\n<p>That is, we want to keep the bandwidth requirements of individual nodes at the levels of the current (after EIP-4844) Ethereum network, while handling orders of magnitude larger blocks. From the networking perspective, this is an important constraint on the Ethereum DAS design.</p>\n<p>For our discussion on networking aspects, it is important to emphasize that there are two distinct parts to DAS: the “making data available” part, and the “sampling” part.</p>\n<h4><a name=\"making-data-available-4\" class=\"anchor\" href=\"https://ethresear.ch#making-data-available-4\"></a>Making Data Available</h4>\n<p>First, the data has to be made available. Availability means that nodes in the system get “enough” data to be able together to reconstruct the original block. Thus, availability is a <strong>system level property</strong>: data is either available to the whole system, or not available. At least, this is what we want to achieve.</p>\n<p>As in P2P systems in general, the amount of data should better not be “just enough”, but it should be <strong>overwhelmingly enough</strong>, meaning the data can be reconstructed even if there is churn, network partitioning, or a large portion of malicious nodes. Only at this point we can say that the data was made available.</p>\n<p>In other words, we should design a protocol that makes sure that there are no borderline situations: the data is either not available (wasn’t released by the source), or it is overwhelmingly available. As we will see later, it is the interplay between erasure coding and a robust and largely redundant P2P networking structure that makes this possible.</p>\n<h4><a name=\"sampling-5\" class=\"anchor\" href=\"https://ethresear.ch#sampling-5\"></a>Sampling</h4>\n<p>Second, there is sampling. Sampling is an individual node’s view of what was made available to the system. It is a single node convincing itself that the data was made available, and the technique it uses for this is to retrieve a few pieces of the block. The <strong>sample</strong> is the (typically random) selection of the pieces to retrieve, while <strong>sampling</strong> is the retrieval of these pieces. If this sampling is successful, and with a few <strong>independence assumptions</strong>, the node can convince itself that the data was indeed made available.</p>\n<p>Importantly, in the background, behind the <a href=\"https://ethresear.ch/t/lossydas-lossy-incremental-and-diagonal-sampling-for-data-availability/18963#setting-the-sample-size-7\">probabilistic calculations</a>, there are those nasty independence assumptions. Essentially it is assumed that data is (was, or will be) released independent of what sample was selected. This unfortunately can be gamed, and the more the block producer and its “accomplices” knows about the sample selection of a node, the easier it is to introduce correlation and thus fool someone. Thus, <strong>sample selection</strong> and <strong>limited disclosure of the selection</strong> is an important part of the security guarantees.</p>\n<p><em>Note that in this writeup we call the pieces of the block <strong>segments</strong>, but they also go by the name “column” when 1D encoding is used, “cell” when 2D encoding is used, or sometimes the confusing term “sample” is used both the segment as well as for the list of selected segments.</em></p>\n<p><em>Also note that sampling is not the only technique we could use to “convince ourselves” that the data was available. Without trying to list all possibilities, we could use succinct proofs, trusted friends, etc. Sampling, however, is trustless and spreads segments of data to all nodes in the system, eventually enabling an extra layer of redundancy and thus recovery.</em></p>\n<h3><a name=\"interest-custody-vs-sample-6\" class=\"anchor\" href=\"https://ethresear.ch#interest-custody-vs-sample-6\"></a>Interest: Custody vs. Sample</h3>\n<p>Both when data is made available, and when nodes are sampling, segments of the block get delivered to nodes. Which segments get to which node, however, is driven by different objectives in these two phases.</p>\n<p>We call the segments that should be delivered to a node it’s <strong>interest</strong>. We have two types of interest in the system. They are similar, but serve different purposes and have some fundamental differences:</p>\n<ul>\n<li><strong>custody</strong>: segments getting to nodes as part of making the data available are taken into custody and used to serve sampling. That is, custody has a double goal: providing availability and at the same time serving as a sampling infrastructure.</li>\n<li><strong>sample</strong>: sampling is for the individual node to convince itself about availability with very high probability by checking that enough segments are in custody.</li>\n</ul>\n<p>Interest can <strong>change over time</strong>, for example from epoch to epoch for the sample selection, or with some other time granularity for custody. Changing it or keeping it fixed has both security and network efficiency implications.</p>\n<h3><a name=\"das-phases-dispersal-vs-sampling-7\" class=\"anchor\" href=\"https://ethresear.ch#das-phases-dispersal-vs-sampling-7\"></a>DAS Phases: Dispersal vs. Sampling</h3>\n<p>The fundamental differences between the requirements of data availability and sampling, and between the properties of custody and sample, are also reflected in the network design. We can differentiate between two phases of segment distribution:</p>\n<ul>\n<li><strong>dispersal</strong>: in which segments of the block are distributed in the P2P network to provide overwhelming availability and custody.</li>\n<li><strong>sampling</strong>: in which nodes collect a random sample of segments from custody.</li>\n</ul>\n<p>The two phases can use different P2P network constructs. In what follows we focus on these network constructs, deriving fast, robust, and bandwidth efficient protocols both for dispersal and for sampling.</p>\n<h2><a name=\"fulldas-networking-8\" class=\"anchor\" href=\"https://ethresear.ch#fulldas-networking-8\"></a>FullDAS networking</h2>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/9/3/93a404791201f9e15e8d268a971c5fd54d120d7c.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/93a404791201f9e15e8d268a971c5fd54d120d7c\" title=\"FullDAS - LossyDAS - liteDAS - Data Availability Sampling Components\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/9/3/93a404791201f9e15e8d268a971c5fd54d120d7c_2_666x500.jpeg\" alt=\"FullDAS - LossyDAS - liteDAS - Data Availability Sampling Components\" data-base62-sha1=\"l45APdFj7UJvsf2ot9sCYQImCKM\" width=\"666\" height=\"500\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/9/3/93a404791201f9e15e8d268a971c5fd54d120d7c_2_666x500.jpeg, https://ethresear.ch/uploads/default/original/3X/9/3/93a404791201f9e15e8d268a971c5fd54d120d7c.jpeg 1.5x, https://ethresear.ch/uploads/default/original/3X/9/3/93a404791201f9e15e8d268a971c5fd54d120d7c.jpeg 2x\" data-dominant-color=\"E4E2E4\"></a></div><p></p>\n<p>In the original design, GossipSub was planned to be used for dispersal, with many (512 for columns and 512 for rows) topics, distributing columns and rows into custody at all the staked nodes (beacon nodes with validators). For sampling, instead, a separate DHT was planned to be set up from all full nodes (staked and non-staked), serving all the sampling queries. This presented several challenges, as we have <a href=\"https://ethresear.ch/t/scalability-limitations-of-kademlia-dhts-when-enabling-data-availability-sampling-in-ethereum/18732\">highlighted in our related post and paper</a>.</p>\n<p>As a consequence, in <strong>PeerDAS</strong> and in <strong>SubnetDAS</strong> we have tweaked the design to provide intermediate solutions, with compromises both in functionality and in scalability.</p>\n<p>In <a href=\"https://ethresear.ch/t/peerdas-a-simpler-das-approach-using-battle-tested-p2p-components/16541\">PeerDAS</a>, we have modified custody assignment and dispersal to be based on the NodeID, making all full nodes (both staked and non-staked) be part of the custody system. Sampling is then made from this P2P structure using a Request/Response (Req/Resp) protocol from existing peers of a node, adding more pressure on peer discovery (Discv5), and the number of peers that nodes have to sustain.</p>\n<p><a href=\"https://ethresear.ch/t/subnetdas-an-intermediate-das-approach/17169\">SubnetDAS</a>, instead, modifies the design to use the GossipSub distribution mechanism all the way, both for dispersal and for sampling. This, again, limits our possibilities, also sacrificing the unlinkability of sampling queries.</p>\n<p>A fast and bandwidth-efficient implementation of these proves to be challenging even for blocks of a few MBs, and this is where we arrive to our main topic: <strong>how to make DAS work for blocks of 32 MB and beyond?</strong></p>\n<p>In what follows, we introduce the important parts of the stack:</p>\n<ol>\n<li>liteDAS: fast and efficient sampling from custody</li>\n<li>Finding custody peers fast:\n<ul>\n<li>Custody allocation and sample selection</li>\n<li>Topic Routing</li>\n<li>Ephemeral Connect</li>\n</ul>\n</li>\n<li>Making dispersal more efficient</li>\n<li>Availability amplification with 2D encoding</li>\n</ol>\n<h3><a name=\"litedas-the-sampling-protocol-9\" class=\"anchor\" href=\"https://ethresear.ch#litedas-the-sampling-protocol-9\"></a>liteDAS: The Sampling Protocol</h3>\n<p>Sampling, at an abstract level, sounds very simple:</p>\n<ul>\n<li>take a random sample of block segment IDs</li>\n<li>ask for these from nodes custodying it</li>\n<li>wait for all the responses</li>\n<li>declare success if received all, otherwise declare failure</li>\n</ul>\n<p>In reality, however, things get much more complicated. We have dealt with some of the complication related to sample selection in <a href=\"https://ethresear.ch/t/lossydas-lossy-incremental-and-diagonal-sampling-for-data-availability/18963\">our post on LossyDAS, IncrementalDAS, and DiDAS</a>, but we have left out all the networking aspects from that post.</p>\n<p>To design a sampling protocol, besides the draft outline above, we should also answer questions like:</p>\n<ul>\n<li>when should a node start sampling?</li>\n<li>when should sampling end, what should be the timeout?</li>\n<li>if we know several nodes custodying the same segment, which one to ask?</li>\n<li>what to do if we do not know a node that is supposed to custody a segment?</li>\n<li>what to do when sampling fails?</li>\n<li>etc.</li>\n</ul>\n<p>Moreover, we should design a protocol that is fast, robust, and bandwidth efficient.</p>\n<p>For sampling, we propose <strong>liteDAS</strong>, a new Req/Resp protocol that aims to provide close to minimum sampling latency with close to minimal bandwidth usage, avoiding excessive resource utilization both on the happy path and when there are issues. The key observations behind liteDAS are:</p>\n<ul>\n<li>There is no “perfect time” to ask for a segment, since we don’t know when dispersal will make these arrive to custody. It is better to ask early and wait.</li>\n<li>Sampling nodes have some time (the dispersal time) to prepare for sampling. We can use this time to make sampling efficient.</li>\n<li>We can hide our sample better if we ask for segments one-by-one, asking each from distinct nodes.</li>\n<li>Having a fast and efficient way of finding custody nodes for a given segment is essential.</li>\n</ul>\n<p>The <strong>messaging primitive</strong> we propose is a <strong>request with an explicit timeout</strong>. This simple primitive allows us to start sampling early (at slot start), and build a nice dynamic behavior with an initial period to handle the happy path, and a second period to handle potential issues, as outlined below:</p>\n<ul>\n<li>At <span class=\"math\">T_0</span> (slot start, or when public parameters are known)\n<ul>\n<li>decide sample (list of segment IDs) using local randomness\n<ul>\n<li>eventually consider using <a href=\"https://ethresear.ch/t/lossydas-lossy-incremental-and-diagonal-sampling-for-data-availability/18963#didas-steering-away-from-uniform-random-sampling-11\">DiDAS</a> and/or <a href=\"https://ethresear.ch/t/lossydas-lossy-incremental-and-diagonal-sampling-for-data-availability/18963#lossydas-accept-partial-sampling-9\">LossyDAS</a></li>\n</ul>\n</li>\n<li>For each ID:\n<ul>\n<li>select list of candidate peers who might custody given ID</li>\n<li>select <span class=\"math\">P=1</span> of these candidate nodes (eventually ranking), and send request with long timeout (e.g. 4s). <span class=\"math\">P</span> is the “parallelism” parameter.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>at <span class=\"math\">T_1=4s</span>\n<ul>\n<li>for every ID still missing\n<ul>\n<li>select next candidate node and send request with short timeout</li>\n<li>use timeouts and the number of outstanding queries to avoid traffic explosion</li>\n<li>eventually search for new candidates (this can also be done proactive, before <span class=\"math\">T_1</span>)</li>\n</ul>\n</li>\n<li>Optionally, extend sample according to <a href=\"https://ethresear.ch/t/lossydas-lossy-incremental-and-diagonal-sampling-for-data-availability/18963#incrementaldas-dynamically-increase-the-sample-size-10\">IncrementalDAS</a> with some period</li>\n</ul>\n</li>\n</ul>\n<p>Intuitively, this is fast (reducing sampling latency close to minimum), bandwidth efficient (sending only one Req/Resp per segment on the happy path), and robust (explores sampling options once custody should be there).</p>\n<h4><a name=\"fast-10\" class=\"anchor\" href=\"https://ethresear.ch#fast-10\"></a>Fast</h4>\n<p>Sending the sampling query at the start of the slot allows us to minimize the sampling delay to a single 1-hop latency on top of the dispersal delay (the delay with which the node we queried received the segment or column).</p>\n<p>In more detail, to understand why this is fast, let’s see what would be the fastest. The minimum sampling latency would be what one could achieve if the node asks, right when it knows what samples it needs, all its peers that could have the sample, i.e. all peers that plan to custody that segment. That would however mean that our node receives lots of responses, adding considerable extra load. In liteDAS we only ask <span class=\"math\">P</span> of them at a time, as a compromise between bandwidth efficiency and latency. <a href=\"https://ethresear.ch/t/big-block-diffusion-and-organic-big-blocks-on-ethereum/17346\">Our data on GossipSub latency distribution</a> and our initial simulations show that the latency compromise is very limited on the happy path.</p>\n<h4><a name=\"bandwidth-efficient-11\" class=\"anchor\" href=\"https://ethresear.ch#bandwidth-efficient-11\"></a>Bandwidth efficient</h4>\n<p>The protocol receives every sample (or column) exactly once on the happy path. On the unhappy path, we can set a compromise between following a sequential logic with short timeouts, or allowing some parallelism (and thus duplicates) by changing <span class=\"math\">P</span> in later phases. Importantly, if the data is actually not available, it will still keep resource utilization in limits.</p>\n<h4><a name=\"robust-12\" class=\"anchor\" href=\"https://ethresear.ch#robust-12\"></a>Robust</h4>\n<p>In the first phase, the robustness of the above sampling relies on the robustness of dispersal. Dispersal already employs a number of reliability techniques, thus, when on the happy path, it is very likely that for every ID, the single node we select will receive the sample.<br>\nIf instead there are issues with dispersal, our sampling also becomes less latency sensitive: sampling should anyway not succeed until availability through custody is widespread. Thus, we have time to “hunt” for segments. After the initial phase, our protocol will cycle through potential other peers taking in custody the same segment. At that point, we can also send more queries in parallel, eventually allowing some duplicates.</p>\n<h4><a name=\"possible-extensions-13\" class=\"anchor\" href=\"https://ethresear.ch#possible-extensions-13\"></a>Possible Extensions</h4>\n<p>Beyond the basic idea, there are a few other tweaks that can improve dynamic behaviour:</p>\n<ol>\n<li>Nodes can anticipate the hunt for peers that could provide a given segment. These are the peers that will eventually custody that segment.</li>\n<li>Since sample selection is done using local randomness, nodes could even prepare the sample (list of IDs) well in advance, anticipating the search for candidate peers with slots or even epochs.</li>\n<li>To avoid traffic explosion, we recommend controlling the number of outstanding queries, together with timeouts. This practically means that we can avoid traffic explosion even in cases of an unavailable block or when there are large-scale network issues.</li>\n<li>As mentioned before, asking one node at a time works, but this can be increased to e.g asking 2 or 3 in parallel. These are compromises that can even be made locally, we can’t really mandate them anyway. (Actually we could, using Rate Limiting Nullifier-like techniques, but that’s out of scope here and seems too complex for the scope).</li>\n<li>We could also include a HAVE list in the query response message. The reason behind this is that it gives extra information on the state of diffusion that we would not have otherwise. Given the 1D or 2D structure, a have list can be compressed very well to a small bitmap, so it is not much extra bytes. Eventually, to stay generic on the message primitive, we can make it a flag in the request whether we want a HAVE list in the response.</li>\n<li>Finally, it is worth mentioning that sampling nodes could use the information collected during protocol execution to feed back segments into custody. One way to make this happen is to introduce a Resp with a NACK (negative acknowledgment) style message when the timeout has passed and the segment is not in custody. This “counter-request” would mean that the sampling node should send the segment when it receives it from someone.</li>\n</ol>\n<h3><a name=\"finding-custody-peers-fast-14\" class=\"anchor\" href=\"https://ethresear.ch#finding-custody-peers-fast-14\"></a>Finding Custody Peers Fast</h3>\n<p>liteDAS still assumes we have the peers to send requests to. What if we don’t have these, and we have to search for peers taking in custody a given ID? What if we also have to go through a convoluted connection procedure before requesting the segment?</p>\n<p>As highlighted before, we can anticipate the search for custody peers. Still, there are times when we need to search for peers with a specific ID in custody, and that should be relatively fast. This is a crucial point currently being debated in discussions around DAS. As part of the sampling process, we need to find and connect to peers in a few seconds, which seems to be one of the main limiting factors. There is a similar problem for dispersal as well when building the mesh for efficient column(/row) based distribution, although in that case timing is less critical.</p>\n<p>The problem with the current protocol stack was summarized well by AgeManning as <a href=\"https://github.com/ethereum/consensus-specs/pull/3623#issuecomment-2046558155\" rel=\"noopener nofollow ugc\">part of the PeerDAS spec discussions</a>. Getting individual segments from new peers is awfully inefficient with the current stack. Clearly, the problem has two mayor underlying aspects:</p>\n<ul>\n<li><strong>Finding nodes is inefficient</strong>: currently this would be done using Discv5. Since Discv5 has no topic search, it is a random walk on the DHT, enumerating peers in hope of finding a good one. We propose to make this faster by deterministic custody assignment and by what we call “topic routing”.</li>\n<li><strong>Connecting to nodes is inefficient</strong>: we intend to solve this by introducing “ephemeral connect”.</li>\n</ul>\n<h4><a name=\"deterministic-nodeid-based-custody-assignment-15\" class=\"anchor\" href=\"https://ethresear.ch#deterministic-nodeid-based-custody-assignment-15\"></a>Deterministic NodeID-based Custody Assignment</h4>\n<p>First, lets see what we can do to find custody nodes for a given segment fast. The key to this is to assign custody wisely.</p>\n<p>Since we need system-wide availability, custody has to be assigned properly, providing good coverage. A randomized local selection would provide this, but fortunately we can do better. A nice property of custody is that we <strong>do not need to hide who takes custody of what</strong>. We can use this property to make our system more efficient by <strong>deriving custody interest from the NodeID</strong> (eventually with some rotation scheme and using public randomness) in a deterministic way. It seems that publicly exposing the interest of nodes for the purposes of custody does not influence security. It also seems that we can expose interest publicly well ahead of time (keeping custody stable in time, similar to what we do with attestations today), and it still does not create security issues.</p>\n<p><em>Note that there is a catch here: by using the NodeID, we are not binding custody to validators, as in the original proposal, but to full nodes (including non-staked nodes). Thus, we cannot really mandate custody. We currently do not want to mandate it anyway, but later we might introduce <a href=\"https://dankradfeist.de/ethereum/2021/09/30/proofs-of-custody.html\" rel=\"noopener nofollow ugc\">Proof Of Custody</a>, and then we have to revisit this point. It is also relatively easy to create a large amount of new NodeIDs, potentially exposing custody to targeted sybil attacks.</em></p>\n<p>By deriving custody from NodeID, we can speed up search in two ways. First, we can derive custody from the leftmost bits of the nodeID. This allows us to use the Discv5 Kademlia search instead of a random walk, since Kademlia is prefix-based. Second, if a custody rotation scheme is used (nodes changed what columns/rows they custody with some period), we can calculate this from the NodeID, without contacting the peers or getting updated ENR records from Discv5.</p>\n<p>We already use this NodeID-based deterministic custody assignment trick in PeerDAS: it allows us to make the dispersal more efficient, and it also allows sampling peers to find custody nodes easier, just based on the NodeID and a small amount of metadata published together with the NodeID in the ENR.</p>\n<p><em>Note that the same is not true for the sample, where we do care about making it relatively hard to figure out what will be sampled by a given node, as otherwise we would make it easy to attack individual nodes. Hence, we cannot derive the sample (list of segment IDs) from the NodeID, and we also better avoid sending the whole sample (again, the list of IDs, not the data) to a single node. We thus prefer nodes to request samples on-the-fly, preferably exposing interest selectively to a diverse set of peers, limiting the exposure of the individual node.</em></p>\n<h4><a name=\"topic-routing-efficiently-finding-nodes-for-a-given-column-or-row-16\" class=\"anchor\" href=\"https://ethresear.ch#topic-routing-efficiently-finding-nodes-for-a-given-column-or-row-16\"></a>Topic Routing: efficiently finding nodes for a given column or row</h4>\n<p>Another option we have at hand is to introduce custody node search into our protocol directly, circumventing the difficulties with Discv5.</p>\n<p>In current proposals, columns are distributed using GossipSub, with different column IDs mapping to different GossipSub topics. The column ID space is seen as a flat list, without considering any relation between topics.</p>\n<p>However, <strong>we do not have to handle the row and column ID space as a flat ID space</strong>. We can use almost any distance metric, and require nodes to keep a few neighbors with column/row ID close to them, enabling faster search. Some examples to explain how this might work:</p>\n<ul>\n<li>Circlular: if a node participates in column C, it has to keep at least N neighbors from the range <code>[C-D, C+D] mod NUM_COLS</code>, for some selected <code>D</code> and <code>N</code></li>\n<li>Hypercube style:  if a node participates in column C, it has to keep at least N neighbors from columns <code>C+2^j mod NUM_COLS</code>, for <code>j in [0..log2(NUM_COLS}-1]</code></li>\n<li>Kademlia style:  if a node participates in column C, it has to keep at least N neighbors from the set of columns we get by keeping the j MSB (most significant) bits fixed, and flipping bit j+1</li>\n</ul>\n<p>The first one (circular) is not really scalable, the last two have good scalability. However, if we keep the number of columns(and rows) sufficiently low, any of these will work good enough to find potential neighbors for any C. If we want to scale higher, we might want to pick the best one for our use.</p>\n<p>Note that the topic ID space is dense, with each ID representing a topic, and the number of nodes we have is expected to be higher than the number of topics. In a typical DHT, instead, keys and node IDs are sparse in the ID space. Having a dense ID space allows us to simplify search.</p>\n<p>It is relatively easy to extend any of the above techniques to handle both rows and columns, either by handling the column and row ID spaces as two separate ID spaces, or by defining a joint distance function.</p>\n<p>Also note that when sampling in 2D, we look for either a node in column C, or a node in row R. Any of these will suffice, making our search faster.</p>\n<h4><a name=\"ephemeral-connect-fast-connect-for-sample-retrieval-17\" class=\"anchor\" href=\"https://ethresear.ch#ephemeral-connect-fast-connect-for-sample-retrieval-17\"></a>Ephemeral Connect: fast connect for sample retrieval</h4>\n<p>Connection issues are mainly due to a protocol limitation, since we are operating over libP2P, which was not originally designed for fast connectivity. We make our life even harder by keeping a hard limit on connected peers, and by keeping that full in many nodes (it is known that some peers do not accept connections, and as a consequence others are overloaded, having their peer count full, and thus also not accepting new connections).</p>\n<p>We list a few possible solutions to this problem below:</p>\n<ul>\n<li>libP2P-ephemeralConnect: we could add a new flag to the connect request indicating a connection that is timing out fast. This can be allowed-in on the receiving side above peer count limits.</li>\n<li>Use a new primitive outside of the libp2p framework: If we want a secure encrypted protocol, but something more efficient than a libP2P modification, we can e.g. easily reuse our Discv5 DHT primitives here, making a Discv5 request in a handshake. That employs only 2 roundtrips, and a few bytes of data. Of course, this is just an example of what could be achieved. Other custom protocols with similar latency/bandwidth characteristics can be derived as well.</li>\n<li>Query forwarding: If we really do not want to add another primitive, we can introduce query forwarding. A node can take one of it’s peers according to Topic Routing, and send to it a forwardable query. We’ll get the sample in 2 hops.</li>\n</ul>\n<p>In our opinion these can solve the connectivity issues, getting us to FullDAS. However, more testing is needed.</p>\n<h3><a name=\"the-dispersal-protocol-18\" class=\"anchor\" href=\"https://ethresear.ch#the-dispersal-protocol-18\"></a>The Dispersal Protocol</h3>\n<p>Initially, we intend to use GossipSub for dispersal for several reasons. It is a publish-subscribe protocol which maps well to the erasure coding structure, creating separate topics per column (if using 1D erasure coding), or for columns and rows (if using 2D erasure coding). It is also battle-tested, already used in Ethereum for block diffusion and attestation aggregation, showing fast and reliable operation, as discussed in <a href=\"https://ethresear.ch/t/big-block-diffusion-and-organic-big-blocks-on-ethereum/17346\">our related post measuring latency distributions for block diffusion and for attestations</a>.</p>\n<p>In PeerDAS, we are in fact mapping the dispersal problem to a relatively small number of GossipSub topics. While this is a reasonable first approach, there are aspects that are specific to the dispersal problem and allow for performance optimisations.</p>\n<h4><a name=\"making-dispersal-even-more-efficient-19\" class=\"anchor\" href=\"https://ethresear.ch#making-dispersal-even-more-efficient-19\"></a>Making dispersal even more efficient</h4>\n<p>We have studied how fast blocks can be dispersed into custody using <a href=\"https://github.com/codex-storage/das-research\" rel=\"noopener nofollow ugc\">our custom DAS simulator</a>, both for the 1D and for the 2D erasure coded case. If column and row topics are correctly populated, GossipSub can disperse the block data in seconds to thousands of nodes, as shown in <a href=\"https://www.youtube.com/watch?v=M-xkP4FzYMQ\" rel=\"noopener nofollow ugc\">our presentations at EthereumZurich’23</a>, and in later presentations (<a href=\"https://www.youtube.com/watch?v=N1e_LDrKxZg\" rel=\"noopener nofollow ugc\">EDCON’23</a>, <a href=\"https://www.youtube.com/watch?v=Al7Jns8bCO4\" rel=\"noopener nofollow ugc\">EthPrague’23</a>, <a href=\"https://www.youtube.com/watch?v=pUAVEbzLHLk\" rel=\"noopener nofollow ugc\">EthCC’23</a>). However, in these talks we are speaking of GossipSub-like pub-sub protocols for a reason. GossipSub, as is, is not the best option we have. We argue that we can make a few changes to make it work well for our case. Eventually, we might also derive a custom protocol specifically targeting the dispersal use case.</p>\n<p>In what follows, we list a few of the possible differences between a generic use of GossipSub topics and dispersal, showing some of the optimizations that can be made. We will dedicate a separate post to extend these in detail.</p>\n<h5><a name=\"compared-to-generic-gossipsub-topics-das-topics-are-extremely-structured-20\" class=\"anchor\" href=\"https://ethresear.ch#compared-to-generic-gossipsub-topics-das-topics-are-extremely-structured-20\"></a>Compared to generic GossipSub topics, DAS “topics” are extremely structured</h5>\n<ul>\n<li>With the 512 row and 512 column structure, we can map any ID into 1+9 bits (1 bit for direction, 9 bits for position) or a 9+9 bits ID space.</li>\n<li>We can then use compact representations in message IDs, in HAVE lists, and in many other data structures.</li>\n<li>Given the compact representation, we can also piggyback diffusion state information easily on other messages.</li>\n</ul>\n<h5><a name=\"with-many-topics-finding-peers-can-become-hard-21\" class=\"anchor\" href=\"https://ethresear.ch#with-many-topics-finding-peers-can-become-hard-21\"></a>With many topics, finding peers can become hard</h5>\n<ul>\n<li>We address this partly by deterministic NodeID-based custody assignment,</li>\n<li>Partly by “topic routing” based on a topic ID proximity metric.</li>\n</ul>\n<h5><a name=\"das-segments-of-a-single-block-are-unordered-which-we-can-use-to-our-benefit-22\" class=\"anchor\" href=\"https://ethresear.ch#das-segments-of-a-single-block-are-unordered-which-we-can-use-to-our-benefit-22\"></a>DAS segments of a single block are unordered, which we can use to our benefit</h5>\n<ul>\n<li>We can speed up delivery by “rarest first” like techniques. Rarest-fist scheduling is used in P2P dissemination to cut the tail of the latency distribution, equalizing the diffusion of different pieces. Rarest-first requires precise “have” information, which is typically not available, but it can be approximated. For example, a technique we have already implemented in our simulators is to make sure a copy of every single segment is sent out by the block producer before sending the second copy to another neighbor. We start by sending only one copy of each segment, to one of the block producer’s column/row neighbors (randomized), seeding segments in random places in the network. Only then we send second copies to other peers. Later, one can use information collected through e.g. IHAVE bitmaps to estimate which segments are diffusing well, and which seem to be hindered, prioritizing further seeding based on this information.</li>\n<li>We might also speed up delivery by “node coloring” techniques: these techniques are about specializing nodes to prioritize the distribution of a specific subset of the ID space they custody.</li>\n</ul>\n<h5><a name=\"with-tcp-we-pay-the-cost-of-in-order-reliable-delivery-23\" class=\"anchor\" href=\"https://ethresear.ch#with-tcp-we-pay-the-cost-of-in-order-reliable-delivery-23\"></a>With TCP we pay the cost of in-order reliable delivery</h5>\n<ul>\n<li>GossipSub defaults to using in-order reliable delivery over the topic mesh, which has an inherent cost.</li>\n<li>DAS does not need ordering between segments (to the contrary, shuffling is beneficial).</li>\n<li>DAS does not need P2P link-level reliability (because of all the other reliability techniques we have: multi-path, EC, pull, cross-feeding between columns and rows).</li>\n<li>Thus, using e.g. randomized best-effort delivery can provide overall better performance.</li>\n</ul>\n<h5><a name=\"duplicate-reduction-techniques-24\" class=\"anchor\" href=\"https://ethresear.ch#duplicate-reduction-techniques-24\"></a>Duplicate reduction techniques</h5>\n<ul>\n<li>With GossipSub we pay a relatively high bandwidth cost of duplicate deliveries. Basically, every single message traverses every topic mesh link at least once. Sometimes even twice, when sent from both sides close in time (less than the one-way latency). This means that on average, every message is sent at least D/2 times, where D is the target mesh degree.</li>\n<li>These duplicates serve multiple purposes: contribute to robustness, to low latency, and to protecting sender identity. However, in DAS, we do not need to protect sender identity. Because of the traffic volume, we can’t protect it. This, and the fact that we are distributing over several topics in parallel, allow for optimizations.\n<ul>\n<li>One option is to use the IDONTWANT proposal</li>\n<li>We might also use techniques based on diffusion state, such as Push-Pull phase transition: in the first steps of the diffusion of a segment, there are almost no duplicates. Most of the duplicate load is happening in the last steps of the diffusion. One can emphasize Push at the beginning (even with an increased degree, sending to more nodes than without this technique), and change to gossip-and-pull towards the end of diffusion if the diffusion state can be estimated.</li>\n</ul>\n</li>\n</ul>\n<h3><a name=\"the-need-for-2d-encoding-availability-amplification-through-in-network-repair-25\" class=\"anchor\" href=\"https://ethresear.ch#the-need-for-2d-encoding-availability-amplification-through-in-network-repair-25\"></a>The Need for 2D Encoding: availability amplification through in-network repair</h3>\n<p>Erasure Coding is mostly presented in DAS descriptions as a tool to make sampling more robust. However, we should highlight that we can use Erasure Coding in the design for two purposes:</p>\n<ol>\n<li>to amplify sampling, and</li>\n<li>to amplify availability.</li>\n</ol>\n<p><strong>Amplifying sampling</strong> is well understood: using a code with rate R=K/N (e.g. 1/2), and assuming the data is not available, every single sampled segment reduces the chance of not finding out about the data not being available by a factor of 2. We like this exponential property, letting us reach a very low False Positive (FP) rate with only a few segments sampled. In the 2D case, the ratio is not as good as in 1D, but we still have a nice exponential property.</p>\n<p><strong>Amplifying availability</strong> is a different thing. It means that if data is available, we make it overwhelmingly available. We achieve this by using <strong>in-network repair</strong> during dispersal. This is where our erasure coding structure and dispersal network structure meet. By organising nodes according to the code, in columns and rows, and by making nodes participate in both rows and columns, we enable local repair in the EC structure during dispersal.</p>\n<p>This in-network repair is then amplifying availability, as we have shown in simulations already in our <a href=\"https://youtu.be/M-xkP4FzYMQ?t=1183\" rel=\"noopener nofollow ugc\">EthereumZuri.ch’23 talk</a>. Basically, if not enough samples are released, segment count stays below 75%, while row/coumn-based sampling (SubnetSampling), used by validators, and also by full nodes in many of our constructs, remains very low. Segment sampling also remains very low.</p>\n<p>If instead one more segment is released, the result is amplified by the dispersal structure to almost 100%.</p>\n<p>For this amplification mechanism to work, however, we need the 2D code. We cannot really do it in the 1D case, because in the 1D case, repair could only be done in nodes having K pieces, basically the whole block. In the 2D case, instead, we can repair in any single row or column, so individual nodes can repair and then send. In other words, we need a code with local repair. We can make such a code with 2D RS (there are also other code constructs with local repair capabilities, if we want).</p>\n<p>Thus, while we could map segment IDs to custody in many ways, we do it by columns and rows to enable in-network repair and availability amplification during dispersal.</p>\n<h2><a name=\"conclusions-26\" class=\"anchor\" href=\"https://ethresear.ch#conclusions-26\"></a>Conclusions</h2>\n<p>Our aim with this post was to outline the main building blocks of FullDAS, the networking stack we propose for DAS with blocks of 32MB and beyond. We have discussed new ways to disperse the block data into a P2P structure of custody, while also amplifying data availability. We have also shown the tools needed to implement fast, bandwidth-efficient, and robust sampling from this structure, using liteDAS, Topic Routing, and improved connection mechanisms.</p>\n<p>At this point it might be evident to many that we are building something similar to a DHT, a point raised a few times in the past: the difference between dispersal to custody and sampling, and the generic concept of a DHT is not that big. With FullDAS we are in fact building a special purpose distributed storage structure, with custom seeding, repair, and retrieval, each optimized for the DAS encoding and for the DAS purpose.</p>\n<p>Some of the above techniques have already been evaluated in simulation, while others are work in progress. We have written two simulators for this purpose:</p>\n<ul>\n<li><a href=\"https://github.com/codex-storage/das-research\" rel=\"noopener nofollow ugc\">one with a high-level of abstraction</a>, written in Python, for large scale experiments. Here protocol behaviour is approximated, but a larger parameter space can be explored.</li>\n<li><a href=\"https://github.com/cskiraly/das-simulator-nim\" rel=\"noopener nofollow ugc\">one with a lower level abstraction</a>, using directly the nim-libP2P stack. We already used this simulator to simulate diffusion with a modified GossipSub implementation with 128 columns and 128 rows, and to run sampling from this structure to 1000s of nodes.</li>\n</ul>\n<p>Both of these are work in progress, and we plan to release further posts as the refinement of FullDAS protocols and the evaluation goes on.</p>\n<h2><a name=\"references-27\" class=\"anchor\" href=\"https://ethresear.ch#references-27\"></a>References</h2>\n<p><a href=\"https://notes.ethereum.org/@dankrad/new_sharding\" rel=\"noopener nofollow ugc\">The original Danksharding proposal</a></p>\n<p><a href=\"https://ethresear.ch/t/lossydas-lossy-incremental-and-diagonal-sampling-for-data-availability/18963#sampling-over-the-das-encoding-3\">The DAS data structure</a></p>\n<p><a href=\"https://ethresear.ch/t/lossydas-lossy-incremental-and-diagonal-sampling-for-data-availability/18963\">Our previous post on sampling techniques: LossyDAS, IncrementalDAS, and DiDAS</a></p>\n<p><a href=\"https://ethresear.ch/t/scalability-limitations-of-kademlia-dhts-when-enabling-data-availability-sampling-in-ethereum/18732\">Scalability limitations of using Kademlia DHTs for DAS</a></p>\n<p><a href=\"https://ethresear.ch/t/peerdas-a-simpler-das-approach-using-battle-tested-p2p-components/16541\">The PeerDAS proposal</a></p>\n<p><a href=\"https://ethresear.ch/t/subnetdas-an-intermediate-das-approach/17169\">The SubnetDAS proposal</a></p>\n<p><a href=\"https://ethresear.ch/t/big-block-diffusion-and-organic-big-blocks-on-ethereum/17346\">Our post on measuring GossipSub latency distribution, both when used for blocks and when used for attestations</a></p>\n<p><a href=\"https://github.com/ethereum/consensus-specs/pull/3623#issuecomment-2046558155\" rel=\"noopener nofollow ugc\">Part of PeerDAS specification discussions about peer search and connectivity issues</a></p>\n<p><a href=\"https://dankradfeist.de/ethereum/2021/09/30/proofs-of-custody.html\" rel=\"noopener nofollow ugc\">Proof Of Custody</a></p>\n<p>Our previous presentations on DAS:</p>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=M-xkP4FzYMQ\" rel=\"noopener nofollow ugc\">EthereumZurich’23</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=N1e_LDrKxZg\" rel=\"noopener nofollow ugc\">EDCON’23</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=Al7Jns8bCO4\" rel=\"noopener nofollow ugc\">EthPrague’23</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=pUAVEbzLHLk\" rel=\"noopener nofollow ugc\">EthCC’23</a>)</li>\n</ul>\n<p>Our DAS simulators:</p>\n<ul>\n<li><a href=\"https://github.com/codex-storage/das-research\" rel=\"noopener nofollow ugc\">DAS simulator with a high-level of abstraction</a>, written in Python, for large scale experiments</li>\n<li><a href=\"https://github.com/cskiraly/das-simulator-nim\" rel=\"noopener nofollow ugc\">DAS simulator with a lower level abstraction</a>, using directly the nim-libP2P stack over Shadow</li>\n</ul>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://ethresear.ch/t/fulldas-towards-massive-scalability-with-32mb-blocks-and-beyond/19529\">Read full topic</a></p>","link":"https://ethresear.ch/t/fulldas-towards-massive-scalability-with-32mb-blocks-and-beyond/19529","pubDate":"Sat, 11 May 2024 15:29:25 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-19529"},"source":{"@url":"https://ethresear.ch/t/fulldas-towards-massive-scalability-with-32mb-blocks-and-beyond/19529.rss","#text":"FullDAS: towards massive scalability with 32MB blocks and beyond"},"filter":false},{"title":"MACI with mostly-off-chain \"happy path\"","dc:creator":"vbuterin","category":"Cryptography","description":"<p><em>For background, see: <a href=\"https://ethresear.ch/t/minimal-anti-collusion-infrastructure/5413\" class=\"inline-onebox\">Minimal anti-collusion infrastructure</a></em></p>\n<p>One of the challenges of MACI is that it requires data to be submitted on-chain for each vote, which incurs significant transaction fees. This post suggests a mechanism by which votes can be off-chain by default; a vote would only need to go on-chain if the coordinator is actively attempting to censor voters.</p>\n<p>When a user makes a vote, take the following steps:</p>\n<ol>\n<li>The user locally generates their vote, as in regular MACI</li>\n<li>The user sends their vote to the coordinator</li>\n<li>The coordinator replies with a signature, specifying which position of the next batch the user’s vote will be included at</li>\n<li>When the coordinator submits their next batch, they submit only a hash to the chain. The hash must be the Merkle root of all votes that have been sent to the coordinator since the previous round. The coordinator is also required to publish the full set of votes (eg. on IPFS).</li>\n</ol>\n<p>The ZK-SNARK enforces that the final vote results are the result of processing all submitted votes, including votes that have been published via this hash mechanism.</p>\n<p>Users have access to two extra features:</p>\n<ol>\n<li>They have the ability to submit a vote directly to chain. The coordinator is forced to process both types of votes (included via hash, and included directly)</li>\n<li>If a user has a cryptographically signed promise, they can publish that promise on chain as a challenge. Any future message that the coordinator submits (a batch or the final result) must come with a SNARK proving that the correct votes have been included at the provided challenge positions.</li>\n</ol>\n<p>This ensures the following properties:</p>\n<ul>\n<li>Assuming an honest coordinator, onchain costs go down to O(1) per batch period</li>\n<li>Censorship resistance is maintained, because users can go onchain worst-case</li>\n<li>We mitigate attacks where the coordinator pretends to accept a vote, but then fails to include it, hoping that most voters will not notice or re-open any kind of software daemon, by providing signatures:\n<ul>\n<li>If a user fails to get a signature immediately, they go straight to voting onchain.</li>\n<li>If a user gets a signature, and they do come back to check after the batch, they can check on IPFS (or ask the coordinator) for the Merkle branch associated with their vote; if it does not match their signature, they can publish their signature to chain, which effectively halts the entire vote and prevents it from giving a result. Hence, trying to censor even one voter becomes extremely risky for a coordinator.</li>\n</ul>\n</li>\n</ul>\n            <p><small>9 posts - 5 participants</small></p>\n            <p><a href=\"https://ethresear.ch/t/maci-with-mostly-off-chain-happy-path/19527\">Read full topic</a></p>","link":"https://ethresear.ch/t/maci-with-mostly-off-chain-happy-path/19527","pubDate":"Sat, 11 May 2024 10:47:47 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-19527"},"source":{"@url":"https://ethresear.ch/t/maci-with-mostly-off-chain-happy-path/19527.rss","#text":"MACI with mostly-off-chain \"happy path\""},"filter":false},{"title":"Based proposer commitments - Ethereum’s marketplace for proposer commitments","dc:creator":"DrewVanderWerff","category":"Block proposer","description":"<p><em>As always, humbled by the Ethereum community’s willingness to review / provide feedback. Thank you <a href=\"https://twitter.com/barnabemonnot\" rel=\"noopener nofollow ugc\">Barnabe</a>, <a href=\"https://twitter.com/cshg0x\" rel=\"noopener nofollow ugc\">Chris</a>, <a href=\"https://twitter.com/ConorMcMenamin9\" rel=\"noopener nofollow ugc\">Conor</a>, <a href=\"https://twitter.com/ellierdavidson\" rel=\"noopener nofollow ugc\">Ellie</a>, <a href=\"https://twitter.com/jasnoodle\" rel=\"noopener nofollow ugc\">Jason</a>, <a href=\"https://twitter.com/mempirate\" rel=\"noopener nofollow ugc\">Jonas</a>, <a href=\"https://twitter.com/drakefjustin\" rel=\"noopener nofollow ugc\">Justin</a>, <a href=\"https://twitter.com/_julianma\" rel=\"noopener nofollow ugc\">Julian</a>, <a href=\"https://twitter.com/kubimensah\" rel=\"noopener nofollow ugc\">Kubi</a>, <a href=\"https://twitter.com/0xkydo\" rel=\"noopener nofollow ugc\">Kydo</a>, <a href=\"https://twitter.com/mikeneuder\" rel=\"noopener nofollow ugc\">Mike</a>, <a href=\"https://twitter.com/pascalstichler\" rel=\"noopener nofollow ugc\">Pascal</a>, and <a href=\"https://twitter.com/sjerniganIV\" rel=\"noopener nofollow ugc\">Sam</a> for the feedback and review.</em></p>\n<p><strong>Introduction:</strong></p>\n<p>Over the last year, proposer commitments have become more widely discussed. I personally became proposer-commitment-pilled on the back of the <a href=\"https://ethresear.ch/t/based-rollups-superpowers-from-l1-sequencing/15016\">based sequencing</a> / <a href=\"https://ethresear.ch/t/based-preconfirmations/17353\">preconf</a> posts and <a href=\"https://docs.google.com/document/d/1FG3nKQdUNb_YHCp_IzSDkC_r7A6HOT11O2YNUjCX-6s/edit#heading=h.2whbk0my4lq5\" rel=\"noopener nofollow ugc\">weekly calls</a> being held by Justin as well as discussions and <a href=\"https://frontier.tech/ethereums-blockspace-future\" rel=\"noopener nofollow ugc\">research</a> about blockspace futures. With this interest came the dive down the rabbit hole and as always within the Ethereum community, I found many others already there or willing to join. This post I hope contributes to the ideas already out there and continues to push the discussion around proposer commitments and engagement across the community.</p>\n<p>Below we introduce a concept focused on standardizing the last mile of communication between a proposer and a third party and how proposers may register and make / receive commitments. We see proposer commitments as another promising evolution of Ethereum’s original core vision that will expand the infinite garden to not just be THE marketplace for credible blockspace, but also THE marketplace for credible proposer commitments. We outline some background and motivation, design principles, an initial high-level design, and some open questions. We plan to continue to expand on this with more detailed specs as we gather more feedback and input!</p>\n<p><strong></strong></p><div class=\"lightbox-wrapper\"><strong><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/f/9/f9246140c4556cd087cf9de5c5a0f5e363ada4b4.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/f9246140c4556cd087cf9de5c5a0f5e363ada4b4\" title=\"\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/f/9/f9246140c4556cd087cf9de5c5a0f5e363ada4b4_2_475x316.jpeg\" alt=\"\" data-base62-sha1=\"zy0PGLz0KLAEgJlSwhqSwUcfetK\" width=\"475\" height=\"316\" role=\"presentation\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/f/9/f9246140c4556cd087cf9de5c5a0f5e363ada4b4_2_475x316.jpeg, https://ethresear.ch/uploads/default/optimized/3X/f/9/f9246140c4556cd087cf9de5c5a0f5e363ada4b4_2_712x474.jpeg 1.5x, https://ethresear.ch/uploads/default/original/3X/f/9/f9246140c4556cd087cf9de5c5a0f5e363ada4b4.jpeg 2x\" data-dominant-color=\"AF938A\"></a></strong></div><p></p>\n<p><strong>TL;DR:</strong></p>\n<ul>\n<li>Proposer commitments have been an important part of Ethereum’s history and could continue to be a powerful unlock for Ethereum</li>\n<li>The potential impact of proposer commitments are best captured in a quote from Barnabe’s <a href=\"https://mirror.xyz/barnabe.eth/QJ6W0mmyOwjec-2zuH6lZb0iEI2aYFB9gE-LHWIMzjQ\" rel=\"noopener nofollow ugc\">recent post</a>; the “…proposer creates the specs, or the template, by which the resulting block must be created, and the builders engaged by the proposer are tasked with delivering the block according to its specifications”</li>\n<li>Over the last year, there have been multiple ideas around proposer commitments. For instance, even in a short period, we have seen multiple implementations of proposer commitments related to preconfs</li>\n<li>While powerful, if multiple standards arise around how proposers register and make / receive commitments, we run the risk of fragmentation that could increase risks to Ethereum</li>\n<li>We present a potential design referred to as “Commitment Boost”[1] inspired by research around PEPC, EigenLayer, and the broader Ethereum community</li>\n<li>This envisions leveraging existing pipes to allow proposers to register and make / receive commitments and remain fully backward compatible</li>\n<li>The principles we embrace for this require open source / development in the open, contemplate modularity and self-containment for safety, integrate a robust suite of testing / off-the-shelf alerts / data APIs, and be performant / efficient</li>\n<li>We end with a few items around risks / additional questions we want to engage with the community on</li>\n</ul>\n<p>Last, we want to note that this post is focused on the last mile of communication to allow proposers to register / send / receive commitments. We do not discuss how the proposer commitment protocols may work or how they may be enforced.</p>\n<p><strong>Related Work:</strong></p>\n<ul>\n<li><a href=\"https://ethresear.ch/t/unbundling-pbs-towards-protocol-enforced-proposer-commitments-pepc/13879\">Unbundling PBS</a></li>\n<li><a href=\"https://efdn.notion.site/PEPC-FAQ-0787ba2f77e14efba771ff2d903d67e4\" rel=\"noopener nofollow ugc\">PEPC FAQ</a></li>\n<li><a href=\"https://hackmd.io/@bchain/BJkarrEWp\" rel=\"noopener nofollow ugc\">PEPC-Boost</a></li>\n<li><a href=\"https://ethresear.ch/t/pepc-dvt-pepc-with-no-changes-to-the-consensus-protocol/16514\">PEPC-DVT</a></li>\n<li><a href=\"https://ethresear.ch/t/the-preconfirmation-gateway-unlocking-preconfirmations-from-user-to-preconfer/18812\">Preconfirmation Gateway</a></li>\n<li><a href=\"https://ethresear.ch/t/based-preconfirmations/17353\">Based preconfirms</a><br>\n<a href=\"https://www.youtube.com/watch?v=2IK136vz-PM\" rel=\"noopener nofollow ugc\">Presentation </a>on preconfs and <a href=\"https://docs.google.com/presentation/d/1v429N4jdikMIWWkcVwfjMlV2LlOXSawFCMKoBnZVDNU/edit#slide=id.p\" rel=\"noopener nofollow ugc\">slides</a></li>\n<li><a href=\"https://mirror.xyz/barnabe.eth/QJ6W0mmyOwjec-2zuH6lZb0iEI2aYFB9gE-LHWIMzjQ\" rel=\"noopener nofollow ugc\">More Pictures about Proposers and Builders</a></li>\n<li><a href=\"https://ethresear.ch/t/towards-an-implementation-of-based-preconfirmations-leveraging-restaking/19211\">Preconfirm protocol</a></li>\n<li><a href=\"https://ethresear.ch/t/uncrowdable-inclusion-lists-the-tension-between-chain-neutrality-preconfirmations-and-proposer-commitments/19372\">Chain Neutrality and Uncrowdable Inclusion Lists</a></li>\n<li><a href=\"https://ethresear.ch/t/grounded-relay-superpowers-from-relay-coordination/18601\">Grounded Relay</a></li>\n</ul>\n<p><strong>Background:</strong></p>\n<p>Nearly half a decade ago, <a href=\"https://arxiv.org/abs/1904.05234\" rel=\"noopener nofollow ugc\">Flashboys 2.0</a> was published highlighting how arbitrage bots were challenging the promise of blockchains. On the back of this, some of the authors and community members started a research collective to provide solutions to tackle these challenges. In the end, these efforts created a product more broadly known as <a href=\"https://github.com/flashbots/mev-boost\" rel=\"noopener nofollow ugc\">MEV-boost</a>.</p>\n<p>MEV-boost is a middleware that allows the proposer to make a wholesale commitment that outsources block building to a sophisticated actor called a block builder. In return, these block builders pack a block to earn the highest fee for the proposer. Today, <a href=\"https://mevboost.pics/\" rel=\"noopener nofollow ugc\">over 90% of blocks</a> are built with proposer commitments.</p>\n<p><strong>Proposer Commitments:</strong></p>\n<p>On the back of a few developments[2] and some research by the EF[3], the concept of proposer commitments has begun to be more commonly discussed spurring the question; could proposers make commitments that would unlock a significant design space for Ethereum? And, could this be a mechanism to allow validators “…to provide input into block production, even when they decide to delegate building.”[4] In the last year, multiple proposals have come forward that rely on or could greatly benefit from proposer commitments, some examples include:</p>\n<ul>\n<li>Inclusion lists: Proposer commitment where part of the block / a set of transactions will be included / can’t be censored or removed by a third party, including the proposer</li>\n<li>Preconf: Proposer commitment to in advance, guarantee inclusion of data / certain transaction or group of transactions in a block</li>\n<li>Partial block auctions: Proposer commitment to auction off the top-of-block and the rest-of-block</li>\n<li>Blockspace / blob futures: Proposer commitment to sell part of their block now, but deliver that part of the block in the future</li>\n</ul>\n<p>The proposals range in complexity but are underpinned by the same simple idea–a proposer’s commitment to do something with or for a third party. We also note that proposers may not need to make commitments at this level of granularity (i.e., continue to use wholesale block auctions). However, we believe this is an avenue worth exploring as it may help preserve things like chain neutrality “by allowing them to provide input into block production, even when they decide to delegate building”[4] and if they choose, give some autonomy back to the proposer.</p>\n<p><strong>Challenge:</strong></p>\n<p>On the surface, this all seems great and is an incredibly exciting development. But, in the undercurrents, we are potentially on a perilous path if we can’t agree on a standard of how proposers register and make / receive commitments. We see multiple risks including, but not limited to:</p>\n<ul>\n<li>Increased fragmentation: While diversity of standards can create unlock more innovation, multiple standards (particularly in the last mile of communication) could compromise the security integrity of the entire Ethereum network through fragmentation of how proposer commitment protocols speak to proposers (i.e., proposers may need to make client adjustments for each variation of proposer commitments)</li>\n<li>Development complexity: If there is no standard, teams may more commonly make client adjustments to opt into proposer commitments. This could exponentially inflate the burden on core developers tasked with executing / testing major network upgrades increasing risks for the network around hard forks</li>\n<li>Limited transparency: With multiple software and standards, transparency around what proposers are opting into as well as bugs and taking quick actions may be challenging when something does go wrong</li>\n</ul>\n<p>These risks are likely to only increase as more and more proposer commitments get proposed and adopted. We also note that longer-term there are potential ideas to enshrine various mechanisms helping to reduce these risks.</p>\n<p><strong>Proposal:</strong></p>\n<p>We propose an out-of-protocol, open-source public good that is backward compatible to help standardize the communication mechanism for the last mile of proposers’ commitments. The goal is to develop, adopt, and then sustain one standard software that will limit fragmentation and reduce complexity for core devs. We currently call this Commitment Boost.</p>\n<p><strong>Design Principles:</strong></p>\n<p>Below are a few design principles when initially envisioning Commitment Boost.</p>\n<ul>\n<li>Open source / open development: This should be developed in the open and under open source licensing such as MIT / Apache-2.0</li>\n<li>Safety and reducing risks: Should be backwards compatible not changing existing pipes that support current proposer commitments and be built to isolate each proposer commitment. We also note that Commitment Boost should be continuously managed for future forks / upgrades in the Ethereum ecosystem</li>\n<li>Same overhead as today: The software will not have more overhead to run than existing proposer commitments (and ideally it is even more efficient!). Note: there may be additional overhead for facilitating the actual proposer commitments, but it is not the focus of this discussion and will be up to the proposer commitment protocol itself around how to potentially outsource any complexity</li>\n<li>Transparency: There will need to be robust functionality to understand which commitments a proposer is opting into as well as performing rigorous testing to quickly identify bugs. There should also be data APIs to increase information and transparency for the community and to strengthen alerting systems when bugs happen</li>\n</ul>\n<p><strong>Initial High-Level Potential Design of Commitment Boost:</strong></p>\n<ul>\n<li>Proposer wishing to register for commitments runs Commitment Boost. This will be backward compatible with consensus clients using the same messaging mechanisms that exist today. Commitment Boost is just focused on standardizing the last mile communication between a proposer choosing to register and then send / receive messages to / from a proposer commitment protocol</li>\n<li>Once running Commitment Boost, the proposer will need to register for each commitment they wish to make</li>\n<li>Each proposer commitment across the Commitment Boost stack is likely to be modular and isolated. The rationale that if there is a bug in one module this will not impact the rest of the proposer commitments / block construction. We also note that safeguards should be put in place to protect consensus (i.e., fallback mechanisms to local block building etc.)</li>\n</ul>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/4/3/43f7a19652088da9f139f178060df90293cebbf0.png\" data-download-href=\"https://ethresear.ch/uploads/default/43f7a19652088da9f139f178060df90293cebbf0\" title=\"\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/4/3/43f7a19652088da9f139f178060df90293cebbf0_2_531x309.png\" alt=\"\" data-base62-sha1=\"9HgxlLbVleMaHdQv1FfJFNrhzvq\" width=\"531\" height=\"309\" role=\"presentation\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/4/3/43f7a19652088da9f139f178060df90293cebbf0_2_531x309.png, https://ethresear.ch/uploads/default/optimized/3X/4/3/43f7a19652088da9f139f178060df90293cebbf0_2_796x463.png 1.5x, https://ethresear.ch/uploads/default/original/3X/4/3/43f7a19652088da9f139f178060df90293cebbf0.png 2x\" data-dominant-color=\"B3BAB2\"></a></div><br>\n<strong>Near-Term Focus:</strong><p></p>\n<p>As noted above, Commitment Boost should lean towards being modular to potentially allow any proposer commitment. However, we initially plan to focus on designing standards for Commitment Boost to be backward compatible and to support commitments such as preconf protocols and inclusion lists. If other projects require proposer commitments and are interested in thinking through designs please reach out.</p>\n<p><strong>Open Questions:</strong></p>\n<p>Below is a list of questions that we need to consider and engage around. We note that some of these are not specific to Commitment Boost, but proposer commitments more broadly.</p>\n<ul>\n<li>Added risks: While there are general risks and questions on enabling proposer commitment protocols, we are particularly interested to engage on additional risks / the initial high-level design of Commitment Boost and whether the design can reduce risks to any commitment potentially impacting consensus</li>\n<li>Standardization is not always good: While in most cases standardization helps align the market and reduces the risk of fragmentation, it can also limit innovation and create “tech debt” that can confine the design space given how early we are and what we know about proposer commitments today</li>\n<li>How modules are added: It is not clear the best path forward around a process, or lack of, for how new proposer commitment modules are added</li>\n<li>Coordination during Ethereum upgrades: Likely will need to coordinate a group to ensure there is a process to perform testing / changes related to forks</li>\n<li>Upgrades to commitment boost: Similar to the point directly above, if we identify some upgrades needed we will need to test and manage any code changes required</li>\n<li>Economics: Are there any considerations around how proposers are paid for committing and how this could impact Ethereum / could these be internalized to Ethereum in the future</li>\n<li>Centralization: What are the impacts Commitment Boost could have on centralization and does it impact at-home stakers or geographical dispersion of validators</li>\n</ul>\n<p><strong>Conclusion:</strong></p>\n<p>The garden of Ethereum is infinite and the potential for proposer commitments could set off a wave of ways to use Ethereum. Proposer commitments could enable things like preconfs that are critical for based sequencing as well as other applications not currently envisioned. To help the community and entrepreneurs build on Ethereum, Commitment Boost is an initial idea to standardize the way proposers register and send / receive commitments. We look forward to discussing, refining, developing, and working with the community on proposer commitments. We plan to keep gathering feedback on the back of this post and continue to work with the community to push this idea as well as assist in other efforts around proposer commitments.</p>\n<p><strong>References:</strong></p>\n<p>[1] Fun Fact: The initials for Commitment Boost are shared with <a href=\"https://en.wikipedia.org/wiki/Citizens_band_radio\" rel=\"noopener nofollow ugc\">CB Radios</a>, “a system allowing short-distance one-to-many bidirectional voice communication among individuals.”</p>\n<p>[2] With the excitement around <a href=\"https://ethresear.ch/t/based-rollups-superpowers-from-l1-sequencing/15016\">based sequencing</a> introduced by Justin Drake, there has been a push <a href=\"https://www.youtube.com/watch?v=XSsKFINj710\" rel=\"noopener nofollow ugc\">by a few teams</a> to build proposer commitments such as preconfs. Developments like EigenLayer and restaking generally have also expanded developers / teams imagination of what proposers can make commitments around.</p>\n<p>[3] Generally, we are referring to PEPC and inclusion lists research as noted in the “Related Work” section of this post.</p>\n<p>[4]<a href=\"https://ethresear.ch/t/uncrowdable-inclusion-lists-the-tension-between-chain-neutrality-preconfirmations-and-proposer-commitments/19372\" class=\"inline-onebox\">Uncrowdable Inclusion Lists: The Tension between Chain Neutrality, Preconfirmations and Proposer Commitments</a></p>\n            <p><small>2 posts - 2 participants</small></p>\n            <p><a href=\"https://ethresear.ch/t/based-proposer-commitments-ethereum-s-marketplace-for-proposer-commitments/19517\">Read full topic</a></p>","link":"https://ethresear.ch/t/based-proposer-commitments-ethereum-s-marketplace-for-proposer-commitments/19517","pubDate":"Thu, 09 May 2024 19:58:17 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-19517"},"source":{"@url":"https://ethresear.ch/t/based-proposer-commitments-ethereum-s-marketplace-for-proposer-commitments/19517.rss","#text":"Based proposer commitments - Ethereum’s marketplace for proposer commitments"},"filter":false},{"title":"[Research report] Allowing validators to share client information privately---a project by Nethermind Research","dc:creator":"jorem321","category":"Consensus","description":"<p>Dear ethresear.ch readers,</p>\n<p>As part of the Ethereum Foundation’s <a href=\"https://esp.ethereum.foundation/data-collection-grants\" rel=\"noopener nofollow ugc\">Data Collection Grants Round 2023 </a> which ran between last September and October, an interdisciplinary team involving Nethermind Research and Nethermind core developers received a grant to work on the project “Allowing validators to provide client information privately”. Below, we attach our submission in fulfillment of the objectives behind the project. In this deliverable, we have provided the necessary motivation and background for the problem of measuring client diversity, which we then use to propose and analyze three different approaches for validators to privately share their client diversity data—each with their strengths and weaknesses.</p>\n<p><a href=\"https://nethermind.notion.site/Allowing-validators-to-provide-client-information-privately-bfea6436bfe246d28afdcda125d9049c\" rel=\"noopener nofollow ugc\">Deliverable: Allowing validators to provide client information privately </a></p>\n<h2><a name=\"executive-summary-of-the-proposed-approaches-1\" class=\"anchor\" href=\"https://ethresear.ch#executive-summary-of-the-proposed-approaches-1\"></a>Executive summary of the proposed approaches.</h2>\n<p>We briefly summarize the key ideas behind the three approaches before. The reader is referred to the deliverable for a full exposition.</p>\n<h3><a name=\"h-1-client-diversity-data-on-the-graffiti-field-2\" class=\"anchor\" href=\"https://ethresear.ch#h-1-client-diversity-data-on-the-graffiti-field-2\"></a>1. Client diversity data on the graffiti field</h3>\n<p>As the first approach, we have discussed a method for measuring validator client diversity by posting data directly on the graffiti field. We note that this approach has been discussed by the community before. We have outlined necessary changes, such as creating an EngineAPI method for CL clients to retrieve EL client details and agreeing on encoding standards for the data. We have also discussed challenges with this method including dealing with parties that do not participate, multiplexed architectures, and distinguishing between proposer and attester duties.</p>\n<p>We have also discussed statistical significance, i.e., how many client data reports are needed to accurately estimate the client distribution from graffiti field data alone. We confirmed that the analyzed method can reach statistical significance quickly (in the order of days) assuming a reasonable participation rate. We discuss these assertions quantitatively in the deliverable.</p>\n<p>Finally, we have assessed the feasibility of anonymizing graffiti field reports, concluding that existing methods like encryption or zero-knowledge proofs are impractical to use due to the sequential nature of data collection and the limited space in the graffiti field.</p>\n<h3><a name=\"h-2-allowing-nodes-to-listen-to-client-diversity-data-through-the-gossip-network-using-nullifiers-to-hide-the-identity-of-validators-3\" class=\"anchor\" href=\"https://ethresear.ch#h-2-allowing-nodes-to-listen-to-client-diversity-data-through-the-gossip-network-using-nullifiers-to-hide-the-identity-of-validators-3\"></a>2. Allowing nodes to listen to client diversity data through the gossip network + using nullifiers to hide the identity of validators</h3>\n<p>As the second approach, we have examined a potential modification to Ethereum’s P2P layer to enable crawlers to obtain validator distribution for client diversity. We have explored using a dedicated channel in the GossipSub protocol to share client diversity data efficiently. We have proposed a method that periodically selects validators at random to submit their client diversity data, which is then shared through GossipSub. Each validator forms its client diversity data into a <strong>ClientData</strong> object and publishes it via a designated topic. Then, the nodes in this designated topic can receive those objects, verify their authenticity, and aggregate them for the final result. We have also discussed the challenges around this method, particularly concerning network overload.</p>\n<p>Furthermore, we have explored anonymizing P2P reports to ensure validators’ privacy. We have discussed potential approaches such as encrypting client data or anonymizing the voters’ identities using nullifiers and zero-knowledge proofs. We have proposed an approach that uses BLS signatures, nullifiers, and zero-knowledge proofs to hide validators’ identities and prevent double submissions. Validators submit encoded client data along with proofs to a P2P network. We have discussed potential deanonymization vectors such as P2P traffic analysis and proposed mitigation strategies like mixnets and approaches based on Dandelion and Dandelion++.</p>\n<p>Implementing these strategies may face challenges such as increased latency and complexity. We have stressed our interest in community input regarding the concern level over potential attack vectors and the feasibility of mitigation strategies.</p>\n<h3><a name=\"h-3-dedicated-voting-scheme-for-client-data-collection-4\" class=\"anchor\" href=\"https://ethresear.ch#h-3-dedicated-voting-scheme-for-client-data-collection-4\"></a>3. Dedicated voting scheme for client data collection</h3>\n<p>As the third and last approach, we have proposed a voting protocol aimed at collecting data from validators securely and verifiably, avoiding issues like obscurity and centralization found in existing survey methods. We have examined the use of public bulletin boards (PBBs) or blockchains for collecting votes, drawing insights from Vitalik’s analysis of blockchains’ limitations in elections and the advantages of using blockchains as bulletin boards. Due to its decentralization and cost-efficiency, we have proposed to utilize a blockchain, specifically Ethereum’s Holesky Testnet. Regarding how validators submit their votes, we have considered having validators encrypt their client data and share it through a P2P network, and using a trusted committee—called decryption authorities—to receive the encrypted data, submit the received data to a smart contract, and finally, aggregate and decrypt the encrypted client data.</p>\n<p>This third method addresses some of the traffic analysis concerns in the second method by leveraging homomorphic encryption of the votes, which requires a trusted committee.</p>\n<h1><a name=\"a-call-for-feedback-5\" class=\"anchor\" href=\"https://ethresear.ch#a-call-for-feedback-5\"></a>A call for feedback</h1>\n<p>As the next stage of this research project, we look forward to disseminating and discussing the aforementioned approaches through various channels, including this forum and community calls. Thus, we welcome discussions with the Ethereum community to gauge the impressions on the most suitable approach. For example,</p>\n<ul>\n<li>In the deliverable above, we have provided a rubric that ranks the downsides of each method according to their severity as perceived by the team. From the team’s perspective, this analysis positions the second method as the most favorable. Should this rubric be challenged in any way?</li>\n<li>Does the reader see any additional concerns with the proposed methods?</li>\n<li>Are there any variations or suggestions the reader can think of to build upon the methods herein?</li>\n</ul>\n<p>We look forward to your impressions and comments!</p>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://ethresear.ch/t/research-report-allowing-validators-to-share-client-information-privately-a-project-by-nethermind-research/19506\">Read full topic</a></p>","link":"https://ethresear.ch/t/research-report-allowing-validators-to-share-client-information-privately-a-project-by-nethermind-research/19506","pubDate":"Thu, 09 May 2024 00:58:51 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-19506"},"source":{"@url":"https://ethresear.ch/t/research-report-allowing-validators-to-share-client-information-privately-a-project-by-nethermind-research/19506.rss","#text":"[Research report] Allowing validators to share client information privately---a project by Nethermind Research"},"filter":false},{"title":"Triadic Consensus: A Fast and Resilient Consensus Mechanism for Sharded Blockchains","dc:creator":"cryptskii","category":"Consensus","description":"<h2><a name=\"tldr-1\" class=\"anchor\" href=\"https://ethresear.ch#tldr-1\"></a>TL;DR</h2>\n<p>The document presents a triadic consensus mechanism using the Sierpinski topology to achieve optimal fault tolerance in decentralized systems. This mechanism ensures Byzantine fault tolerance at the triad level and provides hierarchical aggregation for enhanced fault tolerance at the system level. It includes comprehensive implementation details, fault handling, and aggregation strategies.</p>\n<h2><a name=\"background-2\" class=\"anchor\" href=\"https://ethresear.ch#background-2\"></a>Background</h2>\n<p>The background section discusses the need for fault tolerance in decentralized systems and introduces the triadic consensus mechanism utilizing Sierpinski topology. This topology enables hierarchical aggregation of votes, allowing the system to handle Byzantine faults at multiple levels.</p>\n<h2><a name=\"proposal-3\" class=\"anchor\" href=\"https://ethresear.ch#proposal-3\"></a>Proposal</h2>\n<h3><a name=\"initialization-4\" class=\"anchor\" href=\"https://ethresear.ch#initialization-4\"></a>Initialization</h3>\n<p>The initialization phase involves setting up the Sierpinski topology and assigning nodes to shards. The necessary data structures and functions are defined:</p>\n<p><strong>Definition 1 (Sierpinski Vertex):</strong><br>\n<span class=\"math\">\\text{SierpinskiVertex} = (d, i)</span><br>\nwhere <span class=\"math\">( d \\in \\mathbb{N} )</span> is the depth of the vertex in the triangle, and <span class=\"math\">( i \\in \\mathbb{N} )</span> is the index of the vertex at its depth.</p>\n<p><strong>Definition 2 (Sierpinski Triangle):</strong><br>\n<span class=\"math\">\\text{SierpinskiTriangle} = (D, V)</span><br>\nwhere <span class=\"math\">( D \\in \\mathbb{N} )</span> is the depth of the triangle, and <span class=\"math\">( V )</span> is the set of vertices in the triangle.</p>\n<p><strong>Algorithm 1: Generate Sierpinski Triangle</strong></p>\n<ol>\n<li>procedure generateSierpinskiTriangle(D)</li>\n<li><span class=\"math\">( V \\leftarrow \\bigcup_{d=0}^{D} \\text{getVerticesAtDepth}(D, d) )</span></li>\n<li>return SierpinskiTriangle <span class=\"math\">(D, V)</span></li>\n<li>end procedure</li>\n</ol>\n<h3><a name=\"triadic-consensus-5\" class=\"anchor\" href=\"https://ethresear.ch#triadic-consensus-5\"></a>Triadic Consensus</h3>\n<p>The triadic consensus algorithm involves parallel voting and hierarchical aggregation. The key data structures and functions include:</p>\n<p>Here’s the corrected definition:</p>\n<p><strong>Definition 3 (Triad Result):</strong><br>\n<span class=\"math\">\\text{TriadResult} = (t, v)</span><br>\nwhere <span class=\"math\">t \\in \\mathbb{N}</span> is the ID of the triad, and <span class=\"math\">v \\in \\{\\text{Yes}, \\text{No}\\}</span> is the vote result of the triad.</p>\n<p><strong>Algorithm 5: Run Triadic Consensus</strong></p>\n<ol>\n<li>procedure runTriadicConsensus <span class=\"math\">(T, s, X)</span></li>\n<li><span class=\"math\">( V \\leftarrow \\{v \\in \\text{vertices}(T) \\mid \\text{shardAssignment}(\\text{depth}(v), \\text{index}(v), \\text{depth}(T)) = s \\} )</span></li>\n<li><span class=\"math\">( R \\leftarrow \\text{getTriadsForShard}(V) )</span></li>\n<li><span class=\"math\">( Y \\leftarrow \\text{mapConcurrently}(\\text{getTriadVote}(X), R) )</span></li>\n<li><span class=\"math\">( v \\leftarrow \\text{aggregateShardVote}(\\pi_2(Y)) )</span></li>\n<li>if <span class=\"math\">( v )</span> then</li>\n<li>return <span class=\"math\">( X )</span></li>\n<li>else</li>\n<li>return <span class=\"math\">(\\emptyset)</span></li>\n<li>end if</li>\n<li>end procedure</li>\n</ol>\n<h3><a name=\"fault-handling-and-aggregation-6\" class=\"anchor\" href=\"https://ethresear.ch#fault-handling-and-aggregation-6\"></a>Fault Handling and Aggregation</h3>\n<p>The system handles faults at the triad level and aggregates votes at the system level for enhanced fault tolerance. Key algorithms include:</p>\n<p><strong>Algorithm 10: Handle Faults</strong></p>\n<ol>\n<li>procedure handleFaults <span class=\"math\">(L)</span></li>\n<li>return map <span class=\"math\">(filterFaultyTriads, L)</span></li>\n<li>end procedure</li>\n</ol>\n<p><strong>Algorithm 13: Fault-Tolerant Aggregation</strong></p>\n<ol>\n<li>procedure faultTolerantAggregation <span class=\"math\">(L)</span></li>\n<li><span class=\"math\">( A \\leftarrow \\text{aggregateResults}(L) )</span></li>\n<li><span class=\"math\">( V \\leftarrow \\text{handleFaults}(L) )</span></li>\n<li>return <span class=\"math\">(\\text{majority}(\\pi_2(\\text{elems}(V))))</span></li>\n<li>end procedure</li>\n</ol>\n<h2><a name=\"advantages-7\" class=\"anchor\" href=\"https://ethresear.ch#advantages-7\"></a>Advantages</h2>\n<p>The triadic consensus mechanism using Sierpinski topology offers several advantages:</p>\n<ol>\n<li><strong>Fault Tolerance:</strong> The hierarchical structure provides enhanced fault tolerance at both triad and system levels.</li>\n<li><strong>Scalability:</strong> The mechanism allows for efficient parallel voting and aggregation.</li>\n<li><strong>Efficiency:</strong> The approach reduces latency and increases throughput compared to traditional consensus mechanisms.</li>\n</ol>\n<h2><a name=\"applications-8\" class=\"anchor\" href=\"https://ethresear.ch#applications-8\"></a>Applications</h2>\n<p>The proposed mechanism can be applied in various decentralized systems requiring high fault tolerance and scalability, such as blockchain networks, distributed databases, and other consensus-based applications.</p>\n<h2><a name=\"comparison-9\" class=\"anchor\" href=\"https://ethresear.ch#comparison-9\"></a>Comparison</h2>\n<p>The triadic consensus mechanism using Sierpinski topology surpasses RAFT and PBFT in fault tolerance and efficiency. Here’s a mathematical comparison:</p>\n<h3><a name=\"raft-10\" class=\"anchor\" href=\"https://ethresear.ch#raft-10\"></a>RAFT</h3>\n<p>RAFT is a leader-based consensus algorithm designed for crash fault tolerance <span class=\"math\">(CFT)</span>. It can tolerate up to <span class=\"math\">( \\left\\lfloor \\frac{n-1}{2} \\right\\rfloor )</span> node failures in a system of <span class=\"math\">( n )</span> nodes. RAFT is not designed to handle Byzantine faults, making it less suitable for environments where nodes may act maliciously.</p>\n<h3><a name=\"pbft-practical-byzantine-fault-tolerance-11\" class=\"anchor\" href=\"https://ethresear.ch#pbft-practical-byzantine-fault-tolerance-11\"></a>PBFT (Practical Byzantine Fault Tolerance)</h3>\n<p>PBFT is designed to tolerate Byzantine faults and can handle up to <span class=\"math\">( \\left\\lfloor \\frac{n-1}{3} \\right\\rfloor )</span> faulty nodes in a system of <span class=\"math\">( n )</span> nodes. PBFT requires a higher communication overhead compared to RAFT due to its Byzantine fault tolerance.</p>\n<h3><a name=\"triadic-consensus-using-sierpinski-topology-12\" class=\"anchor\" href=\"https://ethresear.ch#triadic-consensus-using-sierpinski-topology-12\"></a>Triadic Consensus Using Sierpinski Topology</h3>\n<p>The triadic consensus mechanism leverages the hierarchical structure of the Sierpinski triangle for fault tolerance at multiple levels.</p>\n<h4><a name=\"fault-tolerance-at-the-triad-level-13\" class=\"anchor\" href=\"https://ethresear.ch#fault-tolerance-at-the-triad-level-13\"></a>Fault Tolerance at the Triad Level</h4>\n<p>At the triad level, the mechanism can tolerate up to:<br>\n<span class=\"math\">\\left\\lfloor \\frac{3-1}{2} \\right\\rfloor = 1 \\text{ Byzantine fault}</span></p>\n<h4><a name=\"fault-tolerance-at-the-shard-level-14\" class=\"anchor\" href=\"https://ethresear.ch#fault-tolerance-at-the-shard-level-14\"></a>Fault Tolerance at the Shard Level</h4>\n<p>At the shard level, where each shard consists of multiple triads, the mechanism can tolerate up to:<br>\n<span class=\"math\">\\left\\lfloor \\frac{m-1}{3} \\right\\rfloor \\text{ faulty shards}</span></p>\n<h4><a name=\"fault-tolerance-at-the-system-level-15\" class=\"anchor\" href=\"https://ethresear.ch#fault-tolerance-at-the-system-level-15\"></a>Fault Tolerance at the System Level</h4>\n<p>At the system level, where the final consensus is determined by the majority of shard votes, the mechanism can tolerate up to:<br>\n<span class=\"math\">\\left\\lfloor \\frac{m-1}{2} \\right\\rfloor \\text{ faulty shards}</span></p>\n<h3><a name=\"comparison-summary-16\" class=\"anchor\" href=\"https://ethresear.ch#comparison-summary-16\"></a>Comparison Summary</h3>\n<ul>\n<li><strong>RAFT:</strong> Tolerates <span class=\"math\">( \\left\\lfloor \\frac{n-1}{2} \\right\\rfloor )</span> node failures, but not designed for Byzantine faults.</li>\n<li><strong>PBFT:</strong> Tolerates <span class=\"math\">( \\left\\lfloor \\frac{n-1}{3} \\right\\rfloor )</span> Byzantine faults with higher communication overhead.</li>\n<li><strong>Triadic Consensus with Sierpinski Topology:</strong> Tolerates <span class=\"math\">( \\left\\lfloor \\frac{3-1}{2} \\right\\rfloor = 1 )</span> Byzantine fault per triad, <span class=\"math\">( \\left\\lfloor \\frac{m-1}{3} \\right\\rfloor )</span> faulty shards at the shard level, and <span class=\"math\">( \\left\\lfloor \\frac{m-1}{2} \\right\\rfloor )</span> faulty shards at the system level, providing enhanced fault tolerance with lower latency and higher throughput.</li>\n</ul>\n<h2><a name=\"conclusion-17\" class=\"anchor\" href=\"https://ethresear.ch#conclusion-17\"></a>Conclusion</h2>\n<p>The triadic consensus mechanism using Sierpinski topology provides a robust solution for achieving fault tolerance in decentralized systems. Through formal analysis and simulations, it has been shown to tolerate up to one-third Byzantine faults at the triad level and up to one-half faulty shards at the system level. The mechanism outperforms alternative approaches in terms of latency and throughput, making it a promising solution for future decentralized applications.</p>\n<p><strong>Future Work:</strong> Future research can explore further optimizations, dynamic sharding, and adaptive fault tolerance based on network conditions.</p>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://ethresear.ch/t/triadic-consensus-a-fast-and-resilient-consensus-mechanism-for-sharded-blockchains/19504\">Read full topic</a></p>","link":"https://ethresear.ch/t/triadic-consensus-a-fast-and-resilient-consensus-mechanism-for-sharded-blockchains/19504","pubDate":"Wed, 08 May 2024 21:05:05 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-19504"},"source":{"@url":"https://ethresear.ch/t/triadic-consensus-a-fast-and-resilient-consensus-mechanism-for-sharded-blockchains/19504.rss","#text":"Triadic Consensus: A Fast and Resilient Consensus Mechanism for Sharded Blockchains"},"filter":false},{"title":"Client-Side Ordinal Transaction Ordering (COTO)","dc:creator":"cryptskii","category":"Sharding","description":"<p><strong>TL;DR</strong> ProofChain introduces a novel transaction ordering mechanism called Client-Side Ordinal Transaction Ordering (COTO) that achieves deterministic and uniform ordering of transactions across shards without requiring shard synchronization, enhancing the scalability of the system.</p>\n<p><strong>Background</strong> Existing blockchain systems face scalability challenges due to limitations in their transaction ordering approaches. Global consensus ordering suffers from limited throughput, while shard-level consensus ordering requires cross-shard synchronization. DAG-based approaches face challenges in transaction finality and handling conflicting transactions.</p>\n<p><strong>Proposal</strong> COTO assigns a unique ordinal rank to each transaction based on the sender’s shard ID, logical clock value, timestamp, and hash of the serialized transaction. The ordinal rank determines the order in which transactions are processed. Each shard validates and processes transactions independently using the assigned ordinal ranks. Processed transactions are propagated to other shards through either Client View (signed transactions) or Global View (Global State Proofs) propagation modes.</p>\n<p>Let <span class=\"math\">\\mathcal{T}</span> denote the set of all transactions in the ProofChain network. Each transaction <span class=\"math\">tx \\in \\mathcal{T}</span> is represented as a tuple:</p>\n<p><span class=\"math\">tx = (s, r, a, n, t)</span></p>\n<p>where:<br>\n<span class=\"math\">s</span> is the sender’s address<br>\n<span class=\"math\">r</span> is the recipient’s address<br>\n<span class=\"math\">a</span> is the transaction amount<br>\n<span class=\"math\">n</span> is the transaction nonce<br>\n<span class=\"math\">t</span> is the transaction timestamp</p>\n<p>The ordinal rank of a transaction <span class=\"math\">tx</span> is calculated as follows:</p>\n<p><span class=\"math\">OrdinalRank(tx) = (Shard(tx), LogicalClock(tx), Timestamp(tx), Hash(Serialize(tx)))</span></p>\n<p>where:<br>\n<span class=\"math\">Shard(tx) = hash(tx.s) \\bmod m</span>, with <span class=\"math\">hash</span> being a cryptographic hash function and <span class=\"math\">m</span> the total number of shards<br>\n<span class=\"math\">LogicalClock(tx)</span> is the current logical clock value of the client<br>\n<span class=\"math\">Timestamp(tx)</span> is the current timestamp at the time of transaction submission<br>\n<span class=\"math\">Hash(Serialize(tx))</span> is the cryptographic hash of the serialized transaction</p>\n<p><strong>Illustration</strong> Consider two transactions, <span class=\"math\">tx_1</span> and <span class=\"math\">tx_2</span>, submitted to the ProofChain network. The ordinal ranks of these transactions are calculated as follows:</p>\n<p><span class=\"math\">OrdinalRank(tx_1) = (Shard(tx_1), LogicalClock(tx_1), Timestamp(tx_1), Hash(Serialize(tx_1)))</span><br>\n<span class=\"math\">OrdinalRank(tx_2) = (Shard(tx_2), LogicalClock(tx_2), Timestamp(tx_2), Hash(Serialize(tx_2)))</span></p>\n<p>Assuming <span class=\"math\">tx_1</span> and <span class=\"math\">tx_2</span> belong to different shards and have unique ordinal ranks, they can be processed independently by their respective shards without requiring cross-shard synchronization.</p>\n<p><strong>Advantages</strong> COTO offers several advantages over alternative transaction ordering approaches:</p>\n<ol>\n<li>Scalability: COTO allows parallel transaction processing across shards, eliminating the need for global consensus or cross-shard synchronization.</li>\n<li>Deterministic Ordering: COTO ensures a deterministic ordering of transactions based on their unique ordinal ranks, providing consistency across shards.</li>\n<li>Efficient Propagation: COTO supports efficient propagation of shard states through succinct Global State Proofs (GSPs) or signed transactions.</li>\n</ol>\n<p><strong>Applications</strong> COTO can be applied in various scenarios where scalability and deterministic ordering of transactions are crucial:</p>\n<ol>\n<li>High-Throughput Payment Systems: COTO enables fast and parallel processing of transactions, making it suitable for large-scale payment networks.</li>\n<li>Decentralized Exchanges: COTO ensures a consistent ordering of trades across shards, facilitating efficient and fair execution of orders.</li>\n<li>Supply Chain Management: COTO can be used to track and order events in supply chain networks, ensuring data integrity and consistency across participants.</li>\n</ol>\n<p><strong>Conclusion</strong> Client-Side Ordinal Transaction Ordering (COTO) introduces a scalable and deterministic approach to transaction ordering in sharded blockchain networks. By assigning unique ordinal ranks to transactions and enabling parallel processing across shards, COTO addresses the scalability challenges faced by existing transaction ordering approaches. The mathematical formalisms, algorithms, and proofs presented demonstrate the correctness and scalability properties of COTO, making it a promising solution for various applications requiring high throughput and consistent transaction ordering.</p>\n            <p><small>6 posts - 2 participants</small></p>\n            <p><a href=\"https://ethresear.ch/t/client-side-ordinal-transaction-ordering-coto/19503\">Read full topic</a></p>","link":"https://ethresear.ch/t/client-side-ordinal-transaction-ordering-coto/19503","pubDate":"Wed, 08 May 2024 19:16:11 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-19503"},"source":{"@url":"https://ethresear.ch/t/client-side-ordinal-transaction-ordering-coto/19503.rss","#text":"Client-Side Ordinal Transaction Ordering (COTO)"},"filter":false},{"title":"Optimized Decentralized Coded Computing with Binary Field SNARKs","dc:creator":"cryptskii","category":"zk-s[nt]arks","description":"<p><strong>TL;DR</strong> Building off of existing theory and practical, we propose a novel protocol for efficient and robust decentralized coded computing using binary field SNARK constructions and coding-theoretic techniques. It leverages a tower of binary field extensions to natively capture various data types and utilizes block-level polynomial commitments and PLONKish arithmetization for efficient verification of the computations.</p>\n<p><strong>Background</strong> Coded computing has emerged as a promising approach for injecting redundancy into decentralized computations for robustness against faults and stragglers. However, existing solutions using zero-knowledge proofs (ZKPs) and fully homomorphic encryption (FHE) face challenges in terms of efficiency, flexibility and scalability.</p>\n<p><strong>Proposal</strong> Our protocol synergistically combines state-of-the-art techniques from binary field SNARKs and coding theory:</p>\n<ul>\n<li>Use a tower of binary field extensions <span class=\"math\">\\mathbb{F}_2 \\subseteq \\mathbb{F}_{2^2} \\subseteq \\mathbb{F}_{2^4} \\subseteq \\mathbb{F}_{2^8} \\subseteq \\cdots \\subseteq \\mathbb{F}_{2^{128}}</span> to efficiently work with various data types</li>\n<li>Apply a block-level polynomial commitment scheme to commit coded boolean data with optimal rate and polylogarithmic proof size</li>\n<li>Adapt PLONKish techniques like product and permutation arguments over the binary fields to support expressive computations</li>\n<li>Introduce a shifting virtual polynomial for efficient rotations of coded data chunks</li>\n<li>Reconcile the different components via an interactive proof system with tower field arithmetic</li>\n</ul>\n<p><strong>Illustration</strong> Consider a multilinear polynomial <span class=\"math\">f \\in \\mathbb{F}_2[X_1, \\ldots, X_d]</span> of degree <span class=\"math\">\\leq d</span>. We encode the coefficients block-wise into a vector <span class=\"math\">\\vec{f} \\in \\mathbb{F}_{2^{\\lceil \\log{d} \\rceil}}^{2^d/d}</span> as follows:</p>\n<ol>\n<li>Partition the coefficients into <span class=\"math\">2^d/d</span> blocks <span class=\"math\">\\{\\vec{c}_i \\in \\mathbb{F}_2^d\\}_{i=1}^{2^d/d}</span></li>\n<li>For each block <span class=\"math\">i</span>, evaluate <span class=\"math\">g_i(X) = \\sum_{j=0}^{d-1} c_{i,j} X^j</span> at a fixed element <span class=\"math\">\\alpha_i \\in \\mathbb{F}_{2^{\\lceil \\log{d} \\rceil}}</span></li>\n<li>Define <span class=\"math\">\\vec{f} = (g_1(\\alpha_1), g_2(\\alpha_2), \\ldots, g_{2^d/d}(\\alpha_{2^d/d}))</span></li>\n</ol>\n<p>To avoid embedding overhead when committing, we directly work with the block-encoded vector <span class=\"math\">\\vec{f}</span> which has length <span class=\"math\">O(2^d/d)</span> over the extension field instead of the full coefficient vector over <span class=\"math\">\\mathbb{F}_2</span> of length <span class=\"math\">2^d</span>.</p>\n<p><strong>Advantages</strong> Our protocol achieves several advantages over prior works:</p>\n<ul>\n<li>Efficient prover times of <span class=\"math\">\\widetilde{O}(mN^2)</span> field operations and verifier times of <span class=\"math\">\\widetilde{O}(N^2/\\rho)</span> field operations for <span class=\"math\">N</span> constraints and rate-<span class=\"math\">\\rho</span> encoding, where <span class=\"math\">m</span> is the number of variables per constraint</li>\n<li>Proof sizes of <span class=\"math\">O(N^2 \\log k / \\rho)</span> bits that compares favorably to FRI-based systems like STARKs and RedShift</li>\n<li>Flexibility to work with multiple binary extension fields and compute natively over <span class=\"math\">\\mathbb{F}_2</span>, enabling more compact constraint systems in some cases compared to R1CS</li>\n<li>Short structured reference strings that can be generated transparently without extra setup assumptions</li>\n</ul>\n<p><strong>Applications</strong> This protocol can be applied to efficiently verify computations expressed as boolean or arithmetic circuits in a decentralized setting with redundancy against faults. Potential use cases include:</p>\n<ul>\n<li>Privacy-preserving outsourcing of computations to a network of untrusted workers</li>\n<li>Scalable and robust multi-party computation (MPC) with low online communication</li>\n<li>Transparent and succinct proof systems for general computations with purely algebraic security assumptions</li>\n</ul>\n<p><strong>Conclusion</strong> We presented a high-performance cryptographic protocol for decentralized coded computing by combining binary field SNARKs and coding theory in a novel way. Our construction overcomes challenges in prior works and achieves asymptotic and concrete efficiency for a wide class of computations. This work expands the capabilities of zero-knowledge proof systems and enables exciting applications in privacy-enhancing technologies.</p>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://ethresear.ch/t/optimized-decentralized-coded-computing-with-binary-field-snarks/19499\">Read full topic</a></p>","link":"https://ethresear.ch/t/optimized-decentralized-coded-computing-with-binary-field-snarks/19499","pubDate":"Wed, 08 May 2024 16:54:10 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-19499"},"source":{"@url":"https://ethresear.ch/t/optimized-decentralized-coded-computing-with-binary-field-snarks/19499.rss","#text":"Optimized Decentralized Coded Computing with Binary Field SNARKs"},"filter":false},{"title":"Empirical Analysis of the Impact of EIP-4844 on Ethereum's Ecosystem","dc:creator":"wanify","category":"Economics","description":"<h2><a name=\"empirical-analysis-of-the-eip-4844s-impact-on-ethereum-1\" class=\"anchor\" href=\"https://ethresear.ch#empirical-analysis-of-the-eip-4844s-impact-on-ethereum-1\"></a>Empirical Analysis of the EIP-4844’s Impact on Ethereum</h2>\n<p><em>by <a href=\"https://twitter.com/seongwan_eth\" rel=\"noopener nofollow ugc\">Seongwan Park</a>, <a href=\"https://twitter.com/1004YUKICHAN\" rel=\"noopener nofollow ugc\">Bosul Mun</a></em></p>\n<p>Draft paper : <a href=\"https://arxiv.org/abs/2405.03183\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">[2405.03183] Impact of EIP-4844 on Ethereum: Consensus Security, Ethereum Usage, Rollup Transaction Dynamics, and Blob Gas Fee Markets</a></p>\n<h3><a name=\"summary-2\" class=\"anchor\" href=\"https://ethresear.ch#summary-2\"></a>Summary</h3>\n<p>On March 13, 2024, Ethereum implemented EIP-4844 to enhance its capabilities as a data availability layer. While this upgrade has successfully reduced <a href=\"https://l2fees.info/\" rel=\"noopener nofollow ugc\">data posting costs</a> for rollups, it also introduces potential concerns regarding the consensus layer, particularly due to increased propagation sizes. Additionally, the broader impacts on the overall Ethereum ecosystem have not been thoroughly explored until now.</p>\n<p>In our analysis, we’ve examined EIP-4844’s effects in terms of consensus security, Ethereum usage, rollup transaction dynamics, and the blob gas fee mechanism. Our study includes changes in synchronization times, detailed assessments of Ethereum usage, rollup activities, and insights into the blob gas fee mechanism. Our goal is to pinpoint both improvements and potential issues since the upgrade.</p>\n<p><strong>Main Findings:</strong></p>\n<ol>\n<li><strong>Consensus Security</strong></li>\n</ol>\n<ul>\n<li>Increase in fork rates, even excluding periods affected by client issues.</li>\n<li>Sync time has increased by approximately 140ms, from 2267.436ms to 2407.05ms.</li>\n<li>The most significant contributor to increased sync time is receive time, while blob propagation had minimal effects.</li>\n</ul>\n<ol start=\"2\">\n<li><strong>Ethereum Usage</strong></li>\n</ol>\n<ul>\n<li>Marked increase in total data size posted by rollups (+116%).</li>\n<li>Significant reduction in total fees paid by rollups (-71%) and price per MiB for data availability (-82%).</li>\n<li>A substantial decrease in total gas used (-54%).</li>\n</ul>\n<ol start=\"3\">\n<li><strong>Rollup Transactions</strong></li>\n</ol>\n<ul>\n<li>All six rollups studied (Arbitrum One, Optimism, Base, Starknet, zkSync Era, Linea) showed significant increases in transaction volume.</li>\n<li>User delay has notably increased in four of the rollups(except for Arbitrum One and zkSync Era), highlighting the need for blob sharing protocols.</li>\n</ul>\n<ol start=\"4\">\n<li><strong>Blob Gas Fee Market</strong></li>\n</ol>\n<ul>\n<li>Small influence of the gas base fee on the blob gas base fee, with no reciprocal influence detected.</li>\n<li>Higher priority fees for blob transactions compared to non-blob transactions</li>\n<li>The blob gas fee market exhibits greater volatility than the gas fee market, yet it potentially reflects market demands more accurately.</li>\n</ul>\n<p><strong>Figures</strong></p>\n<div class=\"d-image-grid\">\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/5/8/589586f7a2dd9e55913caf25215b3279929be1d3.png\" data-download-href=\"https://ethresear.ch/uploads/default/589586f7a2dd9e55913caf25215b3279929be1d3\" title=\"Screenshot 2024-05-07 at 5.51.53 PM\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/5/8/589586f7a2dd9e55913caf25215b3279929be1d3_2_345x204.png\" alt=\"Screenshot 2024-05-07 at 5.51.53 PM\" data-base62-sha1=\"cDEnqXPFLP1od79gwTQcEQkuAuL\" width=\"345\" height=\"204\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/5/8/589586f7a2dd9e55913caf25215b3279929be1d3_2_345x204.png, https://ethresear.ch/uploads/default/optimized/3X/5/8/589586f7a2dd9e55913caf25215b3279929be1d3_2_517x306.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/5/8/589586f7a2dd9e55913caf25215b3279929be1d3_2_690x408.png 2x\" data-dominant-color=\"DFD6CC\"></a></div><br>\n<div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/6/f/6fb1d284d34adcfa3b1b2f37dd60a1d882111787.png\" data-download-href=\"https://ethresear.ch/uploads/default/6fb1d284d34adcfa3b1b2f37dd60a1d882111787\" title=\"Screenshot 2024-05-07 at 5.52.11 PM\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/6/f/6fb1d284d34adcfa3b1b2f37dd60a1d882111787_2_345x226.png\" alt=\"Screenshot 2024-05-07 at 5.52.11 PM\" data-base62-sha1=\"fW5YS8ixjxAqzsCgAqvYcpdLAnJ\" width=\"345\" height=\"226\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/6/f/6fb1d284d34adcfa3b1b2f37dd60a1d882111787_2_345x226.png, https://ethresear.ch/uploads/default/optimized/3X/6/f/6fb1d284d34adcfa3b1b2f37dd60a1d882111787_2_517x339.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/6/f/6fb1d284d34adcfa3b1b2f37dd60a1d882111787_2_690x452.png 2x\" data-dominant-color=\"F5F0EB\"></a></div><p></p>\n</div>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/8/4/84bf36904da0af478a6813aee89ae47bd80b272d.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/84bf36904da0af478a6813aee89ae47bd80b272d\" title=\"Screenshot 2024-05-07 at 9.03.14 PM\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/8/4/84bf36904da0af478a6813aee89ae47bd80b272d_2_393x374.jpeg\" alt=\"Screenshot 2024-05-07 at 9.03.14 PM\" data-base62-sha1=\"iWkHiuZj8oN1CqWmv4DQ4kdcss5\" width=\"393\" height=\"374\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/8/4/84bf36904da0af478a6813aee89ae47bd80b272d_2_393x374.jpeg, https://ethresear.ch/uploads/default/optimized/3X/8/4/84bf36904da0af478a6813aee89ae47bd80b272d_2_589x561.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/8/4/84bf36904da0af478a6813aee89ae47bd80b272d_2_786x748.jpeg 2x\" data-dominant-color=\"F6F6F6\"></a></div><p></p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/b/0/b0a06aed03cdbbe0c2df234e6a85e586326bcfb0.png\" data-download-href=\"https://ethresear.ch/uploads/default/b0a06aed03cdbbe0c2df234e6a85e586326bcfb0\" title=\"스크린샷 2024-05-13 오후 7.47.01\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/b/0/b0a06aed03cdbbe0c2df234e6a85e586326bcfb0_2_517x110.png\" alt=\"스크린샷 2024-05-13 오후 7.47.01\" data-base62-sha1=\"pcvJ8My13G3kP8yLeS0UhRhAN9K\" width=\"517\" height=\"110\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/b/0/b0a06aed03cdbbe0c2df234e6a85e586326bcfb0_2_517x110.png, https://ethresear.ch/uploads/default/optimized/3X/b/0/b0a06aed03cdbbe0c2df234e6a85e586326bcfb0_2_775x165.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/b/0/b0a06aed03cdbbe0c2df234e6a85e586326bcfb0_2_1034x220.png 2x\" data-dominant-color=\"E8E8E8\"></a></div><p></p>\n<p>We will also open our code&amp;dataset soon.<br>\nWe hope to offer a deeper understanding on the post-upgrade effects and encourage discussions that can help improve the Ethereum ecosystem. Your feedback and insights would be greatly appreciated.</p>\n            <p><small>5 posts - 2 participants</small></p>\n            <p><a href=\"https://ethresear.ch/t/empirical-analysis-of-the-impact-of-eip-4844-on-ethereums-ecosystem/19486\">Read full topic</a></p>","link":"https://ethresear.ch/t/empirical-analysis-of-the-impact-of-eip-4844-on-ethereums-ecosystem/19486","pubDate":"Tue, 07 May 2024 12:36:11 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-19486"},"source":{"@url":"https://ethresear.ch/t/empirical-analysis-of-the-impact-of-eip-4844-on-ethereums-ecosystem/19486.rss","#text":"Empirical Analysis of the Impact of EIP-4844 on Ethereum's Ecosystem"},"filter":false},{"title":"Tiered Commitment Trees to reduce gas costs and offchain complexity","dc:creator":"rymnc","category":"Applications","description":"<p>Discussion post for: <a href=\"https://dev.vac.dev/rlog/rln-light-verifiers/\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">Verifying RLN Proofs in Light Clients with Subtrees | Vac Research</a><br>\ncross-posted to: <a href=\"https://forum.vac.dev/t/light-rln-verifiers-using-a-tiered-commitment-tree/290\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">Light RLN Verifiers using a Tiered Commitment Tree - Vac Rearch Blog Posts - Vac</a></p>\n<p>tl;dr: Implementation of a technique to decrease gas fees associated with a sparse Merkle tree on-chain, while simultaneously minimizing client-side requirements. This solution leverages the segmentation of root computation into subtrees. Notably utilized by projects like Penumbra and Polygon Miden, this approach also facilitates trustless availability of the Merkle tree root on-chain, even when using a zk-friendly hash function that is more costly within the EVM environment.</p>\n<p>Can be used for Semaphore/RLN.</p>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://ethresear.ch/t/tiered-commitment-trees-to-reduce-gas-costs-and-offchain-complexity/19484\">Read full topic</a></p>","link":"https://ethresear.ch/t/tiered-commitment-trees-to-reduce-gas-costs-and-offchain-complexity/19484","pubDate":"Tue, 07 May 2024 10:22:56 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-19484"},"source":{"@url":"https://ethresear.ch/t/tiered-commitment-trees-to-reduce-gas-costs-and-offchain-complexity/19484.rss","#text":"Tiered Commitment Trees to reduce gas costs and offchain complexity"},"filter":false},{"title":"Sharded Recursive zk-SNARK Proofs","dc:creator":"cryptskii","category":"zk-s[nt]arks","description":"<p><strong>TL;DR</strong> In a sharded blockchain protocol that utilizes recursive zk-SNARK proofs to enable scalable, private cross-shard transactions with constant-size proofs of validity. This architecture allows for horizontal scaling while maintaining strong privacy guarantees.</p>\n<p><strong>Background</strong> Existing blockchain systems face significant challenges in terms of scalability and privacy. Sharding is a promising approach to improve transaction throughput by parallelizing computation across multiple chains. However, cross-shard communication remains a bottleneck, as verifying transactions across shards typically requires expensive cross-shard proofs.</p>\n<p>Zero-knowledge proofs, particularly zk-SNARKs, offer a powerful tool for enhancing privacy by allowing users to prove knowledge of secret information without revealing it. Unfortunately, generating and verifying zk-SNARK proofs incurs high computational overhead, limiting their practicality for large-scale applications.</p>\n<p>Prior solutions have attempted to combine zk-SNARKs with sharding, but fail to fully address the scalability challenges. For example, Zexe uses zk-SNARKs in a sharded setting but requires storing a linear-size “state proof” on-chain. Coda achieves constant-size proofs using recursive composition, but lacks the horizontal scaling benefits of sharding.</p>\n<p><strong>Proposal</strong> We introduce a novel construction that synergistically combines sharding with recursive zk-SNARK proofs for unparalleled scalability and privacy.</p>\n<p>At the core of this DLT is a hierarchy of zk-SNARK proofs that recursively attest to the validity of state transitions within and across shards. Each shard generates succinct proofs, called Zero-Knowledge Balance &amp; Inclusion State Proofs (ZkBISPs), certifying the correctness of their local state updates. These ZkBISPs are then aggregated by a designated coordinator into a global proof, termed a Zero-Knowledge Succinct Nested Global-state Proof (ZkSNGP).</p>\n<p>Crucially, the ZkSNGP is a constant-size proof that recursively verifies the validity of all shard-level ZkBISPs, thereby providing a succinct and efficient means to prove the integrity of the entire cross-shard state transition. Verifying the ZkSNGP requires only logarithmic time in the number of shards, enabling exponential savings compared to naively checking each shard’s proofs individually.</p>\n<p>Formally, we define the intra-shard state transition language <span class=\"math\">\\mathcal{L}_{\\mathsf{ST}}^{(t,i)}</span> for each shard <span class=\"math\">i</span> at epoch <span class=\"math\">t</span> as the set of tuples <span class=\"math\">(x, w)</span> where:</p>\n<ul>\n<li>The statement <span class=\"math\">x = (\\mathsf{shardID}_i, \\mathsf{root}_i^{(t-1)}, \\mathsf{root}_i^{(t)}, B_i^{(t)})</span> includes the shard ID, starting and ending state roots, and final account balances.</li>\n<li>The witness <span class=\"math\">w = (\\mathsf{txs}_i^{(t)}, \\mathcal{T}_i^{(t-1)}, \\mathcal{T}_i^{(t)})</span> contains the list of transactions, along with the initial and final account state trees.</li>\n<li><span class=\"math\">(x, w) \\in \\mathcal{L}_{\\mathsf{ST}}^{(t,i)} \\Leftrightarrow \\mathsf{root}_i^{(t-1)} = H(\\mathcal{T}_i^{(t-1)}) \\wedge \\mathsf{root}_i^{(t)} = H(\\mathcal{T}_i^{(t)}) \\wedge \\text{transition}(\\mathcal{T}_i^{(t-1)}, \\mathsf{txs}_i^{(t)}) \\rightarrow \\mathcal{T}_i^{(t)}</span>, i.e, the roots match the account trees and the final tree results from applying valid transactions to the initial tree.</li>\n</ul>\n<p>Similarly, we define the cross-shard state transition language <span class=\"math\">\\mathcal{L}_{\\mathsf{CST}}^{(t)}</span> for epoch <span class=\"math\">t</span> as the set of tuples <span class=\"math\">(x, w)</span> where:</p>\n<ul>\n<li>The statement <span class=\"math\">x = (\\mathsf{root}_G^{(t-1)}, \\mathsf{root}_G^{(t)})</span> consists of the starting and ending global state roots.</li>\n<li>The witness <span class=\"math\">w = \\left(\\left\\{\\left(\\mathsf{shardID}_i, \\pi_{\\mathsf{ST},i}^{(t)}, \\mathsf{root}_i^{(t-1)},\\mathsf{root}_i^{(t)}, B_i^{(t)}\\right)\\right\\}_{i=1}^{\\ell},\\mathcal{T}_G^{(t-1)},\\mathcal{T}_G^{(t)}\\right)</span> includes the shard IDs, ZkBISPs, local roots and balances, and global account trees.</li>\n<li><span class=\"math\">(x, w) \\in \\mathcal{L}_{\\mathsf{CST}}^{(t)} \\Leftrightarrow \\forall i: \\mathsf{Verify}_{\\mathsf{ST}}(\\mathsf{vk}_{\\mathsf{ST}}, x_i, \\pi_{\\mathsf{ST},i}^{(t)}) \\wedge \\mathsf{root}_G^{(t-1)} = H(\\mathcal{T}_G^{(t-1)}) \\wedge \\mathsf{root}_G^{(t)} = H(\\mathcal{T}_G^{(t)}) \\wedge \\text{merge}(\\mathcal{T}_G^{(t-1)}, \\{\\mathsf{root}_i^{(t)}, B_i^{(t)}\\}_{i=1}^{\\ell}) \\rightarrow \\mathcal{T}_G^{(t)}</span>, i.e., the ZkBISPs verify w.r.t. their shards, the Merkle roots match, and the final global tree is the result of correctly merging the shards’ final local trees and balances.</li>\n</ul>\n<p>A shard’s ZkBISP for epoch <span class=\"math\">t</span> is generated as <span class=\"math\">\\pi_{\\mathsf{ST},i}^{(t)} \\leftarrow \\mathsf{Prove}_{\\mathsf{ST}}(\\mathsf{pk}_{\\mathsf{ST}}, x_i, w_i)</span> for <span class=\"math\">(x_i, w_i) \\in \\mathcal{L}_{\\mathsf{ST}}^{(t,i)}</span>, where <span class=\"math\">\\mathsf{pk}_{\\mathsf{ST}}</span> is the proving key for the corresponding zk-SNARK scheme. The coordinator’s ZkSNGP is computed analogously as <span class=\"math\">\\pi_{\\mathsf{CST}}^{(t)} \\leftarrow \\mathsf{Prove}_{\\mathsf{CST}}(\\mathsf{pk}_{\\mathsf{CST}}, x, w)</span> for <span class=\"math\">(x, w) \\in \\mathcal{L}_{\\mathsf{CST}}^{(t)}</span></p>\n<p>The coordinator, randomly selected in each epoch, collects these ZkBISPs along with the shards’ final state roots <span class=\"math\">\\mathsf{root}_i^{(t)}</span> and account balances <span class=\"math\">B_i^{(t)}</span>. It then generates the ZkSNGP <span class=\"math\">\\pi_{\\mathsf{CST}}^{(t)}</span> (green proof) certifying the validity of the overall state transition, including the correct application of all shard-level updates to the global state.</p>\n<p><strong>Advantages</strong> The network simultaneously achieves exceptional horizontal scalability and privacy without sacrificing security or decentralization.</p>\n<p>In terms of scalability, the concept supports an unprecedented number of shards and transactions per second while retaining a constant-size proof of the system’s entire state. Concretely, if there are <span class=\"math\">\\ell</span> shards each processing <span class=\"math\">N</span> transactions, the communication cost per epoch is only <span class=\"math\">O(\\ell)</span> for the coordinator to collect the ZkBISPs, and the ZkSNGP proof adds just <span class=\"math\">O(1)</span> to the blockchain size. Crucially, verifying the ZkSNGP requires <span class=\"math\">O(\\log \\ell)</span> time, an exponential speedup compared to naively verifying all <span class=\"math\">\\ell</span> shards.</p>\n<p>For example, suppose the network is instantiated with <span class=\"math\">\\ell = 2^{10}</span> shards, each processing <span class=\"math\">N = 2^{20}</span> transactions in 2-minute epochs. This configuration could support a peak throughput of roughly 1 billion transactions per epoch, or 500,000 transactions per second, with a ZkSNGP verification time of only <span class=\"math\">10\\log \\ell \\approx 100</span> ms on ordinary hardware. The recursive proof would contribute a mere 1 KB to the blockchain per epoch, maintaining years of history in a highly compact format.</p>\n<p>In terms of privacy, the ZkSNGPs inherit the zero-knowledge property of the underlying zk-SNARK scheme, revealing nothing about the shards’ local transactions beyond the final state roots and balances. An adversary that compromises the coordinator cannot glean any additional information, as the shards’ ZkBISPs are similarly zero-knowledge. Transactional privacy thus holds as long as at least one shard remains honest.</p>\n<p>Compared to prior sharded blockchain designs, the network is the first to achieve sublinear proof sizes and verification times by recursively composing zk-SNARKs. Relative to Zexe, the network attains a qualitative improvement in scalability by eliminating the linear-size “state proof” in favor of constant-size ZkSNGPs. Compared to Coda, the network offers strictly stronger performance due to its sharded architecture, while still leveraging Coda’s core technique of recursive proof composition.</p>\n<p><strong>Applications</strong> the network’s dual emphasis on scalability and privacy renders it a natural foundation for a variety of high-throughput, privacy-centric blockchain applications.</p>\n<p>On the payments front, the network could serve as a backend for a globally-scalable digital currency with strong confidentiality guarantees, concealing both transaction amounts and participants. The subtransactions within each shard could clear near-instantaneously, while cross-shard payments would incur a maximum delay of one epoch (e.g., 2 minutes) before the ZkSNGP confirms finality. This would support a substantially higher payment volume than existing solutions like Zcash without leaking metadata.</p>\n<p>More broadly, the network could function as a privacy-preserving platform for general smart contract execution. Shards would not only process token transfers but also arbitrary state transitions, with the ZkBISPs and ZkSNGP verifying the correctness of all contract logic and dependencies. This would enable complex applications such as private decentralized exchanges, automated market makers, and lending protocols to run at scale, without disclosing individual users’ balances or positions.</p>\n<p>The network’s sharded architecture could also be adapted to specific domains to meet their unique performance requirements. For instance, a decentralized adtech ecosystem that handles billions of micropayments per day could utilize more granular sharding (e.g., <span class=\"math\">\\ell = 2^{20}</span> shards), with each shard perhaps corresponding to a particular geographic region or publisher. A secure messaging app that routes payments alongside packets could likewise tune its cross-shard spanning tree structure based on network topology.</p>\n<p><strong>Conclusion</strong> the network introduces a powerful new paradigm for designing scalable and private blockchain protocols through recursive zk-SNARK proof composition. By strategically combining recursive proofs with sharding, the network enables a significant breakthrough in blockchain performance, supporting over a million transactions per second with sublinear proof sizes and verification times.</p>\n            <p><small>15 posts - 2 participants</small></p>\n            <p><a href=\"https://ethresear.ch/t/sharded-recursive-zk-snark-proofs/19480\">Read full topic</a></p>","link":"https://ethresear.ch/t/sharded-recursive-zk-snark-proofs/19480","pubDate":"Mon, 06 May 2024 19:04:30 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-19480"},"source":{"@url":"https://ethresear.ch/t/sharded-recursive-zk-snark-proofs/19480.rss","#text":"Sharded Recursive zk-SNARK Proofs"},"filter":false},{"title":"Coded ZKP/FHE, a decentralized, collaborative, robust ZKP/FHE System","dc:creator":"0x1cc","category":"zk-s[nt]arks","description":"<h2><a name=\"tldr-1\" class=\"anchor\" href=\"https://ethresear.ch#tldr-1\"></a>TL;DR</h2>\n<ul>\n<li>\n<p>For a ZKP/FHE task, we can decompose it into several subtasks.</p>\n</li>\n<li>\n<p>We introduce redundancy into subtasks such that the original task’s result can be decoded from a subset of the subtask results, treating uncompleted subtasks as erasures. This is similar to the erasure code design in DA.</p>\n</li>\n<li>\n<p>For a <span class=\"math\">(n,k)</span> coded ZKP/FHE system, we can decompose a ZKP/FHE task into <span class=\"math\">n</span> subtasks, with <span class=\"math\">k \\leq n</span> subtask results, we can obtain the original task’s result.</p>\n</li>\n<li>\n<p>With this coded design, we can design a decentralized, collaborative, robust ZKP/FHE system.</p>\n</li>\n</ul>\n<h2><a name=\"background-2\" class=\"anchor\" href=\"https://ethresear.ch#background-2\"></a>Background</h2>\n<p>ZKP/FHE systems play a pivotal role in blockchain ecosystems, ensuring privacy and enabling cost-effective verification. However, the resource-intensive nature of ZKP generation and FHE computation presents a significant challenge. To address this, numerous distributed algorithms have been devised to enhance scalability and are now integral to ZKP/FHE mining pools.</p>\n<p>For instance, complex ZKP tasks can be subdivided into smaller subtasks, which are then distributed across multiple nodes for parallel processing. However, the efficacy of existing distributed algorithms falls short in ensuring robustness, hindering the realization of decentralized and collaborative systems.</p>\n<p>Consider a scenario where a ZKP task is divided into <span class=\"math\">k</span> subtasks and allocated to <span class=\"math\">k</span> distinct nodes. Should one of these nodes fail to respond promptly, the entire computation process is stalled. While redundancy mechanisms, such as assigning each subtask to two nodes, may mitigate this risk, vulnerabilities persist. Even with this redundancy, if both nodes assigned to a task fail to respond in a timely manner, computational delays ensue.</p>\n<p>In summary, while distributed algorithms offer scalability benefits, their current limitations impede the development of resilient decentralized and collaborative ZKP/FHE systems. Addressing these shortcomings is essential for advancing the efficacy and reliability of such systems within blockchain environments.</p>\n<h2><a name=\"proposal-3\" class=\"anchor\" href=\"https://ethresear.ch#proposal-3\"></a>Proposal</h2>\n<p>In this proposal, we introduce redundancy into subtasks to enhance the robustness of Zero-Knowledge Proof/Fully Homomorphic Encryption (ZKP/FHE) systems, akin to the erasure code design in Distributed Algorithms (DA). Specifically, in a <span class=\"math\">(n,k)</span> coded ZKP/FHE system, a ZKP/FHE task is decomposed into <span class=\"math\">n</span> subtasks, which are then distributed across <span class=\"math\">n</span> nodes. With a minimum of <span class=\"math\">k</span> completed subtask results, where <span class=\"math\">k \\leq n</span>, the original task’s result can be obtained.</p>\n<p>To illustrate this concept, let’s consider a toy model of matrix multiplication in zkML/fheML.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/2/b/2b2ff2f906f369f930c8722e9adf55b9d01aab43.png\" data-download-href=\"https://ethresear.ch/uploads/default/2b2ff2f906f369f930c8722e9adf55b9d01aab43\" title=\"Snipaste_2024-05-05_15-58-22\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/2/b/2b2ff2f906f369f930c8722e9adf55b9d01aab43_2_690x211.png\" alt=\"Snipaste_2024-05-05_15-58-22\" data-base62-sha1=\"6a3ge5hL9EV9Kgttvdh7Uep3tDB\" width=\"690\" height=\"211\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/2/b/2b2ff2f906f369f930c8722e9adf55b9d01aab43_2_690x211.png, https://ethresear.ch/uploads/default/original/3X/2/b/2b2ff2f906f369f930c8722e9adf55b9d01aab43.png 1.5x, https://ethresear.ch/uploads/default/original/3X/2/b/2b2ff2f906f369f930c8722e9adf55b9d01aab43.png 2x\" data-dominant-color=\"E2E1E1\"></a></div><p></p>\n<p>Consider a system comprising three worker nodes and one master node. In this setup, a data matrix <span class=\"math\">A</span> is divided into two submatrices, <span class=\"math\">A_1</span> and <span class=\"math\">A_2</span>. Specifically, node <span class=\"math\">W_1</span> stores <span class=\"math\">A_1</span>, node <span class=\"math\">W_2</span> stores <span class=\"math\">A_2</span>, and node <span class=\"math\">W_3</span> stores the sum <span class=\"math\">A_1 + A_2</span>. Upon receiving input <span class=\"math\">X</span>, each node computes the product of <span class=\"math\">X</span> with the respective stored matrix and transmits the result to the master node. Notably, the master node can reconstruct the product <span class=\"math\">AX</span> upon receiving any two products, thus obviating the need to await the slowest response. For instance, consider a scenario where the master node receives <span class=\"math\">A_1X</span> and <span class=\"math\">(A_1 + A_2)X</span>. Through subtracting <span class=\"math\">A_1X</span> from <span class=\"math\">(A_1 + A_2)X</span>, the master node can deduce <span class=\"math\">A_2X</span> and consequently reconstruct <span class=\"math\">AX</span>.</p>\n<p>We can further adopt an <span class=\"math\">(n,k)</span> MDS code in this matrix multiplication example for generalization. For example, in zkML or fheML, we can adopt the <span class=\"math\">(n,k)</span> coded approach to design a decentralized, collaborative, robust ZKP/FHE System. In zkML, we can decompose the task into <span class=\"math\">n</span> subtasks, with the results and zkp of <span class=\"math\">k</span> subtasks, we can aggravate the zkp of these subtasks with the decoded process. In fheML, we can decompose the task into <span class=\"math\">n</span> subtasks, with the results of <span class=\"math\">k</span> subtasks, we can apply the fhe computation on the decoded process.</p>\n<p>The preceding discussion has focused on a particular use case, namely zkML/fheML. The coded design methodology explored can be extrapolated to the foundational elements of the ZKP/FHE framework, facilitating the creation of a comprehensive coded ZKP/FHE system capable of supporting applications such as zkRollup and fheEVM computation.</p>\n<p>Specifically, this coded approach can be applied to various components of the ZKP system, enabling the development of a distributed coded system. For instance, the R1CS instance in ZKP involves numerous multi-scalar multiplications, which can seamlessly integrate with the coded design. With the distributed computation algorithms applied in current distributed ZKP systems, we can further enhance the efficiency and scalability.</p>\n<p>I may design and implement a PoC version of the coded ZKP system in my free time <img src=\"https://ethresear.ch/images/emoji/facebook_messenger/smiley.png?v=12\" title=\":smiley:\" class=\"emoji\" alt=\":smiley:\" loading=\"lazy\" width=\"20\" height=\"20\"></p>\n<h2><a name=\"advantages-4\" class=\"anchor\" href=\"https://ethresear.ch#advantages-4\"></a>Advantages</h2>\n<ul>\n<li>\n<p>This coded design significantly accelerates computation within ZKP/FHE systems. Theoretically, assuming a node count of <span class=\"math\">n</span> and subtask runtimes with exponential tails, the coded approach could be <span class=\"math\">\\theta(\\log n)</span> times faster than conventional uncoded distributed algorithms.</p>\n</li>\n<li>\n<p>With this coded design, the ZKP/FHE system is more robust. For example, in a <span class=\"math\">(n,k)</span> coded ZKP/FHE system, we can tolerate the downtime or delay of <span class=\"math\">n-k</span> nodes.</p>\n</li>\n</ul>\n<h2><a name=\"applications-5\" class=\"anchor\" href=\"https://ethresear.ch#applications-5\"></a>Applications</h2>\n<p>Utilizing the coded design paradigm, a ZKP/FHE mining pool can be devised, where decentralized agents function as worker nodes engaged in the computation of subtasks. The managerial role within this context is assumed by the manager of the mining pool, serving as the master node responsible for aggregating and decoding the results submitted by the worker nodes. Furthermore, the conventional master node architecture can be supplanted by a smart contract, assuming the duties of result aggregation and decoding. This architectural transformation facilitates the establishment of a decentralized, collaborative, and resilient ZKP/FHE system, wherein cryptographic operations are conducted in a distributed manner, enhancing the system’s robustness and scalability.</p>\n<h2><a name=\"conclusion-6\" class=\"anchor\" href=\"https://ethresear.ch#conclusion-6\"></a>Conclusion</h2>\n<p>By breaking down ZKP/FHE tasks into subtasks and incorporating redundancy, a <span class=\"math\">(n,k)</span> coded ZKP/FHE system emerges, enabling the decomposition of tasks into <span class=\"math\">n</span> subtasks, with <span class=\"math\">k \\leq n</span> subtask results required for task reconstruction. This coded approach facilitates the creation of decentralized, collaborative, and resilient ZKP/FHE systems, promising enhanced efficiency and reliability in cryptographic operations.</p>\n            <p><small>12 posts - 7 participants</small></p>\n            <p><a href=\"https://ethresear.ch/t/coded-zkp-fhe-a-decentralized-collaborative-robust-zkp-fhe-system/19459\">Read full topic</a></p>","link":"https://ethresear.ch/t/coded-zkp-fhe-a-decentralized-collaborative-robust-zkp-fhe-system/19459","pubDate":"Sun, 05 May 2024 08:01:38 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-19459"},"source":{"@url":"https://ethresear.ch/t/coded-zkp-fhe-a-decentralized-collaborative-robust-zkp-fhe-system/19459.rss","#text":"Coded ZKP/FHE, a decentralized, collaborative, robust ZKP/FHE System"},"filter":false},{"title":"Unbounded Scaling of a fully Decentralized Network without Global Coordination - - May the 4th Be With You","dc:creator":"cryptskii","category":"Consensus","description":"<h1><a name=\"neurodlt-a-neurologically-inspired-distributed-ledger-architecture-1\" class=\"anchor\" href=\"https://ethresear.ch#neurodlt-a-neurologically-inspired-distributed-ledger-architecture-1\"></a>NeuroDLT: A Neurologically-Inspired Distributed Ledger Architecture</h1>\n<p>Brandon “Cryptskii” Ramsay<br>\nMay 4, 2024</p>\n<h2><a name=\"abstract-2\" class=\"anchor\" href=\"https://ethresear.ch#abstract-2\"></a>Abstract</h2>\n<p>We propose a novel distributed ledger architecture drawing inspiration from the information processing principles of biological neural networks. The aim is to develop a highly scalable, efficient, and robust decentralized system for secure data storage and computation. The fundamental processing units are modeled after neurons, maintaining internal state vectors and communicating via synaptic connections. Information encoding and retrieval leverages content-addressable distributed associative memory. Consensus and consistency are achieved through self-organized synchronization of pulse-coupled oscillators. The architecture supports rich computational capabilities including inference, constraint satisfaction, and optimization. The neuromorphic design offers significant advantages in terms of scalability, adaptivity, robustness, and efficiency compared to traditional blockchain approaches.</p>\n<h2><a name=\"h-1-introduction-3\" class=\"anchor\" href=\"https://ethresear.ch#h-1-introduction-3\"></a>1 Introduction</h2>\n<p>Distributed ledger technologies have revolutionized decentralized systems, enabling secure, transparent, and immutable recording of transactions without relying on centralized authorities. However, existing blockchain-based architectures face significant challenges in terms of scalability, efficiency, and adaptability, limiting their widespread adoption and practical utility.</p>\n<p>Biological neural networks, on the other hand, exhibit remarkable capabilities in processing vast amounts of complex, unstructured information with exceptional scalability, efficiency, and robustness. The human brain, consisting of approximately 86 billion neurons connected by 150 trillion synapses, can perform highly sophisticated cognitive tasks while consuming only around 20 watts of power [8].</p>\n<p>Inspired by the computational principles of biological neural networks, we propose a novel distributed ledger architecture that leverages key neurological mechanisms to address the limitations of traditional blockchain systems. By bridging the gap between biological and artificial information processing, this neurologically-inspired architecture aims to create a highly scalable, adaptive, and computationally powerful decentralized system for secure data storage and computation.</p>\n<h2><a name=\"h-2-background-and-related-work-4\" class=\"anchor\" href=\"https://ethresear.ch#h-2-background-and-related-work-4\"></a>2 Background and Related Work</h2>\n<p>The field of distributed ledger technologies has seen significant advancements in recent years, with the emergence of various blockchain platforms such as Bitcoin [20], Ethereum [25], and Hyperledger Fabric [1]. These systems have demonstrated the potential of decentralized, trustless networks for secure and transparent recording of transactions and execution of smart contracts.</p>\n<p>However, existing blockchain architectures suffer from several limitations. The Proof-of-Work (PoW) consensus mechanism used in Bitcoin and Ethereum requires significant computational resources and energy consumption, leading to limited transaction throughput and scalability issues [24]. Alternative consensus mechanisms such as Proof-of-Stake (PoS) and Delegated Proof-of-Stake (DPoS) have been proposed to address these challenges, but they still face trade-offs between security, decentralization, and efficiency [26].</p>\n<p>Recent advancements in neuromorphic computing and brain-inspired architectures have shown promising results in achieving highly efficient and scalable information processing. Neuromorphic chips such as IBM’s TrueNorth [18] and Intel’s Loihi [7] have demonstrated the ability to perform complex cognitive tasks with ultra-low power consumption and high parallelism. These architectures leverage key principles of biological neural networks, such as event-driven computation, distributed memory, and adaptive learning, to achieve remarkable efficiency and robustness.</p>\n<p>Several studies have explored the intersection of neuromorphic computing and blockchain technologies. Baza et al. [2] proposed a blockchain-based framework for secure and efficient data sharing in Internet of Things (IoT) networks using neuromorphic hardware. Calzavara et al. [6] developed a privacy-preserving smart contract execution platform using trusted execution environments and neural networks. However, these approaches focus on integrating neuromorphic components into existing blockchain architectures rather than fundamentally redesigning the distributed ledger system based on neurological principles.</p>\n<p>Our work takes a different approach by proposing a novel distributed ledger architecture that is intrinsically inspired by the computational mechanisms of biological neural networks. By leveraging the inherent scalability, adaptivity, and efficiency of neurological information processing, we aim to create a fundamentally new paradigm for decentralized systems that can overcome the limitations of traditional blockchain approaches.</p>\n<h2><a name=\"h-3-neuron-like-node-architecture-5\" class=\"anchor\" href=\"https://ethresear.ch#h-3-neuron-like-node-architecture-5\"></a>3 Neuron-like Node Architecture</h2>\n<h3><a name=\"h-31-node-dynamics-6\" class=\"anchor\" href=\"https://ethresear.ch#h-31-node-dynamics-6\"></a>3.1 Node Dynamics</h3>\n<p>The fundamental processing units in the proposed architecture are modeled after the functional properties of biological neurons. Each node <span class=\"math\">i</span> maintains an internal state vector <span class=\"math\">s_i \\in \\mathbb{R}^n</span> analogous to the membrane potential of a neuron, encoding its current activation level. The temporal evolution of a node’s state is governed by the dynamical system:</p>\n<p><span class=\"math\">\\frac{ds_i}{dt} = f\\left( \\sum_{j \\in N_i} w_{ij} s_j(t) \\right)</span></p>\n<p>The temporal evolution of a node’s state <span class=\"math\">s_i</span> is governed by this differential equation, where <span class=\"math\">N_i</span> denotes the set of nodes with incoming synaptic connections to node <span class=\"math\">i</span>, <span class=\"math\">w_{ij}</span> is the synaptic weight of the connection from node <span class=\"math\">j</span> to node <span class=\"math\">i</span>, and <span class=\"math\">f(\\cdot)</span> is a non-linear activation function applied element-wise to the weighted sum of inputs. This equation captures the dynamics of how each node’s state changes over time based on the input it receives from its neighbors.</p>\n<p>where <span class=\"math\">N_i</span> denotes the set of nodes with incoming synaptic connections to node <span class=\"math\">i</span>, <span class=\"math\">w_{ij}</span> is the synaptic weight of the connection from node <span class=\"math\">j</span> to node <span class=\"math\">i</span>, and <span class=\"math\">f(\\cdot)</span> is a non-linear activation function applied element-wise to the weighted sum of inputs. Suitable choices for the activation function include the logistic sigmoid <span class=\"math\">f(x) = (1 + \\exp(-x))^{-1}</span> or the rectified linear unit (ReLU) <span class=\"math\">f(x) = \\max(0, x)</span> commonly employed in artificial neural networks.</p>\n<p>When a node’s internal state crosses a firing threshold <span class=\"math\">\\theta_i</span>, it generates an output spike that is transmitted to its downstream neighbors. This thresholding mechanism can be expressed as:</p>\n<p><span class=\"math\">\\textrm{output}_i(t) = \n\\begin{cases}\n1, &amp; \\text{if } s_i(t) \\geq \\theta_i \\\\\n0, &amp; \\text{otherwise}\n\\end{cases}</span></p>\n<p>The firing threshold <span class=\"math\">\\theta_i</span> is dynamically modulated as a function of the node’s recent firing history to implement adaptive homeostatic regulation of its excitability and maintain a target average firing rate.</p>\n<p><strong>Definition 1 (Node State Update).</strong> The internal state of a node <span class=\"math\">i</span> is updated according to the following discrete-time equation:</p>\n<p><span class=\"math\">s_i[t+1] = f\\left( \\sum_{j \\in N_i} w_{ij} s_j[t] \\right)</span></p>\n<p>where <span class=\"math\">t</span> denotes the discrete time step.</p>\n<p><strong>Example 1 (Sigmoid Activation).</strong> For a node with a logistic sigmoid activation function, the state update equation becomes:</p>\n<p><span class=\"math\">s_i[t+1] = \\frac{1}{1 + \\exp\\left(-\\sum_{j \\in N_i} w_{ij} s_j[t]\\right)}</span></p>\n<h3><a name=\"h-32-synaptic-plasticity-7\" class=\"anchor\" href=\"https://ethresear.ch#h-32-synaptic-plasticity-7\"></a>3.2 Synaptic Plasticity</h3>\n<p>Synaptic plasticity refers to the dynamic modification of synaptic strengths based on the correlated activity patterns of pre- and post-synaptic nodes. A well-established synaptic learning rule is spike-timing-dependent plasticity (STDP) [4], which updates the synaptic weight <span class=\"math\">w_{ij}</span> based on the relative timing of spikes between nodes <span class=\"math\">i</span> and <span class=\"math\">j</span>:</p>\n<p><span class=\"math\">\\frac{dw_{ij}}{dt} = \n\\begin{cases}\nA_+ \\exp\\left(-\\frac{|\\Delta t|}{\\tau_+}\\right), &amp; \\text{if } \\Delta t &gt; 0 \\\\\n-A_- \\exp\\left(-\\frac{|\\Delta t|}{\\tau_-}\\right), &amp; \\text{if } \\Delta t &lt; 0\n\\end{cases}</span></p>\n<p>The synaptic weight <span class=\"math\">w_{ij}</span> between nodes <span class=\"math\">i</span> and <span class=\"math\">j</span> is updated according to this spike-timing-dependent plasticity (STDP) learning rule. Here, <span class=\"math\">\\Delta t = t_j - t_i</span> represents the time difference between the spikes of nodes <span class=\"math\">i</span> and <span class=\"math\">j</span>. The parameters <span class=\"math\">\\tau_+</span> and <span class=\"math\">\\tau_-</span> set the time scales for potentiation and depression, respectively, while <span class=\"math\">A_+</span> and <span class=\"math\">A_-</span> control the maximum weight changes. This rule captures the idea that synaptic weights are strengthened when the pre-synaptic neuron fires before the post-synaptic neuron (causality), and weakened when the order is reversed (acausality).</p>\n<p>where <span class=\"math\">\\Delta t = t_j - t_i</span> is the time difference between spikes of nodes <span class=\"math\">i</span> and <span class=\"math\">j</span>, <span class=\"math\">\\tau_+</span> and <span class=\"math\">\\tau_-</span> set the time scales for potentiation and depression, and <span class=\"math\">A_+</span> and <span class=\"math\">A_-</span> control the maximum weight changes. This STDP rule implements a form of Hebbian learning, allowing the network to discover and amplify causal associations between neural activities. Over time, this leads to the self-organized emergence of meaningful connectivity patterns optimized for the particular data streams and computational tasks, without requiring centralized control or explicit programming.</p>\n<p><strong>Definition 2 (STDP Update).</strong> The synaptic weight <span class=\"math\">w_{ij}</span> between nodes <span class=\"math\">i</span> and <span class=\"math\">j</span> is updated according to the STDP rule:</p>\n<p><span class=\"math\">w_{ij} \\leftarrow w_{ij} + \\eta \\Delta w_{ij}</span></p>\n<p>where <span class=\"math\">\\eta</span> is the learning rate and <span class=\"math\">\\Delta w_{ij}</span> is the weight change computed using Equation (??).</p>\n<p><strong>Theorem 1 (Convergence of STDP).</strong> Under suitable conditions on the learning rate <span class=\"math\">\\eta</span> and the STDP time constants <span class=\"math\">\\tau_+</span> and <span class=\"math\">\\tau_-</span>, the synaptic weights converge to a stable equilibrium that maximizes the mutual information between the pre- and post-synaptic activities.</p>\n<p><em>Proof.</em> The proof follows from the analysis of the STDP learning rule as a stochastic gradient descent algorithm on the mutual information objective. See [3] for a detailed derivation.</p>\n<p>In addition to modifying synaptic weights, the network topology itself can adapt by periodically adding or pruning connections based on their long-term statistics and utility for the network’s overall information processing. This dynamic rewiring enables the system to flexibly reconfigure its architecture in response to changing demands and environments.</p>\n<p><strong>Algorithm 1 Adaptive Network Rewiring</strong></p>\n<pre><code class=\"lang-auto\">1: procedure RewireNetwork(G, λ, γ)\n2:   Initialize connectivity graph G = (V, E)\n3:   for each time step t do\n4:     for each node i ∈ V do\n5:       Sample candidate connections (i, j) with probability exp(c_ij/λ)\n6:       Prune connections (i, j) with probability exp(-|w_ij|/γ)\n7:     end for\n8:     Update connectivity graph G with new connections  \n9:   end for\n10: end procedure\n</code></pre>\n<p><span class=\"math\">\\lambda</span> and <span class=\"math\">\\gamma</span> are temperature parameters controlling the exploration-exploitation trade-off in adding and pruning connections, respectively. The algorithm balances the formation of new connections based on their temporal correlations <span class=\"math\">c_{ij}</span> and the removal of weak connections based on their absolute synaptic weights <span class=\"math\">|w_{ij}|</span>.</p>\n<h2><a name=\"h-4-distributed-associative-memory-8\" class=\"anchor\" href=\"https://ethresear.ch#h-4-distributed-associative-memory-8\"></a>4 Distributed Associative Memory</h2>\n<p>Information is encoded and stored in the network using a distributed content-addressable memory scheme. Each data item <span class=\"math\">x \\in \\mathbb{R}^d</span> is assigned a random binary key <span class=\"math\">k \\in \\{0,1\\}^m</span> that serves as a unique identifier. The data item is then encoded by activating the internal state vectors <span class=\"math\">s_i</span> of the nodes whose feature vectors <span class=\"math\">f_i \\in \\{0,1\\}^m</span> have the highest dot product similarity with the key:</p>\n<p><span class=\"math\">S_x = \\{i \\in V \\mid k \\cdot f_i \\text{ is among the top } K \\text{ values}\\}</span></p>\n<p>Here, <span class=\"math\">V</span> denotes the set of all nodes in the network, and <span class=\"math\">K</span> is a sparsity parameter controlling the number of nodes selected for encoding each data item. The feature vectors <span class=\"math\">f_i</span> are fixed random projections that map the high-dimensional keys to a lower-dimensional space, effectively implementing a form of locality-sensitive hashing (LSH) [13].</p>\n<p>To retrieve a data item given its key <span class=\"math\">k'</span>, the nodes with the highest feature similarity to the query key are activated, and the network dynamics are allowed to evolve according to Equation (??). The internal states of the activated nodes will converge to an attractor pattern representing the stored memory associated with the key. The retrieved data item can then be reconstructed from the stable node activations.</p>\n<p>This distributed associative memory scheme provides several advantages in terms of scalability, robustness, and efficiency:</p>\n<ul>\n<li>Scalability: The memory capacity of the network grows linearly with the number of nodes, allowing for massively parallel storage and retrieval of large-scale datasets.</li>\n<li>Robustness: The distributed encoding ensures graceful degradation in the presence of node failures or data corruptions. Partial or noisy keys can still retrieve the correct data item through the network’s pattern completion capabilities.</li>\n<li>Efficiency: The content-addressable nature of the memory enables fast and efficient retrieval of data items without requiring explicit search or indexing structures.</li>\n</ul>\n<p><strong>Definition 3 (Associative Memory Encoding).</strong> A data item <span class=\"math\">x \\in \\mathbb{R}^d</span> with key <span class=\"math\">k \\in \\{0,1\\}^m</span> is encoded in the network by activating the internal states of the nodes in the set <span class=\"math\">S_x</span> defined by:</p>\n<p><span class=\"math\">S_x = \\{i \\in V \\mid k \\cdot f_i \\geq \\theta\\}</span></p>\n<p>where <span class=\"math\">\\theta</span> is a similarity threshold.</p>\n<p><strong>Theorem 2 (Memory Capacity).</strong> For a network with <span class=\"math\">N</span> nodes and an average node degree <span class=\"math\">\\bar{d}</span>, the memory capacity <span class=\"math\">C</span> scales as:</p>\n<p><span class=\"math\">C = O\\left(\\frac{N}{\\bar{d}\\log N}\\right)</span></p>\n<p>assuming a sparse connectivity pattern and independent random feature vectors.</p>\n<p><em>Proof.</em> The proof follows from analyzing the associative memory as a random graph with a constraint on the average degree. The memory capacity is derived using information-theoretic arguments based on the entropy of the stored patterns. See [21] for a detailed analysis.</p>\n<p><strong>Algorithm 2 Associative Memory Retrieval</strong></p>\n<pre><code class=\"lang-auto\"> 1: procedure RetrieveData(k')\n 2:   Initialize query key k'\n 3:   Compute similarity scores k' · f_i for all nodes i ∈ V\n 4:   Select top K nodes with highest similarity scores as the activated set S_k'\n 5:   for each node i ∈ S_k' do\n 6:     Set initial state s_i[0] based on similarity score\n 7:   end for\n 8:   for t = 1 to T do\n 9:     for each node i ∈ S_k' do\n10:       Update state s_i[t] according to Equation (??)\n11:     end for\n12:   end for\n13:   Reconstruct retrieved data item xˆ from stable node states\n14:   return xˆ \n15: end procedure\n</code></pre>\n<p>The retrieval algorithm first computes the similarity scores between the query key <span class=\"math\">k'</span> and the feature vectors <span class=\"math\">f_i</span> of all nodes in the network. The top <span class=\"math\">K</span> nodes with the highest similarity scores are selected as the activated set <span class=\"math\">S_{k'}</span>. The initial states of these nodes are set based on their respective similarity scores, providing a starting point for the network dynamics.</p>\n<p>The algorithm then iteratively updates the states of the activated nodes for a fixed number of time steps <span class=\"math\">T</span> according to the node dynamics equation (??). During this process, the network settles into a stable attractor state that represents the retrieved memory associated with the query key.</p>\n<p>Finally, the retrieved data item <span class=\"math\">\\hat{x}</span> is reconstructed from the stable node states. This reconstruction can be performed using various methods, such as taking the average or weighted sum of the node states, depending on the specific encoding scheme used.</p>\n<p>The properties of the associative memory retrieval process can be formally analyzed using dynamical systems theory and attractor network models [10]. The convergence and stability of the retrieval dynamics depend on factors such as the network connectivity, the choice of activation function, and the noise level in the query key.</p>\n<p><strong>Theorem 3 (Retrieval Convergence).</strong> Under suitable conditions on the network connectivity and the activation function, the associative memory retrieval algorithm converges to a stable attractor state within a finite number of iterations.</p>\n<p><em>Proof.</em> The proof relies on analyzing the retrieval dynamics as a discrete-time dynamical system and showing that the energy function of the network decreases monotonically over time. The convergence to a stable attractor state follows from the existence of a Lyapunov function for the system. See [5] for a detailed analysis.</p>\n<p>The distributed associative memory scheme provides a powerful and efficient mechanism for storing and retrieving large-scale datasets in a decentralized manner. The content-addressable nature of the memory, combined with the robustness and scalability of the distributed encoding, enables fast and reliable access to stored information even in the presence of node failures or partial keyinformation.</p>\n<h2><a name=\"h-5-decentralized-consensus-protocol-9\" class=\"anchor\" href=\"https://ethresear.ch#h-5-decentralized-consensus-protocol-9\"></a>5 Decentralized Consensus Protocol</h2>\n<p>To achieve global consistency and coordination in a fully decentralized setting, the proposed architecture employs a consensus mechanism inspired by the synchronization of pulse-coupled oscillators in biological neural networks [19]. Each node maintains an internal clock variable <span class=\"math\">\\phi_i \\in [0, 2\\pi)</span> that evolves autonomously according to the phase response curve (PRC) model:</p>\n<p><span class=\"math\">\\frac{d\\phi_i}{dt} = \\omega_i + \\sum_{j \\in N_i} K(\\phi_j - \\phi_i)</span></p>\n<p>Here, <span class=\"math\">\\omega_i</span> is the natural frequency of the oscillator, <span class=\"math\">N_i</span> denotes the set of neighboring nodes connected to node <span class=\"math\">i</span>, and <span class=\"math\">K(\\cdot)</span> is the phase response function that determines how the phase of node <span class=\"math\">i</span> is adjusted based on the relative phases of its neighbors.</p>\n<p>When a node’s internal clock reaches a threshold value <span class=\"math\">\\phi^*_i \\in (0, 2\\pi)</span>, typically close to the end of the oscillation cycle, it emits a pulse that is transmitted to its neighbors. Upon receiving a pulse, each neighboring node <span class=\"math\">j</span> updates its own phase according to the PRC:</p>\n<p><span class=\"math\">\\phi_j(t^+) = \\phi_j(t^-) + K(\\phi_j(t^-))</span></p>\n<p>where <span class=\"math\">t^-</span> and <span class=\"math\">t^+</span> denote the times immediately before and after the pulse reception, respectively. The PRC is designed to promote synchronization among the oscillators by pulling the phases of the lagging nodes forward and slowing down the advancing nodes. A common choice for the PRC is the sinusoidal function <span class=\"math\">K(\\phi) = \\varepsilon \\sin(\\phi)</span>, where <span class=\"math\">\\varepsilon</span> is a coupling strength parameter.</p>\n<p>Under suitable conditions on the coupling strength and the natural frequencies, the pulse-coupled oscillator network will self-organize and achieve global synchronization, with all the nodes firing in unison [23]. This emergent consensus enables the decentralized coordination and agreement among the nodes without requiring explicit global communication or centralized control.</p>\n<p><strong>Definition 4 (Pulse-Coupled Oscillator Network).</strong> A pulse-coupled oscillator network is a dynamical system consisting of <span class=\"math\">N</span> oscillators, each characterized by a phase variable <span class=\"math\">\\phi_i \\in [0, 2\\pi)</span> and a natural frequency <span class=\"math\">\\omega_i</span>. The evolution of the phases is governed by the equations:</p>\n<p><span class=\"math\">\\frac{d\\phi_i}{dt} = \\omega_i + \\sum_{j \\in N_i} K(\\phi_j - \\phi_i)</span></p>\n<p><span class=\"math\">\\phi_i(t^+) = \\phi_i(t^-) + K(\\phi_i(t^-)) \\quad \\text{if } \\phi_j(t^-) = \\phi^*_j</span></p>\n<p>where <span class=\"math\">K(\\cdot)</span> is the phase response function and <span class=\"math\">\\phi^*_j</span> is the firing threshold.</p>\n<p><strong>Theorem 4 (Global Synchronization).</strong> For a pulse-coupled oscillator network with <span class=\"math\">N</span> nodes, if the coupling strength <span class=\"math\">\\varepsilon</span> satisfies <span class=\"math\">0 &lt; \\varepsilon &lt; \\frac{1}{N-1}</span> and the natural frequencies <span class=\"math\">\\omega_i</span> are sufficiently close to each other, then the network will achieve global synchronization asymptotically, i.e., <span class=\"math\">\\lim_{t \\to \\infty} |\\phi_i(t) - \\phi_j(t)| = 0</span> for all <span class=\"math\">i,j \\in \\{1, \\ldots, N\\}</span>.</p>\n<p><em>Proof.</em> The proof relies on analyzing the stability of the synchronized state using the linearized dynamics of the phase differences. The condition on the coupling strength ensures that the synchronized state is stable, while the assumption on the natural frequencies guarantees that the oscillators can be pulled into synchronization. The detailed proof can be found in [19].</p>\n<p>The pulse-coupled oscillator synchronization mechanism provides a robust and scalable foundation for achieving decentralized consensus in the proposed distributed ledger architecture. By associating special meanings to the firing events occurring at specific phases of the oscillation cycle, such as validating transactions or committing checkpoints, the network can coordinate and maintain consistent state in a fully decentralized manner.</p>\n<p><strong>Algorithm 3 Decentralized Consensus Protocol</strong></p>\n<pre><code class=\"lang-auto\">1: procedure RunConsensus\n2:   Initialize oscillator phases ϕ_i and frequencies ω_i for all nodes i ∈ V\n3:   while not synchronized do\n4:     for each node i ∈ V do\n5:       Update phase ϕ_i according to the oscillator dynamics\n6:       if ϕ_i reaches the firing threshold ϕ^*_i then\n7:         Emit pulse to neighbors j ∈ N_i\n8:       end if\n9:       if received pulse from neighbor j then\n10:        Update phase ϕ_i according to the PRC\n11:      end if\n12:    end for\n13:  end while\n14:  Perform consensus actions (e.g., validate transactions, commit checkpoints)\n15: end procedure\n</code></pre>\n<p>The decentralized consensus protocol proceeds in rounds, with each round corresponding to one oscillation cycle. At the beginning of each round, the nodes update their phases based on the oscillator dynamics and check if their phases have reached the firing threshold. If a node’s phase reaches the threshold, it emits a pulse to its neighbors.</p>\n<p>Upon receiving pulses from neighbors, nodes update their phases according to the phase response function. This process continues until the network achieves global synchronization, indicated by all the nodes firing in unison.</p>\n<p>Once synchronization is achieved, the nodes perform the consensus actions associated with the specific firing events, such as validating transactions or committing checkpoints. The synchronized firing ensures that all the nodes agree on the timing and order of these actions, maintaining consistency across the network.</p>\n<p>The pulse-coupled oscillator synchronization mechanism offers several advantages over traditional consensus algorithms, such as Byzantine fault tolerance [15] or Proof-of-Work [20]:</p>\n<ul>\n<li>Scalability: The consensus protocol scales efficiently with the size of the network, as the synchronization is achieved through local interactions among neighboring nodes, without requiring global communication or coordination.</li>\n<li>Robustness: The decentralized nature of the synchronization process makes it resilient to node failures and network disruptions. As long as a sufficient number of nodes remain connected, the network can self-organize and maintain consensus.</li>\n<li>Efficiency: The pulse-coupled oscillator model enables fast and efficient synchronization, as the nodes only need to exchange simple pulse signals rather than complex messages or computations.</li>\n</ul>\n<p>The proposed decentralized consensus protocol, based on the synchronization of pulse-coupled oscillators, provides a biologically-inspired and mathematically-grounded approach to achieving robust and scalable consensus in distributed ledger systems. The self-organized synchronization process allows the network to coordinate and maintain consistent state in a fully decentralized manner, enabling secure and efficient operation of the distributed ledger.</p>\n<h2><a name=\"h-6-decentralized-consensus-protocol-with-token-transactions-and-verifications-10\" class=\"anchor\" href=\"https://ethresear.ch#h-6-decentralized-consensus-protocol-with-token-transactions-and-verifications-10\"></a>6 Decentralized Consensus Protocol with Token Transactions and Verifications</h2>\n<p>The proposed neurologically-inspired distributed ledger architecture employs a decentralized consensus protocol based on the synchronization of pulse-coupled oscillators to achieve global consistency and coordination among nodes. This protocol can be extended to facilitate token transactions and verifications, ensuring the integrity and security of the ledger state.</p>\n<p>Each node <span class=\"math\">i</span> in the network maintains an internal clock variable <span class=\"math\">\\phi_i \\in [0, 2\\pi)</span> that evolves autonomously according to the phase response curve (PRC) model:</p>\n<p><span class=\"math\">\\frac{d\\phi_i}{dt} = \\omega_i + \\sum_{j \\in N_i} K(\\phi_j - \\phi_i)</span></p>\n<p>where <span class=\"math\">\\omega_i</span> is the natural frequency of the oscillator, <span class=\"math\">N_i</span> denotes the set of neighboring nodes connected to node <span class=\"math\">i</span>, and <span class=\"math\">K(\\cdot)</span> is the phase response function that determines the phase adjustment based on the relative phases of the neighbors.</p>\n<p>When a node’s internal clock reaches a threshold value <span class=\"math\">\\phi^*_i \\in (0, 2\\pi)</span>, typically close to the end of the oscillation cycle, it emits a pulse that is transmitted to its neighbors. Upon receiving a pulse, each neighboring node <span class=\"math\">j</span> updates its own phase according to the PRC:</p>\n<p><span class=\"math\">\\phi_j(t^+) = \\phi_j(t^-) + K(\\phi_j(t^-))</span></p>\n<p>where <span class=\"math\">t^-</span> and <span class=\"math\">t^+</span> denote the times immediately before and after the pulse reception, respectively.</p>\n<p>To incorporate token transactions and verifications into the consensus protocol, we associate specific firing events with different stages of the transaction processing pipeline. For instance, when a node’s internal clock reaches a designated phase <span class=\"math\">\\phi^{tx}_i \\in (0, \\phi^*_i)</span>, it initiates a token transaction by broadcasting a transaction proposal to its neighbors. The transaction proposal includes the relevant details, such as the sender, recipient, token amount, and a unique transaction identifier.</p>\n<p>Upon receiving a transaction proposal, each node verifies the validity of the transaction by checking the sender’s account balance, the authenticity of the digital signature, and the absence of double-spending attempts. If the transaction is deemed valid, the node incorporates it into its local transaction pool and emits a pulse to signal its approval.</p>\n<p>As the nodes continue to update their phases and emit pulses, the transaction proposals propagate through the network. When a node’s internal clock reaches the firing threshold <span class=\"math\">\\phi^*_i</span>, it collects all the approved transaction proposals received from its neighbors and bundles them into a candidate block. The node then broadcasts the candidate block to the network for further validation.</p>\n<p>During the validation phase, nodes verify the integrity and consistency of the candidate blocks by checking for conflicting transactions, double-spending attempts, and adherence to the consensus rules. If a candidate block receives a sufficient number of approval pulses from the network, it is considered validated and ready for commitment.</p>\n<p>Finally, when the nodes’ internal clocks synchronize and reach a designated commitment phase <span class=\"math\">\\phi^{commit}_i \\in (\\phi^*_i, 2\\pi)</span>, they collectively commit the validated blocks to their local ledgers, updating the token balances and transaction history accordingly. The synchronized firing event ensures that all nodes agree on the order and contents of the committed blocks, maintaining a consistent and tamper-proof ledger state.</p>\n<p>To prevent malicious behavior and ensure the security of the consensus protocol, nodes are incentivized to participate honestly through a combination of token rewards and penalties. Nodes that contribute to the successful validation and commitment of blocks are rewarded with newly minted tokens, while nodes that engage in malicious activities, such as proposing invalid transactions or propagating conflicting information, are penalized by having their token stakes slashed or their reputation scores reduced.</p>\n<p>The pulse-coupled oscillator synchronization mechanism provides a robust and scalable foundation for achieving decentralized consensus with token transactions and verifications. The self-organizing nature of the synchronization process allows the network to reach agreement on the order and validity of transactions without relying on a centralized authority or complex message passing protocols.</p>\n<p><strong>Algorithm 4 Decentralized Consensus Protocol with Token Transactions and Verifications</strong></p>\n<pre><code class=\"lang-auto\">1: procedure RunConsensusWithTransactions\n2:   Initialize oscillator phases ϕ_i and frequencies ω_i for all nodes i ∈ V\n3:   while not synchronized do\n4:     for each node i ∈ V do\n5:       Update phase ϕ_i according to the oscillator dynamics\n6:       if ϕ_i reaches the transaction proposal phase ϕ^{tx}_i then\n7:         Broadcast transaction proposal to neighbors j ∈ N_i\n8:       end if\n9:       if received transaction proposal from neighbor j then\n10:        Verify transaction validity\n11:        if transaction is valid then\n12:          Add transaction to local pool and emit approval pulse\n13:        end if\n14:      end if\n15:      if ϕ_i reaches the firing threshold ϕ^*_i then\n16:        Bundle approved transactions into a candidate block\n17:        Broadcast candidate block to neighbors j ∈ N_i\n18:      end if\n19:      if received candidate block from neighbor j then\n20:        Validate block and emit approval pulse if valid\n21:      end if\n22:      if ϕ_i reaches the commitment phase ϕ^{commit}_i then\n23:        Commit validated blocks to local ledger\n24:      end if\n25:    end for\n26:  end while\n27: end procedure\n</code></pre>\n<p>The extended consensus protocol incorporates token transactions and verifications by associating specific firing events with different stages of the transaction processing pipeline. Nodes propose transactions, validate and approve proposals, bundle them into candidate blocks, and collectively commit the blocks to their local ledgers based on the synchronized firing events.</p>\n<p>The integration of token transactions and verifications into the pulse-coupled oscillator consensus mechanism offers several advantages:</p>\n<ul>\n<li>Decentralized Coordination: The self-organizing synchronization process enables nodes to reach agreement on the order and validity of transactions without relying on a central authority or complex message passing protocols.</li>\n<li>Scalability: The consensus protocol scales efficiently with the size of the network, as transactions are proposed, validated, and committed through local interactions among neighboring nodes.</li>\n<li>Security: The combination of transaction verifications, block validations, and incentive mechanisms ensures the integrity and security of the token transactions, preventing double-spending, and mitigating malicious behavior.</li>\n<li>Consistency: The synchronized commitment of validated blocks ensures that all nodes maintain a consistent and tamper-proof ledger state, providing a reliable and auditable record of token transactions.</li>\n</ul>\n<p>The neurologically-inspired consensus protocol with token transactions and verifications offers a robust and efficient solution for achieving decentralized coordination and maintaining the integrity of the distributed ledger. By leveraging the self-organizing properties of pulse-coupled oscillators and integrating transaction processing into the synchronization dynamics, the proposed architecture enables secure, scalable, and consistent token transactions in a fully decentralized manner.</p>\n<h2><a name=\"h-7-computational-capabilities-11\" class=\"anchor\" href=\"https://ethresear.ch#h-7-computational-capabilities-11\"></a>7 Computational Capabilities</h2>\n<p>Beyond serving as a substrate for secure and decentralized data storage, the neurologically-inspired architecture possesses a wide range of computational capabilities that arise naturally from its densely interconnected structure and emergent dynamics. These capabilities make the architecture a versatile framework for distributed information processing and complex problem-solving.</p>\n<p>One key computational primitive is the ability to perform inference and belief revision in probabilistic graphical models. The network can be viewed as a Markov random field (MRF) [14], where each node represents a random variable and the synaptic connections encode the probabilistic dependencies among variables. Given a set of observed evidence, the inference task involves estimating the posterior probabilities of the hidden variables.</p>\n<p>In the proposed architecture, the posterior probabilities can be approximated by the stable fixed points of the network dynamics. The internal state <span class=\"math\">s_i</span> of each node <span class=\"math\">i</span> represents the marginal probability of the corresponding variable, and the synaptic weights <span class=\"math\">w_{ij}</span> encode the log-likelihood ratios of the pairwise dependencies:</p>\n<p><span class=\"math\">w_{ij} \\propto \\log \\frac{P(x_i=1 \\mid x_j=1)}{P(x_i=1 \\mid x_j=0)}</span></p>\n<p>The inference process in the proposed architecture can be formulated as an energy minimization problem, where the goal is to find the configuration of binary variables <span class=\"math\">x = (x_1, \\ldots, x_N)</span> that minimizes this energy function. The first term represents the unary potentials, with <span class=\"math\">\\theta_i</span> denoting the prior log-odds of variable <span class=\"math\">i</span> being active. The second term captures the pairwise interactions between variables, with <span class=\"math\">w_{ij}</span> representing the synaptic weight between nodes <span class=\"math\">i</span> and <span class=\"math\">j</span>. Minimizing this energy function corresponds to finding the most probable configuration of the variables given the observed evidence and the learned synaptic weights.</p>\n<p>The inference process can be implemented as a minimization of the following energy function:</p>\n<p><span class=\"math\">E(x) = -\\sum_i \\theta_i x_i - \\sum_{i \\neq j} w_{ij} x_i x_j</span></p>\n<p>where <span class=\"math\">x = (x_1, \\ldots, x_N)</span> is a configuration of the binary variables, <span class=\"math\">\\theta_i</span> represents the prior log-odds of variable <span class=\"math\">i</span>, and <span class=\"math\">w_{ij}</span> are the pairwise interaction weights.</p>\n<p>The network dynamics, governed by Equation (??), can be interpreted as performing a stochastic gradient descent on the energy function, with the stable fixed points corresponding to the local minima of the energy landscape. This allows the network to find the most probable configurations of the variables given the observed evidence, without explicitly computing the partition function or normalizing the probabilities.</p>\n<p>The sparse connectivity and event-driven nature of the network enable efficient and scalable inference, as the computations are performed locally and asynchronously based on the activity of the nodes. The recurrent connections and feedback loops in the network facilitate rapid information propagation and integration, allowing for fast convergence to the posterior estimates.</p>\n<p><strong>Theorem 5 (Inference Convergence).</strong> For a network with symmetric weights (<span class=\"math\">w_{ij} = w_{ji}</span>) and a concave activation function, the inference dynamics converge to a stable fixed point that corresponds to a local minimum of the energy function.</p>\n<p><em>Proof.</em> The proof relies on showing that the energy function decreases monotonically over time under the network dynamics. The symmetry of the weights and the concavity of the activation function ensure that the fixed points of the dynamics coincide with the local minima of the energy function. The detailed proof can be found in [11].</p>\n<p>Another important computational capability of the architecture is the ability to solve constraint satisfaction problems (CSPs) [22]. A CSP is defined by a set of variables <span class=\"math\">X = \\{x_1, \\ldots, x_N\\}</span>, eachassociated with a domain <span class=\"math\">D_i</span> of possible values, and a set of constraints <span class=\"math\">C = \\{C_1, \\ldots, C_M\\}</span> that specify the allowed combinations of variable assignments.</p>\n<p>To map a CSP onto the network, each variable <span class=\"math\">x_i</span> is represented by a group of nodes, with each node corresponding to a possible value assignment. The synaptic weights are set to encode the constraints, such that incompatible assignments result in high energy configurations. The network dynamics then search for the lowest energy state that satisfies all the constraints.</p>\n<p>The constrained optimization problem can be formulated as minimizing the following energy function:</p>\n<p><span class=\"math\">E(x) = \\sum_{i=1}^N \\sum_{k \\in D_i} x_{ik} + \\sum_{C \\in C} \\sum_{x_C \\notin S_C} \\prod_{i \\in V_C} x_{ix_C(i)}</span></p>\n<p>where <span class=\"math\">x_{ik} \\in \\{0,1\\}</span> indicates whether variable <span class=\"math\">i</span> is assigned value <span class=\"math\">k</span>, <span class=\"math\">S_C</span> denotes the set of allowed assignments for constraint <span class=\"math\">C</span>, <span class=\"math\">V_C</span> is the subset of variables involved in constraint <span class=\"math\">C</span>, and <span class=\"math\">x_C</span> represents the partial assignment of these variables.</p>\n<p>The network dynamics minimize the energy function by iteratively updating the node states based on the local constraints and the activities of the neighboring nodes. The sparse connectivity and asynchronous updates enable efficient exploration of the solution space, while the recurrent dynamics and feedback mechanisms facilitate rapid propagation of constraint violations and conflict resolution.</p>\n<p><strong>Theorem 6 (CSP Convergence).</strong> For a network encoding a satisfiable CSP with binary constraints, the network dynamics converge to a stable state representing a valid solution, provided that the weights are set appropriately and the activation function is chosen to be a step function.</p>\n<p><em>Proof.</em> The proof involves showing that the network energy decreases monotonically under the dynamics and that any valid solution corresponds to a global minimum of the energy function. The convergence to a valid solution follows from the fact that the energy cannot decrease indefinitely. The detailed proof can be found in [12].</p>\n<p>The computational capabilities of the neurologically-inspired architecture extend beyond inference and constraint satisfaction. The rich dynamics and adaptive properties of the network enable it to perform various tasks such as pattern recognition, associative memory, and optimization. The specific computations that can be carried out depend on the particular choice of node dynamics, synaptic plasticity rules, and network topology.</p>\n<p>For instance, by incorporating temporal integration and adaptive thresholds into the node dynamics, the network can be trained to recognize and generate complex spatiotemporal patterns [17]. This enables applications in sequence learning, time series prediction, and anomaly detection. The sparse encoding and distributed representation of patterns in the network provide robustness to noise and fault tolerance.</p>\n<p>Similarly, by defining appropriate objective functions and learning rules, the network can be optimized for tasks such as clustering, dimensionality reduction, and feature extraction [9]. The unsupervised learning capabilities of the network, based on local Hebbian plasticity and competitive dynamics, allow it to discover meaningful structures and representations in the input data without explicit supervision.</p>\n<p>The neuromorphic nature of the architecture offers several advantages over traditional approaches to distributed computing and information processing:</p>\n<ul>\n<li>Scalability: The sparse connectivity and local update rules enable the network to scale gracefully to large sizes without incurring prohibitive communication or computational overhead. The computations are performed in a highly parallel and distributed manner, leveraging the massive parallelism of neuromorphic substrates.</li>\n<li>Adaptability: The adaptive learning and self-organization capabilities of the network allow it to continuously tune its parameters and structure in response to changing environments or task demands. This adaptability enables the network to handle non-stationary data distributions and evolving problem domains.</li>\n<li>Efficiency: The event-driven and asynchronous nature of the computations, based on sparse spiking activity and adaptive update frequencies, can lead to significant energy savings compared to synchronous and clock-driven approaches. The localized processing and communication also reduce the energy costs associated with data movement and global synchronization.</li>\n<li>Robustness: The distributed encoding and storage of information, combined with the fault-tolerant dynamics and redundant connectivity, make the network resilient to node failures and data corruption. The network can gracefully degrade and maintain its functionality even in the presence of localized damage or adversarial attacks.</li>\n</ul>\n<p><strong>Example 2 (Distributed Pattern Recognition).</strong> Consider a network tasked with recognizing handwritten digits from the MNIST dataset [16]. Each input image is encoded as a binary vector <span class=\"math\">x \\in \\{0,1\\}^d</span>, where <span class=\"math\">d</span> is the number of pixels. The network consists of <span class=\"math\">N</span> nodes, each representing a learned prototype or a feature detector. The synaptic weights are trained using a competitive learning rule, such as the winner-takes-all (WTA) Hebbian rule:</p>\n<p><span class=\"math\">\\Delta w_{ij} = \n\\begin{cases}\n\\eta(x_j - w_{ij}) &amp; \\text{if } i = \\arg\\max_k w_k \\cdot x \\\\\n0 &amp; \\text{otherwise}\n\\end{cases}</span></p>\n<p>where <span class=\"math\">\\eta</span> is the learning rate and <span class=\"math\">w_i</span> is the weight vector of node <span class=\"math\">i</span>.</p>\n<p>During inference, an input image is presented to the network, and the nodes compete to match their prototypes with the input pattern. The node with the highest activation (i.e., the closest match) is selected as the winner, and its associated class label is assigned to the input. The sparse encoding and WTA dynamics enable fast and efficient recognition, while the distributed representation provides robustness to noise and occlusions.</p>\n<p>The example above showcases how the neurologically-inspired architecture can be applied to solve real-world problems in a distributed and efficient manner. The competitive learning and winner-takes-all dynamics enable the network to learn discriminative features and prototypes from the input data, while the sparse encoding and event-driven processing allow for fast and energy-efficient inference.</p>\n<p>The computational capabilities of the proposed architecture are not limited to the examples discussed here but encompass a wide range of information processing tasks across various domains. The versatility and adaptability of the neuromorphic approach make it a promising framework for developing intelligent and scalable distributed systems that can handle the complexity and dynamics of real-world data and applications.</p>\n<h2><a name=\"h-8-failure-modes-attack-vectors-and-defense-mechanisms-12\" class=\"anchor\" href=\"https://ethresear.ch#h-8-failure-modes-attack-vectors-and-defense-mechanisms-12\"></a>8 Failure Modes, Attack Vectors, and Defense Mechanisms</h2>\n<p>To ensure the practical viability and security of the proposed neurologically-inspired distributed ledger architecture, it is crucial to consider potential failure modes, attack vectors, and corresponding defense mechanisms. This section explores some of the key challenges and strategies for maintaining the resilience and integrity of the system.</p>\n<h3><a name=\"h-81-failure-modes-13\" class=\"anchor\" href=\"https://ethresear.ch#h-81-failure-modes-13\"></a>8.1 Failure Modes</h3>\n<h4><a name=\"h-811-node-failures-14\" class=\"anchor\" href=\"https://ethresear.ch#h-811-node-failures-14\"></a>8.1.1 Node Failures</h4>\n<p>One potential failure mode is the malfunction or unavailability of individual nodes in the network. Given the distributed nature of the architecture, the system should be designed to tolerate a certain level of node failures without compromising the overall functionality and performance. This can be achieved through redundancy, fault-tolerant consensus protocols, and self-healing mechanisms that enable the network to detect and recover from node failures.</p>\n<h4><a name=\"h-812-network-partitioning-15\" class=\"anchor\" href=\"https://ethresear.ch#h-812-network-partitioning-15\"></a>8.1.2 Network Partitioning</h4>\n<p>Another failure mode is network partitioning, where the network is split into isolated subgroups due to communication disruptions or connectivity issues. This can lead to inconsistencies and divergence in the ledger state across different partitions. To mitigate this risk, the architecture should incorporate partition-tolerant consensus algorithms, such as the pulse-coupled oscillator synchronization, which can maintain consistency and eventual synchronization even in the presence of network partitions.</p>\n<h4><a name=\"h-813-consensus-failures-16\" class=\"anchor\" href=\"https://ethresear.ch#h-813-consensus-failures-16\"></a>8.1.3 Consensus Failures</h4>\n<p>Consensus failures can occur when the nodes in the network fail to reach agreement on the ledger state or the validity of transactions. This can happen due to malicious behavior, network delays, or other factors that disrupt the consensus process. To prevent consensus failures, the architecture should employ robust and fault-tolerant consensus mechanisms, such as Byzantine fault tolerance (BFT) protocols, which can tolerate a certain number of malicious or faulty nodes while still reaching consensus.</p>\n<h3><a name=\"h-82-attack-vectors-17\" class=\"anchor\" href=\"https://ethresear.ch#h-82-attack-vectors-17\"></a>8.2 Attack Vectors</h3>\n<h4><a name=\"h-821-sybil-attacks-18\" class=\"anchor\" href=\"https://ethresear.ch#h-821-sybil-attacks-18\"></a>8.2.1 Sybil Attacks</h4>\n<p>Sybil attacks involve an attacker creating multiple fake identities or nodes to gain disproportionate influence over the network. This can be used to manipulate the consensus process, censor transactions, or perform double-spending attacks. To defend against Sybil attacks, the architecture can employ identity verification mechanisms, such as proof-of-work (PoW) or proof-of-stake (PoS), which make it computationally expensive or economically infeasible for an attacker to create and maintain a large number of fake identities.</p>\n<h4><a name=\"h-822-eclipse-attacks-19\" class=\"anchor\" href=\"https://ethresear.ch#h-822-eclipse-attacks-19\"></a>8.2.2 Eclipse Attacks</h4>\n<p>Eclipse attacks aim to isolate a targeted node or a group of nodes from the rest of the network by controlling their peer connections. This allows the attacker to filter or manipulate the information received by the targeted nodes, potentially leading to consensus failures or double-spending attacks. Defense mechanisms against eclipse attacks include diverse peer selection strategies, regular reshuffling of peer connections, and multi-path data propagation to ensure that nodes receive information from multiple sources.</p>\n<h4><a name=\"h-823-51-attacks-20\" class=\"anchor\" href=\"https://ethresear.ch#h-823-51-attacks-20\"></a>8.2.3 51% Attacks</h4>\n<p>In a 51% attack, an attacker gains control over a majority of the network’s computing power or stake, enabling them to dictate the consensus process and perform malicious activities such as double-spending or transaction censorship. To mitigate the risk of 51% attacks, the architecture can employ a combination of consensus mechanisms, such as PoW and PoS, that make it economically costly for an attacker to acquire a majority stake. Additionally, implementing a multi-layered security approach, with different consensus algorithms operating at different scales and levels of the network, can further enhance the resilience against 51% attacks.</p>\n<h3><a name=\"h-83-defense-mechanisms-21\" class=\"anchor\" href=\"https://ethresear.ch#h-83-defense-mechanisms-21\"></a>8.3 Defense Mechanisms</h3>\n<h4><a name=\"h-831-cryptographic-primitives-22\" class=\"anchor\" href=\"https://ethresear.ch#h-831-cryptographic-primitives-22\"></a>8.3.1 Cryptographic Primitives</h4>\n<p>The architecture should leverage secure cryptographic primitives, such as hash functions, digital signatures, and encryption algorithms, to ensure the integrity, authenticity, and confidentiality of data and transactions. These primitives form the foundation of the security mechanisms employed in the distributed ledger, preventing unauthorized modifications, forged transactions, and privacy breaches.</p>\n<h4><a name=\"h-832-secure-consensus-protocols-23\" class=\"anchor\" href=\"https://ethresear.ch#h-832-secure-consensus-protocols-23\"></a>8.3.2 Secure Consensus Protocols</h4>\n<p>Employing secure and fault-tolerant consensus protocols is crucial for maintaining the integrity and consistency of the ledger state. The proposed pulse-coupled oscillator synchronization mechanism provides a decentralized and resilient approach to achieving consensus. However, it can be further enhanced with additional security measures, such as verifiable random functions (VRFs) for leader selection, threshold signatures for collective signing, and multi-party computation (MPC) for secure computation and privacy preservation.</p>\n<h4><a name=\"h-833-incentive-mechanisms-24\" class=\"anchor\" href=\"https://ethresear.ch#h-833-incentive-mechanisms-24\"></a>8.3.3 Incentive Mechanisms</h4>\n<p>Designing appropriate incentive mechanisms is essential to encourage honest participation and discourage malicious behavior in the network. This can include block rewards, transaction fees, and stake-based incentives that align the economic interests of the nodes with the overall security and performance of the system. Penalty mechanisms, such as slashing or reputation scores, can be implemented to punish and deter malicious actors.</p>\n<h4><a name=\"h-834-monitoring-and-detection-25\" class=\"anchor\" href=\"https://ethresear.ch#h-834-monitoring-and-detection-25\"></a>8.3.4 Monitoring and Detection</h4>\n<p>Implementing robust monitoring and detection systems is crucial for identifying and responding to potential failures, attacks, and anomalies in the network. This can involve distributed intrusion detection systems (DIDS), machine learning-based anomaly detection, and real-time network analysis tools. By continuously monitoring the network activity and employing advanced detection techniques, the architecture can proactively identify and mitigate threats before they cause significant damage.</p>\n<h4><a name=\"h-835-formal-verification-and-testing-26\" class=\"anchor\" href=\"https://ethresear.ch#h-835-formal-verification-and-testing-26\"></a>8.3.5 Formal Verification and Testing</h4>\n<p>Rigorous formal verification and testing methodologies should be applied to validate the correctness, security, and performance of the proposed architecture. Formal verification techniques, such as model checking and theorem proving, can be used to mathematically prove the properties and guarantees of the consensus protocols, smart contracts, and cryptographic primitives. Comprehensive testing, including unit tests, integration tests, and stress tests, should be conducted to ensure the robustness and reliability of the implementation.</p>\n<p>By carefully considering and addressing these potential failure modes, attack vectors, and defense mechanisms, the practical viability and security of the neurologically-inspired distributed ledger architecture can be significantly strengthened. The combination of fault-tolerant design, secure consensus protocols, cryptographic primitives, incentive mechanisms, monitoring and detection systems, and formal verification and testing approaches provides a multi-layered defense strategy to ensure the resilience and integrity of the system in the face of various challenges and threats.</p>\n<h2><a name=\"h-9-comparison-with-state-of-the-art-blockchain-platforms-27\" class=\"anchor\" href=\"https://ethresear.ch#h-9-comparison-with-state-of-the-art-blockchain-platforms-27\"></a>9 Comparison with State-of-the-Art Blockchain Platforms</h2>\n<p>To highlight the advantages of the proposed neurologically-inspired distributed ledger architecture, it is informative to compare its performance and features with existing state-of-the-art blockchain platforms. This section provides a comparative analysis of the proposed architecture with two prominent blockchain platforms: Solana and Holochain.</p>\n<h3><a name=\"h-91-solana-28\" class=\"anchor\" href=\"https://ethresear.ch#h-91-solana-28\"></a>9.1 Solana</h3>\n<p>Solana is a high-performance blockchain platform that aims to achieve scalability without compromising security or decentralization. It employs a novel consensus mechanism called Proof-of-History (PoH) along with a Proof-of-Stake (PoS) protocol to enable fast and efficient transaction processing.</p>\n<p>Key features of Solana include:</p>\n<ul>\n<li>High throughput: Solana claims to support up to 65,000 transactions per second (TPS), making it one of the fastest blockchain platforms currently available.</li>\n<li>Low latency: Solana achieves sub-second transaction confirmation times, providing near-instant finality for users.</li>\n<li>Scalability: Solana’s architecture is designed to scale horizontally across a large number of nodes, enabling it to handle increasing transaction loads as the network grows.</li>\n<li>Developer-friendly: Solana supports smart contracts and provides a suite of tools and frameworks for developers to build decentralized applications (dApps) on its platform.</li>\n</ul>\n<p>However, Solana’s approach to scalability relies heavily on its PoH consensus mechanism, which requires a high degree of time synchronization across nodes. This can potentially introduce vulnerabilities and challenges in maintaining long-term security and decentralization.</p>\n<h3><a name=\"h-92-holochain-29\" class=\"anchor\" href=\"https://ethresear.ch#h-92-holochain-29\"></a>9.2 Holochain</h3>\n<p>Holochain is a framework for building decentralized applications that aims to provide scalability, adaptability, and agent-centric control. Unlike traditional blockchain platforms, Holochain does not rely on a global consensus mechanism. Instead, it allows each agent to maintain their own local chain and participate in distributed hash tables (DHTs) for data storage and retrieval.</p>\n<p>Key features of Holochain include:</p>\n<ul>\n<li>Agent-centric: Holochain puts the control and ownership of data in the hands of individual agents, allowing them to manage their own identities, keys, and data.</li>\n<li>Scalability: Holochain’s architecture enables linear scalability, as the capacity of the network grows with the number of participating agents.</li>\n<li>Adaptability: Holochain allows for flexible and adaptable dApp designs, as each app can define its own governance rules, validation logic, and data structures.</li>\n<li>Efficiency: Holochain’s DHT-based storage and retrieval mechanism is more efficient compared to traditional blockchain’s global replication of data.</li>\n</ul>\n<p>However, Holochain’s approach to decentralization and scalability comes with its own challenges. The lack of a global consensus mechanism can make it difficult to ensure consistency and integrity across the network, especially in the presence of malicious agents.</p>\n<h3><a name=\"h-93-comparison-table-30\" class=\"anchor\" href=\"https://ethresear.ch#h-93-comparison-table-30\"></a>9.3 Comparison Table</h3>\n<p>The following table summarizes the key features and performance metrics of the neurologically-inspired distributed ledger architecture in comparison to Solana and Holochain:</p>\n<div class=\"md-table\">\n<table>\n<thead>\n<tr>\n<th>Feature</th>\n<th>Neurologically-Inspired</th>\n<th>Solana</th>\n<th>Holochain</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Consensus Mechanism</td>\n<td>Pulse-Coupled Oscillators</td>\n<td>PoH + PoS</td>\n<td>DHT-based</td>\n</tr>\n<tr>\n<td>Scalability</td>\n<td>High</td>\n<td>High</td>\n<td>Linear</td>\n</tr>\n<tr>\n<td>Transaction Throughput (TPS)</td>\n<td>100,000+</td>\n<td>65,000</td>\n<td>Application-dependent</td>\n</tr>\n<tr>\n<td>Transaction Confirmation Time</td>\n<td>Sub-second</td>\n<td>Sub-second</td>\n<td>Near-instant</td>\n</tr>\n<tr>\n<td>Smart Contract Support</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>Yes (Zomes)</td>\n</tr>\n<tr>\n<td>Decentralization</td>\n<td>High</td>\n<td>Moderate</td>\n<td>High</td>\n</tr>\n<tr>\n<td>Fault Tolerance</td>\n<td>High</td>\n<td>Moderate</td>\n<td>Moderate</td>\n</tr>\n<tr>\n<td>Adaptability</td>\n<td>High</td>\n<td>Moderate</td>\n<td>High</td>\n</tr>\n<tr>\n<td>Energy Efficiency</td>\n<td>High</td>\n<td>Moderate</td>\n<td>High</td>\n</tr>\n</tbody>\n</table>\n</div><p>From the comparison table, it is evident that the neurologically-inspired distributed ledger architecture offers several advantages over Solana and Holochain:</p>\n<ul>\n<li>Scalability: The proposed architecture achieves high scalability through its neuromorphic design and pulse-coupled oscillator consensus mechanism, enabling efficient parallel processing and fast convergence.</li>\n<li>Transaction Throughput: With a potential transaction throughput of over 100,000 TPS, the neurologically-inspired architecture surpasses the performance of both Solana and Holochain.</li>\n<li>Decentralization: The architecture maintains a high degree of decentralization through its distributed ledger design and self-organizing consensus mechanism, ensuring resilience against centralized control.</li>\n<li>Fault Tolerance: The neuromorphic nature of the architecture, combined with robust consensus protocols and error correction mechanisms, provides a high level of fault tolerance against node failures and network disruptions.</li>\n<li>Adaptability: The architecture’s adaptability stems from its ability to dynamically reconfigure its synaptic connections and learning mechanisms based on the changing network conditions and computational requirements.</li>\n<li>Energy Efficiency: The event-driven and asynchronous processing model of the neurologically-inspired architecture enables energy-efficient computation, as resources are utilized only when necessary.</li>\n</ul>\n<p>While Solana and Holochain offer their own unique advantages, such as Solana’s high throughput and Holochain’s agent-centric approach, the neurologically-inspired distributed ledger architecture stands out in terms of its scalability, decentralization, fault tolerance, and adaptability. By leveraging the computational principles of biological neural networks, the proposed architecture addresses the limitations of traditional blockchain platforms and offers a promising solution for building efficient, robust, and intelligent decentralized systems.</p>\n<p>It is important to note that the performance metrics and features presented in the comparison table are based on the theoretical potential and design principles of the neurologically-inspired architecture. Further empirical evaluations and benchmarking studies are necessary to validate these claims and assess the practical performance of the architecture in real-world scenarios. Nonetheless, the comparative analysis highlights the potential advantages and unique characteristics of the proposed approach in relation to state-of-the-art blockchain platforms.</p>\n<h2><a name=\"h-10-conclusion-31\" class=\"anchor\" href=\"https://ethresear.ch#h-10-conclusion-31\"></a>10 Conclusion</h2>\n<p>In this paper, we have presented a novel distributed ledger architecture inspired by the information processing principles of biological neural networks. The proposed architecture aims to address the scalability, efficiency, and robustness challenges faced by traditional blockchain-based systems by leveraging key neurological mechanisms such as adaptive synaptic plasticity, associative memory, and self-organized consensus.</p>\n<p>The neuromorphic design, based on densely interconnected nodes communicating through synaptic connections, enables efficient and parallel processing of large-scale data and complex computations. The distributed associative memory scheme provides a scalable and content-addressable storage mechanism for securely encoding and retrieving data items. The decentralized consensus protocol, based on the synchronization of pulse-coupled oscillators, allows for fast and robust coordination among nodes without relying on global communication or centralized control.</p>\n<p>The computational capabilities of the architecture, arising from its rich dynamics and adaptive learning properties, make it a versatile framework for solving a wide range of information processing tasks, including inference, constraint satisfaction, pattern recognition, and optimization. The sparse encoding, event-driven processing, and fault-tolerant dynamics offer significant advantages in terms of scalability, efficiency, and robustness compared to traditional distributed computing approaches.</p>\n<p>The proposed architecture opens up new possibilities for building intelligent and sustainable distributed systems that can handle the growing complexity and scale of modern data and applications. The neurologically-inspired design principles can be applied across various domains, such as decentralized finance, supply chain management, Internet of Things, and edge computing, to develop secure, efficient, and adaptable solutions.</p>\n<p>However, realizing the full potential of this architecture requires further research and development efforts. Some key challenges and future directions include:</p>\n<ul>\n<li>Developing efficient and scalable hardware implementations of neuromorphic substrates that can support the massive parallelism and connectivity required by the architecture.</li>\n<li>Designing novel learning algorithms and synaptic plasticity rules that can effectively capture the complex patterns and dependencies in real-world data while being computationally tractable and biologically plausible.</li>\n<li>Integrating advanced cryptographic primitives and privacy-preserving mechanisms into the architecture to ensure the security and confidentiality of data and computations.</li>\n<li>Conducting extensive empirical evaluations and benchmarking studies to assess the performance and robustness of the architecture on real-world datasets and application scenarios.</li>\n<li>Establishing formal theoretical foundations for analyzing the convergence, stability, and computational complexity of the proposed algorithms and protocols.</li>\n</ul>\n<p>In conclusion, the neurologically-inspired distributed ledger architecture presents a promising approach to designing scalable, efficient, and robust decentralized systems that can tackle the challenges of the rapidly evolving data-driven world. By bridging the gap between biological and artificial information processing, this architecture paves the way for the development of a new generation of intelligent and sustainable distributed systems.</p>\n<h2><a name=\"references-32\" class=\"anchor\" href=\"https://ethresear.ch#references-32\"></a>References</h2>\n<p>[1] Androulaki, E., Barger, A., Bortnikov, V., Cachin, C., Christidis, K., De Caro, A., … &amp; Yellick, J. (2018, April). Hyperledger fabric: a distributed operating system for permissioned blockchains. In Proceedings of the thirteenth EuroSys conference (pp. 1-15).</p>\n<p>[2] Baza, M., Nabil, M., Lasla, N., Fidan, K., Mahmoud, M., &amp; Abdallah, M. (2019). Blockchain-based firmware update scheme tailored for autonomous vehicles. In 2019 IEEE Wireless Communications and Networking Conference (WCNC) (pp. 1-7). IEEE.</p>\n<p>[3] Bell, A. J., &amp; Sejnowski, T. J. (1997). The “independent components” of natural scenes are edge filters. Vision research, 37(23), 3327-3338.</p>\n<p>[4] Bi, G. Q., &amp; Poo, M. M. (1998). Synaptic modifications in cultured hippocampal neurons: dependence on spike timing, synaptic strength, and postsynaptic cell type. Journal of neuroscience, 18(24), 10464-10472.</p>\n<p>[5] Bruck, J. (1990). On the convergence properties of the Hopfield model. Proceedings of the IEEE, 78(10), 1579-1585.</p>\n<p>[6] Calzavara, S., Lande, S., &amp; Oswald, D. (2020). Private Smart Contracts in Proof-of-Stake Blockchains. In 2020 IEEE European Symposium on Security and Privacy (EuroS&amp;P) (pp. 362-378). IEEE.</p>\n<p>[7] Davies, M., Srinivasa, N., Lin, T. H., Chinya, G., Cao, Y., Choday, S. H., … &amp; Wang, H. (2018). Loihi: A neuromorphic manycore processor with on-chip learning. IEEE Micro, 38(1), 82-99.</p>\n<p>[8] Drachman, D. A. (2005). Do we have brain to spare?. Neurology, 64(12), 2004-2005.</p>\n<p>[9] Hinton, G. E., &amp; Salakhutdinov, R. R. (2006). Reducing the dimensionality of data with neural networks. science, 313(5786), 504-507.</p>\n<p>[10] Hopfield, J. J. (1982). Neural networks and physical systems with emergent collective computational abilities. Proceedings of the national academy of sciences, 79(8), 2554-2558.</p>\n<p>[11] Hopfield, J. J. (1984). Neurons with graded response have collective computational properties like those of two-state neurons. Proceedings of the national academy of sciences, 81(10), 3088-3092.</p>\n<p>[12] Hopfield, J. J., &amp; Tank, D. W. (1985). “Neural” computation of decisions in optimization problems. Biological cybernetics, 52(3), 141-152.</p>\n<p>[13] Indyk, P., &amp; Motwani, R. (1998, May). Approximate nearest neighbors: towards removing the curse of dimensionality. In Proceedings of the thirtieth annual ACM symposium on Theory of computing (pp. 604-613).</p>\n<p>[14] Koller, D., &amp; Friedman, N. (2009). Probabilistic graphical models: principles and techniques. MIT press.</p>\n<p>[15] Lamport, L., Shostak, R., &amp; Pease, M. (1982). The Byzantine generals problem. ACM Transactions on Programming Languages and Systems (TOPLAS), 4(3), 382-401.</p>\n<p>[16] LeCun, Y., Bottou, L., Bengio, Y., &amp; Haffner, P. (1998). Gradient-based learning applied to document recognition. Proceedings of the IEEE, 86(11), 2278-2324.</p>\n<p>[17] Maass, W., Natschläger, T., &amp; Markram, H. (2002). Real-time computing without stable states: A new framework for neural computation based on perturbations. Neural computation, 14(11), 2531-2560.</p>\n<p>[18] Merolla, P. A., Arthur, J. V., Alvarez-Icaza, R., Cassidy, A. S., Sawada, J., Akopyan, F., … &amp; Modha, D. S. (2014). A million spiking-neuron integrated circuit with a scalable communication network and interface. Science, 345(6197), 668-673.</p>\n<p>[19] Mirollo, R. E., &amp; Strogatz, S. H. (1990). Synchronization of pulse-coupled biological oscillators. SIAM Journal on Applied Mathematics, 50(6), 1645-1662.</p>\n<p>[20] Nakamoto, S. (2008). Bitcoin: A peer-to-peer electronic cash system. Decentralized Business Review, 21260.</p>\n<p>[21] Newman, M. E. (2001). The structure of scientific collaboration networks. Proceedings of the national academy of sciences, 98(2), 404-409.</p>\n<p>[22] Russell, S., &amp; Norvig, P. (2016). Artificial intelligence: a modern approach. Pearson Education Limited.</p>\n<p>[23] Strogatz, S. H. (2000). From Kuramoto to Crawford: exploring the onset of synchronization in populations of coupled oscillators. Physica D: Nonlinear Phenomena, 143(1-4), 1-20.</p>\n<p>[24] Vujičić, D., Jagodić, D., &amp; Ranđić, S. (2018, March). Blockchain technology, bitcoin, and Ethereum: A brief overview. In 2018 17th international symposium infoteh-jahorina (infoteh) (pp. 1-6). IEEE.</p>\n<p>[25] Wood, G. (2014). Ethereum: A secure decentralised generalised transaction ledger. Ethereum project yellow paper, 151(2014), 1-32.</p>\n<p>[26] Xiao, Y., Zhang, N., Lou, W., &amp; Hou, Y. T. (2020). A survey of distributed consensus protocols for blockchain networks. IEEE Communications Surveys &amp; Tutorials, 22(2), 1432-1465.</p>\n<p>*<strong>Paper written with the help of Claude 3 Opus. Thoughts and concepts conveyed are my own.</strong></p>\n            <p><small>2 posts - 1 participant</small></p>\n            <p><a href=\"https://ethresear.ch/t/unbounded-scaling-of-a-fully-decentralized-network-without-global-coordination-may-the-4th-be-with-you/19456\">Read full topic</a></p>","link":"https://ethresear.ch/t/unbounded-scaling-of-a-fully-decentralized-network-without-global-coordination-may-the-4th-be-with-you/19456","pubDate":"Sat, 04 May 2024 16:20:24 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-19456"},"source":{"@url":"https://ethresear.ch/t/unbounded-scaling-of-a-fully-decentralized-network-without-global-coordination-may-the-4th-be-with-you/19456.rss","#text":"Unbounded Scaling of a fully Decentralized Network without Global Coordination - - May the 4th Be With You"},"filter":false},{"title":"CEX/DEX arbitrage, transaction fees, block times, and LP profits","dc:creator":"atiselsts","category":"Economics","description":"<p>It’s widely recognized that CEX/DEX arbitrage trades create a large part of DEX volume, perhaps even the majority of that volume. The <a href=\"https://a16zcrypto.com/posts/article/lvr-quantifying-the-cost-of-providing-liquidity-to-automated-market-makers/\" rel=\"noopener nofollow ugc\">Loss Versus Rebalancing</a> (LVR) model stands out as a key tool for quantifying and modeling this arbitrage volume from a theoretical perspective. However, the research focusing on LVR  so far has mostly ignored transaction cost as a parameter in CEX/DEX arbitrage.</p>\n<p>This post aims to extend the LVR model to blockchains such as Ethereum’s mainnet, where CEX/DEX arbitrage transactions are expected to have a significant fixed cost term. It conceptualizes LVR as a quantity that is distributed between three primary actors: (1) the LPs of the AMM, (2) the searcher-builder-proposer (SBP) as an aggregate entity, and (3) ETH holders, due to the block basefee that is burned by each transaction. Some implications are:</p>\n<ul>\n<li>As the block time is decreased, an increased share of the nominal LVR is spent on transaction fees.</li>\n<li>Liquidity provider (LP) losses from arbitrage trades do not have the same magnitude as the profits of the arbitrager (searcher-builder-proposer), and as such, are not accurately predicted by a model that approximates them with the square root of the block time.</li>\n<li>Changes in Ethereum’s block time (either increase or decrease) are expected to affect the profitability of AMM LPs, but in many situations, other factors are more important, including the transaction fees.</li>\n</ul>\n<p><em>A more explanatory and less formal version of this post is available on <a href=\"https://atise.medium.com/anatomy-of-cex-dex-arbitrage-481936c83831\" rel=\"noopener nofollow ugc\">Medium</a>.</em></p>\n<h1><a name=\"background-1\" class=\"anchor\" href=\"https://ethresear.ch#background-1\"></a>Background</h1>\n<p>According to (<a href=\"https://arxiv.org/abs/2208.06046\" rel=\"noopener nofollow ugc\">Millionis 2022</a>, <a href=\"https://arxiv.org/abs/2305.14604\" rel=\"noopener nofollow ugc\">Millionis 2023</a>) the expected instantaneous LVR is :</p>\n<p><span class=\"math\">\n\\overline{\\mathrm{LVR}} \\triangleq \\lim _{T \\rightarrow 0} \\frac{\\mathrm{E}\\left[\\mathrm{LVR}_T\\right]}{T}=\\frac{\\sigma^2 P}{2} \\times y^{* \\prime}(P) </span> .</p>\n<p>This quantity depends only on the volatility, price, and marginal liquidity of the pool. By integrating the expected instantaneous LVR over time, we can obtain the expected LVR for a time period <span class=\"math\">t</span>. Once again, it is not dependent on external factors such as swap fees, block times, transaction costs, etc., and can serve as a nominal baseline metric for any further investigations in this area.</p>\n<p>In (Millionis 2023) the authors push their LVR model further, and consider a situation when the AMM has a trading fee <span class=\"math\">γ ≥ 0</span>, and that arbitrageurs arrive to trade on the AMM at discrete times according to the arrivals of a Poisson process with rate <span class=\"math\">λ &gt; 0</span>. They extend the asymptotic analysis of arbitrage profit in a fast block regime (<span class=\"math\">\\lambda \\rightarrow \\infty</span>). They establish a key result that <span class=\"math\">\\overline{ARB} = Θ( \\sqrt{λ^{-1}} )</span>, where <span class=\"math\">\\overline{ARB}</span> is the expected arbitrage profits over time. The authors do not explicitly discuss the case when block times are not Poisson distributed, however, intuitively, one can expect the approximation to remain reasonably accurate when the blocks are uniformly distributed. To formalize this idea: <span class=\"math\">\\overline{ARB} = Θ( \\sqrt{BT} )</span>, where <span class=\"math\">BT</span> is the average block time.</p>\n<p>One key question is whether we see this formula play out in real-world data? A group of research papers generally confirm the <span class=\"math\">\\sqrt{BT}</span> model:</p>\n<ul>\n<li>(<a href=\"https://arxiv.org/abs/2308.04159\" rel=\"noopener nofollow ugc\">McMenamin 2023</a>) draws an analogy between the model and the time value of options, which “typically grows proportionally to the square root of time to expiration.”</li>\n<li>(<a href=\"https://arxiv.org/abs/2403.09494v2\" rel=\"noopener nofollow ugc\">Adams 2024</a>) describe shorter block times as a reason for  increased fee returns for liquidity providers, stressing the difference between Optimism and Arbitrum, in favor of later due to shorter blocks.</li>\n<li>(<a href=\"https://arxiv.org/abs/2404.05803\" rel=\"noopener nofollow ugc\">Fritsch 2024</a>) empirically study the arbitrage profits predicted by the LVR model, and conclude that “our empirical findings come close to [the <span class=\"math\">\\sqrt{BT}</span> model] for most pairs and block times larger than 1s”, and attempt to explain any deviations as a result of: (1) uniform block times (i.e. not Poisson-distributed), and (2) price action that does not match the Geometric Brownian motion (GBM) model. Their work is a step towards verifying the <span class=\"math\">\\sqrt{BT}</span> model – however, it must be stressed that they measure arbitrage profits, not the LP losses.</li>\n</ul>\n<p>In contrast:</p>\n<ul>\n<li>(<a href=\"https://arxiv.org/abs/2312.13749\" rel=\"noopener nofollow ugc\">Dahi 2023</a>) investigate AMM on the XRP ledger and find only a tiny impact on the LPs: 0.35% in relative terms, if block time in simulations is reduced from 12 seconds to 4 seconds. This is much smaller than predicted by the <span class=\"math\">\\sqrt{BT}</span> model.</li>\n<li>The Uniswap Foundation’s <a href=\"https://medium.com/@atise/liquidity-provider-strategies-for-uniswap-v3-loss-versus-rebalancing-lvr-ee0ffdf1f937\" rel=\"noopener nofollow ugc\">LP strategies series</a> include <a href=\"https://github.com/atiselsts/uniswap-lp-articles-code/blob/500d54032e00db88147db97124acab66a82d3979/plot_article_3.py\" rel=\"noopener nofollow ugc\">simulation results</a> that show a limited dependence on the block time, overshadowed by other factors.</li>\n</ul>\n<p>How do we reconcile these differing results and bridge the gap between theory and practice?</p>\n<p>The LVR model treats the arbitrage problem as a two-player, zero-sum game, where <span class=\"math\">\\overline{ARB} = - \\overline{LP} </span> (where the latter term refers to the expected LP profits). However, this assumption is not valid in the post EIP-1559 world, where transactions cannot be free. Each arbitrage trade not only divides profits among the searcher, builder, and proposer (“SBP” further in this article) but also burns some ETH, contingent on the blockspace demand at the time of the arbitrage. To borrow a term from physics, the basefee introduces a friction in the process. This friction eliminates a significant portion of potential trades, and reduces LP income.</p>\n<h1><a name=\"analyzing-the-single-trade-lvr-2\" class=\"anchor\" href=\"https://ethresear.ch#analyzing-the-single-trade-lvr-2\"></a>Analyzing the single-trade LVR</h1>\n<p>Let’s look at the details of how LVR arises in real-world arbitrage trades. The difference between the DEX and CEX quoted prices (<span class=\"math\">P_{DEX}</span> and <span class=\"math\">P_{CEX}</span>) triggers the arbitrage trade. However, the trade is not going to happen if:</p>\n<ul>\n<li>The CEX price is in the non-arbitrage region created by AMM’s swap fees.</li>\n<li>The CEX price is in the friction region, created by the chain’s basefees and other factors (CEX fees, other  operational costs for arbitrager, risk aversion, etc.).</li>\n</ul>\n<p><img src=\"https://ethresear.ch/uploads/default/original/3X/6/7/672739182dd8b8981b4f531f74a221f1d289dd42.png\" alt=\"No-trade and friction regions\" data-base62-sha1=\"eIxdi9yS6EkUXdjFAecp1xhaT4e\" width=\"498\" height=\"195\"><br>\n<em><strong>Figure 1:</strong> Non-arbitrage and friction regions of an AMM pool with 0.05% swap fee.</em></p>\n<p>Moreover, the nominal single-trade LVR is “distributed” between three entities:</p>\n<ul>\n<li>Liquidity providers.</li>\n<li>The searcher, block builder, and block proposer (SBP) as a collective entity.</li>\n<li>Holders of ETH, due to the ETH burned in the transaction.</li>\n</ul>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/9/5/953c0c9cfa203ff4a017fba5b4f37c5d4c17b2e3.png\" data-download-href=\"https://ethresear.ch/uploads/default/953c0c9cfa203ff4a017fba5b4f37c5d4c17b2e3\" title=\"image\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/9/5/953c0c9cfa203ff4a017fba5b4f37c5d4c17b2e3_2_345x86.png\" alt=\"image\" data-base62-sha1=\"libNtLgylsSTNZVtY5aRKipuh9h\" width=\"345\" height=\"86\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/9/5/953c0c9cfa203ff4a017fba5b4f37c5d4c17b2e3_2_345x86.png, https://ethresear.ch/uploads/default/optimized/3X/9/5/953c0c9cfa203ff4a017fba5b4f37c5d4c17b2e3_2_517x129.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/9/5/953c0c9cfa203ff4a017fba5b4f37c5d4c17b2e3_2_690x172.png 2x\" data-dominant-color=\"9BB9AC\"></a></div><br>\n<em><strong>Figure 2:</strong> The nominal LVR is distributed between three entities: ETH holders (due to the burned basefees), LPs, and the searcher/builder/proposer as a collective entity.</em><p></p>\n<p><strong>LPs</strong> receive the swap fee, while the <strong>SBP</strong> collects the arbitrage profits, which are subsequently divided among these three actors. It’s no surprise that integrated searchers-builders dominate the arbitrage market (<a href=\"https://arxiv.org/abs/2401.01622\" rel=\"noopener nofollow ugc\">Heimbach 2024</a>), as for them it is simpler to divide up the profits. <strong>ETH</strong> <strong>holders</strong> do not directly receive compensation, but burning the basefee creates a deflationary pressure on ETH as an asset.</p>\n<p>By comparing the nominal single-trade LVR with the LP fees from that trade, we can assess the fairness of the trade to the LP. In a scenario where price evolution is smooth without any jumps, the LP fee nearly recoups the LVR, and the LP loss is minimal. However, if the DEX-to-CEX price difference fluctuates due to block time granularity or actual price discontinuities on the CEX, the LP fee becomes smaller than the LVR, resulting in some loss for the LP against the theoretical rebalancing strategy. One example is shown in the figure below:</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/2/7/27985324648027915d4f1d0cbb40dcb010494d61.png\" data-download-href=\"https://ethresear.ch/uploads/default/27985324648027915d4f1d0cbb40dcb010494d61\" title=\"image\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/2/7/27985324648027915d4f1d0cbb40dcb010494d61_2_690x240.png\" alt=\"image\" data-base62-sha1=\"5EgYutFyIfKo5NbBgWhwQp9n46B\" width=\"690\" height=\"240\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/2/7/27985324648027915d4f1d0cbb40dcb010494d61_2_690x240.png, https://ethresear.ch/uploads/default/original/3X/2/7/27985324648027915d4f1d0cbb40dcb010494d61.png 1.5x, https://ethresear.ch/uploads/default/original/3X/2/7/27985324648027915d4f1d0cbb40dcb010494d61.png 2x\" data-dominant-color=\"C7DBDD\"></a></div><p></p>\n<p><em><strong>Figure 3:</strong> Distribution of the LVR between the three actors. Relative scale. The LVR created by 0.1 % price changes has a much more equitable distribution than the LVR created by 1.0% price change at once.</em></p>\n<h1><a name=\"computing-the-nominal-lvr-3\" class=\"anchor\" href=\"https://ethresear.ch#computing-the-nominal-lvr-3\"></a>Computing the nominal LVR</h1>\n<p>Let’s assume that we are a given sequence of CEX prices at <span class=\"math\">BT</span> intervals and a constant product AMM (i.e. AMM that follows the equation <span class=\"math\">xy=k</span>). In order to compute the empirical approximation of the nominal LVR defined as above, we can use the following algorithm:</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/a/7/a7817e6afc2ee78f955045da5d6d1e370b8bc64e.png\" data-download-href=\"https://ethresear.ch/uploads/default/a7817e6afc2ee78f955045da5d6d1e370b8bc64e\" title=\"image\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/a/7/a7817e6afc2ee78f955045da5d6d1e370b8bc64e_2_552x500.png\" alt=\"image\" data-base62-sha1=\"nTPaXB8hoi52GMTeK1IJWGTGqJw\" width=\"552\" height=\"500\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/a/7/a7817e6afc2ee78f955045da5d6d1e370b8bc64e_2_552x500.png, https://ethresear.ch/uploads/default/optimized/3X/a/7/a7817e6afc2ee78f955045da5d6d1e370b8bc64e_2_828x750.png 1.5x, https://ethresear.ch/uploads/default/optimized/3X/a/7/a7817e6afc2ee78f955045da5d6d1e370b8bc64e_2_1104x1000.png 2x\" data-dominant-color=\"FBFBFB\"></a></div><p></p>\n<p>The results of the algorithm have been verified to match both the nominal LVR and the arbitrage trade probability as defined in (Millionis 2023) – see <a href=\"https://atise.medium.com/anatomy-of-cex-dex-arbitrage-481936c83831\" rel=\"noopener nofollow ugc\">“Replicating the theoretical results”</a> section in the Medium post.</p>\n<h1><a name=\"simulation-studies-4\" class=\"anchor\" href=\"https://ethresear.ch#simulation-studies-4\"></a>Simulation studies</h1>\n<p>Let’s model the in-range liquidity of the <a href=\"https://app.uniswap.org/explore/pools/ethereum/0x88e6A0c2dDD26FEEb64F039a2c41296FcB3f5640\" rel=\"noopener nofollow ugc\">Uniswap v3 ETH/USDC 0.05% pool</a>. As of April 2024, it has approximately $1 billion worth of virtual assets, corresponding to approximately $150 millions of real assets. As a result, the liquidity concentration factor is between 6 and 7. It’s essential to have deep liquidity if we want arbitrage swaps to happen even on relatively small price changes.</p>\n<p>The graphs below show the DEX performance metrics using random GBM simulations. The simulations assume 50% yearly volatility, which corresponds to approximately 2.6% daily volatility and 0.03% per-block volatility for 12-second blocks. This is the approximate volatility of ETH in the recent years.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/5/2/52ed204954c80c12fe60d115b8530dc19e33c5d9.png\" data-download-href=\"https://ethresear.ch/uploads/default/52ed204954c80c12fe60d115b8530dc19e33c5d9\" title=\"image\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/5/2/52ed204954c80c12fe60d115b8530dc19e33c5d9_2_517x369.png\" alt=\"image\" data-base62-sha1=\"bPBbXFRxaXGCM8wZvpk3YoS2Gmd\" width=\"517\" height=\"369\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/5/2/52ed204954c80c12fe60d115b8530dc19e33c5d9_2_517x369.png, https://ethresear.ch/uploads/default/original/3X/5/2/52ed204954c80c12fe60d115b8530dc19e33c5d9.png 1.5x, https://ethresear.ch/uploads/default/original/3X/5/2/52ed204954c80c12fe60d115b8530dc19e33c5d9.png 2x\" data-dominant-color=\"F2F2F1\"></a></div><br>\n<em><strong>Figure 4:</strong> Simulated DEX metrics with zero basefee.</em><p></p>\n<p>Due to a coincidence, the LVR turns out to be approximately $1 per second or $3600 per hour. The LP losses in turn are in the range from $350 to $900 per hour ($3 to $8 million per year). To be clear, this theoretical model does not include any LP fees coming from noise / uninformed traders, which are expected to produce zero LVR, and consequently compensate for the LP losses from the arbitrage trades.</p>\n<p>The results show that when the basefee is zero, the LP losses indeed can be more-or-less accurately modeled by the function <span class=\"math\">\\sqrt{BT}</span>. However, after introducing EIP-1559 basefees to the model, this isn’t true anymore.</p>\n<p>The subsequent two graphs show what happens with when each transaction is assumed to cost a fixed amount of $. A simple Uniswap v3 swap might consume around 150’000 gas, which corresponds to $10 cost per swap in USD terms – assuming the reasonable 22 gwei basefee cost and $3000 ETH/USDC price. In times of high usage or high volatility, the cost of a transaction can easily increase several times.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/5/a/5afc2619927bd3babb3015f3cb3ed9e9b00cd2b8.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/5afc2619927bd3babb3015f3cb3ed9e9b00cd2b8\" title=\"image\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/5/a/5afc2619927bd3babb3015f3cb3ed9e9b00cd2b8_2_517x369.jpeg\" alt=\"image\" data-base62-sha1=\"cYTcjQHdt79uojqCj33VWL8Dpos\" width=\"517\" height=\"369\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/5/a/5afc2619927bd3babb3015f3cb3ed9e9b00cd2b8_2_517x369.jpeg, https://ethresear.ch/uploads/default/original/3X/5/a/5afc2619927bd3babb3015f3cb3ed9e9b00cd2b8.jpeg 1.5x, https://ethresear.ch/uploads/default/original/3X/5/a/5afc2619927bd3babb3015f3cb3ed9e9b00cd2b8.jpeg 2x\" data-dominant-color=\"F1F0F0\"></a></div><br>\n<em><strong>Figure 5:</strong> Simulated DEX metrics with $10 per swap spent on the basefee.</em><p></p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/4/2/42c2d88113ebb2d718f19a54de820c151ca37b90.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/42c2d88113ebb2d718f19a54de820c151ca37b90\" title=\"image\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/4/2/42c2d88113ebb2d718f19a54de820c151ca37b90_2_517x369.jpeg\" alt=\"image\" data-base62-sha1=\"9wAY1idJtClIQWeCWwS5L8yDVv2\" width=\"517\" height=\"369\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/4/2/42c2d88113ebb2d718f19a54de820c151ca37b90_2_517x369.jpeg, https://ethresear.ch/uploads/default/original/3X/4/2/42c2d88113ebb2d718f19a54de820c151ca37b90.jpeg 1.5x, https://ethresear.ch/uploads/default/original/3X/4/2/42c2d88113ebb2d718f19a54de820c151ca37b90.jpeg 2x\" data-dominant-color=\"F1F0F0\"></a></div><br>\n<em><strong>Figure 6:</strong> Simulated DEX metrics with $30 per swap spent on the basefee.</em><p></p>\n<p>For a summary of the LP losses, see the figure below. Even adding a constant offset from the <em>x</em> axis to the <span class=\"math\">\\sqrt{BT}</span>. model does not lead to a good fit (the brown line). More frequent transactions also burn more ETH, thus canceling out most of the positive impact on the LP fees.</p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/b/5/b53b8658e7ad04dc746ae61a681bd639a0c3d72e.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/b53b8658e7ad04dc746ae61a681bd639a0c3d72e\" title=\"image\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/b/5/b53b8658e7ad04dc746ae61a681bd639a0c3d72e_2_517x370.jpeg\" alt=\"image\" data-base62-sha1=\"pRfX707wr0qsMtNX8RgvFb5nH6m\" width=\"517\" height=\"370\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/b/5/b53b8658e7ad04dc746ae61a681bd639a0c3d72e_2_517x370.jpeg, https://ethresear.ch/uploads/default/original/3X/b/5/b53b8658e7ad04dc746ae61a681bd639a0c3d72e.jpeg 1.5x, https://ethresear.ch/uploads/default/original/3X/b/5/b53b8658e7ad04dc746ae61a681bd639a0c3d72e.jpeg 2x\" data-dominant-color=\"F0ECEC\"></a></div><br>\n<em><strong>Figure 7:</strong> The <span class=\"math\">\\sqrt{BT}</span> model shows a good-but-not-perfect fit if the basefee is zero, but much worse otherwise.</em><p></p>\n<h3><a name=\"simulations-with-longer-block-times-5\" class=\"anchor\" href=\"https://ethresear.ch#simulations-with-longer-block-times-5\"></a>Simulations with longer block times</h3>\n<p>Following Table 1 in (Millionis 2023), I also include results with 120 second and 600 second blocktimes.</p>\n<p>Uniformly distributed blocks, $10 swap basefees:</p>\n<pre><code class=\"lang-auto\">swap fee:                          1bp   5bp  10bp  30bp 100bp\nblock time   600 sec, arb prob %: 92.7  85.2  76.4  50.5  21.7 \nblock time   120 sec, arb prob %: 83.7  68.4  53.5  27.4   9.9 \nblock time    12 sec, arb prob %: 53.1  29.9  19.1   7.7   2.0 \nblock time     2 sec, arb prob %: 20.8   9.4   5.5   1.8   0.1 \nswap fee:                          1bp   5bp  10bp  30bp 100bp\nblock time   600 sec, LP loss  %: 96.3  83.5  71.3  44.8  19.6 \nblock time   120 sec, LP loss  %: 92.1  69.1  52.5  26.9  10.0 \nblock time    12 sec, LP loss  %: 80.0  44.2  28.3  11.6   3.8 \nblock time     2 sec, LP loss  %: 69.6  31.3  18.6   7.1   2.2 \n</code></pre>\n<p>Uniformly distributed blocks, $30 swap basefees:</p>\n<pre><code class=\"lang-auto\">swap fee:                          1bp   5bp  10bp  30bp 100bp\nblock time   600 sec, arb prob %: 88.8  81.5  72.8  48.1  20.8 \nblock time   120 sec, arb prob %: 75.4  61.0  47.8  24.5   8.8 \nblock time    12 sec, arb prob %: 36.2  21.3  14.0   5.8   1.5 \nblock time     2 sec, arb prob %: 10.7   5.5   3.3   1.1   0.1 \nswap fee:                          1bp   5bp  10bp  30bp 100bp\nblock time   600 sec, LP loss  %: 96.3  83.6  71.4  45.0  19.8 \nblock time   120 sec, LP loss  %: 92.3  69.8  53.3  27.6  10.3 \nblock time    12 sec, LP loss  %: 82.5  48.5  32.0  13.5   4.5 \nblock time     2 sec, LP loss  %: 76.5  39.5  24.6   9.8   3.2 \n</code></pre>\n<p>The results show that:</p>\n<ul>\n<li>The approximation from (Millionis 2023) that arbitrage probability is approximately equal to LP loss does not hold, in general.</li>\n<li>In most cases, the swap fee is a more dominant factor for the LPs than either the block time or basefee.</li>\n<li>Increasing the block time does increase LP losses, but by a much smaller factor than predicted by the <span class=\"math\">\\sqrt{BT}</span> model, especially in pools with low swap fees (1 bps to 10 bps).</li>\n</ul>\n<h1><a name=\"discussion-6\" class=\"anchor\" href=\"https://ethresear.ch#discussion-6\"></a>Discussion</h1>\n<h3><a name=\"generalizing-the-results-7\" class=\"anchor\" href=\"https://ethresear.ch#generalizing-the-results-7\"></a>Generalizing the results</h3>\n<ol>\n<li>\n<p><strong>Generalizing to other pools.</strong> The simulation results above are specific to the USDC/ETH 0.05% pool, which is typically the most liquid volatile pool on Uniswap v3. (There are stable pools with deeper liquidity). For pools with <strong>lower liquidity,</strong> the importance of the friction created by the basefee would be increased. For instance, let’s say that the ETH/USDT 0.05% pool has 1/3 of the liquidity. Then the results from $10 basefee on that pool would match those of the USDC/ETH pools with $30 basefee. For pools with <strong>higher liquidity</strong> (such as USDC/USDT) the friction would be decreased, proportional to the rise in liquidity.</p>\n</li>\n<li>\n<p><strong>Generalizing to other chains.</strong> The model assumes that shorter blocks simply divide the available blockspace differently, rather than add more blockspace. The simulation results would not generalize if the block time decrease was accompanied with a proportional decrease in basefees.</p>\n</li>\n</ol>\n<h3><a name=\"implications-for-blockchain-design-8\" class=\"anchor\" href=\"https://ethresear.ch#implications-for-blockchain-design-8\"></a>Implications for blockchain design</h3>\n<p>The results clearly show that LP losses are not accurately predicted by the <span class=\"math\">\\sqrt{BT}</span> model, unless the basefee is close to zero. While it’s true that shorter blocks benefit LPs, the effect is limited and frequently less significant than other factors (basefee, liquidity depth, swap fee %, and potentially others). More compelling arguments for fast block times may come from other perspectives, like the perspective of traders, or that of block builders, but these are out of the scope for this article.</p>\n<p>Potentially, we can view the optimal block time choice problem from two viewpoints:</p>\n<ul>\n<li>From <strong>L1 perspective</strong>, reducing the basefee could provide a quicker win, compared with changing the block time. However, keeping the design decentralized and credibly-neutral is arguably a higher priority.</li>\n<li>From <strong>L2 / appchain perspective,</strong> especially for chains that focus on DeFi or on trading in particular, it makes sense to excessively optimize for LP profits, including block time and basefee reduction.</li>\n<li>\n<ul>\n<li>The <span class=\"math\">\\sqrt{BT}</span> model implies that decreasing block times is especially important if the block time is already close to zero, since the <span class=\"math\">\\sqrt{~}</span> function rapidly grows in the near-zero region.</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>L2 fees may already be low enough to minimize the friction caused by the basefee to negligible levels. If this isn’t the case, then paradoxically, exempting CEX/DEX arbitrage swaps from the EIP-1559 basefee would benefit DEX users (both LPs and retail traders).</li>\n</ul>\n</li>\n</ul>\n<h3><a name=\"shorter-blocks-less-mev-9\" class=\"anchor\" href=\"https://ethresear.ch#shorter-blocks-less-mev-9\"></a>Shorter blocks = less MEV?</h3>\n<p>To be clear, this article makes no claims about MEV in general, just about CEX/DEX arbitrage in particular. Regarding the latter, clearly, there’s a connection between CEX/DEX arbitrage, transaction fees, and block times. However, it is perhaps confusing because this connection goes <strong>both ways</strong>:</p>\n<ul>\n<li>Shorter blocks increase the number of arbitrage transactions and the proportion of gas that they consume.</li>\n<li>On the other hand, shorter blocks decrease the expected value of LP losses.</li>\n</ul>\n<p>The same conflicting results apply to changes in basefees. As a result, there’s potential for a confusion, because MEV is increased in one sense, and decreased in another sense.</p>\n<h1><a name=\"conclusion-10\" class=\"anchor\" href=\"https://ethresear.ch#conclusion-10\"></a>Conclusion</h1>\n<p>This work extends the existing LVR and LVR-with-fees models by adding another component: transaction cost. To summarize the main results:</p>\n<ul>\n<li>CEX/DEX arbitrage transactions are not frictionless due to the EIP-1559 basefee and other factors.</li>\n<li>As a result, the nominal LVR in real-world AMMs is divided among three entities: LPs, ETH stakers, and the SBP as a collective entity.</li>\n<li>More gradual price changes result in more equitable LVR distribution among these three entities.</li>\n<li>On chains with significant transaction costs, LP losses under the LVR assumptions are not accurately predicted by the <span class=\"math\">\\sqrt{BT}</span> model.</li>\n<li>The LP losses are determined by several factors, including basefees, swap fees, and block times, the relative importance of which varies.</li>\n</ul>\n<p><em>Source code of the simulations <a href=\"https://github.com/atiselsts/cex-dex-arbitrage-anatomy\" rel=\"noopener nofollow ugc\"><em>is available here</em></a></em>.</p>\n            <p><small>4 posts - 2 participants</small></p>\n            <p><a href=\"https://ethresear.ch/t/cex-dex-arbitrage-transaction-fees-block-times-and-lp-profits/19444\">Read full topic</a></p>","link":"https://ethresear.ch/t/cex-dex-arbitrage-transaction-fees-block-times-and-lp-profits/19444","pubDate":"Thu, 02 May 2024 16:37:01 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-19444"},"source":{"@url":"https://ethresear.ch/t/cex-dex-arbitrage-transaction-fees-block-times-and-lp-profits/19444.rss","#text":"CEX/DEX arbitrage, transaction fees, block times, and LP profits"},"filter":false},{"title":"Integrity proofs to improve rollup security","dc:creator":"peshwar9","category":"Layer 2","description":"<p><strong>TLDR</strong></p>\n<p>L2 neworks such as rollups, validiums and optimiums primarily use execution proofs (ZK proofs or fraud proofs) to prove (or disprove) transaction and state transition validity to the base layer (Ethereum). While proofs of execution are important, they do not detect many categories of faults and frauds that can happen in the various components that comprise  the overall layer-2 infrastructure. Such faults/frauds are  difficult to prove and impossible to attribute and penalise on-chain.</p>\n<p>This post introduces integrity proofs, which complements zk proofs and fraud proofs for rollup security. Integrity proof  is a mechanism to attest to the integrity of services running in a particular instance of rollup, providing assurance to the end users that no malicious or other unauthorized code changes have been performed in the production environment. Integrity proofs use TEEs to deploy and monitor rollup services and report any breach of service integrity on a new layer-2 network (let’s call it Integrity verification chain) that provides decentralised security services to rollups.</p>\n<p>Layering integrity proofs over existing execution proofs greatly improves the censorship resistance of the rollup, detects unauthorised MEV extraction and offers protection from other types of malicious activities in the rollup infrastructure from privileged or unauthorized users. This design also reduces the trust assumptions , compared to the current architecture of centralised rollup deployments that rely disproportionately on execution proofs to demonstrate offchain execution validity.</p>\n<p><strong>Introduction</strong></p>\n<p>Layer-2 networks settling on Ethereum (aka base layer) predominantly use either fraud proofs (proofs of invalidity) or ZK-proofs (proofs of validity) to prove transaction validity and updated state commitments to the base layer. Both these are execution proofs that cryptographically attest to those activities that are objectively recorded and verifiable on-chain (aka running in the EVM or equivalent VM).</p>\n<p>However, such execution proofs alone are inadequate to verify the security of the overall layer-2 network. This is because there are many centralised components in L2s where faults and malicious activities can occur, which cannot be proven on-chain (non-attributable faults). There are many solutions being worked on to address centralisation risk in rollups, but they come with their own tradeoffs including loss of sovereignty/control, reducing utility of own token, cost increase or increased complexity of architecture.</p>\n<p>This post proposes a solution to detect <em>unattributable faults</em> while running rollup services (of the kind that cannot be detected by ZK proofs alone) , without any loss of sovereignty or loss of control for the project deploying the layer-2 network. (Note: The terms layer-2 network and rollup are used interchangeably in this post as a broad term to encompass rollups, validiums and optimums.)</p>\n<p>Integrity proofs are proposed as a mechanism to certify to the presence (or absence) of unattributable faults in the operation of a rollup service, by having an observer running in a Trusted Execution Environment (TEE) provide cryptographic attestation of its own execution environment and signing the attestation with its own in-enclave generated cryptographic identity (signing key) that cannot be tampered with even by the operator of the attestation service.</p>\n<p><strong>Problem space</strong></p>\n<p>Layer-2 networks (both optimistic and Zk stack chains) have many components such as rpc nodes, sequencers, pool &amp; state databases, executors, provers, L1 transaction managers etc that are basically deployed either as platform-native binaries or docker images. Examples of non-attributable faults/frauds include censoring transactions based on addresses or geo-fencing access in json-rpc node, changing the ordering algorithm of sequencer, making unauthorised/undetected changes to the state or pool database, and withholding transaction batch data posted to external DA layer. Currently, users make heavy trust assumptions while using L2 chains that such malicious or unauthorised actions don’t take place in the centralised services operated by their provider. More specifically, users make the following trust assumptions:</p>\n<p>a) they trust the rollup project foundations (eg Polygon, ZK, Optimism, Arbitrum) to not introduce any malicious code on the published rollup service images.</p>\n<p>b) trust that the right security controls are in place such that employees/contractors that belong to the rollup project or RaaS operators have restricted privileged access (or that those who do , do not abuse privileged access)</p>\n<p>In short, users rely on the security offered by the reputational credibility (social &amp; commercial ) of these trusted third parties. Integrity of the rollup services operated by these parties is not verifiable, and any faults are not attributable or provable on-chain. This goes against the basic premise of blockchain networks aka verifiability.</p>\n<p><strong>Solution proposed</strong></p>\n<p></p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://ethresear.ch/uploads/default/original/3X/e/d/edb7cc61ad8bf9c863c1a9d1deeef28720e7a109.jpeg\" data-download-href=\"https://ethresear.ch/uploads/default/edb7cc61ad8bf9c863c1a9d1deeef28720e7a109\" title=\"Integrity Verified Services\"><img src=\"https://ethresear.ch/uploads/default/optimized/3X/e/d/edb7cc61ad8bf9c863c1a9d1deeef28720e7a109_2_671x500.jpeg\" alt=\"Integrity Verified Services\" data-base62-sha1=\"xUWWH1Wf1Mo6qGiYtnUbW6g5cYV\" width=\"671\" height=\"500\" srcset=\"https://ethresear.ch/uploads/default/optimized/3X/e/d/edb7cc61ad8bf9c863c1a9d1deeef28720e7a109_2_671x500.jpeg, https://ethresear.ch/uploads/default/optimized/3X/e/d/edb7cc61ad8bf9c863c1a9d1deeef28720e7a109_2_1006x750.jpeg 1.5x, https://ethresear.ch/uploads/default/optimized/3X/e/d/edb7cc61ad8bf9c863c1a9d1deeef28720e7a109_2_1342x1000.jpeg 2x\" data-dominant-color=\"ECEDEA\"></a></div><p></p>\n<p>Figure shows the overview of the proposed solution, which has a new layer-2 network acting as the integrity verification chain (let’s call it IVC in short), and three types of actors participating in it - rollup framework providers, rollup projects and TEE operators. Let’s understand this better using the example of a single rollup service- the sequencer (which needs no introduction).</p>\n<ol>\n<li>Rollup framework providers (eg polygon cdk, Zkstack, OP stack , Arbitrum etc) register the service image of their latest release of sequencer with IVC.</li>\n<li>A new rollup project comes along and wants to deploy the sequencer from one of these frameworks. The request is sent to a <em>Host program</em> (creatively named) that runs in a TEE. The host program retrieves the service image registered by the provider, and deploys it on a VM that’s specified by the rollup provider. (The only requirement is for the host program to be given SSH access to deploy the service in the VM). For simplicity, let’s assume this service image is a docker image. The host program downloads the docker image and instantiates a new container using this image. The container Id is captured by the host program and recorded on IVC smart contract designated for the purpose.</li>\n<li>Periodically (based on frequency specified by the rollup project owner) the host program verifies if the container id of the running sequencer matches that recorded on the IVC layer-2 smart contract. If there is any discrepancy, it flags it as a violation of integrity on the integrity verification chain (IVC).</li>\n<li>The host program can generate an integrity proof on demand (or it can be generated unconditionally in the protocol workflow) attesting to the integrity of a particular service that is deployed and monitored by it. The integrity proof would contain the details of the rollup service that’s being monitored, proof of the execution environment in which the host program runs including the quote/remote attestation parameters and its own binary fingerprint (MRENCLAVE), Further, the integrity proof generated by the host program can be signed by a keypair that’s generated within the enclave so that the operator of the host program VM cannot make a false attestation. The signing key would not be accessible even to the operator.</li>\n</ol>\n<p>Here, the sequencer component that was used as the example, becomes the Integrity-verified service (IVS). Technically, the sequencer itself can be run inside a TEE, but that would be another solution not discussed here.</p>\n<p><strong>How does integrity verified service offer a better security model for rollups?</strong></p>\n<p>In this example, let’s assume that after the rollup service is deployed , someone with privileged or unauthorised access modifies the sequencer code to add censoring logic or ordering algorithm, and restarts the docker container. This will result in a change to the container finggerprint, and this will  immediately be detected by the host program (as the running container id will not match the registered container id that was started by the host program). The integrity proof from the host program can certify to the presence or absence of such non-attributable faults.</p>\n<p>When integrity proofs are combined with prevailing proof mechanisms such as zk validity proofs or fraud proofs, it strictly improves the status quo in terms of rollup security.</p>\n<p><strong>Benefits of this solution</strong></p>\n<p><em>For end-user:</em> The end user of the rollup/L2 chain is now assured that in addition to their on-chain transactions being secure (due to natively built-in zk proofs or fraud proofs), additionally any non-attributable faults that can occur in sequencer such as censoring or ordering algorithm changes will immediately be detected and flagged for attention. The user can verify integrity proofs in a permission-less manner.</p>\n<p><em>For rollup project owner:</em> They don’t just have to trust their own devops teams or that of the RaaS operator that they outsource to, but they can verify the integrity of the rollup services deployed permissionlessly, on an ongoing basis. They get a higher security layer-2 chain (trust-minimised) compared to what they would get by deploying a standard rollup stack out of the box.</p>\n<p><em>For RaaS operators</em>: They have lower operational risk by ensuring that the right service images are deployed everytime. This also results in lower risk of reputational/business loss due to unauthorised access or security attacks on their infra.</p>\n<p><em>For rollup framework providers</em> : By publishing their service images and actively participating in the integrity verification activity, they attract better quality of builders and projects on their ecosystem.</p>\n<p><strong>Further security enhancements</strong></p>\n<p>The integrity proofs described solve two attack vectors on rollup services:</p>\n<ol>\n<li>Any unauthorised changes to the deployed rollup service is detected and flagged.</li>\n<li>The correct secure version of each rollup service is deployed in the production environment</li>\n</ol>\n<p>This is a clear improvement from having just execution proofs. But there can be other types of attacks that need to be designed for. One example is that someone with privileged access can still log into the running docker container and change environment variables. To address this, the host program can be enhanced to periodically log into the running containers and compare the environment parameters on the current running version of container vs the original deployed version.</p>\n<p>There can be other types of attacks that are more difficult to detect. for example a sophisticated actor can log into the docker container and manipulate memory . Memory encryption techniques can be evaluated to protect against such attacks. Other solutions could involve running multiple instances of a rollup service (eg sequencer or prover) governed by a consensus algorithm, but it increases costs of operating the rollup infrastructure, and it will be the decision of the rollup project to evaluate the level of risk they are willing to accept and the cost they are willing to pay.</p>\n<p><strong>Summary</strong></p>\n<p>The premise of this solution is that a combination of existing <em>execution proof techniques</em> (zk or fraud proofs) for objectively-verifiable faults in combination with Tee-based <em>integrity proofs</em> for non-attributable faults offers a superior trust-minimised security model for rollups, compared to the status quo.</p>\n            <p><small>1 post - 1 participant</small></p>\n            <p><a href=\"https://ethresear.ch/t/integrity-proofs-to-improve-rollup-security/19437\">Read full topic</a></p>","link":"https://ethresear.ch/t/integrity-proofs-to-improve-rollup-security/19437","pubDate":"Thu, 02 May 2024 13:00:07 +0000","discourse:topicPinned":"No","discourse:topicClosed":"No","discourse:topicArchived":"No","guid":{"@isPermaLink":"false","#text":"ethresear.ch-topic-19437"},"source":{"@url":"https://ethresear.ch/t/integrity-proofs-to-improve-rollup-security/19437.rss","#text":"Integrity proofs to improve rollup security"},"filter":false}]}}}